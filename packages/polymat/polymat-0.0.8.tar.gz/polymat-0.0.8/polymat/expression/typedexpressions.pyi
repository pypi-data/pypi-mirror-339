"""
The following classes are used exclusively for type hinting.

A separate stub file was used to avoid ha
"""

from typing import Iterable, overload

from polymat.expression.expression import Expression
from polymat.expressiontree.from_ import FromAnyTypes
from polymat.expressiontree.operations.combinations import Combinations
from polymat.expressiontree.operations.filterpredicator import FilterPredicate
from polymat.expressiontree.nodes import (
    ExpressionNode,
    SingleChildExpressionNode,
)
from polymat.expressiontree.operations.getitem import GetItem
from polymat.expressiontree.operations.product import Product
from polymat.expressiontree.operations.truncatemonomials import TruncateMonomials
from polymat.sparserepr.sparserepr import SparseRepr
from polymat.state.state import State as BaseState
from polymat.symbols.symbol import Symbol

type VariableVectorType[State: BaseState] = (
    VariableVectorExpression[State] | tuple[int, ...]
)

class MatrixExpression[State: BaseState](SingleChildExpressionNode[State]):
    def __add__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __getitem__(
        self, key: GetItem.KeyType
    ) -> ScalarPolynomialExpression[State]: ...
    @overload
    def __matmul__(self, other: VectorExpression[State]) -> VectorExpression[State]: ...
    @overload
    def __matmul__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __mul__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __neg__(self) -> MatrixExpression[State]: ...
    def __pow__(self, exponent: int) -> MatrixExpression[State]: ...
    def __radd__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __rmul__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __rmatmul__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __rsub__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __sub__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __truediv__(self, other: float | int) -> MatrixExpression[State]: ...
    def apply(self, state: State) -> tuple[State, SparseRepr]: ...
    def block_diag(
        self, others: Iterable[MatrixExpression[State]]
    ) -> MatrixExpression[State]: ...
    def cache(self) -> MatrixExpression[State]: ...
    def copy(self, child: ExpressionNode) -> MatrixExpression[State]: ...
    def diff(self, variables: VariableVectorType[State]) -> MatrixExpression[State]: ...
    def eval[S: Symbol](
        self,
        substitutions: Expression.SubstitutionType[S],
    ) -> MatrixExpression[State]: ...
    def h_stack(
        self, others: Iterable[MatrixExpression[State]]
    ) -> MatrixExpression[State]: ...
    def kron(self, other: MatrixExpression[State]) -> MatrixExpression[State]: ...
    def monomial_vector(
        self, variables: VariableVectorType[State]
    ) -> MonomialVectorExpression[State]: ...
    def rep_mat(self, n: int, m: int) -> MatrixExpression[State]: ...
    def reshape(self, n: int, m: int) -> MatrixExpression[State]: ...
    def slice(
        self, slice: tuple[tuple[int, ...], tuple[int, ...]]
    ) -> MatrixExpression[State]: ...
    def sum(self) -> VectorExpression[State]: ...
    def symmetric(self) -> SymmetricMatrixExpression[State]: ...
    @property
    def T(self) -> MatrixExpression[State]: ...
    def to_polynomial(self) -> ScalarPolynomialExpression[State]: ...
    def to_variable_vector(self) -> VariableVectorType[State]: ...
    def to_vector(self) -> VectorExpression[State]: ...
    def to_monomial_vector(self) -> MonomialVectorExpression[State]: ...
    def to_symmetric_matrix(self) -> SymmetricMatrixExpression[State]: ...
    def truncate_monomials(
        self,
        variables: VariableVectorType[State],
        degrees: TruncateMonomials.DegreeType,
    ) -> MatrixExpression[State]: ...
    def v_stack(
        self, others: Iterable[MatrixExpression[State]]
    ) -> MatrixExpression[State]: ...

class SymmetricMatrixExpression[State: BaseState](MatrixExpression[State]):
    @overload
    def __add__(
        self, other: SymmetricMatrixExpression[State]
    ) -> SymmetricMatrixExpression[State]: ...
    @overload
    def __add__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    @overload
    def __matmul__(self, other: VectorExpression[State]) -> VectorExpression[State]: ...
    @overload
    def __matmul__(
        self, other: SymmetricMatrixExpression[State]
    ) -> SymmetricMatrixExpression[State]: ...
    @overload
    def __matmul__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    @overload
    def __mul__(
        self, other: SymmetricMatrixExpression[State]
    ) -> SymmetricMatrixExpression[State]: ...
    @overload
    def __mul__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __neg__(self) -> SymmetricMatrixExpression[State]: ...
    def __pow__(self, exponent: int) -> SymmetricMatrixExpression[State]: ...
    def __radd__(self, other: FromAnyTypes) -> SymmetricMatrixExpression[State]: ...
    def __rmul__(self, other: FromAnyTypes) -> SymmetricMatrixExpression[State]: ...
    def __rsub__(self, other: FromAnyTypes) -> SymmetricMatrixExpression[State]: ...
    @overload
    def __sub__(
        self, other: SymmetricMatrixExpression[State]
    ) -> SymmetricMatrixExpression[State]: ...
    @overload
    def __sub__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    @overload
    def block_diag(
        self, others: Iterable[SymmetricMatrixExpression[State]]
    ) -> SymmetricMatrixExpression[State]: ...
    @overload
    def block_diag(
        self, others: Iterable[MatrixExpression[State]]
    ) -> MatrixExpression[State]: ...
    def cache(self) -> SymmetricMatrixExpression[State]: ...
    def copy(self, child: ExpressionNode) -> SymmetricMatrixExpression[State]: ...
    def diag(self) -> VectorExpression[State]: ...
    def diff(
        self, variables: VariableVectorType[State]
    ) -> SymmetricMatrixExpression[State]: ...
    def eval[S: Symbol](
        self,
        substitutions: Expression.SubstitutionType[S],
    ) -> SymmetricMatrixExpression[State]: ...
    @overload
    def kron(
        self, other: SymmetricMatrixExpression[State]
    ) -> SymmetricMatrixExpression[State]: ...
    @overload
    def kron(self, other: MatrixExpression[State]) -> MatrixExpression[State]: ...
    @property
    def T(self) -> SymmetricMatrixExpression[State]: ...
    def trace(self) -> ScalarPolynomialExpression[State]: ...
    def truncate_monomials(
        self,
        variables: VariableVectorType[State],
        degrees: TruncateMonomials.DegreeType,
    ) -> SymmetricMatrixExpression[State]: ...

class VectorExpression[State: BaseState](MatrixExpression[State]):
    def __add__(self, other: FromAnyTypes) -> VectorExpression[State]: ...
    def __mul__(self, other: FromAnyTypes) -> VectorExpression[State]: ...
    def __neg__(self) -> VectorExpression[State]: ...
    def __pow__(self, exponent: int) -> VectorExpression[State]: ...
    def __radd__(self, other: FromAnyTypes) -> VectorExpression[State]: ...
    @overload
    def __matmul__(
        self, other: RowVectorExpression[State]
    ) -> SymmetricMatrixExpression[State]: ...
    @overload
    def __matmul__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __rmul__(self, other: FromAnyTypes) -> VectorExpression[State]: ...
    def __rsub__(self, other: FromAnyTypes) -> VectorExpression[State]: ...
    def __sub__(self, other: FromAnyTypes) -> VectorExpression[State]: ...
    def __truediv__(self, other: float | int) -> VectorExpression[State]: ...
    def cache(self) -> VectorExpression[State]: ...
    def combinations(
        self, degrees: Combinations.DegreeType
    ) -> VectorExpression[State]: ...
    def copy(self, child: ExpressionNode) -> VectorExpression[State]: ...
    def diag(self) -> SymmetricMatrixExpression[State]: ...
    def diff(self, variables: VariableVectorType[State]) -> VectorExpression[State]: ...
    def eval[S: Symbol](
        self,
        substitutions: Expression.SubstitutionType[S],
    ) -> VectorExpression[State]: ...
    def filter_predicate(
        self, predicate: FilterPredicate.PredicatorType
    ) -> VectorExpression[State]: ...
    def filter_non_zero(self) -> VectorExpression[State]: ...
    @overload
    def kron(self, other: VectorExpression[State]) -> VectorExpression[State]: ...
    @overload
    def kron(self, other: MatrixExpression[State]) -> MatrixExpression[State]: ...
    def coefficients_vector(
        self,
        variables: VariableVectorType[State] | None = None,
        monomials: MonomialVectorExpression[State] | None = None,
    ) -> MatrixExpression[State]: ...
    def parametrize(
        self, variable: Symbol | str
    ) -> VariableVectorSymbolExpression[State]: ...
    def product(
        self,
        others: Iterable[VectorExpression[State]],
        degrees: Product.DegreeType = None,
    ) -> VectorExpression[State]: ...
    def sum(self) -> ScalarPolynomialExpression[State]: ...
    def v_stack(
        self, others: Iterable[VectorExpression[State]]
    ) -> VectorExpression[State]: ...
    @property
    def T(self) -> RowVectorExpression[State]: ...
    def truncate_monomials(
        self,
        variables: VariableVectorType[State],
        degrees: TruncateMonomials.DegreeType,
    ) -> VectorExpression[State]: ...

class RowVectorExpression[State: BaseState](MatrixExpression[State]):
    def __add__(self, other: FromAnyTypes) -> RowVectorExpression[State]: ...
    def __mul__(self, other: FromAnyTypes) -> RowVectorExpression[State]: ...
    def __neg__(self) -> RowVectorExpression[State]: ...
    def __pow__(self, exponent: int) -> RowVectorExpression[State]: ...
    def __radd__(self, other: FromAnyTypes) -> RowVectorExpression[State]: ...
    @overload
    def __matmul__(
        self, other: SymmetricMatrixExpression[State]
    ) -> RowVectorExpression[State]: ...
    @overload
    def __matmul__(
        self, other: VectorExpression[State]
    ) -> ScalarPolynomialExpression[State]: ...
    @overload
    def __matmul__(self, other: FromAnyTypes) -> MatrixExpression[State]: ...
    def __rmul__(self, other: FromAnyTypes) -> RowVectorExpression[State]: ...
    def __rsub__(self, other: FromAnyTypes) -> RowVectorExpression[State]: ...
    def __sub__(self, other: FromAnyTypes) -> RowVectorExpression[State]: ...
    def __truediv__(self, other: float | int) -> RowVectorExpression[State]: ...
    def cache(self) -> RowVectorExpression[State]: ...
    def copy(self, child: ExpressionNode) -> RowVectorExpression[State]: ...
    def diff(
        self, variables: VariableVectorType[State]
    ) -> RowVectorExpression[State]: ...
    def eval[S: Symbol](
        self,
        substitutions: Expression.SubstitutionType[S],
    ) -> RowVectorExpression[State]: ...
    def h_stack(
        self, others: Iterable[RowVectorExpression[State]]
    ) -> RowVectorExpression[State]: ...
    @overload
    def kron(self, other: VectorExpression[State]) -> RowVectorExpression[State]: ...
    @overload
    def kron(self, other: MatrixExpression[State]) -> MatrixExpression[State]: ...
    def sum(self) -> ScalarPolynomialExpression[State]: ...
    @property
    def T(self) -> VectorExpression[State]: ...
    def truncate_monomials(
        self,
        variables: VariableVectorType[State],
        degrees: TruncateMonomials.DegreeType,
    ) -> RowVectorExpression[State]: ...

class ScalarPolynomialExpression[State: BaseState](VectorExpression[State]):
    def __add__(self, other: FromAnyTypes) -> ScalarPolynomialExpression[State]: ...
    def __mul__(self, other: FromAnyTypes) -> ScalarPolynomialExpression[State]: ...
    def __neg__(self) -> ScalarPolynomialExpression[State]: ...
    def __pow__(self, exponent: int) -> ScalarPolynomialExpression[State]: ...
    def __radd__(self, other: FromAnyTypes) -> ScalarPolynomialExpression[State]: ...
    def __rmul__(self, other: FromAnyTypes) -> ScalarPolynomialExpression[State]: ...
    def __rsub__(self, other: FromAnyTypes) -> ScalarPolynomialExpression[State]: ...
    def __sub__(self, other: FromAnyTypes) -> ScalarPolynomialExpression[State]: ...
    def __truediv__(self, other: float | int) -> ScalarPolynomialExpression[State]: ...
    def cache(self) -> ScalarPolynomialExpression[State]: ...
    def copy(self, child: ExpressionNode) -> ScalarPolynomialExpression[State]: ...
    def diff(
        self, variables: VariableVectorType[State]
    ) -> RowVectorExpression[State]: ...
    def eval[S: Symbol](
        self,
        substitutions: Expression.SubstitutionType[S],
    ) -> ScalarPolynomialExpression[State]: ...
    def h_stack(
        self, others: Iterable[MatrixExpression[State]]
    ) -> RowVectorExpression[State]: ...
    def coefficients_vector(
        self,
        variables: VariableVectorType[State] | None = None,
        monomials: MonomialVectorExpression[State] | None = None,
    ) -> RowVectorExpression[State]: ...
    def sum(self) -> ScalarPolynomialExpression[State]: ...
    def truncate_monomials(
        self,
        variables: VariableVectorType[State],
        degrees: TruncateMonomials.DegreeType,
    ) -> ScalarPolynomialExpression[State]: ...

class MonomialVectorExpression[State: BaseState](VectorExpression[State]):
    @overload
    def __mul__(
        self, other: MonomialVectorExpression[State]
    ) -> MonomialVectorExpression[State]: ...
    @overload
    def __mul__(self, other: FromAnyTypes) -> VectorExpression[State]: ...
    def __pow__(self, exponent: int) -> MonomialVectorExpression[State]: ...
    def cache(self) -> MonomialVectorExpression[State]: ...
    def copy(self, child: ExpressionNode) -> MonomialVectorExpression[State]: ...
    def filter_predicate(
        self, predicate: FilterPredicate.PredicatorType
    ) -> MonomialVectorExpression[State]: ...
    def filter_non_zero(self) -> MonomialVectorExpression[State]: ...
    @overload
    def product(
        self,
        others: Iterable[MonomialVectorExpression[State]],
        degrees: Product.DegreeType = None,
    ) -> MonomialVectorExpression[State]: ...
    @overload
    def product(
        self,
        others: Iterable[VectorExpression[State]],
        degrees: Product.DegreeType = None,
    ) -> VectorExpression[State]: ...

class MonomialExpression[State: BaseState](
    ScalarPolynomialExpression[State], MonomialVectorExpression[State]
):
    @overload
    def __mul__(
        self, other: MonomialExpression[State]
    ) -> MonomialExpression[State]: ...
    @overload
    def __mul__(self, other: FromAnyTypes) -> ScalarPolynomialExpression[State]: ...
    def __pow__(self, exponent: int) -> MonomialExpression[State]: ...
    def cache(self) -> MonomialExpression[State]: ...
    def copy(self, child: ExpressionNode) -> MonomialExpression[State]: ...

class VariableVectorExpression[State: BaseState](MonomialVectorExpression[State]):
    def __pow__(self, exponent: int) -> MonomialVectorExpression[State]: ...
    def cache(self) -> VariableVectorExpression[State]: ...
    def combinations(
        self, degrees: Combinations.DegreeType
    ) -> MonomialVectorExpression[State]: ...
    def copy(self, child: ExpressionNode) -> VariableVectorExpression[State]: ...
    def filter_predicate(
        self, predicate: FilterPredicate.PredicatorType
    ) -> VariableVectorExpression[State]: ...
    def filter_non_zero(self) -> VariableVectorExpression[State]: ...

class VariableVectorSymbolExpression[State: BaseState](VariableVectorExpression[State]):
    def cache(self) -> VariableVectorSymbolExpression[State]: ...
    def copy(self, child: ExpressionNode) -> VariableVectorSymbolExpression[State]: ...
    @property
    def symbol(self) -> Symbol: ...

class VariableExpression[State: BaseState](
    MonomialExpression[State],
    VariableVectorSymbolExpression[State],
):
    def cache(self) -> VariableExpression[State]: ...
    def copy(self, child: ExpressionNode) -> VariableExpression[State]: ...
