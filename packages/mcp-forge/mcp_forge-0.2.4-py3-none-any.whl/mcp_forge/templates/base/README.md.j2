# {{ config.project_name }}

{{ config.description }}

This project is an MCP (Model Context Protocol) server generated by `mcp-forge`. It provides a starting point for building your own server with custom tools and resources.

## Project Structure

```
./
├── {{ config.package_name }}/           # Python package for your server code
│   ├── __init__.py              # Package initialization
│   ├── server_stdio.py          # Entry point for running the server with stdio transport
│   ├── server_sse.py            # Entry point for running the server with SSE transport (HTTP)
│   ├── interfaces/              # Base classes/interfaces for tools and resources
│   │   ├── __init__.py
│   │   ├── resource.py
│   │   └── tool.py
│   ├── resources/               # Implementation of resources
│   │   ├── __init__.py
│   │   ├── hello_world.py       # Example static resource
│   │   └── user_profile.py      # Example dynamic resource with URI parameters
│   ├── services/                # Services for managing tools and resources
│   │   ├── __init__.py
│   │   ├── resource_service.py  # Handles resource registration and routing
│   │   └── tool_service.py      # Handles tool registration and execution
│   └── tools/                   # Implementation of tools
│       ├── __init__.py
│       └── hello_world.py       # Example tool with input/output schemas
├── pyproject.toml               # Project metadata and dependencies (using Hatch)
├── test_client.py               # Example client script to test server functionality
└── README.md                    # This file
```

## Setup

This project uses `uv` for dependency management. Ensure you have `uv` installed (`pip install uv`).

1.  **Navigate** into the project directory:
    ```bash
    cd {{ config.project_name }}
    ```
2.  **Create a virtual environment** and install dependencies:
    ```bash
    uv venv
    uv pip install -e .
    ```

## Running the Server

You can run the server using either the SSE (HTTP-based) transport or the stdio (standard input/output) transport.

### SSE Server

Runs an HTTP server (using Uvicorn/Starlette) that communicates over Server-Sent Events.

```bash
# Run the SSE server (defaults to http://0.0.0.0:6969)
uv run python -m {{ config.package_name }}.server_sse

# You can specify host and port:
uv run python -m {{ config.package_name }}.server_sse --host 127.0.0.1 --port 8000
```

### Stdio Server

Runs the server communicating over standard input and output. Useful for local development or direct process interaction.

```bash
uv run python -m {{ config.package_name }}.server_stdio
```

## Testing the Server

A test client script (`test_client.py`) is included to verify the server's functionality. It demonstrates connecting via both SSE and stdio (if possible), listing available tools and resources, and calling them with example inputs.

1.  **Start the server** (either SSE or stdio) in one terminal.
2.  In a **separate terminal** (ensure you are in the project directory):
    ```bash
    uv run test_client.py
    ```

The client will output the results of its interactions with the server, showing tool calls and resource reads.

## Developing Your Server

### Adding New Tools

1.  **Create a new Python file** in the `{{ config.package_name }}/tools/` directory (e.g., `my_tool.py`).
2.  **Define your tool class** inheriting from `Tool` (from `{{ config.package_name }}.interfaces.tool`).
3.  **Define an input model** inheriting from `BaseToolInput` for your tool's parameters using Pydantic.
4.  **Implement the `execute` method** containing your tool's logic.
5.  **Import and add your tool class** to the `__all__` list in `{{ config.package_name }}/tools/__init__.py`.
6.  **Instantiate your tool** in the `get_available_tools` function within `{{ config.package_name }}/server_stdio.py` and `{{ config.package_name }}/server_sse.py`.

### Adding New Resources

1.  **Create a new Python file** in the `{{ config.package_name }}/resources/` directory (e.g., `my_resource.py`).
2.  **Define your resource class** inheriting from `Resource` (from `{{ config.package_name }}.interfaces.resource`).
3.  **Define the required class attributes**: `name`, `description`, `uri`, `mime_type`.
4.  **Implement the `read` method**. For dynamic URIs (e.g., `data://{item_id}`), parameters are passed as keyword arguments to `read` (e.g., `read(item_id=...)`).
5.  **Import and add your resource class** to the `__all__` list in `{{ config.package_name }}/resources/__init__.py`.
6.  **Instantiate your resource** in the `get_available_resources` function within `{{ config.package_name }}/server_stdio.py` and `{{ config.package_name }}/server_sse.py`.

### Service Layer

- `ToolService`: Manages the registration and execution of tools. It dynamically creates handler functions based on tool input schemas.
- `ResourceService`: Manages the registration and reading of resources. It handles routing for static and dynamic URIs.

## Learn More About MCP

Visit the official [Model Context Protocol Documentation](https://modelcontextprotocol.io/) for detailed information about the protocol, concepts, and advanced features.
