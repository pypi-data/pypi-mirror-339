"""Rules generator for creating .cursorrules files."""

import re
from pathlib import Path
from typing import Any, Dict, List, Optional
import os

from amauta_ai.analyzer.service import AnalyzerService
from amauta_ai.config.service import ConfigService

# Add AI service import
from amauta_ai.ai.service import AiService
from amauta_ai.ai.provider_selection import ProviderMode

# Constants for template directories
RULES_TEMPLATES_DIR = Path(__file__).parent.parent.parent / "rules"
RULES_NEW_TEMPLATES_DIR = Path(__file__).parent.parent.parent / "rules-new"


class RulesGenerator:
    """
    Rules generator for creating .cursorrules files.

    This class is responsible for generating .cursorrules files based on
    analysis results and configuration.
    """

    def __init__(
        self,
        config_service: Optional[ConfigService] = None,
        analyzer_service: Optional[AnalyzerService] = None,
        base_path: str = ".",
    ):
        """
        Initialize the rules generator.

        Args:
            config_service: The configuration service to use. If None, a new one is created.
            analyzer_service: The analyzer service to use. If None, a new one is created.
            base_path: The base path to use for generating rules.
        """
        self.config_service = config_service or ConfigService()
        self.analyzer_service = analyzer_service or AnalyzerService(
            config_service, base_path
        )
        self.base_path = Path(base_path).resolve()
        self.config = self.config_service.get_config()

    def generate_rules(self, analysis_result: Optional[Dict[str, Any]] = None) -> str:
        """
        Generate a .cursorrules file based on analysis and configuration.

        Args:
            analysis_result: Analysis results to use. If None, a new analysis will be performed.

        Returns:
            The content of the .cursorrules file
        """
        try:
            # If no analysis result is provided, run a new analysis
            if analysis_result is None:
                try:
                    analysis_result = self.analyzer_service.analyze()
                except Exception as e:
                    # Log the error and use default values
                    analysis_result = {
                        "tech_stack": {
                            "languages": ["Python"],
                            "frameworks": [],
                            "libraries": [],
                            "tools": [],
                        },
                        "project_metrics": None,
                        "dependencies": {},
                        "code_quality": None,
                    }

            # Start building the rules content
            rules_content = [
                "// --- AMAUTA Project: Cursor Development Rules ---",
                "// Version: 1.0",
                f"// Date: {self._get_date()}",
                "// Generated by AMAUTA",
                "// ---",
                "// Purpose: Guide AI development in this specific codebase.",
                "// ---",
                "",
                "// --- Core Principles & Project Context ---",
            ]

            # Project information
            project_name = self.config.project.name or "This Project"
            project_description = (
                self.config.project.description or "A software project"
            )

            rules_content.extend(
                [
                    f"// 1.  **Project Goal:** {project_description}",
                    "// 2.  **Tech Stack:**",
                ]
            )

            # Safely extract tech stack information
            tech_stack = analysis_result.get("tech_stack", {})

            # Helper function to sanitize list items
            def sanitize_list(items: Any) -> List[str]:
                if not isinstance(items, list):
                    return []
                return [
                    str(item) for item in items if item and str(item).lower() != "none"
                ]

            # Add tech stack information
            for language in sanitize_list(tech_stack.get("languages", [])):
                rules_content.append(f"//     - {language}")

            for framework in sanitize_list(tech_stack.get("frameworks", [])):
                rules_content.append(f"//     - {framework}")

            for library in sanitize_list(tech_stack.get("libraries", [])):
                rules_content.append(f"//     - {library}")

            for tool in sanitize_list(tech_stack.get("tools", [])):
                rules_content.append(f"//     - {tool}")

            # Add file structure section
            rules_content.extend(
                [
                    "// 3.  **File Structure:**",
                    "//     - Organize code according to the existing directory structure.",
                    "//     - Place new files in the appropriate directories based on functionality.",
                ]
            )

            # Add custom rules from configuration
            if self.config.custom_rules:
                rules_content.append("// 4.  **Custom Rules:**")
                for rule, description in self.config.custom_rules.items():
                    rules_content.append(f"//     - **{rule}:** {description}")

            # Add project metrics section if available
            project_metrics = analysis_result.get("project_metrics")
            if isinstance(project_metrics, dict):
                rules_content.extend(
                    [
                        "",
                        "// --- Project Metrics ---",
                        f"// Project has {project_metrics.get('complexity', 'unknown')} complexity",
                        f"// Test Coverage: {project_metrics.get('test_coverage', 0)}%",
                        f"// Project has {project_metrics.get('maintainability', 'unknown')} maintainability",
                        f"// Lines of Code: {project_metrics.get('lines_of_code', 0)}",
                    ]
                )

            # Add dependencies section if available
            dependencies = analysis_result.get("dependencies")
            if isinstance(dependencies, dict):
                rules_content.extend(
                    [
                        "",
                        "// --- Dependencies ---",
                    ]
                )
                for dep_type, deps in dependencies.items():
                    if isinstance(deps, list):
                        rules_content.append(
                            f"// {dep_type.capitalize()} Dependencies:"
                        )
                        for dep in deps:
                            rules_content.append(f"//     - {dep}")

            # Add code quality metrics if available
            code_quality = analysis_result.get("code_quality")
            if isinstance(code_quality, dict):
                rules_content.extend(
                    [
                        "",
                        "// --- Code Quality Metrics ---",
                    ]
                )

                # Helper function to validate numeric metrics
                def validate_metric(
                    value: Any, min_val: float = 0, max_val: float = 100
                ) -> Optional[float]:
                    try:
                        val = float(value)
                        if min_val <= val <= max_val:
                            return val
                        return None
                    except (ValueError, TypeError):
                        return None

                linting_score = validate_metric(code_quality.get("linting_score"))
                if linting_score is not None:
                    rules_content.append(f"// Linting Score: {linting_score}%")

                type_coverage = validate_metric(code_quality.get("type_coverage"))
                if type_coverage is not None:
                    rules_content.append(f"// Type Coverage: {type_coverage}%")

                doc_coverage = validate_metric(
                    code_quality.get("documentation_coverage")
                )
                if doc_coverage is not None:
                    rules_content.append(f"// Documentation Coverage: {doc_coverage}%")

            # Add coding standards section
            rules_content.extend(
                [
                    "",
                    "// --- Coding Standards & Conventions ---",
                    "// Python Standards:",
                    "//   - Follow PEP 8 style guidelines.",
                    "//   - Use type annotations for all function signatures.",
                    "//   - Use docstrings for all classes and functions.",
                    "//   - Use f-strings for string formatting.",
                    "//   - Organize imports in alphabetical order: standard library, third-party, local.",
                ]
            )

            # Add JavaScript/TypeScript standards if relevant
            if "TypeScript" in str(
                tech_stack.get("languages", [])
            ) or "JavaScript" in str(tech_stack.get("languages", [])):
                rules_content.extend(
                    [
                        "// JavaScript/TypeScript Standards:",
                        "//   - Use ES6+ features.",
                        "//   - Use const and let instead of var.",
                        "//   - Use arrow functions for anonymous functions.",
                        "//   - Use destructuring assignment.",
                        "//   - Use async/await instead of promises where appropriate.",
                    ]
                )

            # Add command reference section
            rules_content.extend(
                [
                    "",
                    "// --- AMAUTA Command Reference ---",
                    "// AMAUTA is a CLI tool for analyzing code, managing tasks, and enforcing standards.",
                    "// Here are the main commands you can use:",
                    "//",
                    "// - `amauta init`: Initialize AMAUTA in the current project directory.",
                    "// - `amauta analyze`: Analyze the codebase and generate reports.",
                    "// - `amauta parse-prd <file>`: Parse a PRD file and generate tasks.",
                    "// - `amauta task list`: List all tasks.",
                    "// - `amauta task show <id>`: Show details for a specific task.",
                    "// - `amauta task next`: Get the next task to work on.",
                    "// - `amauta task set-status <id> <status>`: Update the status of a task.",
                    "// - `amauta task add-dependency <task_id> <depends_on_id>`: Add a dependency between tasks.",
                    "// - `amauta task remove-dependency <task_id> <depends_on_id>`: Remove a dependency between tasks.",
                    "// - `amauta task validate-dependencies`: Validate task dependencies.",
                    "// - `amauta task fix-dependencies`: Suggest or fix dependency issues.",
                    '// - `amauta task add --prompt="<task description>"`: Add a new task using AI assistance.',
                    '// - `amauta task update --from=<id> --prompt="<description>"`: Update a task using AI assistance.',
                    "// - `amauta task expand --id=<id> [--num=N]`: Expand a task into subtasks using AI assistance.",
                    "// - `amauta task clear-subtasks <id>`: Remove all subtasks from a task.",
                    "// - `amauta task generate-files`: Generate individual task files.",
                    "// - `amauta task analyze-complexity`: Analyze task complexity using AI assistance.",
                    "// - `amauta task complexity-report`: Display the complexity analysis report.",
                    "// - `amauta generate-rules`: Generate .cursorrules based on analysis.",
                    "// - `amauta report`: Generate a comprehensive project report.",
                    "// - `amauta mcp`: Run the Model Control Protocol server for Cursor integration.",
                ]
            )

            # Add "DO NOT" section
            rules_content.extend(
                [
                    "",
                    "// --- DO NOT ---",
                    "// 1. Do not modify `tasks.json` directly. Use AMAUTA commands instead.",
                    "// 2. Do not hardcode API keys or configuration values.",
                    "// 3. Do not introduce code that violates the established coding standards.",
                    "",
                    "// --- END RULES ---",
                ]
            )

            return "\n".join(rules_content)

        except Exception as e:
            # If anything fails, return a minimal valid rules file
            return "\n".join(
                [
                    "// --- AMAUTA Project: Cursor Development Rules ---",
                    "// Version: 1.0",
                    f"// Date: {self._get_date()}",
                    "// Generated by AMAUTA",
                    "// ---",
                    "// Purpose: Guide AI development in this specific codebase.",
                    "// ---",
                    "",
                    "// --- Core Principles & Project Context ---",
                    f"// 1.  **Project Goal:** {self.config.project.description or 'A software project'}",
                    "// 2.  **Tech Stack:**",
                    "//     - Python",
                    "",
                    "// --- END RULES ---",
                ]
            )

    def _get_date(self) -> str:
        """
        Get the current date in a formatted string.

        Returns:
            A string representing the current date in the format "Month Day, Year"
        """
        from datetime import datetime

        return datetime.now().strftime("%B %d, %Y")

    def save_rules(self, rules_content: str) -> str:
        """
        Save the rules content to a .cursorrules file.

        Args:
            rules_content: The content of the .cursorrules file

        Returns:
            The path to the saved file
        """
        # Create .cursor/rules directory if it doesn't exist
        cursor_rules_dir = self.base_path / ".cursor" / "rules"
        cursor_rules_dir.mkdir(parents=True, exist_ok=True)

        # Save the rules file
        rules_file_path = cursor_rules_dir / "dev_workflow.mdc"
        with open(rules_file_path, "w", encoding="utf-8") as f:
            f.write(rules_content)

        # Also save a copy in the root directory for backup
        root_rules_file_path = self.base_path / ".cursorrules"
        with open(root_rules_file_path, "w", encoding="utf-8") as f:
            f.write(rules_content)

        return str(rules_file_path)

    def generate_rules_with_ai(self, analysis_result: Optional[Dict[str, Any]] = None) -> str:
        """
        Generate a .cursorrules file using AI to enhance the rules.
        
        This method uses the AiService to generate more tailored and intelligent
        rules based on the analysis of the codebase and existing rule templates.
        
        Args:
            analysis_result: Analysis results to use. If None, a new analysis will be performed.
            
        Returns:
            The content of the AI-enhanced .cursorrules file
        """
        try:
            # Get basic rules content first as fallback
            basic_rules = self.generate_rules(analysis_result)
            
            # If no analysis result is provided, run a new analysis
            if analysis_result is None:
                try:
                    analysis_result = self.analyzer_service.analyze()
                except Exception as e:
                    print(f"Warning: Analysis failed: {str(e)}. Using basic analysis.")
                    analysis_result = {
                        "tech_stack": {
                            "languages": ["Python"],
                            "frameworks": [],
                            "libraries": [],
                            "tools": [],
                        },
                        "project_metrics": None,
                        "dependencies": {},
                        "code_quality": None,
                    }
            
            # Create AI service
            ai_service = AiService(self.config_service)
            
            # Collect rule template examples from both directories
            template_examples = self._collect_rule_template_examples(analysis_result.get("tech_stack", {}))
            
            # Create prompt context with project information
            context = {
                "project_name": self.config.project.name or "AMAUTA Project",
                "project_description": self.config.project.description or "A software project",
                "tech_stack": analysis_result.get("tech_stack", {}),
                "basic_rules": basic_rules,
                "file_structure": self._get_file_structure_summary(),
                "dependencies": analysis_result.get("dependencies", {}),
                "template_examples": template_examples,
            }
            
            # Generate enhanced rules using AI
            prompt = f"""
            You are an expert developer assistant. Your task is to create a comprehensive .cursorrules file
            for a project to guide AI development in this codebase. 
            
            PROJECT INFORMATION:
            Name: {context['project_name']}
            Description: {context['project_description']}
            
            TECH STACK:
            {self._format_tech_stack(context['tech_stack'])}
            
            FILE STRUCTURE SUMMARY:
            {context['file_structure']}
            
            DEPENDENCIES:
            {self._format_dependencies(context['dependencies'])}
            
            TEMPLATE EXAMPLES:
            {context['template_examples']}
            
            BASIC RULES:
            {context['basic_rules']}
            
            Please generate an enhanced .cursorrules file that:
            1. Maintains the same structure as the basic rules
            2. Incorporates relevant content from the template examples that match the project's tech stack
            3. Adds more specific guidance on code organization and style for the detected tech stack
            4. Includes best practices for the project's primary languages and frameworks
            5. Provides clear instructions on how to handle imports, error handling, and testing
            6. Suggests appropriate naming conventions and documentation standards
            7. Keeps the AMAUTA command reference section intact
            
            The output should be a complete .cursorrules file formatted as a comment block using JavaScript-style comments.
            """
            
            try:
                # Request AI-generated rules with preference for research mode
                enhanced_rules = ai_service.query_llm(
                    prompt=prompt,
                    mode="research",
                    max_tokens=4000,
                    research=True,
                )
                
                # If successful, return the enhanced rules
                if enhanced_rules and "// ---" in enhanced_rules:
                    return enhanced_rules
                
                # If the result doesn't look like rules, fall back to basic rules
                print("Warning: AI-generated rules format was invalid. Using basic rules.")
                return basic_rules
                
            except Exception as ai_error:
                print(f"Warning: AI generation failed: {str(ai_error)}. Using basic rules.")
                return basic_rules
                
        except Exception as e:
            print(f"Error generating AI-enhanced rules: {str(e)}")
            # Fall back to basic rules if anything fails
            return self.generate_rules(analysis_result)
    
    def _collect_rule_template_examples(self, tech_stack: Dict[str, Any]) -> str:
        """
        Collect examples from rule templates that match the project's tech stack.
        
        Args:
            tech_stack: Tech stack information from analysis
            
        Returns:
            A string containing relevant template examples
        """
        examples = []
        relevant_keywords = self._get_tech_stack_keywords()
        
        # Check rules-new directory for MDC files
        if RULES_NEW_TEMPLATES_DIR.exists():
            for template_file in RULES_NEW_TEMPLATES_DIR.glob("*.mdc"):
                # Check if the file name matches any tech stack keyword
                if any(keyword in template_file.stem.lower() for keyword in relevant_keywords):
                    try:
                        with open(template_file, "r", encoding="utf-8") as f:
                            content = f.read()
                            # Add the first 20 lines or 500 characters as example
                            content_preview = "\n".join(content.split("\n")[:20])
                            if len(content_preview) > 500:
                                content_preview = content_preview[:500] + "..."
                            examples.append(f"Example from {template_file.name}:\n{content_preview}\n")
                    except Exception:
                        continue
        
        # Check rules directory for template directories
        if RULES_TEMPLATES_DIR.exists():
            # Find directories that match our tech stack
            for rule_dir in RULES_TEMPLATES_DIR.glob("*"):
                if not rule_dir.is_dir():
                    continue
                
                # Check if the directory name matches any of our tech stack keywords
                dir_name = rule_dir.name.lower()
                if any(keyword in dir_name for keyword in relevant_keywords):
                    # Find the .cursorrules file or prompt file in the directory
                    for rules_file in rule_dir.glob("*.cursorrules") or rule_dir.glob("*prompt-file*"):
                        if rules_file.is_file():
                            try:
                                with open(rules_file, "r", encoding="utf-8") as f:
                                    content = f.read()
                                    # Add the first 20 lines or 500 characters as example
                                    content_preview = "\n".join(content.split("\n")[:20])
                                    if len(content_preview) > 500:
                                        content_preview = content_preview[:500] + "..."
                                    examples.append(f"Example from {rule_dir.name}:\n{content_preview}\n")
                            except Exception:
                                continue
                            break
        
        # If we have too many examples, use only the most relevant ones
        if len(examples) > 5:
            # Sort by relevance and take the top 5
            examples = examples[:5]
        
        return "\n".join(examples) if examples else "No relevant examples found."
    
    def _get_file_structure_summary(self) -> str:
        """Get a summary of the project's file structure."""
        try:
            # Get the repo structure - just top-level directories and counts
            structure = []
            base_path = self.base_path
            
            # Get top-level directories
            for item in base_path.iterdir():
                if item.is_dir() and not item.name.startswith("."):
                    file_count = sum(1 for _ in item.glob("**/*") if _.is_file())
                    structure.append(f"{item.name}/ ({file_count} files)")
                elif item.is_file() and not item.name.startswith("."):
                    structure.append(f"{item.name}")
            
            return "\n".join(structure)
        except Exception:
            return "Unable to analyze file structure"
    
    def _format_tech_stack(self, tech_stack: Dict[str, Any]) -> str:
        """Format tech stack information for the prompt."""
        result = []
        
        # Add languages
        if "languages" in tech_stack and tech_stack["languages"]:
            result.append("Languages: " + ", ".join(tech_stack["languages"]))
            
        # Add frameworks
        if "frameworks" in tech_stack and tech_stack["frameworks"]:
            result.append("Frameworks: " + ", ".join(tech_stack["frameworks"]))
            
        # Add libraries
        if "libraries" in tech_stack and tech_stack["libraries"]:
            result.append("Libraries: " + ", ".join(tech_stack["libraries"]))
            
        # Add tools
        if "tools" in tech_stack and tech_stack["tools"]:
            result.append("Tools: " + ", ".join(tech_stack["tools"]))
            
        return "\n".join(result) if result else "No tech stack information available"
    
    def _format_dependencies(self, dependencies: Dict[str, Any]) -> str:
        """Format dependency information for the prompt."""
        result = []
        
        for dep_type, deps in dependencies.items():
            if deps:
                result.append(f"{dep_type.capitalize()} dependencies:")
                if isinstance(deps, list):
                    for dep in deps[:10]:  # Limit to 10 deps to keep prompt size reasonable
                        result.append(f"- {dep}")
                    if len(deps) > 10:
                        result.append(f"...and {len(deps) - 10} more")
                
        return "\n".join(result) if result else "No dependency information available"
  
    # Update the generate_and_save_rules method to use AI-enhanced rules when possible
    def generate_and_save_rules(self, use_ai: bool = True) -> str:
        """
        Generate and save .cursorrules in one step.
        
        Args:
            use_ai: Whether to use AI-enhanced rule generation
            
        Returns:
            The path to the saved file
        """
        if use_ai:
            try:
                rules_content = self.generate_rules_with_ai()
            except Exception as e:
                print(f"AI-enhanced rule generation failed: {str(e)}. Falling back to basic rules.")
                rules_content = self.generate_rules()
        else:
            rules_content = self.generate_rules()
            
        return self.save_rules(rules_content)

    def generate_cursor_rules(self, output_dir: Optional[str] = None) -> List[str]:
        """
        Generate cursor rules from templates.

        This method copies and customizes rule templates from the rules and rules-new
        directories to the .cursor/rules directory in the project. It uses AI to
        enhance and tailor the rules when possible.

        Args:
            output_dir: Directory to output the rules files to. If None, defaults to
                        .cursor/rules in the base path.

        Returns:
            List of paths to the generated rules files.
        """
        # If no output directory is provided, use .cursor/rules in the base path
        if output_dir is None:
            output_dir = self.base_path / ".cursor" / "rules"
        else:
            output_dir = Path(output_dir).resolve()

        # Create the output directory if it doesn't exist
        output_dir.mkdir(parents=True, exist_ok=True)

        generated_files = []
        
        # Check if AI enhancement is requested
        use_ai = os.environ.get("AMAUTA_GENERATE_RULES_AI", "1") == "1"

        # First, generate the AMAUTA specific rules file
        amauta_rules_path = output_dir / "amauta_project.mdc"
        if use_ai:
            try:
                amauta_rules_content = self.generate_rules_with_ai()
            except Exception as e:
                print(f"Warning: AI rule generation failed: {str(e)}. Using basic rules.")
                amauta_rules_content = self.generate_rules()
        else:
            amauta_rules_content = self.generate_rules()
            
        with open(amauta_rules_path, "w", encoding="utf-8") as f:
            f.write(amauta_rules_content)
        generated_files.append(str(amauta_rules_path))

        # Get tech stack info to prioritize templates
        tech_stack_keywords = self._get_tech_stack_keywords()
        tech_stack_info = self._format_tech_stack(self.analyzer_service.analyze().get("tech_stack", {}))
        
        # Collect templates from both rules-new and rules directories
        template_files = []
        
        # Process rules-new directory (modern templates)
        if RULES_NEW_TEMPLATES_DIR.exists():
            for template_file in RULES_NEW_TEMPLATES_DIR.glob("*.mdc"):
                template_files.append({
                    "path": template_file,
                    "source": "rules-new", 
                    "relevance": self._calculate_template_relevance(template_file.stem, tech_stack_keywords)
                })

        # Process rules directory (legacy templates)
        if RULES_TEMPLATES_DIR.exists():
            for rule_dir in RULES_TEMPLATES_DIR.glob("*"):
                if not rule_dir.is_dir():
                    continue
                    
                # Look for template files in this directory
                for rules_file in rule_dir.glob("*.cursorrules") or rule_dir.glob("*prompt-file*"):
                    if rules_file.is_file():
                        template_files.append({
                            "path": rules_file,
                            "source": "rules", 
                            "dir_name": rule_dir.name,
                            "relevance": self._calculate_template_relevance(rule_dir.name, tech_stack_keywords)
                        })
                        break

        # Sort templates by relevance (higher is better)
        template_files.sort(key=lambda x: x["relevance"], reverse=True)
        
        # Limit to top 10 most relevant templates
        template_files = template_files[:10]
        
        # Create AI service if needed
        ai_service = None
        if use_ai:
            try:
                ai_service = AiService(self.config_service)
            except Exception as e:
                print(f"Warning: Failed to initialize AI service: {str(e)}")
                
        # Process each template
        for template_info in template_files:
            try:
                template_path = template_info["path"]
                source = template_info["source"]
                
                # Read template content
                with open(template_path, "r", encoding="utf-8") as src:
                    content = src.read()
                
                # Determine output filename
                if source == "rules-new":
                    output_filename = template_path.name
                else:
                    # For rules directory, use a cleaner name derived from the directory
                    dir_name = template_info["dir_name"]
                    output_filename = f"{dir_name.replace('-cursorrules-prompt-file', '')}.mdc"
                
                output_file = output_dir / output_filename
                
                # Customize template with AI if available
                if ai_service and use_ai:
                    try:
                        customized_content = self._customize_template_with_ai(
                            ai_service, 
                            content, 
                            template_path.name, 
                            tech_stack_info
                        )
                        if customized_content:
                            content = customized_content
                    except Exception as e:
                        print(f"Warning: AI customization failed for {output_filename}: {str(e)}")
                
                # Write the content to the output file
                with open(output_file, "w", encoding="utf-8") as dst:
                    dst.write(content)
                
                generated_files.append(str(output_file))
                
            except Exception as e:
                print(f"Warning: Failed to process template {template_info.get('path')}: {str(e)}")
                continue

        return generated_files
        
    def _calculate_template_relevance(self, name: str, keywords: List[str]) -> int:
        """
        Calculate the relevance score of a template based on matching keywords.
        
        Args:
            name: The name of the template or directory
            keywords: List of tech stack keywords to match against
            
        Returns:
            A relevance score (higher is more relevant)
        """
        name = name.lower()
        score = 0
        
        # Check for exact matches
        for keyword in keywords:
            if keyword.lower() in name:
                score += 2
                # Priority for language matches
                if keyword.lower() in ["python", "typescript", "javascript", "react", "vue", "angular"]:
                    score += 3
        
        return score
        
    def _customize_template_with_ai(
        self, 
        ai_service: AiService, 
        template_content: str, 
        template_name: str,
        tech_stack_info: str
    ) -> Optional[str]:
        """
        Use AI to customize a template for the current project.
        
        Args:
            ai_service: The AI service to use
            template_content: The original template content
            template_name: The name of the template
            tech_stack_info: Information about the project's tech stack
            
        Returns:
            Customized template content, or None if customization failed
        """
        try:
            # Create a prompt for customizing the template
            prompt = f"""
            You are an expert developer assistant. Your task is to customize this cursor rules template
            for a specific project based on its tech stack.
            
            TEMPLATE NAME: {template_name}
            
            PROJECT TECH STACK:
            {tech_stack_info}
            
            ORIGINAL TEMPLATE CONTENT:
            {template_content[:1000]}  # Limit the content to keep the prompt size reasonable
            
            Please customize this template by:
            1. Keeping the overall structure and format intact
            2. Tailoring the content to match the project's specific tech stack
            3. Adding specific examples and best practices relevant to the project
            4. Removing any irrelevant sections that don't apply to this project's technology
            5. Ensuring all guidance is concrete and actionable
            
            Return the complete customized template with the same basic structure but tailored content.
            """
            
            # Get AI-customized template
            customized_content = ai_service.request_completion(
                prompt=prompt,
                provider_mode=ProviderMode.RESEARCH,
                max_tokens=3000,
            )
            
            if not customized_content or len(customized_content) < 100:
                return None
                
            return customized_content
            
        except Exception:
            return None

    def _get_tech_stack_keywords(self) -> List[str]:
        """
        Extract keywords from the tech stack to match against rule template directories.

        Returns:
            List of lowercase keywords to match against directory names.
        """
        keywords = ["python", "cli", "type"]  # Always include these for AMAUTA

        try:
            analysis_result = self.analyzer_service.analyze()
            tech_stack = analysis_result.get("tech_stack", {})

            # Add languages
            for lang in tech_stack.get("languages", []):
                keywords.append(lang.lower())

            # Add frameworks
            for framework in tech_stack.get("frameworks", []):
                keywords.append(framework.lower())

            # Add libraries
            for library in tech_stack.get("libraries", []):
                keywords.append(library.lower())

            # Split multi-word items and add individual parts
            expanded_keywords = []
            for keyword in keywords:
                expanded_keywords.append(keyword)
                # Split by spaces, hyphens, underscores
                parts = re.split(r"[ \-_]", keyword)
                expanded_keywords.extend([p.lower() for p in parts if p and len(p) > 2])

            # Remove duplicates
            return list(set(expanded_keywords))
        except Exception:
            # Fallback to basic keywords if analysis fails
            return keywords

    def generate_and_save_cursor_rules(self) -> List[str]:
        """
        Generate and save cursor rules in one step.

        Returns:
            List of paths to the generated rules files
        """
        output_dir = str(self.base_path / ".cursor" / "rules")
        return self.generate_cursor_rules(output_dir)

    def generate_main_cursorrules(self) -> str:
        """
        Generate the main .cursorrules file.

        Returns:
            Content for the main .cursorrules file
        """
        # Check if AI enhancement is requested
        use_ai = os.environ.get("AMAUTA_GENERATE_RULES_AI", "1") == "1"
        
        # If AI is requested, use AI-enhanced rules, otherwise use basic rules
        if use_ai:
            try:
                return self.generate_rules_with_ai()
            except Exception as e:
                print(f"Warning: AI-enhanced rule generation failed: {str(e)}. Using basic rules.")
                return self.generate_rules()
        else:
            return self.generate_rules()

    def generate_rule_files(self) -> Dict[str, str]:
        """
        Generate individual rule files for the .cursor/rules directory.

        Returns:
            A dictionary mapping file names to file contents
        """
        rule_files = {}

        # Copy template files if they exist
        templates_dir = RULES_TEMPLATES_DIR
        if not templates_dir.exists() and RULES_NEW_TEMPLATES_DIR.exists():
            templates_dir = RULES_NEW_TEMPLATES_DIR

        if templates_dir.exists():
            for template_file in templates_dir.glob("*.mdc"):
                with open(template_file, "r", encoding="utf-8") as f:
                    content = f.read()

                # Replace placeholders with project-specific information
                content = content.replace(
                    "{{PROJECT_NAME}}", self.config.project.name or "AMAUTA Project"
                )
                content = content.replace(
                    "{{PROJECT_DESCRIPTION}}", self.config.project.description or ""
                )
                content = content.replace("{{DATE}}", self._get_date())

                rule_files[template_file.name] = content

        # Generate standard rule files if there are no templates
        if not rule_files:
            # Development workflow rules
            dev_workflow = [
                "// --- Development Workflow Rules ---",
                "// Version: 1.0",
                f"// Date: {self._get_date()}",
                "// Generated by AMAUTA",
                "// ---",
                "// Purpose: Guide the development workflow in this codebase.",
                "// ---",
                "",
                "1. Start by understanding the task requirements fully.",
                "2. Follow the established code organization patterns.",
                "3. Write tests first for new features when appropriate.",
                "4. Run linting and formatting tools before committing.",
                "5. Ensure all tests pass before submitting code for review.",
                "6. Make small, focused commits with clear messages.",
                "7. Follow the branching strategy established for the project.",
                "8. Document new code and update existing documentation as needed.",
            ]
            rule_files["dev_workflow.mdc"] = "\n".join(dev_workflow)

            # Code style rules
            code_style = [
                "// --- Code Style Rules ---",
                "// Version: 1.0",
                f"// Date: {self._get_date()}",
                "// Generated by AMAUTA",
                "// ---",
                "// Purpose: Define code style rules for this codebase.",
                "// ---",
                "",
                "1. Keep functions small and focused on a single responsibility.",
                "2. Use meaningful variable and function names.",
                "3. Avoid deep nesting of conditional statements.",
                "4. Keep line length reasonable (typically ≤88-100 characters).",
                "5. Use consistent indentation and formatting.",
                "6. Comment complex or non-obvious code, but prefer self-documenting code.",
                "7. Avoid magic numbers - use named constants.",
                "8. Handle errors appropriately with proper logging.",
            ]
            rule_files["code_style.mdc"] = "\n".join(code_style)

        return rule_files
