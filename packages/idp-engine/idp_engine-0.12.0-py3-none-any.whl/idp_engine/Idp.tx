IDP:
    Shebang?
    (prefixes=Prefix)*
    ( vocabularies=Vocabulary
    | theories=TheoryBlock
    | structures=Structure
    | procedures=Procedure
    | displays=Display) *
;

Comment:
  SingleComment | MultiComment
;

SingleComment:
  /\/\/.*$/
;

MultiComment:
  /(?ms)\/\*.*\*\//
;

Shebang: '#!' /.*$/;

Prefix: '@prefix' name=ID ':' uri=Uri '.';

Vocabulary: 'vocabulary' name=ID? '{' (prefixes=Prefix)* (declarations=Declaration)* '}';
  Declaration: TypeDeclaration | SymbolDeclaration | VarDeclaration |Import;

    Import: 'import' (name=ID);

    TypeDeclaration:
      /type[ \t]/
      name=ID
      (DefEqOp ( enumeration=Ranges
            | enumeration=Enumeration
            | enumeration=ConstructedFrom))?
      (ISA super_set=SetName)?;

    SymbolDeclaration: annotations=Annotations
          symbols+= NAME [','] ':'
          partiality=/total|partial/?
          ( '(' sorts*=SetName[/[*‚®Ø]/] ')' | sorts*=SetName[/[*‚®Ø]/] )
          ('->' | '‚Üí') sort_=SetName

          ( '(' repeat_name=NAME /‚äÜ|<:/ super_sets*=SetName[/[*‚®Ø]/] ')'
          | '(' ('domain' ':' domains*=SetName[/[*‚®Ø]/])? ','?
                ('codomain' ':' codomain=SetName)?
             ')'
          )?;

    VarDeclaration: 'var' name=/`?[^\d\W]\w*\b/ IN subtype=SetName;

  Annotations: ('[' annotations*=/[^\]]*/ ']')*;

TheoryBlock: 'theory' (name=ID ':' vocab_name=ID)? '{'
             ( definitions=Definition*
               constraints=Axiom*
               interpretations=SymbolInterpretation*
             )* '}';

  Definition: annotations=Annotations '{' mode=Mode rules*=Rule '}';
    Mode: ('(' ('well-founded' | 'completion' | 'Kripke-Kleene' | 'co-induction' | 'stable' | 'recursive' ) ')')?;
    Rule: annotations=Annotations
          (('!'|'‚àÄ'| 'for' 'all') quantees+=Quantee[','] ':' )*
          definiendum=AppliedSymbol
          (('=' |DefEqOp) out=SumMinus)?
          (('<-'|'‚Üê' | 'if' ) body=Expression)? '.' ;
        Quantee:  subtype=SetName !IN vars+=Variable[',']
                | vars+=Variable[','] ( IN (subtype=SetName | sort=SymbolExpr) )?
                | vars+=VarTuple[','] ( IN (subtype=SetName | sort=SymbolExpr) )?;
            Variable: name=/`?[^\d\W]\w*\b/;
            VarTuple: '(' vars+=Variable[','] ')';
            SetName: ( name='Concept' '['
                          ( '(' ins*=SetName[/[*‚®Ø]/] ')' | ins*=SetName[/[*‚®Ø]/] )
                          ('->' | '‚Üí') out=SetName ']'
                  )
                | name=NAME;

  Axiom: annotations=Annotations expr=Expression '.';

    Expression:     AQuantification | GenExist;
    GenExist:       AGenExist       | RImplication;
    RImplication:   ARImplication   | Equivalence;
    Equivalence:    AEquivalence    | Implication;
    Implication:    AImplication    | Disjunction;
    Disjunction:    ADisjunction    | Conjunction;
    Conjunction:    AConjunction    | Comparison;
    Comparison:     AComparison     | SumMinus;
    SumMinus:       ASumMinus       | MultDiv;
    MultDiv:        AMultDiv        | Power;
    Power:          APower          | Unary;
    Unary:          AUnary          | ExtAggregate;
    ExtAggregate:   AExtAggregate   | Aggregate;
    Aggregate:      AAggregate      | IfExpr;
    IfExpr:         AIfExpr         | Base;


    AQuantification: annotations=Annotations q=Quantor quantees+=Quantee[','] ':' f=Expression;
      Quantor: '‚àÄ' | '!' | '‚àÉ' | '?' | 'for' 'all' | 'there' 'is' 'a';
    AGenExist: annotations=Annotations q=Quantor operator=ComparisonOp number=Number quantees+=Quantee[','] ':' f=Expression;
    ARImplication: sub_exprs=Equivalence (operator=RImplicationOp sub_exprs=Equivalence)+;
    AEquivalence:  sub_exprs=Implication (operator=EquivalenceOp  sub_exprs=Implication)+;
    AImplication:  (sub_exprs=Disjunction (operator=ImplicationOp  sub_exprs=Disjunction)+)
                   | ('if' sub_exprs=Disjunction ',' operator='then' sub_exprs=Disjunction);
    ADisjunction:  sub_exprs=Conjunction (operator=DisjunctionOp  sub_exprs=Conjunction)+;
    AConjunction:  sub_exprs=Comparison  (operator=ConjunctionOp  sub_exprs=Comparison )+;
    AComparison:   annotations=Annotations
                   sub_exprs=SumMinus    (operator=ComparisonOp   sub_exprs=SumMinus   )+;
    ASumMinus:     sub_exprs=MultDiv     (operator=SumMinusOp     sub_exprs=MultDiv    )+;
    AMultDiv:      sub_exprs=Power       (operator=MultDivOp      sub_exprs=Power      )+;
    APower:        sub_exprs=Unary       (operator='^'            sub_exprs=Unary      );
    AUnary: !INT !IDPFLOAT               (operators+=UnaryOperator  f=Aggregate);
    AExtAggregate: aggtype=/sum|min|max|distinct/ '{{' symbols+=AppliedSymbol[','] '}}'
                 | aggtype=/min|max/ '{' symbols+=AppliedSymbol[','] '}'
                 | aggtype=/#|card/ '{' symbols+=AppliedSymbol[','] '}';
    AAggregate:   aggtype=/#|card/ '{' quantees*=Quantee[',']  (':' condition=Expression)? '}'
                | aggtype=/sum|min|max|distinct/ '{{' term=Base '|' quantees*=Quantee[',']  (':' condition=Expression)? '}}'
                | aggtype=/min|max/     '{'  term=Base '|' quantees*=Quantee[',']  (':' condition=Expression)? '}'
                | 'the' aggtype=/sum|minimum|maximum/ 'of' term=Base 'for' 'all' quantees*=Quantee[','] ('such' 'that' condition=Expression)? ;
    AIfExpr: 'if' if_f=Expression 'then' then_f=Expression 'else' else_f=Expression;

    RImplicationOp: '<=' | '‚áê' | /are necessary conditions for/;
    EquivalenceOp: '<=>' | '‚áî' | /is the same as/ | /are necessary and sufficient conditions for/;
    ImplicationOp:  '=>' | '‚áí' | /are sufficient conditions for/;
    DisjunctionOp:   '|' | '‚à®' | 'or';
    ConjunctionOp:   '&' | '‚àß' | 'and';
    DefEqOp:        ':=' | '‚âú' | 'is';
    ComparisonOp:   '=<' | '>=' | '~=' | '=' | '<' | '>' | '‚â§' | '‚â•' | '‚â†'
                    | 'is strictly less than' | 'is less than'
                    | 'is greater than' | 'is strictly greater than'
                    | 'is not' | 'is';
    SumMinusOp:      '+' | '-';
    MultDivOp:       '‚®Ø' | '*' | '/' | '%';
    UnaryOperator:   '-' | '~' | '¬¨' | 'not' ;


    Base:  AQuantification | AppliedSymbol | UnappliedSymbol | Number | Date | Brackets;

      AppliedSymbol: annotations=Annotations
              symbol=SymbolExpr
              '(' ( sub_exprs+=Expression[','] ','? )? ')'
              ( is_enumerated=/is\s+enumerated/
              | is_enumeration=/in|‚àà/ in_enumeration=Enumeration)?;
        SymbolExpr: name=SYMBOL
                  | eval='$' '(' s=Expression ')';
      UnappliedSymbol: name=SYMBOL;
      Number: number=IDPFLOAT | number=INT;
IDPFLOAT: /[+-]?(\d+(\.\d+)?e[+-]?\d+|\.\d+e[+-]?\d+|\d+(\.\d+)?|\.\d+)/;
      Date: iso=/#\d{4}-\d{2}-\d{2}/
          | iso='#TODAY' ( '(' y=INT ',' m=INT ',' d=INT ')' )?;
      Brackets: annotations=Annotations '(' f=Expression ')';


Structure: 'structure' name=ID? (':' vocab_name=ID)?
           '{' interpretations*=SymbolInterpretation '}';
  SymbolInterpretation: name=UnappliedSymbol sign=/:=|:>|‚âú|‚äá/
                        ( enumeration=FunctionEnum ('else' default=Identifier)?
                        | enumeration=Ranges
                        | enumeration=Enumeration
                        | enumeration=CSVEnumeration
                        | enumeration=ConstructedFrom
                        | default=Identifier
                        ) '.';
  FunctionEnum: '{' tuples+=FunctionTuple[','] ','? '}';
  FunctionTuple: ( args=Identifier | '(' ( args*=Identifier[','] ','? )? ')' )?
                  ('->' | '‚Üí') value=Identifier;
  Ranges: '{' elements+=RangeElement[','] ','? '}';
      RangeElement:   (fromI=Number ('..' toI=Number)?)
                    | (fromI=Date   ('..' toI=Date  )?) ;
  Enumeration: '{' ( tuples+=TupleIDP[','] ','? )? '}';
  TupleIDP:  ( args=Identifier | '(' ( args+=Identifier[','] ','? )? ')' );
  CSVEnumeration[noskipws]: /\s*/ '{' /\n/ tuples*=CSVTuple[/\n/] / */ '}';
  CSVTuple[noskipws]:  args*=Identifier[/([\t ]*,[\t ]*|[\t ]+)/];

  ConstructedFrom: constructed=/constructed\s+from/?
                   '{' ( constructors*=Constructor[','] ','? )?  '}';
    Constructor: name=ID ('(' args+=Accessor[','] ','? ')' )?;
    Accessor: (accessor=ID ':')? out=SetName;

  Identifier: AppliedSymbol | UnappliedSymbol | Number | Date;

Goal: 'goal' name=ID;

View: 'view' viewType=ViewType;
  ViewType: 'normal' | 'expanded';

Display: 'display' '{' (constraints=Expression '.' | interpretations=SymbolInterpretation)* '}';

Procedure: 'procedure' name=ID '(' args=ID*')' '{' pystatements=PyStatement* '}';

  PyStatement: PyAssignment | Call1 ;
  PyAssignment: var=ID '=' val=PyExpr;
  PyExpr: !PyAssignment (String | Call1 | Number | PyList);

  Call1: name=ID ( par='(' ( args+=PyExpr[','] (',' kwargs+=PyAssignment[','])?
                     | kwargs*=PyAssignment[',']) ')'
                 )?
        ('.' post=PyExpr)?;
  String: literal=/f?"(\.|[^"])*"/;
  PyList: '[' elements*=PyExpr[','] ']';

Uri: /<https?:\/\/((\w*\.)?)*(\w+\/)*\w+#(\w+)?>/;
PrefID: /[^\d\W]\w*::[^\d\W]\w*/;
ID: PrefID | /[^\d\W]\w*\b/ | Uri; // Extend default ID to also support Prefixed IDs and URIs.
NAME: PrefID | /[^\d\W]\w*\b|'(\.|[^'])*'/ | Uri;
SYMBOL: PrefID | /`?[^\d\W]\w*\b|ùîπ|‚Ñ§|‚Ñù|'(\.|[^'])*'/ | Uri;
IN: /in|‚àà/;
ISA: /<:|‚äÜ/;
