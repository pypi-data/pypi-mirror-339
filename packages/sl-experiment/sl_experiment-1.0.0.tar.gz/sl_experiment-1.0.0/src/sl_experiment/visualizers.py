"""This module provides the Visualizer class, a major training and experiment runtime UI element used to provide
real-time feedback on the animal's task performance and task parameters."""

import numpy as np
import matplotlib
from numpy.typing import NDArray

matplotlib.use("QtAgg")  # Uses QT backend for performance and compatibility with Linux

from ataraxis_time import PrecisionTimer
from matplotlib.axes import Axes
from matplotlib.lines import Line2D
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator, FixedLocator, FixedFormatter
from ataraxis_base_utilities import console
from ataraxis_data_structures import SharedMemoryArray

# Updates plotting dictionaries to preferentially use Arial text style and specific sizes for different text elements
# in plots:
# General parameters and the font size for axes' tick numbers
plt.rcParams.update({"font.family": "Arial", "font.weight": "normal", "xtick.labelsize": 16, "ytick.labelsize": 16})
_fontdict_axis_label = {"family": "Arial", "weight": "normal", "size": 18}  # Axis label fonts
_fontdict_title = {"family": "Arial", "weight": "normal", "size": 20}  # Title fonts
_fontdict_legend = {"family": "Arial", "weight": "normal", "size": 14}  # Legend fonts

# Initializes dictionaries to map colloquial names to specific linestyle and color parameters
_line_style_dict = {"solid": "-", "dashed": "--", "dotdashed": "_.", "dotted": ":"}
_palette_dict = {
    "green": (0.000, 0.639, 0.408),
    "blue": (0.000, 0.525, 0.749),
    "red": (0.769, 0.008, 0.137),
    "yellow": (1.000, 0.827, 0.000),
    "purple": (0.549, 0.000, 0.749),
    "orange": (1.000, 0.502, 0.000),
    "pink": (0.945, 0.569, 0.608),
    "black": (0.000, 0.000, 0.000),
    "white": (1.000, 1.000, 1.000),
    "gray": (0.500, 0.500, 0.500),
}


def _plt_palette(color: str) -> tuple[float, float, float]:
    """Converts colloquial color names to pyplot RGB color codes.

    The provided colors are not perfectly colorblind-friendly. They should be used with different 'line style' formats
    to improve readability in monochrome spectrum. The codes generated by this function should be passed to 'color'
    argument of the pyplot module.

    Args:
        color: Colloquial name of the color to be retrieved. Available options are: 'green', 'blue', 'red', 'yellow',
            'purple', 'orange', 'pink', 'black', 'white', 'gray'.

    Returns:
        A list of R, G, and B values for the requested color.

    Raises:
        KeyError: If the provided color is not recognized.
    """

    try:
        return _palette_dict[color]
    except KeyError:
        message = (
            f"Unexpected color name '{color}' encountered when converting the colloquial color name to RGB array. "
            f"Provide one of the supported color arguments: {', '.join(_palette_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


def _plt_line_styles(line_style: str) -> str:
    """Converts colloquial line style names to pyplot's 'lifestyle' string-codes.

    Args:
        line_style: Colloquial name for the line style to be used. Options are 'solid', 'dashed', 'dotdashed' and
            'dotted'.

    Returns:
        The string-code for the requested line style.

    Raises:
        KeyError: If the provided line style is not recognized.
    """

    try:
        return str(_line_style_dict[line_style])
    except KeyError:
        message = (
            f"Unexpected line style name '{line_style}' encountered when converting the colloquial line style pyplot "
            f"linestyle string. Provide one of the supported line style arguments: "
            f"{', '.join(_line_style_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


class BehaviorVisualizer:
    """Visualizes lick, valve, and running speed data in real time.

    This class is used to visualize the key behavioral metrics collected from animals performing experiment or training
    sessions in the Mesoscope-VR system. Note, the class is statically configured to generate the plots for all
    supported metrics, even if some of them are not used during a particular session.

    Notes:
        This class is designed to run in the main thread of the runtime context. To update the visualized data, ensure
        that the 'update' class method is called repeatedly during runtime.

    Args:
        lick_tracker: The SharedMemoryArray instance exposed by the LickInterface class that communicates the number of
            licks recorded by the class since runtime onset.
        valve_tracker: The SharedMemoryArray instance exposed by the ValveInterface class that communicates the number
            of times the valve has been opened since runtime onset.
        distance_tracker: The SharedMemoryArray instance exposed by the EncoderInterface class that communicates the
            total distance traveled by the animal since runtime onset, in centimeters.

    Attributes:
        _time_window: Specifies the time window, in seconds, to visualize during runtime. Currently, this is statically
            set to 12 seconds.
        _time_step: Specifies the interval, in milliseconds, at which to update the visualization plots. Currently, this
            is statically set to 30 milliseconds, which gives a good balance between update smoothness and rendering
            time.
        _update_timer: The PrecisionTimer instance used to ensure that the figure is updated once every _time_step
            milliseconds.
        _lick_tracker: Stores the lick_tracker SharedMemoryArray.
        _valve_tracker: Stores the valve_tracker SharedMemoryArray.
        _distance_tracker: Stores the distance_tracker SharedMemoryArray.
        _timestamps: A numpy array that stores the timestamps of the displayed data during visualization runtime. The
            timestamps are generated at class initialization and are kept constant during runtime.
        _lick_data: A numpy array that stores the data used to generate the lick sensor state plot.
        _valve_data: A numpy array that stores the data used to generate the solenoid valve state plot.
        _speed_data: A numpy array that stores the data used to generate the running speed plot.
        _previous_valve_count: Stores the total number of valve pulses sampled during the previous update cycle.
        _previous_lick_count: Stores the total number of licks sampled during the previous update cycle.
        _previous_distance: Stores the total distance traveled by the animal sampled during the previous update cycle.
        _speed_timer: Stores the PrecisionTimer instance used to convert traveled distance into running speed.
        _lick_line: Stores the line class used to plot the lick sensor data.
        _valve_line: Stores the line class used to plot the solenoid valve data.
        _speed_line: Stores the line class used to plot the average running speed data.
        _figure: Stores the matplotlib figure instance used to display the plots.
        _lick_axis: The axis object used to plot the lick sensor data during visualization runtime.
        _valve_axis: The axis object used to plot the solenoid valve data during visualization runtime.
        _speed_axis: The axis object used to plot the average running speed data during visualization runtime.
        _speed_threshold_line: Stores the horizontal line class used to plot the running speed threshold used during
            training sessions.
        _duration_threshold_line: Stores the horizontal line class used to plot the running epoch duration used during
            training sessions.
        _running_speed: Stores the current running speed of the animal. Somewhat confusingly, since we already compute
            the average running speed of the animal via the visualizer, it is easier to retrieve and use it from the
            main training runtime. This value is used to share the current running speed with the training runtime.
        _once: This flag is sued to limit certain visualizer operations to only be called once during runtime.
        _speed_threshold_text: Stores the text object used to display the speed threshold value to the user.
        _duration_threshold_text: Stores the text object used to display the running epoch duration value to the user.
    """

    def __init__(
        self,
        lick_tracker: SharedMemoryArray,
        valve_tracker: SharedMemoryArray,
        distance_tracker: SharedMemoryArray,
    ) -> None:
        # Currently, the class is statically configured to visualize the sliding window of 12 seconds.
        self._time_window: int = 12
        self._time_step: int = 30
        self._update_timer = PrecisionTimer("ms")

        # Initializes additional assets used to generate the running speed data from the distance tracking data.
        self._speed_timer: PrecisionTimer = PrecisionTimer("ms")

        # Saves the input trackers to class attributes
        self._lick_tracker: SharedMemoryArray = lick_tracker
        self._valve_tracker: SharedMemoryArray = valve_tracker
        self._distance_tracker: SharedMemoryArray = distance_tracker

        # Precreates the structures used to store the displayed data during visualization runtime
        self._timestamps: NDArray[np.float32] = np.arange(
            start=0 - self._time_window, stop=self._time_step / 1000, step=self._time_step / 1000, dtype=np.float32
        )
        self._lick_data: NDArray[np.uint8] = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._valve_data: NDArray[np.uint8] = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._speed_data: NDArray[np.float64] = np.zeros_like(a=self._timestamps, dtype=np.float64)
        self._previous_valve_count: np.float64 = np.float64(0)
        self._previous_lick_count: np.uint64 = np.uint64(0)
        self._previous_distance: np.float64 = np.float64(0)
        self._running_speed: np.float64 = np.float64(0)

        # Line objects (to be created during initialization)
        self._lick_line: Line2D
        self._valve_line: Line2D
        self._speed_line: Line2D

        # Figure objects
        self._figure: Figure
        self._lick_axis: Axes
        self._valve_axis: Axes
        self._speed_axis: Axes

        # Running speed threshold and duration threshold lines
        self._speed_threshold_line: Line2D
        self._duration_threshold_line: Line2D

        # Creates the figure with three subplots sharing the same x-axis
        self._figure, (self._lick_axis, self._valve_axis, self._speed_axis) = plt.subplots(
            3,
            1,
            figsize=(10, 8),
            sharex=True,
            gridspec_kw={"hspace": 0.3, "left": 0.15, "height_ratios": [1, 1, 3]},  # Third subplot is thrice as tall
        )

        # Sets consistent y-label padding for all axes. This aligns y-axis names for all axes, making the figure more
        # readable.
        self._lick_axis.yaxis.labelpad = 15
        self._valve_axis.yaxis.labelpad = 15
        self._speed_axis.yaxis.labelpad = 15

        # Set up axes properties. This is only done once, during class initialization, and the elements made by
        # this method stay unchanged throughout the entire class runtime.
        # Lick axis
        self._lick_axis.set_title("Lick Sensor State", fontdict=_fontdict_title)
        self._lick_axis.set_ylim(-0.05, 1.05)
        self._lick_axis.set_ylabel("Lick State", fontdict=_fontdict_axis_label)
        self._lick_axis.set_xlabel("")
        self._lick_axis.yaxis.set_major_locator(FixedLocator([0, 1]))
        self._lick_axis.yaxis.set_major_formatter(FixedFormatter(["No Lick", "Lick"]))

        # Valve axis
        self._valve_axis.set_title("Reward Valve State", fontdict=_fontdict_title)
        self._valve_axis.set_ylim(-0.05, 1.05)
        self._valve_axis.set_ylabel("Valve State", fontdict=_fontdict_axis_label)
        self._valve_axis.set_xlabel("")
        self._valve_axis.yaxis.set_major_locator(FixedLocator([0, 1]))
        self._valve_axis.yaxis.set_major_formatter(FixedFormatter(["Closed", "Open"]))

        # Speed axis
        self._speed_axis.set_title("Average Running Speed", fontdict=_fontdict_title)
        self._speed_axis.set_ylim(-2, 22)
        self._speed_axis.set_ylabel("Running speed (cm/s)", fontdict=_fontdict_axis_label)
        self._speed_axis.set_xlabel("Time (s)", fontdict=_fontdict_axis_label)
        self._speed_axis.yaxis.set_major_locator(MaxNLocator(nbins="auto", integer=False))
        self._speed_axis.xaxis.set_major_locator(MaxNLocator(nbins="auto", integer=True))

        # Sets x-limits for all axes (shared x-axis)
        self._speed_axis.set_xlim(-self._time_window, 0)

        # Hides x-tick labels for top plots
        plt.setp(self._lick_axis.get_xticklabels(), visible=False)
        plt.setp(self._valve_axis.get_xticklabels(), visible=False)

        # Aligns all y-labels
        self._figure.align_ylabels([self._lick_axis, self._valve_axis, self._speed_axis])

        # Creates the plot artists. Plot artists are updated each time update() method is called to re-render the
        # line using new data.
        # Lick plot
        (self._lick_line,) = self._lick_axis.plot(
            self._timestamps,
            self._lick_data,
            drawstyle="steps-post",
            color=_plt_palette("red"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        # Valve plot
        (self._valve_line,) = self._valve_axis.plot(
            self._timestamps,
            self._valve_data,
            drawstyle="steps-post",
            color=_plt_palette("blue"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        # Speed plot
        (self._speed_line,) = self._speed_axis.plot(
            self._timestamps, self._speed_data, color=_plt_palette("green"), linewidth=2, alpha=1.0, linestyle="solid"
        )

        # Running speed and duration threshold. These are initially invisible and will not be shown unless the
        # class is used to visualize run training progress.
        self._speed_threshold_line = self._speed_axis.axhline(
            y=0.05, color=_plt_palette("black"), linestyle="dashed", linewidth=1.5, alpha=0.5, visible=False
        )
        self._duration_threshold_line = self._speed_axis.axvline(
            x=-0.05, color=_plt_palette("black"), linestyle="dashed", linewidth=1.5, alpha=0.5, visible=False
        )

        # Generates the figure object and updates it to show the initial (zero-initialized) data state.
        plt.show(block=False)
        self._figure.canvas.draw()
        self._figure.canvas.flush_events()

        # This is used to make speed and duration thresholds visible for runtimes that need this visualization.
        self._once = True

        # Adds text annotations for speed and duration thresholds to the top left corner of the speed plot.
        self._speed_threshold_text = self._speed_axis.text(
            -self._time_window + 0.5,  # x position: left edge and padding
            20,  # y position: near top of plot
            f"Target speed: {0:.2f} cm/s",
            fontdict=_fontdict_legend,
            verticalalignment="top",
            bbox=dict(facecolor="white", alpha=1.0, edgecolor="none", pad=3),
        )

        self._duration_threshold_text = self._speed_axis.text(
            -self._time_window + 0.5,  # x position: left edge and padding
            17.5,  # y position: below speed text
            f"Target duration: {0:.2f} s",
            fontdict=_fontdict_legend,
            verticalalignment="top",
            bbox=dict(facecolor="white", alpha=1.0, edgecolor="none", pad=3),
        )

    def __del__(self) -> None:
        """Ensures all resources are released when the figure object is garbage-collected."""
        self.close()

    def update(self) -> None:
        """Updates the figure managed by the class to display new data.

        This method discards the oldest datapoint in the plot memory and instead samples a new datapoint. It also shifts
        all datapoints one timestamp to the left. When the method is called repeatedly, this makes the plot lines
        naturally flow from the right (now) to the left (12 seconds in the past), accurately displaying the visualized
        data history.

        Notes:
            The method has an internal update frequency limiter. Therefore, to achieve optimal performance, call this
            method as frequently as possible and rely on the internal limiter to force the specific update frequency.
        """
        # Ensures the plot is not updated any faster than necessary to resolve the time-step used by the plot
        if self._update_timer.elapsed < self._time_step:
            return
        self._update_timer.reset()

        # Replaces the oldest timestamp data with the current data.
        self._sample_data()

        # Updates the artists with new data
        self._lick_line.set_data(self._timestamps, self._lick_data)
        self._valve_line.set_data(self._timestamps, self._valve_data)
        self._speed_line.set_data(self._timestamps, self._speed_data)

        # Renders the changes
        self._figure.canvas.draw()
        self._figure.canvas.flush_events()

    def update_speed_thresholds(
        self, speed_threshold: float | np.float64, duration_threshold: float | np.float64
    ) -> None:
        """Updates the running speed and duration threshold lines to use the input anchor values.

        This positions the threshold lines in the running speed plot to indicate the cut-offs for the running speed and
        running epoch duration that elicit water rewards. This is used during run training to visualize the thresholds
        the animal needs to meet to receive water rewards.

        Args:
            speed_threshold: The speed, in centimeter per second, the animal needs to maintain to get water rewards.
            duration_threshold: The duration, in milliseconds, the animal has to maintain the above-threshold speed to
                get water rewards.
        """
        # Converts from milliseconds to seconds
        duration_threshold /= 1000

        # Updates line position(s)
        self._speed_threshold_line.set_ydata([speed_threshold, speed_threshold])  # type: ignore
        self._duration_threshold_line.set_xdata([-duration_threshold, -duration_threshold])  # type: ignore

        # Updates text annotations with current threshold values
        self._speed_threshold_text.set_text(f"Target speed: {speed_threshold:.2f} cm/s")
        self._duration_threshold_text.set_text(f"Target duration: {duration_threshold:.2f} s")

        # This ensures the visibility is only changed once during runtime
        if self._once:
            self._speed_threshold_line.set_visible(True)
            self._duration_threshold_line.set_visible(True)
            self._once = False

        # Renders the changes
        self._figure.canvas.draw()
        self._figure.canvas.flush_events()

    def close(self) -> None:
        """Closes the visualized figure and cleans up the resources used by the class during runtime."""
        plt.close(self._figure)  # Closes the figure

    def _sample_data(self) -> None:
        """Samples new data from tracker SharedMemoryArray instances and update the class memory."""
        # Rolls arrays by one position to the left, so the first element becomes last
        self._valve_data = np.roll(self._valve_data, shift=-1)
        self._lick_data = np.roll(self._lick_data, shift=-1)
        self._speed_data = np.roll(self._speed_data, shift=-1)

        # Replaces the last element (previously the first or 'oldest' value) with new data:

        # Each time the overall lick count increments, displays a lick trigger. Lick counts are incremented at each
        # rising edge of lick detection.
        new_lick_count = self._lick_tracker.read_data(index=0, convert_output=False)
        if new_lick_count != self._previous_lick_count:
            self._lick_data[-1] = np.uint8(1)
        else:
            self._lick_data[-1] = np.uint8(0)
        self._previous_lick_count = new_lick_count

        # Carries out a similar computation for valve tracker. Valve pulse counter also increments on the rising edge
        # of each valve open-close cycle.
        new_valve_count = self._valve_tracker.read_data(index=0, convert_output=False)
        if new_valve_count != self._previous_valve_count:
            self._valve_data[-1] = np.uint8(1)
        else:
            self._valve_data[-1] = np.uint8(0)
        self._previous_valve_count = new_valve_count

        # Finally, speed is computed slightly differently. This is because the update rate of this class exceeds the
        # smoothing window size used to generate running speed values:

        # The speed value is updated ~every 100 milliseconds. Until the update timeout is exhausted, at each graph
        # update cycle the last speed point is overwritten with the previous speed point. This would generate a
        # sequence of 3-4 identical speed readouts, but should not be very noticeable to the user.
        if self._speed_timer.elapsed < 100:
            self._speed_data[-1] = self._speed_data[-2]
        else:
            # Once the timeout passes, determines the total distance covered by the animal while the timeout was
            # active and uses it to compute the running speed in cm/s
            self._speed_timer.reset()
            travelled_distance: np.float64 = self._distance_tracker.read_data(index=0, convert_output=False)
            delta_distance = travelled_distance - self._previous_distance
            running_speed = np.float64((delta_distance / 100) * 1000)  # Gets distance in cm / ms and converts to cm / s

            # Inserts the newly computed datapoint into the data array and updates the previous distance tracker
            self._speed_data[-1] = running_speed
            self._previous_distance = travelled_distance
            self._running_speed = running_speed  # Also stores the value for sharing with training runtime.

    @property
    def running_speed(self) -> np.float64:
        """Returns the current running speed of the animal, calculated over the window of the last 100 milliseconds."""
        return self._running_speed
