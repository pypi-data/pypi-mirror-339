# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AomServiceDiscoveryRuleDiscoveryRuleArgs',
    'AomServiceDiscoveryRuleDiscoveryRuleArgsDict',
    'AomServiceDiscoveryRuleLogPathRuleArgs',
    'AomServiceDiscoveryRuleLogPathRuleArgsDict',
    'AomServiceDiscoveryRuleNameRulesArgs',
    'AomServiceDiscoveryRuleNameRulesArgsDict',
    'AomServiceDiscoveryRuleNameRulesApplicationNameRuleArgs',
    'AomServiceDiscoveryRuleNameRulesApplicationNameRuleArgsDict',
    'AomServiceDiscoveryRuleNameRulesServiceNameRuleArgs',
    'AomServiceDiscoveryRuleNameRulesServiceNameRuleArgsDict',
    'ApiGatewayApiBackendParamArgs',
    'ApiGatewayApiBackendParamArgsDict',
    'ApiGatewayApiFuncGraphArgs',
    'ApiGatewayApiFuncGraphArgsDict',
    'ApiGatewayApiFuncGraphPolicyArgs',
    'ApiGatewayApiFuncGraphPolicyArgsDict',
    'ApiGatewayApiFuncGraphPolicyBackendParamArgs',
    'ApiGatewayApiFuncGraphPolicyBackendParamArgsDict',
    'ApiGatewayApiFuncGraphPolicyConditionArgs',
    'ApiGatewayApiFuncGraphPolicyConditionArgsDict',
    'ApiGatewayApiMockArgs',
    'ApiGatewayApiMockArgsDict',
    'ApiGatewayApiMockPolicyArgs',
    'ApiGatewayApiMockPolicyArgsDict',
    'ApiGatewayApiMockPolicyBackendParamArgs',
    'ApiGatewayApiMockPolicyBackendParamArgsDict',
    'ApiGatewayApiMockPolicyConditionArgs',
    'ApiGatewayApiMockPolicyConditionArgsDict',
    'ApiGatewayApiRequestParamArgs',
    'ApiGatewayApiRequestParamArgsDict',
    'ApiGatewayApiWebArgs',
    'ApiGatewayApiWebArgsDict',
    'ApiGatewayApiWebPolicyArgs',
    'ApiGatewayApiWebPolicyArgsDict',
    'ApiGatewayApiWebPolicyBackendParamArgs',
    'ApiGatewayApiWebPolicyBackendParamArgsDict',
    'ApiGatewayApiWebPolicyConditionArgs',
    'ApiGatewayApiWebPolicyConditionArgsDict',
    'ApiGatewayGroupEnvironmentArgs',
    'ApiGatewayGroupEnvironmentArgsDict',
    'ApiGatewayGroupEnvironmentVariableArgs',
    'ApiGatewayGroupEnvironmentVariableArgsDict',
    'ApiGatewayGroupUrlDomainArgs',
    'ApiGatewayGroupUrlDomainArgsDict',
    'ApigApiBackendParamArgs',
    'ApigApiBackendParamArgsDict',
    'ApigApiFuncGraphArgs',
    'ApigApiFuncGraphArgsDict',
    'ApigApiFuncGraphPolicyArgs',
    'ApigApiFuncGraphPolicyArgsDict',
    'ApigApiFuncGraphPolicyBackendParamArgs',
    'ApigApiFuncGraphPolicyBackendParamArgsDict',
    'ApigApiFuncGraphPolicyConditionArgs',
    'ApigApiFuncGraphPolicyConditionArgsDict',
    'ApigApiMockArgs',
    'ApigApiMockArgsDict',
    'ApigApiMockPolicyArgs',
    'ApigApiMockPolicyArgsDict',
    'ApigApiMockPolicyBackendParamArgs',
    'ApigApiMockPolicyBackendParamArgsDict',
    'ApigApiMockPolicyConditionArgs',
    'ApigApiMockPolicyConditionArgsDict',
    'ApigApiPublishmentHistoryArgs',
    'ApigApiPublishmentHistoryArgsDict',
    'ApigApiRequestParamArgs',
    'ApigApiRequestParamArgsDict',
    'ApigApiWebArgs',
    'ApigApiWebArgsDict',
    'ApigApiWebPolicyArgs',
    'ApigApiWebPolicyArgsDict',
    'ApigApiWebPolicyBackendParamArgs',
    'ApigApiWebPolicyBackendParamArgsDict',
    'ApigApiWebPolicyConditionArgs',
    'ApigApiWebPolicyConditionArgsDict',
    'ApigApplicationQuotaAssociateApplicationArgs',
    'ApigApplicationQuotaAssociateApplicationArgsDict',
    'ApigChannelHealthCheckArgs',
    'ApigChannelHealthCheckArgsDict',
    'ApigChannelMemberArgs',
    'ApigChannelMemberArgsDict',
    'ApigChannelMemberGroupArgs',
    'ApigChannelMemberGroupArgsDict',
    'ApigChannelMicroserviceArgs',
    'ApigChannelMicroserviceArgsDict',
    'ApigChannelMicroserviceCceConfigArgs',
    'ApigChannelMicroserviceCceConfigArgsDict',
    'ApigChannelMicroserviceCseConfigArgs',
    'ApigChannelMicroserviceCseConfigArgsDict',
    'ApigCustomAuthorizerIdentityArgs',
    'ApigCustomAuthorizerIdentityArgsDict',
    'ApigGroupEnvironmentArgs',
    'ApigGroupEnvironmentArgsDict',
    'ApigGroupEnvironmentVariableArgs',
    'ApigGroupEnvironmentVariableArgsDict',
    'ApigGroupUrlDomainArgs',
    'ApigGroupUrlDomainArgsDict',
    'ApigInstanceCustomIngressPortArgs',
    'ApigInstanceCustomIngressPortArgsDict',
    'ApigResponseRuleArgs',
    'ApigResponseRuleArgsDict',
    'ApigResponseRuleHeaderArgs',
    'ApigResponseRuleHeaderArgsDict',
    'ApigThrottlingPolicyAppThrottleArgs',
    'ApigThrottlingPolicyAppThrottleArgsDict',
    'ApigThrottlingPolicyUserThrottleArgs',
    'ApigThrottlingPolicyUserThrottleArgsDict',
    'AsBandwidthPolicyScalingPolicyActionArgs',
    'AsBandwidthPolicyScalingPolicyActionArgsDict',
    'AsBandwidthPolicyScheduledPolicyArgs',
    'AsBandwidthPolicyScheduledPolicyArgsDict',
    'AsConfigurationInstanceConfigArgs',
    'AsConfigurationInstanceConfigArgsDict',
    'AsConfigurationInstanceConfigDiskArgs',
    'AsConfigurationInstanceConfigDiskArgsDict',
    'AsConfigurationInstanceConfigPersonalityArgs',
    'AsConfigurationInstanceConfigPersonalityArgsDict',
    'AsConfigurationInstanceConfigPublicIpArgs',
    'AsConfigurationInstanceConfigPublicIpArgsDict',
    'AsConfigurationInstanceConfigPublicIpEipArgs',
    'AsConfigurationInstanceConfigPublicIpEipArgsDict',
    'AsConfigurationInstanceConfigPublicIpEipBandwidthArgs',
    'AsConfigurationInstanceConfigPublicIpEipBandwidthArgsDict',
    'AsGroupLbaasListenerArgs',
    'AsGroupLbaasListenerArgsDict',
    'AsGroupNetworkArgs',
    'AsGroupNetworkArgsDict',
    'AsGroupSecurityGroupArgs',
    'AsGroupSecurityGroupArgsDict',
    'AsPolicyScalingPolicyActionArgs',
    'AsPolicyScalingPolicyActionArgsDict',
    'AsPolicyScheduledPolicyArgs',
    'AsPolicyScheduledPolicyArgsDict',
    'CbrBackupShareMemberArgs',
    'CbrBackupShareMemberArgsDict',
    'CbrCheckpointBackupArgs',
    'CbrCheckpointBackupArgsDict',
    'CbrPolicyBackupCycleArgs',
    'CbrPolicyBackupCycleArgsDict',
    'CbrPolicyLongTermRetentionArgs',
    'CbrPolicyLongTermRetentionArgsDict',
    'CbrVaultPolicyArgs',
    'CbrVaultPolicyArgsDict',
    'CbrVaultResourceArgs',
    'CbrVaultResourceArgsDict',
    'CceAddonValuesArgs',
    'CceAddonValuesArgsDict',
    'CceClusterCertificateClusterArgs',
    'CceClusterCertificateClusterArgsDict',
    'CceClusterCertificateUserArgs',
    'CceClusterCertificateUserArgsDict',
    'CceClusterComponentConfigurationArgs',
    'CceClusterComponentConfigurationArgsDict',
    'CceClusterExtendParamArgs',
    'CceClusterExtendParamArgsDict',
    'CceClusterMasterArgs',
    'CceClusterMasterArgsDict',
    'CceNodeAttachDataVolumeArgs',
    'CceNodeAttachDataVolumeArgsDict',
    'CceNodeAttachHostnameConfigArgs',
    'CceNodeAttachHostnameConfigArgsDict',
    'CceNodeAttachRootVolumeArgs',
    'CceNodeAttachRootVolumeArgsDict',
    'CceNodeAttachStorageArgs',
    'CceNodeAttachStorageArgsDict',
    'CceNodeAttachStorageGroupArgs',
    'CceNodeAttachStorageGroupArgsDict',
    'CceNodeAttachStorageGroupVirtualSpaceArgs',
    'CceNodeAttachStorageGroupVirtualSpaceArgsDict',
    'CceNodeAttachStorageSelectorArgs',
    'CceNodeAttachStorageSelectorArgsDict',
    'CceNodeAttachTaintArgs',
    'CceNodeAttachTaintArgsDict',
    'CceNodeDataVolumeArgs',
    'CceNodeDataVolumeArgsDict',
    'CceNodeExtendParamsArgs',
    'CceNodeExtendParamsArgsDict',
    'CceNodeExtensionNicArgs',
    'CceNodeExtensionNicArgsDict',
    'CceNodeHostnameConfigArgs',
    'CceNodeHostnameConfigArgsDict',
    'CceNodePoolDataVolumeArgs',
    'CceNodePoolDataVolumeArgsDict',
    'CceNodePoolExtendParamsArgs',
    'CceNodePoolExtendParamsArgsDict',
    'CceNodePoolExtensionScaleGroupArgs',
    'CceNodePoolExtensionScaleGroupArgsDict',
    'CceNodePoolExtensionScaleGroupMetadataArgs',
    'CceNodePoolExtensionScaleGroupMetadataArgsDict',
    'CceNodePoolExtensionScaleGroupSpecArgs',
    'CceNodePoolExtensionScaleGroupSpecArgsDict',
    'CceNodePoolExtensionScaleGroupSpecAutoscalingArgs',
    'CceNodePoolExtensionScaleGroupSpecAutoscalingArgsDict',
    'CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs',
    'CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgsDict',
    'CceNodePoolHostnameConfigArgs',
    'CceNodePoolHostnameConfigArgsDict',
    'CceNodePoolRootVolumeArgs',
    'CceNodePoolRootVolumeArgsDict',
    'CceNodePoolStorageArgs',
    'CceNodePoolStorageArgsDict',
    'CceNodePoolStorageGroupArgs',
    'CceNodePoolStorageGroupArgsDict',
    'CceNodePoolStorageGroupVirtualSpaceArgs',
    'CceNodePoolStorageGroupVirtualSpaceArgsDict',
    'CceNodePoolStorageSelectorArgs',
    'CceNodePoolStorageSelectorArgsDict',
    'CceNodePoolTaintArgs',
    'CceNodePoolTaintArgsDict',
    'CceNodeRootVolumeArgs',
    'CceNodeRootVolumeArgsDict',
    'CceNodeStorageArgs',
    'CceNodeStorageArgsDict',
    'CceNodeStorageGroupArgs',
    'CceNodeStorageGroupArgsDict',
    'CceNodeStorageGroupVirtualSpaceArgs',
    'CceNodeStorageGroupVirtualSpaceArgsDict',
    'CceNodeStorageSelectorArgs',
    'CceNodeStorageSelectorArgsDict',
    'CceNodeTaintArgs',
    'CceNodeTaintArgsDict',
    'CdmClusterInstanceArgs',
    'CdmClusterInstanceArgsDict',
    'CesAlarmruleAlarmActionArgs',
    'CesAlarmruleAlarmActionArgsDict',
    'CesAlarmruleConditionArgs',
    'CesAlarmruleConditionArgsDict',
    'CesAlarmruleInsufficientdataActionArgs',
    'CesAlarmruleInsufficientdataActionArgsDict',
    'CesAlarmruleMetricArgs',
    'CesAlarmruleMetricArgsDict',
    'CesAlarmruleMetricDimensionArgs',
    'CesAlarmruleMetricDimensionArgsDict',
    'CesAlarmruleOkActionArgs',
    'CesAlarmruleOkActionArgsDict',
    'ComputeInstanceBandwidthArgs',
    'ComputeInstanceBandwidthArgsDict',
    'ComputeInstanceDataDiskArgs',
    'ComputeInstanceDataDiskArgsDict',
    'ComputeInstanceNetworkArgs',
    'ComputeInstanceNetworkArgsDict',
    'ComputeInstanceSchedulerHintArgs',
    'ComputeInstanceSchedulerHintArgsDict',
    'ComputeInstanceVolumeAttachedArgs',
    'ComputeInstanceVolumeAttachedArgsDict',
    'CssClusterBackupStrategyArgs',
    'CssClusterBackupStrategyArgsDict',
    'CssClusterNodeArgs',
    'CssClusterNodeArgsDict',
    'CssClusterNodeConfigArgs',
    'CssClusterNodeConfigArgsDict',
    'CssClusterNodeConfigNetworkInfoArgs',
    'CssClusterNodeConfigNetworkInfoArgsDict',
    'CssClusterNodeConfigVolumeArgs',
    'CssClusterNodeConfigVolumeArgsDict',
    'CtsNotificationFilterArgs',
    'CtsNotificationFilterArgsDict',
    'CtsNotificationOperationArgs',
    'CtsNotificationOperationArgsDict',
    'CtsNotificationOperationUserArgs',
    'CtsNotificationOperationUserArgsDict',
    'DcsInstanceBackupPolicyArgs',
    'DcsInstanceBackupPolicyArgsDict',
    'DcsInstanceBandwidthInfoArgs',
    'DcsInstanceBandwidthInfoArgsDict',
    'DcsInstanceParameterArgs',
    'DcsInstanceParameterArgsDict',
    'DcsInstanceWhitelistArgs',
    'DcsInstanceWhitelistArgsDict',
    'DcsParametersConfigurationParameterArgs',
    'DcsParametersConfigurationParameterArgsDict',
    'DcsRestoreRestoreRecordArgs',
    'DcsRestoreRestoreRecordArgsDict',
    'DdsInstanceBackupStrategyArgs',
    'DdsInstanceBackupStrategyArgsDict',
    'DdsInstanceConfigurationArgs',
    'DdsInstanceConfigurationArgsDict',
    'DdsInstanceDatastoreArgs',
    'DdsInstanceDatastoreArgsDict',
    'DdsInstanceFlavorArgs',
    'DdsInstanceFlavorArgsDict',
    'DdsInstanceGroupArgs',
    'DdsInstanceGroupArgsDict',
    'DdsInstanceGroupNodeArgs',
    'DdsInstanceGroupNodeArgsDict',
    'DdsInstanceNodeArgs',
    'DdsInstanceNodeArgsDict',
    'DisStreamPartitionArgs',
    'DisStreamPartitionArgsDict',
    'DliQueueScalingPolicyArgs',
    'DliQueueScalingPolicyArgsDict',
    'DliQueueSparkDriverArgs',
    'DliQueueSparkDriverArgsDict',
    'DliSparkJobDependentPackageArgs',
    'DliSparkJobDependentPackageArgsDict',
    'DliSparkJobDependentPackagePackageArgs',
    'DliSparkJobDependentPackagePackageArgsDict',
    'DmsKafkaInstanceCrossVpcAccessArgs',
    'DmsKafkaInstanceCrossVpcAccessArgsDict',
    'DmsKafkaInstanceParameterArgs',
    'DmsKafkaInstanceParameterArgsDict',
    'DmsKafkaInstancePortProtocolArgs',
    'DmsKafkaInstancePortProtocolArgsDict',
    'DmsKafkaMessageProducePropertyListArgs',
    'DmsKafkaMessageProducePropertyListArgsDict',
    'DmsKafkaPermissionsPolicyArgs',
    'DmsKafkaPermissionsPolicyArgsDict',
    'DmsKafkaTopicConfigArgs',
    'DmsKafkaTopicConfigArgsDict',
    'DnsZoneRouterArgs',
    'DnsZoneRouterArgsDict',
    'DrsJobDestinationDbArgs',
    'DrsJobDestinationDbArgsDict',
    'DrsJobLimitSpeedArgs',
    'DrsJobLimitSpeedArgsDict',
    'DrsJobSourceDbArgs',
    'DrsJobSourceDbArgsDict',
    'DwsClusterElbArgs',
    'DwsClusterElbArgsDict',
    'DwsClusterEndpointArgs',
    'DwsClusterEndpointArgsDict',
    'DwsClusterMaintainWindowArgs',
    'DwsClusterMaintainWindowArgsDict',
    'DwsClusterPublicEndpointArgs',
    'DwsClusterPublicEndpointArgsDict',
    'DwsClusterPublicIpArgs',
    'DwsClusterPublicIpArgsDict',
    'DwsClusterVolumeArgs',
    'DwsClusterVolumeArgsDict',
    'ElbIpgroupIpListArgs',
    'ElbIpgroupIpListArgsDict',
    'ElbL7policyFixedResponseConfigArgs',
    'ElbL7policyFixedResponseConfigArgsDict',
    'ElbL7policyFixedResponseConfigInsertHeadersConfigArgs',
    'ElbL7policyFixedResponseConfigInsertHeadersConfigArgsDict',
    'ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs',
    'ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgsDict',
    'ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs',
    'ElbL7policyFixedResponseConfigRemoveHeadersConfigArgsDict',
    'ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs',
    'ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgsDict',
    'ElbL7policyFixedResponseConfigTrafficLimitConfigArgs',
    'ElbL7policyFixedResponseConfigTrafficLimitConfigArgsDict',
    'ElbL7policyRedirectPoolsConfigArgs',
    'ElbL7policyRedirectPoolsConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgsDict',
    'ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs',
    'ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgsDict',
    'ElbL7policyRedirectPoolsStickySessionConfigArgs',
    'ElbL7policyRedirectPoolsStickySessionConfigArgsDict',
    'ElbL7policyRedirectUrlConfigArgs',
    'ElbL7policyRedirectUrlConfigArgsDict',
    'ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs',
    'ElbL7policyRedirectUrlConfigInsertHeadersConfigArgsDict',
    'ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs',
    'ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgsDict',
    'ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs',
    'ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgsDict',
    'ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs',
    'ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgsDict',
    'ElbL7ruleConditionArgs',
    'ElbL7ruleConditionArgsDict',
    'ElbListenerPortRangeArgs',
    'ElbListenerPortRangeArgsDict',
    'ElbPoolPersistenceArgs',
    'ElbPoolPersistenceArgsDict',
    'ElbSecurityPolicyListenerArgs',
    'ElbSecurityPolicyListenerArgsDict',
    'EvsVolumeAttachmentArgs',
    'EvsVolumeAttachmentArgsDict',
    'FgsFunctionCustomImageArgs',
    'FgsFunctionCustomImageArgsDict',
    'FgsFunctionFuncMountArgs',
    'FgsFunctionFuncMountArgsDict',
    'FgsFunctionNetworkControllerArgs',
    'FgsFunctionNetworkControllerArgsDict',
    'FgsFunctionNetworkControllerTriggerAccessVpcArgs',
    'FgsFunctionNetworkControllerTriggerAccessVpcArgsDict',
    'FgsFunctionReservedInstanceArgs',
    'FgsFunctionReservedInstanceArgsDict',
    'FgsFunctionReservedInstanceTacticsConfigArgs',
    'FgsFunctionReservedInstanceTacticsConfigArgsDict',
    'FgsFunctionReservedInstanceTacticsConfigCronConfigArgs',
    'FgsFunctionReservedInstanceTacticsConfigCronConfigArgsDict',
    'FgsFunctionReservedInstanceTacticsConfigMetricConfigArgs',
    'FgsFunctionReservedInstanceTacticsConfigMetricConfigArgsDict',
    'FgsFunctionVersionArgs',
    'FgsFunctionVersionArgsDict',
    'FgsFunctionVersionAliasesArgs',
    'FgsFunctionVersionAliasesArgsDict',
    'GesGraphEncryptionArgs',
    'GesGraphEncryptionArgsDict',
    'GesGraphLtsOperationTraceArgs',
    'GesGraphLtsOperationTraceArgsDict',
    'GesGraphPublicIpArgs',
    'GesGraphPublicIpArgsDict',
    'GesGraphVertexIdTypeArgs',
    'GesGraphVertexIdTypeArgsDict',
    'IdentityAclIpCidrArgs',
    'IdentityAclIpCidrArgsDict',
    'IdentityAclIpRangeArgs',
    'IdentityAclIpRangeArgsDict',
    'IdentityAgencyProjectRoleArgs',
    'IdentityAgencyProjectRoleArgsDict',
    'IdentityProviderAccessConfigArgs',
    'IdentityProviderAccessConfigArgsDict',
    'IdentityProviderConversionConversionRuleArgs',
    'IdentityProviderConversionConversionRuleArgsDict',
    'IdentityProviderConversionConversionRuleLocalArgs',
    'IdentityProviderConversionConversionRuleLocalArgsDict',
    'IdentityProviderConversionConversionRuleRemoteArgs',
    'IdentityProviderConversionConversionRuleRemoteArgsDict',
    'IdentityProviderConversionRuleArgs',
    'IdentityProviderConversionRuleArgsDict',
    'IdentityProviderConversionRuleLocalArgs',
    'IdentityProviderConversionRuleLocalArgsDict',
    'IdentityProviderConversionRuleRemoteArgs',
    'IdentityProviderConversionRuleRemoteArgsDict',
    'LbPoolPersistenceArgs',
    'LbPoolPersistenceArgsDict',
    'MapreduceClusterAnalysisCoreNodesArgs',
    'MapreduceClusterAnalysisCoreNodesArgsDict',
    'MapreduceClusterAnalysisTaskNodesArgs',
    'MapreduceClusterAnalysisTaskNodesArgsDict',
    'MapreduceClusterBootstrapScriptArgs',
    'MapreduceClusterBootstrapScriptArgsDict',
    'MapreduceClusterComponentConfigArgs',
    'MapreduceClusterComponentConfigArgsDict',
    'MapreduceClusterComponentConfigConfigArgs',
    'MapreduceClusterComponentConfigConfigArgsDict',
    'MapreduceClusterCustomNodeArgs',
    'MapreduceClusterCustomNodeArgsDict',
    'MapreduceClusterExternalDatasourceArgs',
    'MapreduceClusterExternalDatasourceArgsDict',
    'MapreduceClusterMasterNodesArgs',
    'MapreduceClusterMasterNodesArgsDict',
    'MapreduceClusterSmnNotifyArgs',
    'MapreduceClusterSmnNotifyArgsDict',
    'MapreduceClusterStreamingCoreNodesArgs',
    'MapreduceClusterStreamingCoreNodesArgsDict',
    'MapreduceClusterStreamingTaskNodesArgs',
    'MapreduceClusterStreamingTaskNodesArgsDict',
    'NatGatewaySessionConfArgs',
    'NatGatewaySessionConfArgsDict',
    'NetworkingSecgroupRuleArgs',
    'NetworkingSecgroupRuleArgsDict',
    'ObsBucketAclAccountPermissionArgs',
    'ObsBucketAclAccountPermissionArgsDict',
    'ObsBucketAclLogDeliveryUserPermissionArgs',
    'ObsBucketAclLogDeliveryUserPermissionArgsDict',
    'ObsBucketAclOwnerPermissionArgs',
    'ObsBucketAclOwnerPermissionArgsDict',
    'ObsBucketAclPublicPermissionArgs',
    'ObsBucketAclPublicPermissionArgsDict',
    'ObsBucketCorsRuleArgs',
    'ObsBucketCorsRuleArgsDict',
    'ObsBucketLifecycleRuleArgs',
    'ObsBucketLifecycleRuleArgsDict',
    'ObsBucketLifecycleRuleAbortIncompleteMultipartUploadArgs',
    'ObsBucketLifecycleRuleAbortIncompleteMultipartUploadArgsDict',
    'ObsBucketLifecycleRuleExpirationArgs',
    'ObsBucketLifecycleRuleExpirationArgsDict',
    'ObsBucketLifecycleRuleNoncurrentVersionExpirationArgs',
    'ObsBucketLifecycleRuleNoncurrentVersionExpirationArgsDict',
    'ObsBucketLifecycleRuleNoncurrentVersionTransitionArgs',
    'ObsBucketLifecycleRuleNoncurrentVersionTransitionArgsDict',
    'ObsBucketLifecycleRuleTransitionArgs',
    'ObsBucketLifecycleRuleTransitionArgsDict',
    'ObsBucketLoggingArgs',
    'ObsBucketLoggingArgsDict',
    'ObsBucketStorageInfoArgs',
    'ObsBucketStorageInfoArgsDict',
    'ObsBucketWebsiteArgs',
    'ObsBucketWebsiteArgsDict',
    'ProviderAssumeRoleArgs',
    'ProviderAssumeRoleArgsDict',
    'RdsBackupDatabaseArgs',
    'RdsBackupDatabaseArgsDict',
    'RdsInstanceBackupStrategyArgs',
    'RdsInstanceBackupStrategyArgsDict',
    'RdsInstanceDbArgs',
    'RdsInstanceDbArgsDict',
    'RdsInstanceMsdtcHostArgs',
    'RdsInstanceMsdtcHostArgsDict',
    'RdsInstanceNodeArgs',
    'RdsInstanceNodeArgsDict',
    'RdsInstanceParameterArgs',
    'RdsInstanceParameterArgsDict',
    'RdsInstanceRestoreArgs',
    'RdsInstanceRestoreArgsDict',
    'RdsInstanceVolumeArgs',
    'RdsInstanceVolumeArgsDict',
    'RdsMysqlDatabasePrivilegeUserArgs',
    'RdsMysqlDatabasePrivilegeUserArgsDict',
    'RdsMysqlDatabaseTableRestoreDatabaseArgs',
    'RdsMysqlDatabaseTableRestoreDatabaseArgsDict',
    'RdsMysqlDatabaseTableRestoreRestoreTableArgs',
    'RdsMysqlDatabaseTableRestoreRestoreTableArgsDict',
    'RdsMysqlDatabaseTableRestoreRestoreTableTableArgs',
    'RdsMysqlDatabaseTableRestoreRestoreTableTableArgsDict',
    'RdsParametergroupConfigurationParameterArgs',
    'RdsParametergroupConfigurationParameterArgsDict',
    'RdsParametergroupDatastoreArgs',
    'RdsParametergroupDatastoreArgsDict',
    'RdsPgAccountAttributeArgs',
    'RdsPgAccountAttributeArgsDict',
    'RdsPgHbaHostBasedAuthenticationArgs',
    'RdsPgHbaHostBasedAuthenticationArgsDict',
    'RdsReadReplicaInstanceDbArgs',
    'RdsReadReplicaInstanceDbArgsDict',
    'RdsReadReplicaInstanceParameterArgs',
    'RdsReadReplicaInstanceParameterArgsDict',
    'RdsReadReplicaInstanceVolumeArgs',
    'RdsReadReplicaInstanceVolumeArgsDict',
    'RdsSqlserverDatabasePrivilegeUserArgs',
    'RdsSqlserverDatabasePrivilegeUserArgsDict',
    'SfsFileSystemAccessRuleArgs',
    'SfsFileSystemAccessRuleArgsDict',
    'SfsTurboDuTaskDirUsageArgs',
    'SfsTurboDuTaskDirUsageArgsDict',
    'SfsTurboDuTaskDirUsageFileCountArgs',
    'SfsTurboDuTaskDirUsageFileCountArgsDict',
    'SfsTurboObsTargetObsArgs',
    'SfsTurboObsTargetObsArgsDict',
    'SmnSubscriptionExtensionArgs',
    'SmnSubscriptionExtensionArgsDict',
    'SmnSubscriptionFilterPolicyArgs',
    'SmnSubscriptionFilterPolicyArgsDict',
    'SwrOrganizationPermissionsSelfPermissionArgs',
    'SwrOrganizationPermissionsSelfPermissionArgsDict',
    'SwrOrganizationPermissionsUserArgs',
    'SwrOrganizationPermissionsUserArgsDict',
    'VpcAddressGroupIpExtraSetArgs',
    'VpcAddressGroupIpExtraSetArgsDict',
    'VpcBandwidthPublicipArgs',
    'VpcBandwidthPublicipArgsDict',
    'VpcEipBandwidthArgs',
    'VpcEipBandwidthArgsDict',
    'VpcEipPublicipArgs',
    'VpcEipPublicipArgsDict',
    'VpcRouteArgs',
    'VpcRouteArgsDict',
    'VpcRouteTableRouteArgs',
    'VpcRouteTableRouteArgsDict',
    'VpcepServiceConnectionArgs',
    'VpcepServiceConnectionArgsDict',
    'VpcepServicePortMappingArgs',
    'VpcepServicePortMappingArgsDict',
    'VpnConnectionIkepolicyArgs',
    'VpnConnectionIkepolicyArgsDict',
    'VpnConnectionIkepolicyDpdArgs',
    'VpnConnectionIkepolicyDpdArgsDict',
    'VpnConnectionIpsecpolicyArgs',
    'VpnConnectionIpsecpolicyArgsDict',
    'VpnConnectionPolicyRuleArgs',
    'VpnConnectionPolicyRuleArgsDict',
    'VpnGatewayCertificateArgs',
    'VpnGatewayCertificateArgsDict',
    'VpnGatewayEip1Args',
    'VpnGatewayEip1ArgsDict',
    'VpnGatewayEip2Args',
    'VpnGatewayEip2ArgsDict',
    'VpnGatewayMasterEipArgs',
    'VpnGatewayMasterEipArgsDict',
    'VpnGatewaySlaveEipArgs',
    'VpnGatewaySlaveEipArgsDict',
]

MYPY = False

if not MYPY:
    class AomServiceDiscoveryRuleDiscoveryRuleArgsDict(TypedDict):
        check_contents: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        check_mode: pulumi.Input[builtins.str]
        check_type: pulumi.Input[builtins.str]
elif False:
    AomServiceDiscoveryRuleDiscoveryRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AomServiceDiscoveryRuleDiscoveryRuleArgs:
    def __init__(__self__, *,
                 check_contents: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 check_mode: pulumi.Input[builtins.str],
                 check_type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "check_contents", check_contents)
        pulumi.set(__self__, "check_mode", check_mode)
        pulumi.set(__self__, "check_type", check_type)

    @property
    @pulumi.getter(name="checkContents")
    def check_contents(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "check_contents")

    @check_contents.setter
    def check_contents(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "check_contents", value)

    @property
    @pulumi.getter(name="checkMode")
    def check_mode(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "check_mode")

    @check_mode.setter
    def check_mode(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "check_mode", value)

    @property
    @pulumi.getter(name="checkType")
    def check_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "check_type")

    @check_type.setter
    def check_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "check_type", value)


if not MYPY:
    class AomServiceDiscoveryRuleLogPathRuleArgsDict(TypedDict):
        args: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        name_type: pulumi.Input[builtins.str]
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    AomServiceDiscoveryRuleLogPathRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AomServiceDiscoveryRuleLogPathRuleArgs:
    def __init__(__self__, *,
                 args: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 name_type: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def args(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter(name="nameType")
    def name_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name_type")

    @name_type.setter
    def name_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name_type", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AomServiceDiscoveryRuleNameRulesArgsDict(TypedDict):
        application_name_rules: pulumi.Input[Sequence[pulumi.Input['AomServiceDiscoveryRuleNameRulesApplicationNameRuleArgsDict']]]
        service_name_rules: pulumi.Input[Sequence[pulumi.Input['AomServiceDiscoveryRuleNameRulesServiceNameRuleArgsDict']]]
elif False:
    AomServiceDiscoveryRuleNameRulesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AomServiceDiscoveryRuleNameRulesArgs:
    def __init__(__self__, *,
                 application_name_rules: pulumi.Input[Sequence[pulumi.Input['AomServiceDiscoveryRuleNameRulesApplicationNameRuleArgs']]],
                 service_name_rules: pulumi.Input[Sequence[pulumi.Input['AomServiceDiscoveryRuleNameRulesServiceNameRuleArgs']]]):
        pulumi.set(__self__, "application_name_rules", application_name_rules)
        pulumi.set(__self__, "service_name_rules", service_name_rules)

    @property
    @pulumi.getter(name="applicationNameRules")
    def application_name_rules(self) -> pulumi.Input[Sequence[pulumi.Input['AomServiceDiscoveryRuleNameRulesApplicationNameRuleArgs']]]:
        return pulumi.get(self, "application_name_rules")

    @application_name_rules.setter
    def application_name_rules(self, value: pulumi.Input[Sequence[pulumi.Input['AomServiceDiscoveryRuleNameRulesApplicationNameRuleArgs']]]):
        pulumi.set(self, "application_name_rules", value)

    @property
    @pulumi.getter(name="serviceNameRules")
    def service_name_rules(self) -> pulumi.Input[Sequence[pulumi.Input['AomServiceDiscoveryRuleNameRulesServiceNameRuleArgs']]]:
        return pulumi.get(self, "service_name_rules")

    @service_name_rules.setter
    def service_name_rules(self, value: pulumi.Input[Sequence[pulumi.Input['AomServiceDiscoveryRuleNameRulesServiceNameRuleArgs']]]):
        pulumi.set(self, "service_name_rules", value)


if not MYPY:
    class AomServiceDiscoveryRuleNameRulesApplicationNameRuleArgsDict(TypedDict):
        args: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        name_type: pulumi.Input[builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    AomServiceDiscoveryRuleNameRulesApplicationNameRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AomServiceDiscoveryRuleNameRulesApplicationNameRuleArgs:
    def __init__(__self__, *,
                 args: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 name_type: pulumi.Input[builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def args(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter(name="nameType")
    def name_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name_type")

    @name_type.setter
    def name_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name_type", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AomServiceDiscoveryRuleNameRulesServiceNameRuleArgsDict(TypedDict):
        args: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        name_type: pulumi.Input[builtins.str]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    AomServiceDiscoveryRuleNameRulesServiceNameRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AomServiceDiscoveryRuleNameRulesServiceNameRuleArgs:
    def __init__(__self__, *,
                 args: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 name_type: pulumi.Input[builtins.str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "name_type", name_type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def args(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter(name="nameType")
    def name_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name_type")

    @name_type.setter
    def name_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name_type", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ApiGatewayApiBackendParamArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        Where the parameter is located.
        """
        name: pulumi.Input[builtins.str]
        """
        The parameter name.
        """
        type: pulumi.Input[builtins.str]
        """
        The parameter type.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the parameter
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the parameter.
        """
        system_param_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApiGatewayApiBackendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiBackendParamArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 system_param_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: Where the parameter is located.
        :param pulumi.Input[builtins.str] name: The parameter name.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.str] value: The value of the parameter
        :param pulumi.Input[builtins.str] description: The description of the parameter.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if system_param_type is not None:
            pulumi.set(__self__, "system_param_type", system_param_type)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        Where the parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="systemParamType")
    def system_param_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "system_param_type")

    @system_param_type.setter
    def system_param_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_param_type", value)


if not MYPY:
    class ApiGatewayApiFuncGraphArgsDict(TypedDict):
        function_urn: pulumi.Input[builtins.str]
        """
        The URN of the FunctionGraph function.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        function_alias_urn: NotRequired[pulumi.Input[builtins.str]]
        """
        The alias URN of the FunctionGraph function.
        """
        invocation_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The invocation type.
        """
        network_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The network architecture (framework) type of the FunctionGraph function.
        """
        request_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The request protocol of the FunctionGraph function.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The timeout for API requests to backend service.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        The version of the FunctionGraph function.
        """
elif False:
    ApiGatewayApiFuncGraphArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiFuncGraphArgs:
    def __init__(__self__, *,
                 function_urn: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 function_alias_urn: Optional[pulumi.Input[builtins.str]] = None,
                 invocation_type: Optional[pulumi.Input[builtins.str]] = None,
                 network_type: Optional[pulumi.Input[builtins.str]] = None,
                 request_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] function_urn: The URN of the FunctionGraph function.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[builtins.str] function_alias_urn: The alias URN of the FunctionGraph function.
        :param pulumi.Input[builtins.str] invocation_type: The invocation type.
        :param pulumi.Input[builtins.str] network_type: The network architecture (framework) type of the FunctionGraph function.
        :param pulumi.Input[builtins.str] request_protocol: The request protocol of the FunctionGraph function.
        :param pulumi.Input[builtins.int] timeout: The timeout for API requests to backend service.
        :param pulumi.Input[builtins.str] version: The version of the FunctionGraph function.
        """
        pulumi.set(__self__, "function_urn", function_urn)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if function_alias_urn is not None:
            pulumi.set(__self__, "function_alias_urn", function_alias_urn)
        if invocation_type is not None:
            pulumi.set(__self__, "invocation_type", invocation_type)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if request_protocol is not None:
            pulumi.set(__self__, "request_protocol", request_protocol)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="functionUrn")
    def function_urn(self) -> pulumi.Input[builtins.str]:
        """
        The URN of the FunctionGraph function.
        """
        return pulumi.get(self, "function_urn")

    @function_urn.setter
    def function_urn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "function_urn", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="functionAliasUrn")
    def function_alias_urn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The alias URN of the FunctionGraph function.
        """
        return pulumi.get(self, "function_alias_urn")

    @function_alias_urn.setter
    def function_alias_urn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "function_alias_urn", value)

    @property
    @pulumi.getter(name="invocationType")
    def invocation_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The invocation type.
        """
        return pulumi.get(self, "invocation_type")

    @invocation_type.setter
    def invocation_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "invocation_type", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The network architecture (framework) type of the FunctionGraph function.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="requestProtocol")
    def request_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request protocol of the FunctionGraph function.
        """
        return pulumi.get(self, "request_protocol")

    @request_protocol.setter
    def request_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_protocol", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The timeout for API requests to backend service.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version of the FunctionGraph function.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ApiGatewayApiFuncGraphPolicyArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyConditionArgsDict']]]
        """
        The policy conditions.
        """
        function_urn: pulumi.Input[builtins.str]
        """
        The URN of the FunctionGraph function.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the backend policy.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        backend_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyBackendParamArgsDict']]]]
        """
        The configaiton list of the backend parameters.
        """
        effective_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The effective mode of the backend policy.
        """
        function_alias_urn: NotRequired[pulumi.Input[builtins.str]]
        """
        The alias URN of the FunctionGraph function.
        """
        invocation_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The invocation mode of the FunctionGraph function.
        """
        invocation_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The invocation mode of the FunctionGraph function.
        """
        network_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The network (framework) type of the FunctionGraph function.
        """
        request_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The request protocol of the FunctionGraph function.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The timeout for API requests to backend service.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        The version of the FunctionGraph function.
        """
elif False:
    ApiGatewayApiFuncGraphPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiFuncGraphPolicyArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyConditionArgs']]],
                 function_urn: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 backend_params: Optional[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyBackendParamArgs']]]] = None,
                 effective_mode: Optional[pulumi.Input[builtins.str]] = None,
                 function_alias_urn: Optional[pulumi.Input[builtins.str]] = None,
                 invocation_mode: Optional[pulumi.Input[builtins.str]] = None,
                 invocation_type: Optional[pulumi.Input[builtins.str]] = None,
                 network_type: Optional[pulumi.Input[builtins.str]] = None,
                 request_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyConditionArgs']]] conditions: The policy conditions.
        :param pulumi.Input[builtins.str] function_urn: The URN of the FunctionGraph function.
        :param pulumi.Input[builtins.str] name: The name of the backend policy.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyBackendParamArgs']]] backend_params: The configaiton list of the backend parameters.
        :param pulumi.Input[builtins.str] effective_mode: The effective mode of the backend policy.
        :param pulumi.Input[builtins.str] function_alias_urn: The alias URN of the FunctionGraph function.
        :param pulumi.Input[builtins.str] invocation_mode: The invocation mode of the FunctionGraph function.
        :param pulumi.Input[builtins.str] invocation_type: The invocation mode of the FunctionGraph function.
        :param pulumi.Input[builtins.str] network_type: The network (framework) type of the FunctionGraph function.
        :param pulumi.Input[builtins.str] request_protocol: The request protocol of the FunctionGraph function.
        :param pulumi.Input[builtins.int] timeout: The timeout for API requests to backend service.
        :param pulumi.Input[builtins.str] version: The version of the FunctionGraph function.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "function_urn", function_urn)
        pulumi.set(__self__, "name", name)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if backend_params is not None:
            pulumi.set(__self__, "backend_params", backend_params)
        if effective_mode is not None:
            pulumi.set(__self__, "effective_mode", effective_mode)
        if function_alias_urn is not None:
            pulumi.set(__self__, "function_alias_urn", function_alias_urn)
        if invocation_mode is not None:
            pulumi.set(__self__, "invocation_mode", invocation_mode)
        if invocation_type is not None:
            pulumi.set(__self__, "invocation_type", invocation_type)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if request_protocol is not None:
            pulumi.set(__self__, "request_protocol", request_protocol)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyConditionArgs']]]:
        """
        The policy conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="functionUrn")
    def function_urn(self) -> pulumi.Input[builtins.str]:
        """
        The URN of the FunctionGraph function.
        """
        return pulumi.get(self, "function_urn")

    @function_urn.setter
    def function_urn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "function_urn", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the backend policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="backendParams")
    def backend_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyBackendParamArgs']]]]:
        """
        The configaiton list of the backend parameters.
        """
        return pulumi.get(self, "backend_params")

    @backend_params.setter
    def backend_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiFuncGraphPolicyBackendParamArgs']]]]):
        pulumi.set(self, "backend_params", value)

    @property
    @pulumi.getter(name="effectiveMode")
    def effective_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The effective mode of the backend policy.
        """
        return pulumi.get(self, "effective_mode")

    @effective_mode.setter
    def effective_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effective_mode", value)

    @property
    @pulumi.getter(name="functionAliasUrn")
    def function_alias_urn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The alias URN of the FunctionGraph function.
        """
        return pulumi.get(self, "function_alias_urn")

    @function_alias_urn.setter
    def function_alias_urn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "function_alias_urn", value)

    @property
    @pulumi.getter(name="invocationMode")
    def invocation_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The invocation mode of the FunctionGraph function.
        """
        return pulumi.get(self, "invocation_mode")

    @invocation_mode.setter
    def invocation_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "invocation_mode", value)

    @property
    @pulumi.getter(name="invocationType")
    def invocation_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The invocation mode of the FunctionGraph function.
        """
        return pulumi.get(self, "invocation_type")

    @invocation_type.setter
    def invocation_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "invocation_type", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The network (framework) type of the FunctionGraph function.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="requestProtocol")
    def request_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request protocol of the FunctionGraph function.
        """
        return pulumi.get(self, "request_protocol")

    @request_protocol.setter
    def request_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_protocol", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The timeout for API requests to backend service.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version of the FunctionGraph function.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ApiGatewayApiFuncGraphPolicyBackendParamArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        Where the parameter is located.
        """
        name: pulumi.Input[builtins.str]
        """
        The parameter name.
        """
        type: pulumi.Input[builtins.str]
        """
        The parameter type.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the parameter
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the parameter.
        """
        system_param_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApiGatewayApiFuncGraphPolicyBackendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiFuncGraphPolicyBackendParamArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 system_param_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: Where the parameter is located.
        :param pulumi.Input[builtins.str] name: The parameter name.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.str] value: The value of the parameter
        :param pulumi.Input[builtins.str] description: The description of the parameter.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if system_param_type is not None:
            pulumi.set(__self__, "system_param_type", system_param_type)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        Where the parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="systemParamType")
    def system_param_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "system_param_type")

    @system_param_type.setter
    def system_param_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_param_type", value)


if not MYPY:
    class ApiGatewayApiFuncGraphPolicyConditionArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        The value of the backend policy.
        """
        cookie_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The cookie parameter name.
        """
        frontend_authorizer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The frontend authentication parameter name.
        """
        mapped_param_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The location of a parameter generated after orchestration.
        """
        mapped_param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of a parameter generated after orchestration.
        """
        param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The request parameter name.
        """
        source: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the backend policy.
        """
        sys_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The gateway built-in parameter name.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The condition type.
        """
elif False:
    ApiGatewayApiFuncGraphPolicyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiFuncGraphPolicyConditionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 cookie_name: Optional[pulumi.Input[builtins.str]] = None,
                 frontend_authorizer_name: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_location: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_name: Optional[pulumi.Input[builtins.str]] = None,
                 param_name: Optional[pulumi.Input[builtins.str]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 sys_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] value: The value of the backend policy.
        :param pulumi.Input[builtins.str] cookie_name: The cookie parameter name.
        :param pulumi.Input[builtins.str] frontend_authorizer_name: The frontend authentication parameter name.
        :param pulumi.Input[builtins.str] mapped_param_location: The location of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] mapped_param_name: The name of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] param_name: The request parameter name.
        :param pulumi.Input[builtins.str] source: The type of the backend policy.
        :param pulumi.Input[builtins.str] sys_name: The gateway built-in parameter name.
        :param pulumi.Input[builtins.str] type: The condition type.
        """
        pulumi.set(__self__, "value", value)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if frontend_authorizer_name is not None:
            pulumi.set(__self__, "frontend_authorizer_name", frontend_authorizer_name)
        if mapped_param_location is not None:
            pulumi.set(__self__, "mapped_param_location", mapped_param_location)
        if mapped_param_name is not None:
            pulumi.set(__self__, "mapped_param_name", mapped_param_name)
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if sys_name is not None:
            pulumi.set(__self__, "sys_name", sys_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the backend policy.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The cookie parameter name.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="frontendAuthorizerName")
    def frontend_authorizer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The frontend authentication parameter name.
        """
        return pulumi.get(self, "frontend_authorizer_name")

    @frontend_authorizer_name.setter
    def frontend_authorizer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "frontend_authorizer_name", value)

    @property
    @pulumi.getter(name="mappedParamLocation")
    def mapped_param_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The location of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_location")

    @mapped_param_location.setter
    def mapped_param_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_location", value)

    @property
    @pulumi.getter(name="mappedParamName")
    def mapped_param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_name")

    @mapped_param_name.setter
    def mapped_param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_name", value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request parameter name.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the backend policy.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sysName")
    def sys_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gateway built-in parameter name.
        """
        return pulumi.get(self, "sys_name")

    @sys_name.setter
    def sys_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sys_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The condition type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApiGatewayApiMockArgsDict(TypedDict):
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        response: NotRequired[pulumi.Input[builtins.str]]
        """
        The response content of the mock.
        """
        status_code: NotRequired[pulumi.Input[builtins.int]]
        """
        The custom status code of the mock response.
        """
elif False:
    ApiGatewayApiMockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiMockArgs:
    def __init__(__self__, *,
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 response: Optional[pulumi.Input[builtins.str]] = None,
                 status_code: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[builtins.str] response: The response content of the mock.
        :param pulumi.Input[builtins.int] status_code: The custom status code of the mock response.
        """
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The response content of the mock.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The custom status code of the mock response.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class ApiGatewayApiMockPolicyArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyConditionArgsDict']]]
        """
        The policy conditions.
        """
        name: pulumi.Input[builtins.str]
        """
        The backend policy name.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        backend_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyBackendParamArgsDict']]]]
        """
        The configuration list of backend parameters.
        """
        effective_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The effective mode of the backend policy.
        """
        response: NotRequired[pulumi.Input[builtins.str]]
        """
        The response content of the mock.
        """
        status_code: NotRequired[pulumi.Input[builtins.int]]
        """
        The custom status code of the mock response.
        """
elif False:
    ApiGatewayApiMockPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiMockPolicyArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyConditionArgs']]],
                 name: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 backend_params: Optional[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyBackendParamArgs']]]] = None,
                 effective_mode: Optional[pulumi.Input[builtins.str]] = None,
                 response: Optional[pulumi.Input[builtins.str]] = None,
                 status_code: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyConditionArgs']]] conditions: The policy conditions.
        :param pulumi.Input[builtins.str] name: The backend policy name.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyBackendParamArgs']]] backend_params: The configuration list of backend parameters.
        :param pulumi.Input[builtins.str] effective_mode: The effective mode of the backend policy.
        :param pulumi.Input[builtins.str] response: The response content of the mock.
        :param pulumi.Input[builtins.int] status_code: The custom status code of the mock response.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if backend_params is not None:
            pulumi.set(__self__, "backend_params", backend_params)
        if effective_mode is not None:
            pulumi.set(__self__, "effective_mode", effective_mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyConditionArgs']]]:
        """
        The policy conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The backend policy name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="backendParams")
    def backend_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyBackendParamArgs']]]]:
        """
        The configuration list of backend parameters.
        """
        return pulumi.get(self, "backend_params")

    @backend_params.setter
    def backend_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiMockPolicyBackendParamArgs']]]]):
        pulumi.set(self, "backend_params", value)

    @property
    @pulumi.getter(name="effectiveMode")
    def effective_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The effective mode of the backend policy.
        """
        return pulumi.get(self, "effective_mode")

    @effective_mode.setter
    def effective_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effective_mode", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The response content of the mock.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The custom status code of the mock response.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class ApiGatewayApiMockPolicyBackendParamArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        Where the parameter is located.
        """
        name: pulumi.Input[builtins.str]
        """
        The parameter name.
        """
        type: pulumi.Input[builtins.str]
        """
        The parameter type.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the parameter
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the parameter.
        """
        system_param_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApiGatewayApiMockPolicyBackendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiMockPolicyBackendParamArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 system_param_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: Where the parameter is located.
        :param pulumi.Input[builtins.str] name: The parameter name.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.str] value: The value of the parameter
        :param pulumi.Input[builtins.str] description: The description of the parameter.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if system_param_type is not None:
            pulumi.set(__self__, "system_param_type", system_param_type)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        Where the parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="systemParamType")
    def system_param_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "system_param_type")

    @system_param_type.setter
    def system_param_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_param_type", value)


if not MYPY:
    class ApiGatewayApiMockPolicyConditionArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        The value of the backend policy.
        """
        cookie_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The cookie parameter name.
        """
        frontend_authorizer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The frontend authentication parameter name.
        """
        mapped_param_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The location of a parameter generated after orchestration.
        """
        mapped_param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of a parameter generated after orchestration.
        """
        param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The request parameter name.
        """
        source: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the backend policy.
        """
        sys_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The gateway built-in parameter name.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The condition type.
        """
elif False:
    ApiGatewayApiMockPolicyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiMockPolicyConditionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 cookie_name: Optional[pulumi.Input[builtins.str]] = None,
                 frontend_authorizer_name: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_location: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_name: Optional[pulumi.Input[builtins.str]] = None,
                 param_name: Optional[pulumi.Input[builtins.str]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 sys_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] value: The value of the backend policy.
        :param pulumi.Input[builtins.str] cookie_name: The cookie parameter name.
        :param pulumi.Input[builtins.str] frontend_authorizer_name: The frontend authentication parameter name.
        :param pulumi.Input[builtins.str] mapped_param_location: The location of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] mapped_param_name: The name of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] param_name: The request parameter name.
        :param pulumi.Input[builtins.str] source: The type of the backend policy.
        :param pulumi.Input[builtins.str] sys_name: The gateway built-in parameter name.
        :param pulumi.Input[builtins.str] type: The condition type.
        """
        pulumi.set(__self__, "value", value)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if frontend_authorizer_name is not None:
            pulumi.set(__self__, "frontend_authorizer_name", frontend_authorizer_name)
        if mapped_param_location is not None:
            pulumi.set(__self__, "mapped_param_location", mapped_param_location)
        if mapped_param_name is not None:
            pulumi.set(__self__, "mapped_param_name", mapped_param_name)
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if sys_name is not None:
            pulumi.set(__self__, "sys_name", sys_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the backend policy.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The cookie parameter name.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="frontendAuthorizerName")
    def frontend_authorizer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The frontend authentication parameter name.
        """
        return pulumi.get(self, "frontend_authorizer_name")

    @frontend_authorizer_name.setter
    def frontend_authorizer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "frontend_authorizer_name", value)

    @property
    @pulumi.getter(name="mappedParamLocation")
    def mapped_param_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The location of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_location")

    @mapped_param_location.setter
    def mapped_param_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_location", value)

    @property
    @pulumi.getter(name="mappedParamName")
    def mapped_param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_name")

    @mapped_param_name.setter
    def mapped_param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_name", value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request parameter name.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the backend policy.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sysName")
    def sys_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gateway built-in parameter name.
        """
        return pulumi.get(self, "sys_name")

    @sys_name.setter
    def sys_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sys_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The condition type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApiGatewayApiRequestParamArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the request parameter.
        """
        default: NotRequired[pulumi.Input[builtins.str]]
        """
        The default value of the parameter.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The parameter description.
        """
        enumeration: NotRequired[pulumi.Input[builtins.str]]
        """
        The enumerated value.
        """
        example: NotRequired[pulumi.Input[builtins.str]]
        """
        The parameter example.
        """
        location: NotRequired[pulumi.Input[builtins.str]]
        """
        Where this parameter is located.
        """
        maximum: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum value or length (string parameter) for parameter.
        """
        minimum: NotRequired[pulumi.Input[builtins.int]]
        """
        The minimum value or length (string parameter) for parameter.
        """
        orchestrations: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of orchestration rules that parameter used.
        """
        passthrough: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to transparently transfer the parameter.
        """
        required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether this parameter is required.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The parameter type.
        """
        valid_enable: NotRequired[pulumi.Input[builtins.int]]
        """
        Whether to enable the parameter validation.
        """
elif False:
    ApiGatewayApiRequestParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiRequestParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 default: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 enumeration: Optional[pulumi.Input[builtins.str]] = None,
                 example: Optional[pulumi.Input[builtins.str]] = None,
                 location: Optional[pulumi.Input[builtins.str]] = None,
                 maximum: Optional[pulumi.Input[builtins.int]] = None,
                 minimum: Optional[pulumi.Input[builtins.int]] = None,
                 orchestrations: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 passthrough: Optional[pulumi.Input[builtins.bool]] = None,
                 required: Optional[pulumi.Input[builtins.bool]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 valid_enable: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the request parameter.
        :param pulumi.Input[builtins.str] default: The default value of the parameter.
        :param pulumi.Input[builtins.str] description: The parameter description.
        :param pulumi.Input[builtins.str] enumeration: The enumerated value.
        :param pulumi.Input[builtins.str] example: The parameter example.
        :param pulumi.Input[builtins.str] location: Where this parameter is located.
        :param pulumi.Input[builtins.int] maximum: The maximum value or length (string parameter) for parameter.
        :param pulumi.Input[builtins.int] minimum: The minimum value or length (string parameter) for parameter.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] orchestrations: The list of orchestration rules that parameter used.
        :param pulumi.Input[builtins.bool] passthrough: Whether to transparently transfer the parameter.
        :param pulumi.Input[builtins.bool] required: Whether this parameter is required.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.int] valid_enable: Whether to enable the parameter validation.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enumeration is not None:
            pulumi.set(__self__, "enumeration", enumeration)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if orchestrations is not None:
            pulumi.set(__self__, "orchestrations", orchestrations)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if valid_enable is not None:
            pulumi.set(__self__, "valid_enable", valid_enable)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the request parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default value of the parameter.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The parameter description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enumeration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The enumerated value.
        """
        return pulumi.get(self, "enumeration")

    @enumeration.setter
    def enumeration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enumeration", value)

    @property
    @pulumi.getter
    def example(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The parameter example.
        """
        return pulumi.get(self, "example")

    @example.setter
    def example(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "example", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Where this parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum value or length (string parameter) for parameter.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minimum value or length (string parameter) for parameter.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def orchestrations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of orchestration rules that parameter used.
        """
        return pulumi.get(self, "orchestrations")

    @orchestrations.setter
    def orchestrations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "orchestrations", value)

    @property
    @pulumi.getter
    def passthrough(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to transparently transfer the parameter.
        """
        return pulumi.get(self, "passthrough")

    @passthrough.setter
    def passthrough(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "passthrough", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether this parameter is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="validEnable")
    def valid_enable(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Whether to enable the parameter validation.
        """
        return pulumi.get(self, "valid_enable")

    @valid_enable.setter
    def valid_enable(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "valid_enable", value)


if not MYPY:
    class ApiGatewayApiWebArgsDict(TypedDict):
        path: pulumi.Input[builtins.str]
        """
        The backend request path.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        backend_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The backend service address, which consists of a domain name or IP address, and a port number.
        """
        host_header: NotRequired[pulumi.Input[builtins.str]]
        """
        The proxy host header.
        """
        request_method: NotRequired[pulumi.Input[builtins.str]]
        """
        The backend request method of the API.
        """
        request_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The web protocol type of the API request.
        """
        retry_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of retry attempts to request the backend service.
        """
        ssl_enable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable two-way authentication.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The timeout for API requests to backend service.
        """
        vpc_channel_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The VPC channel ID.
        """
elif False:
    ApiGatewayApiWebArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiWebArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 backend_address: Optional[pulumi.Input[builtins.str]] = None,
                 host_header: Optional[pulumi.Input[builtins.str]] = None,
                 request_method: Optional[pulumi.Input[builtins.str]] = None,
                 request_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 retry_count: Optional[pulumi.Input[builtins.int]] = None,
                 ssl_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 vpc_channel_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] path: The backend request path.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[builtins.str] backend_address: The backend service address, which consists of a domain name or IP address, and a port number.
        :param pulumi.Input[builtins.str] host_header: The proxy host header.
        :param pulumi.Input[builtins.str] request_method: The backend request method of the API.
        :param pulumi.Input[builtins.str] request_protocol: The web protocol type of the API request.
        :param pulumi.Input[builtins.int] retry_count: The number of retry attempts to request the backend service.
        :param pulumi.Input[builtins.bool] ssl_enable: Whether to enable two-way authentication.
        :param pulumi.Input[builtins.int] timeout: The timeout for API requests to backend service.
        :param pulumi.Input[builtins.str] vpc_channel_id: The VPC channel ID.
        """
        pulumi.set(__self__, "path", path)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if backend_address is not None:
            pulumi.set(__self__, "backend_address", backend_address)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if request_protocol is not None:
            pulumi.set(__self__, "request_protocol", request_protocol)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if ssl_enable is not None:
            pulumi.set(__self__, "ssl_enable", ssl_enable)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if vpc_channel_id is not None:
            pulumi.set(__self__, "vpc_channel_id", vpc_channel_id)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        The backend request path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="backendAddress")
    def backend_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backend service address, which consists of a domain name or IP address, and a port number.
        """
        return pulumi.get(self, "backend_address")

    @backend_address.setter
    def backend_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backend_address", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The proxy host header.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backend request method of the API.
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="requestProtocol")
    def request_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The web protocol type of the API request.
        """
        return pulumi.get(self, "request_protocol")

    @request_protocol.setter
    def request_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_protocol", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of retry attempts to request the backend service.
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retry_count", value)

    @property
    @pulumi.getter(name="sslEnable")
    def ssl_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable two-way authentication.
        """
        return pulumi.get(self, "ssl_enable")

    @ssl_enable.setter
    def ssl_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssl_enable", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The timeout for API requests to backend service.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="vpcChannelId")
    def vpc_channel_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The VPC channel ID.
        """
        return pulumi.get(self, "vpc_channel_id")

    @vpc_channel_id.setter
    def vpc_channel_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpc_channel_id", value)


if not MYPY:
    class ApiGatewayApiWebPolicyArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyConditionArgsDict']]]
        """
        The policy conditions.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the web policy.
        """
        path: pulumi.Input[builtins.str]
        """
        The backend request address.
        """
        request_method: pulumi.Input[builtins.str]
        """
        The backend request method of the API.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        backend_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The backend service address
        """
        backend_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyBackendParamArgsDict']]]]
        """
        The configuration list of the backend parameters.
        """
        effective_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The effective mode of the backend policy.
        """
        host_header: NotRequired[pulumi.Input[builtins.str]]
        """
        The proxy host header.
        """
        request_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The backend request protocol.
        """
        retry_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of retry attempts to request the backend service.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The timeout for API requests to backend service.
        """
        vpc_channel_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The VPC channel ID.
        """
elif False:
    ApiGatewayApiWebPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiWebPolicyArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyConditionArgs']]],
                 name: pulumi.Input[builtins.str],
                 path: pulumi.Input[builtins.str],
                 request_method: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 backend_address: Optional[pulumi.Input[builtins.str]] = None,
                 backend_params: Optional[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyBackendParamArgs']]]] = None,
                 effective_mode: Optional[pulumi.Input[builtins.str]] = None,
                 host_header: Optional[pulumi.Input[builtins.str]] = None,
                 request_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 retry_count: Optional[pulumi.Input[builtins.int]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 vpc_channel_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyConditionArgs']]] conditions: The policy conditions.
        :param pulumi.Input[builtins.str] name: The name of the web policy.
        :param pulumi.Input[builtins.str] path: The backend request address.
        :param pulumi.Input[builtins.str] request_method: The backend request method of the API.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[builtins.str] backend_address: The backend service address
        :param pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyBackendParamArgs']]] backend_params: The configuration list of the backend parameters.
        :param pulumi.Input[builtins.str] effective_mode: The effective mode of the backend policy.
        :param pulumi.Input[builtins.str] host_header: The proxy host header.
        :param pulumi.Input[builtins.str] request_protocol: The backend request protocol.
        :param pulumi.Input[builtins.int] retry_count: The number of retry attempts to request the backend service.
        :param pulumi.Input[builtins.int] timeout: The timeout for API requests to backend service.
        :param pulumi.Input[builtins.str] vpc_channel_id: The VPC channel ID.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "request_method", request_method)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if backend_address is not None:
            pulumi.set(__self__, "backend_address", backend_address)
        if backend_params is not None:
            pulumi.set(__self__, "backend_params", backend_params)
        if effective_mode is not None:
            pulumi.set(__self__, "effective_mode", effective_mode)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if request_protocol is not None:
            pulumi.set(__self__, "request_protocol", request_protocol)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if vpc_channel_id is not None:
            pulumi.set(__self__, "vpc_channel_id", vpc_channel_id)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyConditionArgs']]]:
        """
        The policy conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the web policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        The backend request address.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> pulumi.Input[builtins.str]:
        """
        The backend request method of the API.
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="backendAddress")
    def backend_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backend service address
        """
        return pulumi.get(self, "backend_address")

    @backend_address.setter
    def backend_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backend_address", value)

    @property
    @pulumi.getter(name="backendParams")
    def backend_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyBackendParamArgs']]]]:
        """
        The configuration list of the backend parameters.
        """
        return pulumi.get(self, "backend_params")

    @backend_params.setter
    def backend_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiGatewayApiWebPolicyBackendParamArgs']]]]):
        pulumi.set(self, "backend_params", value)

    @property
    @pulumi.getter(name="effectiveMode")
    def effective_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The effective mode of the backend policy.
        """
        return pulumi.get(self, "effective_mode")

    @effective_mode.setter
    def effective_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effective_mode", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The proxy host header.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="requestProtocol")
    def request_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backend request protocol.
        """
        return pulumi.get(self, "request_protocol")

    @request_protocol.setter
    def request_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_protocol", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of retry attempts to request the backend service.
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retry_count", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The timeout for API requests to backend service.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="vpcChannelId")
    def vpc_channel_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The VPC channel ID.
        """
        return pulumi.get(self, "vpc_channel_id")

    @vpc_channel_id.setter
    def vpc_channel_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpc_channel_id", value)


if not MYPY:
    class ApiGatewayApiWebPolicyBackendParamArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        Where the parameter is located.
        """
        name: pulumi.Input[builtins.str]
        """
        The parameter name.
        """
        type: pulumi.Input[builtins.str]
        """
        The parameter type.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the parameter
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the parameter.
        """
        system_param_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApiGatewayApiWebPolicyBackendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiWebPolicyBackendParamArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 system_param_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: Where the parameter is located.
        :param pulumi.Input[builtins.str] name: The parameter name.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.str] value: The value of the parameter
        :param pulumi.Input[builtins.str] description: The description of the parameter.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if system_param_type is not None:
            pulumi.set(__self__, "system_param_type", system_param_type)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        Where the parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="systemParamType")
    def system_param_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "system_param_type")

    @system_param_type.setter
    def system_param_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_param_type", value)


if not MYPY:
    class ApiGatewayApiWebPolicyConditionArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        The value of the backend policy.
        """
        cookie_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The cookie parameter name.
        """
        frontend_authorizer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The frontend authentication parameter name.
        """
        mapped_param_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The location of a parameter generated after orchestration.
        """
        mapped_param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of a parameter generated after orchestration.
        """
        param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The request parameter name.
        """
        source: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the backend policy.
        """
        sys_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The gateway built-in parameter name.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The condition type.
        """
elif False:
    ApiGatewayApiWebPolicyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayApiWebPolicyConditionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 cookie_name: Optional[pulumi.Input[builtins.str]] = None,
                 frontend_authorizer_name: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_location: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_name: Optional[pulumi.Input[builtins.str]] = None,
                 param_name: Optional[pulumi.Input[builtins.str]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 sys_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] value: The value of the backend policy.
        :param pulumi.Input[builtins.str] cookie_name: The cookie parameter name.
        :param pulumi.Input[builtins.str] frontend_authorizer_name: The frontend authentication parameter name.
        :param pulumi.Input[builtins.str] mapped_param_location: The location of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] mapped_param_name: The name of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] param_name: The request parameter name.
        :param pulumi.Input[builtins.str] source: The type of the backend policy.
        :param pulumi.Input[builtins.str] sys_name: The gateway built-in parameter name.
        :param pulumi.Input[builtins.str] type: The condition type.
        """
        pulumi.set(__self__, "value", value)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if frontend_authorizer_name is not None:
            pulumi.set(__self__, "frontend_authorizer_name", frontend_authorizer_name)
        if mapped_param_location is not None:
            pulumi.set(__self__, "mapped_param_location", mapped_param_location)
        if mapped_param_name is not None:
            pulumi.set(__self__, "mapped_param_name", mapped_param_name)
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if sys_name is not None:
            pulumi.set(__self__, "sys_name", sys_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the backend policy.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The cookie parameter name.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="frontendAuthorizerName")
    def frontend_authorizer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The frontend authentication parameter name.
        """
        return pulumi.get(self, "frontend_authorizer_name")

    @frontend_authorizer_name.setter
    def frontend_authorizer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "frontend_authorizer_name", value)

    @property
    @pulumi.getter(name="mappedParamLocation")
    def mapped_param_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The location of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_location")

    @mapped_param_location.setter
    def mapped_param_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_location", value)

    @property
    @pulumi.getter(name="mappedParamName")
    def mapped_param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_name")

    @mapped_param_name.setter
    def mapped_param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_name", value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request parameter name.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the backend policy.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sysName")
    def sys_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gateway built-in parameter name.
        """
        return pulumi.get(self, "sys_name")

    @sys_name.setter
    def sys_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sys_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The condition type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApiGatewayGroupEnvironmentArgsDict(TypedDict):
        environment_id: pulumi.Input[builtins.str]
        """
        The ID of the environment to which the variables belongs.
        """
        variables: pulumi.Input[Sequence[pulumi.Input['ApiGatewayGroupEnvironmentVariableArgsDict']]]
        """
        The array of one or more environment variables.
        """
elif False:
    ApiGatewayGroupEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayGroupEnvironmentArgs:
    def __init__(__self__, *,
                 environment_id: pulumi.Input[builtins.str],
                 variables: pulumi.Input[Sequence[pulumi.Input['ApiGatewayGroupEnvironmentVariableArgs']]]):
        """
        :param pulumi.Input[builtins.str] environment_id: The ID of the environment to which the variables belongs.
        :param pulumi.Input[Sequence[pulumi.Input['ApiGatewayGroupEnvironmentVariableArgs']]] variables: The array of one or more environment variables.
        """
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the environment to which the variables belongs.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "environment_id", value)

    @property
    @pulumi.getter
    def variables(self) -> pulumi.Input[Sequence[pulumi.Input['ApiGatewayGroupEnvironmentVariableArgs']]]:
        """
        The array of one or more environment variables.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: pulumi.Input[Sequence[pulumi.Input['ApiGatewayGroupEnvironmentVariableArgs']]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class ApiGatewayGroupEnvironmentVariableArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The variable name.
        """
        value: pulumi.Input[builtins.str]
        """
        The variable value.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the variable that the group has.
        """
        variable_id: NotRequired[pulumi.Input[builtins.str]]
        """
        schema: Deprecated; The ID of the variable that the group has.
        """
elif False:
    ApiGatewayGroupEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayGroupEnvironmentVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 variable_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: The variable name.
        :param pulumi.Input[builtins.str] value: The variable value.
        :param pulumi.Input[builtins.str] id: The ID of the variable that the group has.
        :param pulumi.Input[builtins.str] variable_id: schema: Deprecated; The ID of the variable that the group has.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if variable_id is not None:
            warnings.warn("""Use 'id' instead""", DeprecationWarning)
            pulumi.log.warn("""variable_id is deprecated: Use 'id' instead""")
        if variable_id is not None:
            pulumi.set(__self__, "variable_id", variable_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The variable name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the variable that the group has.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="variableId")
    @_utilities.deprecated("""Use 'id' instead""")
    def variable_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        schema: Deprecated; The ID of the variable that the group has.
        """
        return pulumi.get(self, "variable_id")

    @variable_id.setter
    def variable_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "variable_id", value)


if not MYPY:
    class ApiGatewayGroupUrlDomainArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        is_http_redirect_to_https: NotRequired[pulumi.Input[builtins.bool]]
        min_ssl_version: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApiGatewayGroupUrlDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiGatewayGroupUrlDomainArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 is_http_redirect_to_https: Optional[pulumi.Input[builtins.bool]] = None,
                 min_ssl_version: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if is_http_redirect_to_https is not None:
            pulumi.set(__self__, "is_http_redirect_to_https", is_http_redirect_to_https)
        if min_ssl_version is not None:
            pulumi.set(__self__, "min_ssl_version", min_ssl_version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isHttpRedirectToHttps")
    def is_http_redirect_to_https(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_http_redirect_to_https")

    @is_http_redirect_to_https.setter
    def is_http_redirect_to_https(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_http_redirect_to_https", value)

    @property
    @pulumi.getter(name="minSslVersion")
    def min_ssl_version(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "min_ssl_version")

    @min_ssl_version.setter
    def min_ssl_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_ssl_version", value)


if not MYPY:
    class ApigApiBackendParamArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        Where the parameter is located.
        """
        name: pulumi.Input[builtins.str]
        """
        The parameter name.
        """
        type: pulumi.Input[builtins.str]
        """
        The parameter type.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the parameter
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the parameter.
        """
        system_param_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApigApiBackendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiBackendParamArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 system_param_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: Where the parameter is located.
        :param pulumi.Input[builtins.str] name: The parameter name.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.str] value: The value of the parameter
        :param pulumi.Input[builtins.str] description: The description of the parameter.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if system_param_type is not None:
            pulumi.set(__self__, "system_param_type", system_param_type)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        Where the parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="systemParamType")
    def system_param_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "system_param_type")

    @system_param_type.setter
    def system_param_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_param_type", value)


if not MYPY:
    class ApigApiFuncGraphArgsDict(TypedDict):
        function_urn: pulumi.Input[builtins.str]
        """
        The URN of the FunctionGraph function.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        function_alias_urn: NotRequired[pulumi.Input[builtins.str]]
        """
        The alias URN of the FunctionGraph function.
        """
        invocation_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The invocation type.
        """
        network_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The network architecture (framework) type of the FunctionGraph function.
        """
        request_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The request protocol of the FunctionGraph function.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The timeout for API requests to backend service.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        The version of the FunctionGraph function.
        """
elif False:
    ApigApiFuncGraphArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiFuncGraphArgs:
    def __init__(__self__, *,
                 function_urn: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 function_alias_urn: Optional[pulumi.Input[builtins.str]] = None,
                 invocation_type: Optional[pulumi.Input[builtins.str]] = None,
                 network_type: Optional[pulumi.Input[builtins.str]] = None,
                 request_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] function_urn: The URN of the FunctionGraph function.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[builtins.str] function_alias_urn: The alias URN of the FunctionGraph function.
        :param pulumi.Input[builtins.str] invocation_type: The invocation type.
        :param pulumi.Input[builtins.str] network_type: The network architecture (framework) type of the FunctionGraph function.
        :param pulumi.Input[builtins.str] request_protocol: The request protocol of the FunctionGraph function.
        :param pulumi.Input[builtins.int] timeout: The timeout for API requests to backend service.
        :param pulumi.Input[builtins.str] version: The version of the FunctionGraph function.
        """
        pulumi.set(__self__, "function_urn", function_urn)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if function_alias_urn is not None:
            pulumi.set(__self__, "function_alias_urn", function_alias_urn)
        if invocation_type is not None:
            pulumi.set(__self__, "invocation_type", invocation_type)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if request_protocol is not None:
            pulumi.set(__self__, "request_protocol", request_protocol)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="functionUrn")
    def function_urn(self) -> pulumi.Input[builtins.str]:
        """
        The URN of the FunctionGraph function.
        """
        return pulumi.get(self, "function_urn")

    @function_urn.setter
    def function_urn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "function_urn", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="functionAliasUrn")
    def function_alias_urn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The alias URN of the FunctionGraph function.
        """
        return pulumi.get(self, "function_alias_urn")

    @function_alias_urn.setter
    def function_alias_urn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "function_alias_urn", value)

    @property
    @pulumi.getter(name="invocationType")
    def invocation_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The invocation type.
        """
        return pulumi.get(self, "invocation_type")

    @invocation_type.setter
    def invocation_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "invocation_type", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The network architecture (framework) type of the FunctionGraph function.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="requestProtocol")
    def request_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request protocol of the FunctionGraph function.
        """
        return pulumi.get(self, "request_protocol")

    @request_protocol.setter
    def request_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_protocol", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The timeout for API requests to backend service.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version of the FunctionGraph function.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ApigApiFuncGraphPolicyArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyConditionArgsDict']]]
        """
        The policy conditions.
        """
        function_urn: pulumi.Input[builtins.str]
        """
        The URN of the FunctionGraph function.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the backend policy.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        backend_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyBackendParamArgsDict']]]]
        """
        The configaiton list of the backend parameters.
        """
        effective_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The effective mode of the backend policy.
        """
        function_alias_urn: NotRequired[pulumi.Input[builtins.str]]
        """
        The alias URN of the FunctionGraph function.
        """
        invocation_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The invocation mode of the FunctionGraph function.
        """
        invocation_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The invocation mode of the FunctionGraph function.
        """
        network_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The network (framework) type of the FunctionGraph function.
        """
        request_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The request protocol of the FunctionGraph function.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The timeout for API requests to backend service.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        The version of the FunctionGraph function.
        """
elif False:
    ApigApiFuncGraphPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiFuncGraphPolicyArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyConditionArgs']]],
                 function_urn: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 backend_params: Optional[pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyBackendParamArgs']]]] = None,
                 effective_mode: Optional[pulumi.Input[builtins.str]] = None,
                 function_alias_urn: Optional[pulumi.Input[builtins.str]] = None,
                 invocation_mode: Optional[pulumi.Input[builtins.str]] = None,
                 invocation_type: Optional[pulumi.Input[builtins.str]] = None,
                 network_type: Optional[pulumi.Input[builtins.str]] = None,
                 request_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyConditionArgs']]] conditions: The policy conditions.
        :param pulumi.Input[builtins.str] function_urn: The URN of the FunctionGraph function.
        :param pulumi.Input[builtins.str] name: The name of the backend policy.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyBackendParamArgs']]] backend_params: The configaiton list of the backend parameters.
        :param pulumi.Input[builtins.str] effective_mode: The effective mode of the backend policy.
        :param pulumi.Input[builtins.str] function_alias_urn: The alias URN of the FunctionGraph function.
        :param pulumi.Input[builtins.str] invocation_mode: The invocation mode of the FunctionGraph function.
        :param pulumi.Input[builtins.str] invocation_type: The invocation mode of the FunctionGraph function.
        :param pulumi.Input[builtins.str] network_type: The network (framework) type of the FunctionGraph function.
        :param pulumi.Input[builtins.str] request_protocol: The request protocol of the FunctionGraph function.
        :param pulumi.Input[builtins.int] timeout: The timeout for API requests to backend service.
        :param pulumi.Input[builtins.str] version: The version of the FunctionGraph function.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "function_urn", function_urn)
        pulumi.set(__self__, "name", name)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if backend_params is not None:
            pulumi.set(__self__, "backend_params", backend_params)
        if effective_mode is not None:
            pulumi.set(__self__, "effective_mode", effective_mode)
        if function_alias_urn is not None:
            pulumi.set(__self__, "function_alias_urn", function_alias_urn)
        if invocation_mode is not None:
            pulumi.set(__self__, "invocation_mode", invocation_mode)
        if invocation_type is not None:
            pulumi.set(__self__, "invocation_type", invocation_type)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if request_protocol is not None:
            pulumi.set(__self__, "request_protocol", request_protocol)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyConditionArgs']]]:
        """
        The policy conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="functionUrn")
    def function_urn(self) -> pulumi.Input[builtins.str]:
        """
        The URN of the FunctionGraph function.
        """
        return pulumi.get(self, "function_urn")

    @function_urn.setter
    def function_urn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "function_urn", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the backend policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="backendParams")
    def backend_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyBackendParamArgs']]]]:
        """
        The configaiton list of the backend parameters.
        """
        return pulumi.get(self, "backend_params")

    @backend_params.setter
    def backend_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigApiFuncGraphPolicyBackendParamArgs']]]]):
        pulumi.set(self, "backend_params", value)

    @property
    @pulumi.getter(name="effectiveMode")
    def effective_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The effective mode of the backend policy.
        """
        return pulumi.get(self, "effective_mode")

    @effective_mode.setter
    def effective_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effective_mode", value)

    @property
    @pulumi.getter(name="functionAliasUrn")
    def function_alias_urn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The alias URN of the FunctionGraph function.
        """
        return pulumi.get(self, "function_alias_urn")

    @function_alias_urn.setter
    def function_alias_urn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "function_alias_urn", value)

    @property
    @pulumi.getter(name="invocationMode")
    def invocation_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The invocation mode of the FunctionGraph function.
        """
        return pulumi.get(self, "invocation_mode")

    @invocation_mode.setter
    def invocation_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "invocation_mode", value)

    @property
    @pulumi.getter(name="invocationType")
    def invocation_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The invocation mode of the FunctionGraph function.
        """
        return pulumi.get(self, "invocation_type")

    @invocation_type.setter
    def invocation_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "invocation_type", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The network (framework) type of the FunctionGraph function.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="requestProtocol")
    def request_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request protocol of the FunctionGraph function.
        """
        return pulumi.get(self, "request_protocol")

    @request_protocol.setter
    def request_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_protocol", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The timeout for API requests to backend service.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version of the FunctionGraph function.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ApigApiFuncGraphPolicyBackendParamArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        Where the parameter is located.
        """
        name: pulumi.Input[builtins.str]
        """
        The parameter name.
        """
        type: pulumi.Input[builtins.str]
        """
        The parameter type.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the parameter
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the parameter.
        """
        system_param_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApigApiFuncGraphPolicyBackendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiFuncGraphPolicyBackendParamArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 system_param_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: Where the parameter is located.
        :param pulumi.Input[builtins.str] name: The parameter name.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.str] value: The value of the parameter
        :param pulumi.Input[builtins.str] description: The description of the parameter.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if system_param_type is not None:
            pulumi.set(__self__, "system_param_type", system_param_type)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        Where the parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="systemParamType")
    def system_param_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "system_param_type")

    @system_param_type.setter
    def system_param_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_param_type", value)


if not MYPY:
    class ApigApiFuncGraphPolicyConditionArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        The value of the backend policy.
        """
        cookie_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The cookie parameter name.
        """
        frontend_authorizer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The frontend authentication parameter name.
        """
        mapped_param_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The location of a parameter generated after orchestration.
        """
        mapped_param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of a parameter generated after orchestration.
        """
        param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The request parameter name.
        """
        source: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the backend policy.
        """
        sys_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The gateway built-in parameter name.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The condition type.
        """
elif False:
    ApigApiFuncGraphPolicyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiFuncGraphPolicyConditionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 cookie_name: Optional[pulumi.Input[builtins.str]] = None,
                 frontend_authorizer_name: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_location: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_name: Optional[pulumi.Input[builtins.str]] = None,
                 param_name: Optional[pulumi.Input[builtins.str]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 sys_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] value: The value of the backend policy.
        :param pulumi.Input[builtins.str] cookie_name: The cookie parameter name.
        :param pulumi.Input[builtins.str] frontend_authorizer_name: The frontend authentication parameter name.
        :param pulumi.Input[builtins.str] mapped_param_location: The location of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] mapped_param_name: The name of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] param_name: The request parameter name.
        :param pulumi.Input[builtins.str] source: The type of the backend policy.
        :param pulumi.Input[builtins.str] sys_name: The gateway built-in parameter name.
        :param pulumi.Input[builtins.str] type: The condition type.
        """
        pulumi.set(__self__, "value", value)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if frontend_authorizer_name is not None:
            pulumi.set(__self__, "frontend_authorizer_name", frontend_authorizer_name)
        if mapped_param_location is not None:
            pulumi.set(__self__, "mapped_param_location", mapped_param_location)
        if mapped_param_name is not None:
            pulumi.set(__self__, "mapped_param_name", mapped_param_name)
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if sys_name is not None:
            pulumi.set(__self__, "sys_name", sys_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the backend policy.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The cookie parameter name.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="frontendAuthorizerName")
    def frontend_authorizer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The frontend authentication parameter name.
        """
        return pulumi.get(self, "frontend_authorizer_name")

    @frontend_authorizer_name.setter
    def frontend_authorizer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "frontend_authorizer_name", value)

    @property
    @pulumi.getter(name="mappedParamLocation")
    def mapped_param_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The location of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_location")

    @mapped_param_location.setter
    def mapped_param_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_location", value)

    @property
    @pulumi.getter(name="mappedParamName")
    def mapped_param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_name")

    @mapped_param_name.setter
    def mapped_param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_name", value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request parameter name.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the backend policy.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sysName")
    def sys_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gateway built-in parameter name.
        """
        return pulumi.get(self, "sys_name")

    @sys_name.setter
    def sys_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sys_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The condition type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApigApiMockArgsDict(TypedDict):
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        response: NotRequired[pulumi.Input[builtins.str]]
        """
        The response content of the mock.
        """
        status_code: NotRequired[pulumi.Input[builtins.int]]
        """
        The custom status code of the mock response.
        """
elif False:
    ApigApiMockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiMockArgs:
    def __init__(__self__, *,
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 response: Optional[pulumi.Input[builtins.str]] = None,
                 status_code: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[builtins.str] response: The response content of the mock.
        :param pulumi.Input[builtins.int] status_code: The custom status code of the mock response.
        """
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The response content of the mock.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The custom status code of the mock response.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class ApigApiMockPolicyArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyConditionArgsDict']]]
        """
        The policy conditions.
        """
        name: pulumi.Input[builtins.str]
        """
        The backend policy name.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        backend_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyBackendParamArgsDict']]]]
        """
        The configuration list of backend parameters.
        """
        effective_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The effective mode of the backend policy.
        """
        response: NotRequired[pulumi.Input[builtins.str]]
        """
        The response content of the mock.
        """
        status_code: NotRequired[pulumi.Input[builtins.int]]
        """
        The custom status code of the mock response.
        """
elif False:
    ApigApiMockPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiMockPolicyArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyConditionArgs']]],
                 name: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 backend_params: Optional[pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyBackendParamArgs']]]] = None,
                 effective_mode: Optional[pulumi.Input[builtins.str]] = None,
                 response: Optional[pulumi.Input[builtins.str]] = None,
                 status_code: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyConditionArgs']]] conditions: The policy conditions.
        :param pulumi.Input[builtins.str] name: The backend policy name.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyBackendParamArgs']]] backend_params: The configuration list of backend parameters.
        :param pulumi.Input[builtins.str] effective_mode: The effective mode of the backend policy.
        :param pulumi.Input[builtins.str] response: The response content of the mock.
        :param pulumi.Input[builtins.int] status_code: The custom status code of the mock response.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if backend_params is not None:
            pulumi.set(__self__, "backend_params", backend_params)
        if effective_mode is not None:
            pulumi.set(__self__, "effective_mode", effective_mode)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyConditionArgs']]]:
        """
        The policy conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The backend policy name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="backendParams")
    def backend_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyBackendParamArgs']]]]:
        """
        The configuration list of backend parameters.
        """
        return pulumi.get(self, "backend_params")

    @backend_params.setter
    def backend_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigApiMockPolicyBackendParamArgs']]]]):
        pulumi.set(self, "backend_params", value)

    @property
    @pulumi.getter(name="effectiveMode")
    def effective_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The effective mode of the backend policy.
        """
        return pulumi.get(self, "effective_mode")

    @effective_mode.setter
    def effective_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effective_mode", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The response content of the mock.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "response", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The custom status code of the mock response.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class ApigApiMockPolicyBackendParamArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        Where the parameter is located.
        """
        name: pulumi.Input[builtins.str]
        """
        The parameter name.
        """
        type: pulumi.Input[builtins.str]
        """
        The parameter type.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the parameter
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the parameter.
        """
        system_param_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApigApiMockPolicyBackendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiMockPolicyBackendParamArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 system_param_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: Where the parameter is located.
        :param pulumi.Input[builtins.str] name: The parameter name.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.str] value: The value of the parameter
        :param pulumi.Input[builtins.str] description: The description of the parameter.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if system_param_type is not None:
            pulumi.set(__self__, "system_param_type", system_param_type)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        Where the parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="systemParamType")
    def system_param_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "system_param_type")

    @system_param_type.setter
    def system_param_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_param_type", value)


if not MYPY:
    class ApigApiMockPolicyConditionArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        The value of the backend policy.
        """
        cookie_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The cookie parameter name.
        """
        frontend_authorizer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The frontend authentication parameter name.
        """
        mapped_param_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The location of a parameter generated after orchestration.
        """
        mapped_param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of a parameter generated after orchestration.
        """
        param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The request parameter name.
        """
        source: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the backend policy.
        """
        sys_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The gateway built-in parameter name.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The condition type.
        """
elif False:
    ApigApiMockPolicyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiMockPolicyConditionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 cookie_name: Optional[pulumi.Input[builtins.str]] = None,
                 frontend_authorizer_name: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_location: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_name: Optional[pulumi.Input[builtins.str]] = None,
                 param_name: Optional[pulumi.Input[builtins.str]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 sys_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] value: The value of the backend policy.
        :param pulumi.Input[builtins.str] cookie_name: The cookie parameter name.
        :param pulumi.Input[builtins.str] frontend_authorizer_name: The frontend authentication parameter name.
        :param pulumi.Input[builtins.str] mapped_param_location: The location of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] mapped_param_name: The name of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] param_name: The request parameter name.
        :param pulumi.Input[builtins.str] source: The type of the backend policy.
        :param pulumi.Input[builtins.str] sys_name: The gateway built-in parameter name.
        :param pulumi.Input[builtins.str] type: The condition type.
        """
        pulumi.set(__self__, "value", value)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if frontend_authorizer_name is not None:
            pulumi.set(__self__, "frontend_authorizer_name", frontend_authorizer_name)
        if mapped_param_location is not None:
            pulumi.set(__self__, "mapped_param_location", mapped_param_location)
        if mapped_param_name is not None:
            pulumi.set(__self__, "mapped_param_name", mapped_param_name)
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if sys_name is not None:
            pulumi.set(__self__, "sys_name", sys_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the backend policy.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The cookie parameter name.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="frontendAuthorizerName")
    def frontend_authorizer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The frontend authentication parameter name.
        """
        return pulumi.get(self, "frontend_authorizer_name")

    @frontend_authorizer_name.setter
    def frontend_authorizer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "frontend_authorizer_name", value)

    @property
    @pulumi.getter(name="mappedParamLocation")
    def mapped_param_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The location of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_location")

    @mapped_param_location.setter
    def mapped_param_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_location", value)

    @property
    @pulumi.getter(name="mappedParamName")
    def mapped_param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_name")

    @mapped_param_name.setter
    def mapped_param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_name", value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request parameter name.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the backend policy.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sysName")
    def sys_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gateway built-in parameter name.
        """
        return pulumi.get(self, "sys_name")

    @sys_name.setter
    def sys_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sys_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The condition type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApigApiPublishmentHistoryArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The version description of the API publishment.
        """
        version_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The version ID of the API publishment.
        """
elif False:
    ApigApiPublishmentHistoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiPublishmentHistoryArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 version_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] description: The version description of the API publishment.
        :param pulumi.Input[builtins.str] version_id: The version ID of the API publishment.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version description of the API publishment.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The version ID of the API publishment.
        """
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class ApigApiRequestParamArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the request parameter.
        """
        default: NotRequired[pulumi.Input[builtins.str]]
        """
        The default value of the parameter.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The parameter description.
        """
        enumeration: NotRequired[pulumi.Input[builtins.str]]
        """
        The enumerated value.
        """
        example: NotRequired[pulumi.Input[builtins.str]]
        """
        The parameter example.
        """
        location: NotRequired[pulumi.Input[builtins.str]]
        """
        Where this parameter is located.
        """
        maximum: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum value or length (string parameter) for parameter.
        """
        minimum: NotRequired[pulumi.Input[builtins.int]]
        """
        The minimum value or length (string parameter) for parameter.
        """
        orchestrations: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of orchestration rules that parameter used.
        """
        passthrough: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to transparently transfer the parameter.
        """
        required: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether this parameter is required.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The parameter type.
        """
        valid_enable: NotRequired[pulumi.Input[builtins.int]]
        """
        Whether to enable the parameter validation.
        """
elif False:
    ApigApiRequestParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiRequestParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 default: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 enumeration: Optional[pulumi.Input[builtins.str]] = None,
                 example: Optional[pulumi.Input[builtins.str]] = None,
                 location: Optional[pulumi.Input[builtins.str]] = None,
                 maximum: Optional[pulumi.Input[builtins.int]] = None,
                 minimum: Optional[pulumi.Input[builtins.int]] = None,
                 orchestrations: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 passthrough: Optional[pulumi.Input[builtins.bool]] = None,
                 required: Optional[pulumi.Input[builtins.bool]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 valid_enable: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the request parameter.
        :param pulumi.Input[builtins.str] default: The default value of the parameter.
        :param pulumi.Input[builtins.str] description: The parameter description.
        :param pulumi.Input[builtins.str] enumeration: The enumerated value.
        :param pulumi.Input[builtins.str] example: The parameter example.
        :param pulumi.Input[builtins.str] location: Where this parameter is located.
        :param pulumi.Input[builtins.int] maximum: The maximum value or length (string parameter) for parameter.
        :param pulumi.Input[builtins.int] minimum: The minimum value or length (string parameter) for parameter.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] orchestrations: The list of orchestration rules that parameter used.
        :param pulumi.Input[builtins.bool] passthrough: Whether to transparently transfer the parameter.
        :param pulumi.Input[builtins.bool] required: Whether this parameter is required.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.int] valid_enable: Whether to enable the parameter validation.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enumeration is not None:
            pulumi.set(__self__, "enumeration", enumeration)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if orchestrations is not None:
            pulumi.set(__self__, "orchestrations", orchestrations)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if valid_enable is not None:
            pulumi.set(__self__, "valid_enable", valid_enable)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the request parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The default value of the parameter.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The parameter description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def enumeration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The enumerated value.
        """
        return pulumi.get(self, "enumeration")

    @enumeration.setter
    def enumeration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enumeration", value)

    @property
    @pulumi.getter
    def example(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The parameter example.
        """
        return pulumi.get(self, "example")

    @example.setter
    def example(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "example", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Where this parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum value or length (string parameter) for parameter.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "maximum", value)

    @property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The minimum value or length (string parameter) for parameter.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minimum", value)

    @property
    @pulumi.getter
    def orchestrations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of orchestration rules that parameter used.
        """
        return pulumi.get(self, "orchestrations")

    @orchestrations.setter
    def orchestrations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "orchestrations", value)

    @property
    @pulumi.getter
    def passthrough(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to transparently transfer the parameter.
        """
        return pulumi.get(self, "passthrough")

    @passthrough.setter
    def passthrough(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "passthrough", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether this parameter is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="validEnable")
    def valid_enable(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Whether to enable the parameter validation.
        """
        return pulumi.get(self, "valid_enable")

    @valid_enable.setter
    def valid_enable(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "valid_enable", value)


if not MYPY:
    class ApigApiWebArgsDict(TypedDict):
        path: pulumi.Input[builtins.str]
        """
        The backend request path.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        backend_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The backend service address, which consists of a domain name or IP address, and a port number.
        """
        host_header: NotRequired[pulumi.Input[builtins.str]]
        """
        The proxy host header.
        """
        request_method: NotRequired[pulumi.Input[builtins.str]]
        """
        The backend request method of the API.
        """
        request_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The web protocol type of the API request.
        """
        retry_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of retry attempts to request the backend service.
        """
        ssl_enable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable two-way authentication.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The timeout for API requests to backend service.
        """
        vpc_channel_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The VPC channel ID.
        """
elif False:
    ApigApiWebArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiWebArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 backend_address: Optional[pulumi.Input[builtins.str]] = None,
                 host_header: Optional[pulumi.Input[builtins.str]] = None,
                 request_method: Optional[pulumi.Input[builtins.str]] = None,
                 request_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 retry_count: Optional[pulumi.Input[builtins.int]] = None,
                 ssl_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 vpc_channel_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] path: The backend request path.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[builtins.str] backend_address: The backend service address, which consists of a domain name or IP address, and a port number.
        :param pulumi.Input[builtins.str] host_header: The proxy host header.
        :param pulumi.Input[builtins.str] request_method: The backend request method of the API.
        :param pulumi.Input[builtins.str] request_protocol: The web protocol type of the API request.
        :param pulumi.Input[builtins.int] retry_count: The number of retry attempts to request the backend service.
        :param pulumi.Input[builtins.bool] ssl_enable: Whether to enable two-way authentication.
        :param pulumi.Input[builtins.int] timeout: The timeout for API requests to backend service.
        :param pulumi.Input[builtins.str] vpc_channel_id: The VPC channel ID.
        """
        pulumi.set(__self__, "path", path)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if backend_address is not None:
            pulumi.set(__self__, "backend_address", backend_address)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if request_protocol is not None:
            pulumi.set(__self__, "request_protocol", request_protocol)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if ssl_enable is not None:
            pulumi.set(__self__, "ssl_enable", ssl_enable)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if vpc_channel_id is not None:
            pulumi.set(__self__, "vpc_channel_id", vpc_channel_id)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        The backend request path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="backendAddress")
    def backend_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backend service address, which consists of a domain name or IP address, and a port number.
        """
        return pulumi.get(self, "backend_address")

    @backend_address.setter
    def backend_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backend_address", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The proxy host header.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backend request method of the API.
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="requestProtocol")
    def request_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The web protocol type of the API request.
        """
        return pulumi.get(self, "request_protocol")

    @request_protocol.setter
    def request_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_protocol", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of retry attempts to request the backend service.
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retry_count", value)

    @property
    @pulumi.getter(name="sslEnable")
    def ssl_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable two-way authentication.
        """
        return pulumi.get(self, "ssl_enable")

    @ssl_enable.setter
    def ssl_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssl_enable", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The timeout for API requests to backend service.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="vpcChannelId")
    def vpc_channel_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The VPC channel ID.
        """
        return pulumi.get(self, "vpc_channel_id")

    @vpc_channel_id.setter
    def vpc_channel_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpc_channel_id", value)


if not MYPY:
    class ApigApiWebPolicyArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyConditionArgsDict']]]
        """
        The policy conditions.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the web policy.
        """
        path: pulumi.Input[builtins.str]
        """
        The backend request address.
        """
        request_method: pulumi.Input[builtins.str]
        """
        The backend request method of the API.
        """
        authorizer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend custom authorization.
        """
        backend_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The backend service address
        """
        backend_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyBackendParamArgsDict']]]]
        """
        The configuration list of the backend parameters.
        """
        effective_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The effective mode of the backend policy.
        """
        host_header: NotRequired[pulumi.Input[builtins.str]]
        """
        The proxy host header.
        """
        request_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The backend request protocol.
        """
        retry_count: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of retry attempts to request the backend service.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        The timeout for API requests to backend service.
        """
        vpc_channel_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The VPC channel ID.
        """
elif False:
    ApigApiWebPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiWebPolicyArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyConditionArgs']]],
                 name: pulumi.Input[builtins.str],
                 path: pulumi.Input[builtins.str],
                 request_method: pulumi.Input[builtins.str],
                 authorizer_id: Optional[pulumi.Input[builtins.str]] = None,
                 backend_address: Optional[pulumi.Input[builtins.str]] = None,
                 backend_params: Optional[pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyBackendParamArgs']]]] = None,
                 effective_mode: Optional[pulumi.Input[builtins.str]] = None,
                 host_header: Optional[pulumi.Input[builtins.str]] = None,
                 request_protocol: Optional[pulumi.Input[builtins.str]] = None,
                 retry_count: Optional[pulumi.Input[builtins.int]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None,
                 vpc_channel_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyConditionArgs']]] conditions: The policy conditions.
        :param pulumi.Input[builtins.str] name: The name of the web policy.
        :param pulumi.Input[builtins.str] path: The backend request address.
        :param pulumi.Input[builtins.str] request_method: The backend request method of the API.
        :param pulumi.Input[builtins.str] authorizer_id: The ID of the backend custom authorization.
        :param pulumi.Input[builtins.str] backend_address: The backend service address
        :param pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyBackendParamArgs']]] backend_params: The configuration list of the backend parameters.
        :param pulumi.Input[builtins.str] effective_mode: The effective mode of the backend policy.
        :param pulumi.Input[builtins.str] host_header: The proxy host header.
        :param pulumi.Input[builtins.str] request_protocol: The backend request protocol.
        :param pulumi.Input[builtins.int] retry_count: The number of retry attempts to request the backend service.
        :param pulumi.Input[builtins.int] timeout: The timeout for API requests to backend service.
        :param pulumi.Input[builtins.str] vpc_channel_id: The VPC channel ID.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "request_method", request_method)
        if authorizer_id is not None:
            pulumi.set(__self__, "authorizer_id", authorizer_id)
        if backend_address is not None:
            pulumi.set(__self__, "backend_address", backend_address)
        if backend_params is not None:
            pulumi.set(__self__, "backend_params", backend_params)
        if effective_mode is not None:
            pulumi.set(__self__, "effective_mode", effective_mode)
        if host_header is not None:
            pulumi.set(__self__, "host_header", host_header)
        if request_protocol is not None:
            pulumi.set(__self__, "request_protocol", request_protocol)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if vpc_channel_id is not None:
            pulumi.set(__self__, "vpc_channel_id", vpc_channel_id)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyConditionArgs']]]:
        """
        The policy conditions.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the web policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        The backend request address.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> pulumi.Input[builtins.str]:
        """
        The backend request method of the API.
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="authorizerId")
    def authorizer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend custom authorization.
        """
        return pulumi.get(self, "authorizer_id")

    @authorizer_id.setter
    def authorizer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorizer_id", value)

    @property
    @pulumi.getter(name="backendAddress")
    def backend_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backend service address
        """
        return pulumi.get(self, "backend_address")

    @backend_address.setter
    def backend_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backend_address", value)

    @property
    @pulumi.getter(name="backendParams")
    def backend_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyBackendParamArgs']]]]:
        """
        The configuration list of the backend parameters.
        """
        return pulumi.get(self, "backend_params")

    @backend_params.setter
    def backend_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigApiWebPolicyBackendParamArgs']]]]):
        pulumi.set(self, "backend_params", value)

    @property
    @pulumi.getter(name="effectiveMode")
    def effective_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The effective mode of the backend policy.
        """
        return pulumi.get(self, "effective_mode")

    @effective_mode.setter
    def effective_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "effective_mode", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The proxy host header.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="requestProtocol")
    def request_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backend request protocol.
        """
        return pulumi.get(self, "request_protocol")

    @request_protocol.setter
    def request_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "request_protocol", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of retry attempts to request the backend service.
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retry_count", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The timeout for API requests to backend service.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="vpcChannelId")
    def vpc_channel_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The VPC channel ID.
        """
        return pulumi.get(self, "vpc_channel_id")

    @vpc_channel_id.setter
    def vpc_channel_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpc_channel_id", value)


if not MYPY:
    class ApigApiWebPolicyBackendParamArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        Where the parameter is located.
        """
        name: pulumi.Input[builtins.str]
        """
        The parameter name.
        """
        type: pulumi.Input[builtins.str]
        """
        The parameter type.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the parameter
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the parameter.
        """
        system_param_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApigApiWebPolicyBackendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiWebPolicyBackendParamArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 system_param_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: Where the parameter is located.
        :param pulumi.Input[builtins.str] name: The parameter name.
        :param pulumi.Input[builtins.str] type: The parameter type.
        :param pulumi.Input[builtins.str] value: The value of the parameter
        :param pulumi.Input[builtins.str] description: The description of the parameter.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if system_param_type is not None:
            pulumi.set(__self__, "system_param_type", system_param_type)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        Where the parameter is located.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The parameter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="systemParamType")
    def system_param_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "system_param_type")

    @system_param_type.setter
    def system_param_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "system_param_type", value)


if not MYPY:
    class ApigApiWebPolicyConditionArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        The value of the backend policy.
        """
        cookie_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The cookie parameter name.
        """
        frontend_authorizer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The frontend authentication parameter name.
        """
        mapped_param_location: NotRequired[pulumi.Input[builtins.str]]
        """
        The location of a parameter generated after orchestration.
        """
        mapped_param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of a parameter generated after orchestration.
        """
        param_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The request parameter name.
        """
        source: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the backend policy.
        """
        sys_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The gateway built-in parameter name.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The condition type.
        """
elif False:
    ApigApiWebPolicyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApiWebPolicyConditionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 cookie_name: Optional[pulumi.Input[builtins.str]] = None,
                 frontend_authorizer_name: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_location: Optional[pulumi.Input[builtins.str]] = None,
                 mapped_param_name: Optional[pulumi.Input[builtins.str]] = None,
                 param_name: Optional[pulumi.Input[builtins.str]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 sys_name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] value: The value of the backend policy.
        :param pulumi.Input[builtins.str] cookie_name: The cookie parameter name.
        :param pulumi.Input[builtins.str] frontend_authorizer_name: The frontend authentication parameter name.
        :param pulumi.Input[builtins.str] mapped_param_location: The location of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] mapped_param_name: The name of a parameter generated after orchestration.
        :param pulumi.Input[builtins.str] param_name: The request parameter name.
        :param pulumi.Input[builtins.str] source: The type of the backend policy.
        :param pulumi.Input[builtins.str] sys_name: The gateway built-in parameter name.
        :param pulumi.Input[builtins.str] type: The condition type.
        """
        pulumi.set(__self__, "value", value)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if frontend_authorizer_name is not None:
            pulumi.set(__self__, "frontend_authorizer_name", frontend_authorizer_name)
        if mapped_param_location is not None:
            pulumi.set(__self__, "mapped_param_location", mapped_param_location)
        if mapped_param_name is not None:
            pulumi.set(__self__, "mapped_param_name", mapped_param_name)
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if sys_name is not None:
            pulumi.set(__self__, "sys_name", sys_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the backend policy.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The cookie parameter name.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="frontendAuthorizerName")
    def frontend_authorizer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The frontend authentication parameter name.
        """
        return pulumi.get(self, "frontend_authorizer_name")

    @frontend_authorizer_name.setter
    def frontend_authorizer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "frontend_authorizer_name", value)

    @property
    @pulumi.getter(name="mappedParamLocation")
    def mapped_param_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The location of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_location")

    @mapped_param_location.setter
    def mapped_param_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_location", value)

    @property
    @pulumi.getter(name="mappedParamName")
    def mapped_param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of a parameter generated after orchestration.
        """
        return pulumi.get(self, "mapped_param_name")

    @mapped_param_name.setter
    def mapped_param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mapped_param_name", value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request parameter name.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the backend policy.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sysName")
    def sys_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The gateway built-in parameter name.
        """
        return pulumi.get(self, "sys_name")

    @sys_name.setter
    def sys_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sys_name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The condition type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ApigApplicationQuotaAssociateApplicationArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The application ID bound to the application quota.
        """
        bind_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The binding time, in RFC3339 format.
        """
elif False:
    ApigApplicationQuotaAssociateApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigApplicationQuotaAssociateApplicationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 bind_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: The application ID bound to the application quota.
        :param pulumi.Input[builtins.str] bind_time: The binding time, in RFC3339 format.
        """
        pulumi.set(__self__, "id", id)
        if bind_time is not None:
            pulumi.set(__self__, "bind_time", bind_time)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The application ID bound to the application quota.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="bindTime")
    def bind_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The binding time, in RFC3339 format.
        """
        return pulumi.get(self, "bind_time")

    @bind_time.setter
    def bind_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bind_time", value)


if not MYPY:
    class ApigChannelHealthCheckArgsDict(TypedDict):
        interval: pulumi.Input[builtins.int]
        """
        The interval between consecutive check, in second.
        """
        protocol: pulumi.Input[builtins.str]
        """
        The rotocol for performing health check on backend servers.
        """
        threshold_abnormal: pulumi.Input[builtins.int]
        """
        The unhealthy threshold, which refers to the number of consecutive failed check required for a backend server to be considered unhealthy.
        """
        threshold_normal: pulumi.Input[builtins.int]
        """
        The the healthy threshold, which refers to the number of consecutive successful checks required for a backend server to be considered healthy.
        """
        timeout: pulumi.Input[builtins.int]
        """
        The timeout for determining whether a health check fails, in second.
        """
        enable_client_ssl: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable two-way authentication.
        """
        http_codes: NotRequired[pulumi.Input[builtins.str]]
        """
        The response codes for determining a successful HTTP response.
        """
        method: NotRequired[pulumi.Input[builtins.str]]
        """
        The request method for health check.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        The destination path for health check.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        The destination host port for health check.
        """
        status: NotRequired[pulumi.Input[builtins.int]]
        """
        The status of health check.
        """
elif False:
    ApigChannelHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelHealthCheckArgs:
    def __init__(__self__, *,
                 interval: pulumi.Input[builtins.int],
                 protocol: pulumi.Input[builtins.str],
                 threshold_abnormal: pulumi.Input[builtins.int],
                 threshold_normal: pulumi.Input[builtins.int],
                 timeout: pulumi.Input[builtins.int],
                 enable_client_ssl: Optional[pulumi.Input[builtins.bool]] = None,
                 http_codes: Optional[pulumi.Input[builtins.str]] = None,
                 method: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 status: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] interval: The interval between consecutive check, in second.
        :param pulumi.Input[builtins.str] protocol: The rotocol for performing health check on backend servers.
        :param pulumi.Input[builtins.int] threshold_abnormal: The unhealthy threshold, which refers to the number of consecutive failed check required for a backend server to be considered unhealthy.
        :param pulumi.Input[builtins.int] threshold_normal: The the healthy threshold, which refers to the number of consecutive successful checks required for a backend server to be considered healthy.
        :param pulumi.Input[builtins.int] timeout: The timeout for determining whether a health check fails, in second.
        :param pulumi.Input[builtins.bool] enable_client_ssl: Whether to enable two-way authentication.
        :param pulumi.Input[builtins.str] http_codes: The response codes for determining a successful HTTP response.
        :param pulumi.Input[builtins.str] method: The request method for health check.
        :param pulumi.Input[builtins.str] path: The destination path for health check.
        :param pulumi.Input[builtins.int] port: The destination host port for health check.
        :param pulumi.Input[builtins.int] status: The status of health check.
        """
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "threshold_abnormal", threshold_abnormal)
        pulumi.set(__self__, "threshold_normal", threshold_normal)
        pulumi.set(__self__, "timeout", timeout)
        if enable_client_ssl is not None:
            pulumi.set(__self__, "enable_client_ssl", enable_client_ssl)
        if http_codes is not None:
            pulumi.set(__self__, "http_codes", http_codes)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[builtins.int]:
        """
        The interval between consecutive check, in second.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[builtins.str]:
        """
        The rotocol for performing health check on backend servers.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="thresholdAbnormal")
    def threshold_abnormal(self) -> pulumi.Input[builtins.int]:
        """
        The unhealthy threshold, which refers to the number of consecutive failed check required for a backend server to be considered unhealthy.
        """
        return pulumi.get(self, "threshold_abnormal")

    @threshold_abnormal.setter
    def threshold_abnormal(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "threshold_abnormal", value)

    @property
    @pulumi.getter(name="thresholdNormal")
    def threshold_normal(self) -> pulumi.Input[builtins.int]:
        """
        The the healthy threshold, which refers to the number of consecutive successful checks required for a backend server to be considered healthy.
        """
        return pulumi.get(self, "threshold_normal")

    @threshold_normal.setter
    def threshold_normal(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "threshold_normal", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[builtins.int]:
        """
        The timeout for determining whether a health check fails, in second.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="enableClientSsl")
    def enable_client_ssl(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable two-way authentication.
        """
        return pulumi.get(self, "enable_client_ssl")

    @enable_client_ssl.setter
    def enable_client_ssl(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_client_ssl", value)

    @property
    @pulumi.getter(name="httpCodes")
    def http_codes(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The response codes for determining a successful HTTP response.
        """
        return pulumi.get(self, "http_codes")

    @http_codes.setter
    def http_codes(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "http_codes", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The request method for health check.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The destination path for health check.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The destination host port for health check.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The status of health check.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ApigChannelMemberArgsDict(TypedDict):
        group_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The group name of the backend server.
        """
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        The IP address of the backend server.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backend server.
        """
        is_backup: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether this member is the backup member.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the backend server.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        The port of the backend server.
        """
        status: NotRequired[pulumi.Input[builtins.int]]
        """
        The status of the backend server.
        """
        weight: NotRequired[pulumi.Input[builtins.int]]
        """
        The weight of current backend server.
        """
elif False:
    ApigChannelMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMemberArgs:
    def __init__(__self__, *,
                 group_name: Optional[pulumi.Input[builtins.str]] = None,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 is_backup: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 status: Optional[pulumi.Input[builtins.int]] = None,
                 weight: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] group_name: The group name of the backend server.
        :param pulumi.Input[builtins.str] host: The IP address of the backend server.
        :param pulumi.Input[builtins.str] id: The ID of the backend server.
        :param pulumi.Input[builtins.bool] is_backup: Whether this member is the backup member.
        :param pulumi.Input[builtins.str] name: The name of the backend server.
        :param pulumi.Input[builtins.int] port: The port of the backend server.
        :param pulumi.Input[builtins.int] status: The status of the backend server.
        :param pulumi.Input[builtins.int] weight: The weight of current backend server.
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_backup is not None:
            pulumi.set(__self__, "is_backup", is_backup)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The group name of the backend server.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The IP address of the backend server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backend server.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isBackup")
    def is_backup(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether this member is the backup member.
        """
        return pulumi.get(self, "is_backup")

    @is_backup.setter
    def is_backup(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_backup", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the backend server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The port of the backend server.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The status of the backend server.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The weight of current backend server.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ApigChannelMemberGroupArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the member group.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the member group.
        """
        microservice_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        The microservice tags of the backend server group.
        """
        microservice_port: NotRequired[pulumi.Input[builtins.int]]
        """
        The microservice port of the backend server group.
        """
        microservice_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The microservice version of the backend server group.
        """
        reference_vpc_channel_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the reference load balance channel.
        """
        weight: NotRequired[pulumi.Input[builtins.int]]
        """
        The weight of the current member group.
        """
elif False:
    ApigChannelMemberGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMemberGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 microservice_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 microservice_port: Optional[pulumi.Input[builtins.int]] = None,
                 microservice_version: Optional[pulumi.Input[builtins.str]] = None,
                 reference_vpc_channel_id: Optional[pulumi.Input[builtins.str]] = None,
                 weight: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the member group.
        :param pulumi.Input[builtins.str] description: The description of the member group.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] microservice_labels: The microservice tags of the backend server group.
        :param pulumi.Input[builtins.int] microservice_port: The microservice port of the backend server group.
        :param pulumi.Input[builtins.str] microservice_version: The microservice version of the backend server group.
        :param pulumi.Input[builtins.str] reference_vpc_channel_id: The ID of the reference load balance channel.
        :param pulumi.Input[builtins.int] weight: The weight of the current member group.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if microservice_labels is not None:
            pulumi.set(__self__, "microservice_labels", microservice_labels)
        if microservice_port is not None:
            pulumi.set(__self__, "microservice_port", microservice_port)
        if microservice_version is not None:
            pulumi.set(__self__, "microservice_version", microservice_version)
        if reference_vpc_channel_id is not None:
            pulumi.set(__self__, "reference_vpc_channel_id", reference_vpc_channel_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the member group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the member group.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="microserviceLabels")
    def microservice_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        The microservice tags of the backend server group.
        """
        return pulumi.get(self, "microservice_labels")

    @microservice_labels.setter
    def microservice_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "microservice_labels", value)

    @property
    @pulumi.getter(name="microservicePort")
    def microservice_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The microservice port of the backend server group.
        """
        return pulumi.get(self, "microservice_port")

    @microservice_port.setter
    def microservice_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "microservice_port", value)

    @property
    @pulumi.getter(name="microserviceVersion")
    def microservice_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The microservice version of the backend server group.
        """
        return pulumi.get(self, "microservice_version")

    @microservice_version.setter
    def microservice_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "microservice_version", value)

    @property
    @pulumi.getter(name="referenceVpcChannelId")
    def reference_vpc_channel_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the reference load balance channel.
        """
        return pulumi.get(self, "reference_vpc_channel_id")

    @reference_vpc_channel_id.setter
    def reference_vpc_channel_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reference_vpc_channel_id", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The weight of the current member group.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ApigChannelMicroserviceArgsDict(TypedDict):
        cce_config: NotRequired[pulumi.Input['ApigChannelMicroserviceCceConfigArgsDict']]
        """
        The CCE microservice details.
        """
        cse_config: NotRequired[pulumi.Input['ApigChannelMicroserviceCseConfigArgsDict']]
        """
        schema:Internal; The CSE microservice details.
        """
elif False:
    ApigChannelMicroserviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMicroserviceArgs:
    def __init__(__self__, *,
                 cce_config: Optional[pulumi.Input['ApigChannelMicroserviceCceConfigArgs']] = None,
                 cse_config: Optional[pulumi.Input['ApigChannelMicroserviceCseConfigArgs']] = None):
        """
        :param pulumi.Input['ApigChannelMicroserviceCceConfigArgs'] cce_config: The CCE microservice details.
        :param pulumi.Input['ApigChannelMicroserviceCseConfigArgs'] cse_config: schema:Internal; The CSE microservice details.
        """
        if cce_config is not None:
            pulumi.set(__self__, "cce_config", cce_config)
        if cse_config is not None:
            pulumi.set(__self__, "cse_config", cse_config)

    @property
    @pulumi.getter(name="cceConfig")
    def cce_config(self) -> Optional[pulumi.Input['ApigChannelMicroserviceCceConfigArgs']]:
        """
        The CCE microservice details.
        """
        return pulumi.get(self, "cce_config")

    @cce_config.setter
    def cce_config(self, value: Optional[pulumi.Input['ApigChannelMicroserviceCceConfigArgs']]):
        pulumi.set(self, "cce_config", value)

    @property
    @pulumi.getter(name="cseConfig")
    def cse_config(self) -> Optional[pulumi.Input['ApigChannelMicroserviceCseConfigArgs']]:
        """
        schema:Internal; The CSE microservice details.
        """
        return pulumi.get(self, "cse_config")

    @cse_config.setter
    def cse_config(self, value: Optional[pulumi.Input['ApigChannelMicroserviceCseConfigArgs']]):
        pulumi.set(self, "cse_config", value)


if not MYPY:
    class ApigChannelMicroserviceCceConfigArgsDict(TypedDict):
        cluster_id: pulumi.Input[builtins.str]
        """
        The ID of the CCE cluster.
        """
        namespace: pulumi.Input[builtins.str]
        """
        The name of the CCE namespace.
        """
        workload_type: pulumi.Input[builtins.str]
        """
        The workload type.
        """
        label_key: NotRequired[pulumi.Input[builtins.str]]
        """
        The service label key.
        """
        label_value: NotRequired[pulumi.Input[builtins.str]]
        """
        The service label value.
        """
        workload_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The workload name.
        """
elif False:
    ApigChannelMicroserviceCceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMicroserviceCceConfigArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[builtins.str],
                 namespace: pulumi.Input[builtins.str],
                 workload_type: pulumi.Input[builtins.str],
                 label_key: Optional[pulumi.Input[builtins.str]] = None,
                 label_value: Optional[pulumi.Input[builtins.str]] = None,
                 workload_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cluster_id: The ID of the CCE cluster.
        :param pulumi.Input[builtins.str] namespace: The name of the CCE namespace.
        :param pulumi.Input[builtins.str] workload_type: The workload type.
        :param pulumi.Input[builtins.str] label_key: The service label key.
        :param pulumi.Input[builtins.str] label_value: The service label value.
        :param pulumi.Input[builtins.str] workload_name: The workload name.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "workload_type", workload_type)
        if label_key is not None:
            pulumi.set(__self__, "label_key", label_key)
        if label_value is not None:
            pulumi.set(__self__, "label_value", label_value)
        if workload_name is not None:
            pulumi.set(__self__, "workload_name", workload_name)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the CCE cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[builtins.str]:
        """
        The name of the CCE namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> pulumi.Input[builtins.str]:
        """
        The workload type.
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "workload_type", value)

    @property
    @pulumi.getter(name="labelKey")
    def label_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The service label key.
        """
        return pulumi.get(self, "label_key")

    @label_key.setter
    def label_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "label_key", value)

    @property
    @pulumi.getter(name="labelValue")
    def label_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The service label value.
        """
        return pulumi.get(self, "label_value")

    @label_value.setter
    def label_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "label_value", value)

    @property
    @pulumi.getter(name="workloadName")
    def workload_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The workload name.
        """
        return pulumi.get(self, "workload_name")

    @workload_name.setter
    def workload_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "workload_name", value)


if not MYPY:
    class ApigChannelMicroserviceCseConfigArgsDict(TypedDict):
        engine_id: pulumi.Input[builtins.str]
        """
        schema:Internal; The microservice engine ID.
        """
        service_id: pulumi.Input[builtins.str]
        """
        schema:Internal; The microservice ID.
        """
elif False:
    ApigChannelMicroserviceCseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigChannelMicroserviceCseConfigArgs:
    def __init__(__self__, *,
                 engine_id: pulumi.Input[builtins.str],
                 service_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] engine_id: schema:Internal; The microservice engine ID.
        :param pulumi.Input[builtins.str] service_id: schema:Internal; The microservice ID.
        """
        pulumi.set(__self__, "engine_id", engine_id)
        pulumi.set(__self__, "service_id", service_id)

    @property
    @pulumi.getter(name="engineId")
    def engine_id(self) -> pulumi.Input[builtins.str]:
        """
        schema:Internal; The microservice engine ID.
        """
        return pulumi.get(self, "engine_id")

    @engine_id.setter
    def engine_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "engine_id", value)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> pulumi.Input[builtins.str]:
        """
        schema:Internal; The microservice ID.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_id", value)


if not MYPY:
    class ApigCustomAuthorizerIdentityArgsDict(TypedDict):
        location: pulumi.Input[builtins.str]
        """
        The parameter location.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of the parameter to be verified.
        """
        validation: NotRequired[pulumi.Input[builtins.str]]
        """
        The parameter verification expression.
        """
elif False:
    ApigCustomAuthorizerIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigCustomAuthorizerIdentityArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 validation: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] location: The parameter location.
        :param pulumi.Input[builtins.str] name: The name of the parameter to be verified.
        :param pulumi.Input[builtins.str] validation: The parameter verification expression.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "name", name)
        if validation is not None:
            pulumi.set(__self__, "validation", validation)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        The parameter location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the parameter to be verified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def validation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The parameter verification expression.
        """
        return pulumi.get(self, "validation")

    @validation.setter
    def validation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "validation", value)


if not MYPY:
    class ApigGroupEnvironmentArgsDict(TypedDict):
        environment_id: pulumi.Input[builtins.str]
        """
        The ID of the environment to which the variables belongs.
        """
        variables: pulumi.Input[Sequence[pulumi.Input['ApigGroupEnvironmentVariableArgsDict']]]
        """
        The array of one or more environment variables.
        """
elif False:
    ApigGroupEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigGroupEnvironmentArgs:
    def __init__(__self__, *,
                 environment_id: pulumi.Input[builtins.str],
                 variables: pulumi.Input[Sequence[pulumi.Input['ApigGroupEnvironmentVariableArgs']]]):
        """
        :param pulumi.Input[builtins.str] environment_id: The ID of the environment to which the variables belongs.
        :param pulumi.Input[Sequence[pulumi.Input['ApigGroupEnvironmentVariableArgs']]] variables: The array of one or more environment variables.
        """
        pulumi.set(__self__, "environment_id", environment_id)
        pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the environment to which the variables belongs.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "environment_id", value)

    @property
    @pulumi.getter
    def variables(self) -> pulumi.Input[Sequence[pulumi.Input['ApigGroupEnvironmentVariableArgs']]]:
        """
        The array of one or more environment variables.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: pulumi.Input[Sequence[pulumi.Input['ApigGroupEnvironmentVariableArgs']]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class ApigGroupEnvironmentVariableArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The variable name.
        """
        value: pulumi.Input[builtins.str]
        """
        The variable value.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the variable that the group has.
        """
        variable_id: NotRequired[pulumi.Input[builtins.str]]
        """
        schema: Deprecated; The ID of the variable that the group has.
        """
elif False:
    ApigGroupEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigGroupEnvironmentVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 variable_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: The variable name.
        :param pulumi.Input[builtins.str] value: The variable value.
        :param pulumi.Input[builtins.str] id: The ID of the variable that the group has.
        :param pulumi.Input[builtins.str] variable_id: schema: Deprecated; The ID of the variable that the group has.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if variable_id is not None:
            warnings.warn("""Use 'id' instead""", DeprecationWarning)
            pulumi.log.warn("""variable_id is deprecated: Use 'id' instead""")
        if variable_id is not None:
            pulumi.set(__self__, "variable_id", variable_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The variable name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The variable value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the variable that the group has.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="variableId")
    @_utilities.deprecated("""Use 'id' instead""")
    def variable_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        schema: Deprecated; The ID of the variable that the group has.
        """
        return pulumi.get(self, "variable_id")

    @variable_id.setter
    def variable_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "variable_id", value)


if not MYPY:
    class ApigGroupUrlDomainArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        is_http_redirect_to_https: NotRequired[pulumi.Input[builtins.bool]]
        min_ssl_version: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ApigGroupUrlDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigGroupUrlDomainArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 is_http_redirect_to_https: Optional[pulumi.Input[builtins.bool]] = None,
                 min_ssl_version: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if is_http_redirect_to_https is not None:
            pulumi.set(__self__, "is_http_redirect_to_https", is_http_redirect_to_https)
        if min_ssl_version is not None:
            pulumi.set(__self__, "min_ssl_version", min_ssl_version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isHttpRedirectToHttps")
    def is_http_redirect_to_https(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_http_redirect_to_https")

    @is_http_redirect_to_https.setter
    def is_http_redirect_to_https(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_http_redirect_to_https", value)

    @property
    @pulumi.getter(name="minSslVersion")
    def min_ssl_version(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "min_ssl_version")

    @min_ssl_version.setter
    def min_ssl_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "min_ssl_version", value)


if not MYPY:
    class ApigInstanceCustomIngressPortArgsDict(TypedDict):
        port: pulumi.Input[builtins.int]
        """
        Specified port of the custom ingress port.
        """
        protocol: pulumi.Input[builtins.str]
        """
        Specified protocol of the custom ingress port.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the custom ingress port.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        The current status of the custom ingress port.
        """
elif False:
    ApigInstanceCustomIngressPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigInstanceCustomIngressPortArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[builtins.int],
                 protocol: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] port: Specified port of the custom ingress port.
        :param pulumi.Input[builtins.str] protocol: Specified protocol of the custom ingress port.
        :param pulumi.Input[builtins.str] id: The ID of the custom ingress port.
        :param pulumi.Input[builtins.str] status: The current status of the custom ingress port.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        Specified port of the custom ingress port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[builtins.str]:
        """
        Specified protocol of the custom ingress port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the custom ingress port.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The current status of the custom ingress port.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ApigResponseRuleArgsDict(TypedDict):
        body: pulumi.Input[builtins.str]
        """
        The body template of the API custom response rule.
        """
        error_type: pulumi.Input[builtins.str]
        """
        The error type of the API custom response rule.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApigResponseRuleHeaderArgsDict']]]]
        """
        The configuration of the custom response headers.
        """
        status_code: NotRequired[pulumi.Input[builtins.int]]
        """
        The HTTP status code of the API custom response rule.
        """
elif False:
    ApigResponseRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigResponseRuleArgs:
    def __init__(__self__, *,
                 body: pulumi.Input[builtins.str],
                 error_type: pulumi.Input[builtins.str],
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['ApigResponseRuleHeaderArgs']]]] = None,
                 status_code: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] body: The body template of the API custom response rule.
        :param pulumi.Input[builtins.str] error_type: The error type of the API custom response rule.
        :param pulumi.Input[Sequence[pulumi.Input['ApigResponseRuleHeaderArgs']]] headers: The configuration of the custom response headers.
        :param pulumi.Input[builtins.int] status_code: The HTTP status code of the API custom response rule.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "error_type", error_type)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def body(self) -> pulumi.Input[builtins.str]:
        """
        The body template of the API custom response rule.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="errorType")
    def error_type(self) -> pulumi.Input[builtins.str]:
        """
        The error type of the API custom response rule.
        """
        return pulumi.get(self, "error_type")

    @error_type.setter
    def error_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "error_type", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigResponseRuleHeaderArgs']]]]:
        """
        The configuration of the custom response headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigResponseRuleHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The HTTP status code of the API custom response rule.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class ApigResponseRuleHeaderArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The key name of the response header.
        """
        value: pulumi.Input[builtins.str]
        """
        The value for the specified response header key.
        """
elif False:
    ApigResponseRuleHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigResponseRuleHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: The key name of the response header.
        :param pulumi.Input[builtins.str] value: The value for the specified response header key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The key name of the response header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value for the specified response header key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApigThrottlingPolicyAppThrottleArgsDict(TypedDict):
        max_api_requests: pulumi.Input[builtins.int]
        """
        The maximum number of times an API can be accessed within a specified period.
        """
        throttling_object_id: pulumi.Input[builtins.str]
        """
        The object ID which the special throttling policy belongs.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the special user/application throttling policy.
        """
        throttling_object_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The object name which the special user/application throttling policy belongs.
        """
elif False:
    ApigThrottlingPolicyAppThrottleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigThrottlingPolicyAppThrottleArgs:
    def __init__(__self__, *,
                 max_api_requests: pulumi.Input[builtins.int],
                 throttling_object_id: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 throttling_object_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] max_api_requests: The maximum number of times an API can be accessed within a specified period.
        :param pulumi.Input[builtins.str] throttling_object_id: The object ID which the special throttling policy belongs.
        :param pulumi.Input[builtins.str] id: The ID of the special user/application throttling policy.
        :param pulumi.Input[builtins.str] throttling_object_name: The object name which the special user/application throttling policy belongs.
        """
        pulumi.set(__self__, "max_api_requests", max_api_requests)
        pulumi.set(__self__, "throttling_object_id", throttling_object_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if throttling_object_name is not None:
            pulumi.set(__self__, "throttling_object_name", throttling_object_name)

    @property
    @pulumi.getter(name="maxApiRequests")
    def max_api_requests(self) -> pulumi.Input[builtins.int]:
        """
        The maximum number of times an API can be accessed within a specified period.
        """
        return pulumi.get(self, "max_api_requests")

    @max_api_requests.setter
    def max_api_requests(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "max_api_requests", value)

    @property
    @pulumi.getter(name="throttlingObjectId")
    def throttling_object_id(self) -> pulumi.Input[builtins.str]:
        """
        The object ID which the special throttling policy belongs.
        """
        return pulumi.get(self, "throttling_object_id")

    @throttling_object_id.setter
    def throttling_object_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "throttling_object_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the special user/application throttling policy.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="throttlingObjectName")
    def throttling_object_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The object name which the special user/application throttling policy belongs.
        """
        return pulumi.get(self, "throttling_object_name")

    @throttling_object_name.setter
    def throttling_object_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "throttling_object_name", value)


if not MYPY:
    class ApigThrottlingPolicyUserThrottleArgsDict(TypedDict):
        max_api_requests: pulumi.Input[builtins.int]
        """
        The maximum number of times an API can be accessed within a specified period.
        """
        throttling_object_id: pulumi.Input[builtins.str]
        """
        The object ID which the special throttling policy belongs.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the special user/application throttling policy.
        """
        throttling_object_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The object name which the special user/application throttling policy belongs.
        """
elif False:
    ApigThrottlingPolicyUserThrottleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApigThrottlingPolicyUserThrottleArgs:
    def __init__(__self__, *,
                 max_api_requests: pulumi.Input[builtins.int],
                 throttling_object_id: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 throttling_object_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] max_api_requests: The maximum number of times an API can be accessed within a specified period.
        :param pulumi.Input[builtins.str] throttling_object_id: The object ID which the special throttling policy belongs.
        :param pulumi.Input[builtins.str] id: The ID of the special user/application throttling policy.
        :param pulumi.Input[builtins.str] throttling_object_name: The object name which the special user/application throttling policy belongs.
        """
        pulumi.set(__self__, "max_api_requests", max_api_requests)
        pulumi.set(__self__, "throttling_object_id", throttling_object_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if throttling_object_name is not None:
            pulumi.set(__self__, "throttling_object_name", throttling_object_name)

    @property
    @pulumi.getter(name="maxApiRequests")
    def max_api_requests(self) -> pulumi.Input[builtins.int]:
        """
        The maximum number of times an API can be accessed within a specified period.
        """
        return pulumi.get(self, "max_api_requests")

    @max_api_requests.setter
    def max_api_requests(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "max_api_requests", value)

    @property
    @pulumi.getter(name="throttlingObjectId")
    def throttling_object_id(self) -> pulumi.Input[builtins.str]:
        """
        The object ID which the special throttling policy belongs.
        """
        return pulumi.get(self, "throttling_object_id")

    @throttling_object_id.setter
    def throttling_object_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "throttling_object_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the special user/application throttling policy.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="throttlingObjectName")
    def throttling_object_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The object name which the special user/application throttling policy belongs.
        """
        return pulumi.get(self, "throttling_object_name")

    @throttling_object_name.setter
    def throttling_object_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "throttling_object_name", value)


if not MYPY:
    class AsBandwidthPolicyScalingPolicyActionArgsDict(TypedDict):
        limits: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the operation restrictions.
        """
        operation: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the operation to be performed. The default operation is ADD.
        """
        size: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the bandwidth (Mbit/s).
        """
elif False:
    AsBandwidthPolicyScalingPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsBandwidthPolicyScalingPolicyActionArgs:
    def __init__(__self__, *,
                 limits: Optional[pulumi.Input[builtins.int]] = None,
                 operation: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] limits: Specifies the operation restrictions.
        :param pulumi.Input[builtins.str] operation: Specifies the operation to be performed. The default operation is ADD.
        :param pulumi.Input[builtins.int] size: Specifies the bandwidth (Mbit/s).
        """
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the operation restrictions.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the operation to be performed. The default operation is ADD.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the bandwidth (Mbit/s).
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class AsBandwidthPolicyScheduledPolicyArgsDict(TypedDict):
        launch_time: pulumi.Input[builtins.str]
        """
        Specifies the time when the scaling action is triggered. The time format complies with UTC.
        """
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the end time of the scaling action triggered periodically.
        """
        recurrence_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the periodic triggering type.
        """
        recurrence_value: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the day when a periodic scaling action is triggered.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the start time of the scaling action triggered periodically.
        """
elif False:
    AsBandwidthPolicyScheduledPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsBandwidthPolicyScheduledPolicyArgs:
    def __init__(__self__, *,
                 launch_time: pulumi.Input[builtins.str],
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 recurrence_type: Optional[pulumi.Input[builtins.str]] = None,
                 recurrence_value: Optional[pulumi.Input[builtins.str]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] launch_time: Specifies the time when the scaling action is triggered. The time format complies with UTC.
        :param pulumi.Input[builtins.str] end_time: Specifies the end time of the scaling action triggered periodically.
        :param pulumi.Input[builtins.str] recurrence_type: Specifies the periodic triggering type.
        :param pulumi.Input[builtins.str] recurrence_value: Specifies the day when a periodic scaling action is triggered.
        :param pulumi.Input[builtins.str] start_time: Specifies the start time of the scaling action triggered periodically.
        """
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the time when the scaling action is triggered. The time format complies with UTC.
        """
        return pulumi.get(self, "launch_time")

    @launch_time.setter
    def launch_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "launch_time", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the end time of the scaling action triggered periodically.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the periodic triggering type.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "recurrence_type", value)

    @property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the day when a periodic scaling action is triggered.
        """
        return pulumi.get(self, "recurrence_value")

    @recurrence_value.setter
    def recurrence_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "recurrence_value", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the start time of the scaling action triggered periodically.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class AsConfigurationInstanceConfigArgsDict(TypedDict):
        admin_pass: NotRequired[pulumi.Input[builtins.str]]
        charging_mode: NotRequired[pulumi.Input[builtins.str]]
        dedicated_host_id: NotRequired[pulumi.Input[builtins.str]]
        disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AsConfigurationInstanceConfigDiskArgsDict']]]]
        ecs_group_id: NotRequired[pulumi.Input[builtins.str]]
        flavor: NotRequired[pulumi.Input[builtins.str]]
        flavor_priority_policy: NotRequired[pulumi.Input[builtins.str]]
        image: NotRequired[pulumi.Input[builtins.str]]
        instance_id: NotRequired[pulumi.Input[builtins.str]]
        key_name: NotRequired[pulumi.Input[builtins.str]]
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        personalities: NotRequired[pulumi.Input[Sequence[pulumi.Input['AsConfigurationInstanceConfigPersonalityArgsDict']]]]
        public_ip: NotRequired[pulumi.Input['AsConfigurationInstanceConfigPublicIpArgsDict']]
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        schema: Required
        """
        tenancy: NotRequired[pulumi.Input[builtins.str]]
        user_data: NotRequired[pulumi.Input[builtins.str]]
elif False:
    AsConfigurationInstanceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsConfigurationInstanceConfigArgs:
    def __init__(__self__, *,
                 admin_pass: Optional[pulumi.Input[builtins.str]] = None,
                 charging_mode: Optional[pulumi.Input[builtins.str]] = None,
                 dedicated_host_id: Optional[pulumi.Input[builtins.str]] = None,
                 disks: Optional[pulumi.Input[Sequence[pulumi.Input['AsConfigurationInstanceConfigDiskArgs']]]] = None,
                 ecs_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 flavor: Optional[pulumi.Input[builtins.str]] = None,
                 flavor_priority_policy: Optional[pulumi.Input[builtins.str]] = None,
                 image: Optional[pulumi.Input[builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[builtins.str]] = None,
                 key_name: Optional[pulumi.Input[builtins.str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 personalities: Optional[pulumi.Input[Sequence[pulumi.Input['AsConfigurationInstanceConfigPersonalityArgs']]]] = None,
                 public_ip: Optional[pulumi.Input['AsConfigurationInstanceConfigPublicIpArgs']] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 tenancy: Optional[pulumi.Input[builtins.str]] = None,
                 user_data: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] security_group_ids: schema: Required
        """
        if admin_pass is not None:
            pulumi.set(__self__, "admin_pass", admin_pass)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if ecs_group_id is not None:
            pulumi.set(__self__, "ecs_group_id", ecs_group_id)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if flavor_priority_policy is not None:
            pulumi.set(__self__, "flavor_priority_policy", flavor_priority_policy)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if personalities is not None:
            pulumi.set(__self__, "personalities", personalities)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="adminPass")
    def admin_pass(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "admin_pass")

    @admin_pass.setter
    def admin_pass(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "admin_pass", value)

    @property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dedicated_host_id")

    @dedicated_host_id.setter
    def dedicated_host_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dedicated_host_id", value)

    @property
    @pulumi.getter
    def disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AsConfigurationInstanceConfigDiskArgs']]]]:
        return pulumi.get(self, "disks")

    @disks.setter
    def disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AsConfigurationInstanceConfigDiskArgs']]]]):
        pulumi.set(self, "disks", value)

    @property
    @pulumi.getter(name="ecsGroupId")
    def ecs_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ecs_group_id")

    @ecs_group_id.setter
    def ecs_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ecs_group_id", value)

    @property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "flavor", value)

    @property
    @pulumi.getter(name="flavorPriorityPolicy")
    def flavor_priority_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "flavor_priority_policy")

    @flavor_priority_policy.setter
    def flavor_priority_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "flavor_priority_policy", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_name", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def personalities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AsConfigurationInstanceConfigPersonalityArgs']]]]:
        return pulumi.get(self, "personalities")

    @personalities.setter
    def personalities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AsConfigurationInstanceConfigPersonalityArgs']]]]):
        pulumi.set(self, "personalities", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input['AsConfigurationInstanceConfigPublicIpArgs']]:
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input['AsConfigurationInstanceConfigPublicIpArgs']]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        schema: Required
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenancy", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_data", value)


if not MYPY:
    class AsConfigurationInstanceConfigDiskArgsDict(TypedDict):
        disk_type: pulumi.Input[builtins.str]
        size: pulumi.Input[builtins.int]
        volume_type: pulumi.Input[builtins.str]
        data_disk_image_id: NotRequired[pulumi.Input[builtins.str]]
        dedicated_storage_id: NotRequired[pulumi.Input[builtins.str]]
        iops: NotRequired[pulumi.Input[builtins.int]]
        kms_id: NotRequired[pulumi.Input[builtins.str]]
        snapshot_id: NotRequired[pulumi.Input[builtins.str]]
        throughput: NotRequired[pulumi.Input[builtins.int]]
elif False:
    AsConfigurationInstanceConfigDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsConfigurationInstanceConfigDiskArgs:
    def __init__(__self__, *,
                 disk_type: pulumi.Input[builtins.str],
                 size: pulumi.Input[builtins.int],
                 volume_type: pulumi.Input[builtins.str],
                 data_disk_image_id: Optional[pulumi.Input[builtins.str]] = None,
                 dedicated_storage_id: Optional[pulumi.Input[builtins.str]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 kms_id: Optional[pulumi.Input[builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[builtins.str]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)
        if data_disk_image_id is not None:
            pulumi.set(__self__, "data_disk_image_id", data_disk_image_id)
        if dedicated_storage_id is not None:
            pulumi.set(__self__, "dedicated_storage_id", dedicated_storage_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_id is not None:
            pulumi.set(__self__, "kms_id", kms_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "volume_type", value)

    @property
    @pulumi.getter(name="dataDiskImageId")
    def data_disk_image_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "data_disk_image_id")

    @data_disk_image_id.setter
    def data_disk_image_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_disk_image_id", value)

    @property
    @pulumi.getter(name="dedicatedStorageId")
    def dedicated_storage_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dedicated_storage_id")

    @dedicated_storage_id.setter
    def dedicated_storage_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dedicated_storage_id", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsId")
    def kms_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kms_id")

    @kms_id.setter
    def kms_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class AsConfigurationInstanceConfigPersonalityArgsDict(TypedDict):
        content: pulumi.Input[builtins.str]
        path: pulumi.Input[builtins.str]
elif False:
    AsConfigurationInstanceConfigPersonalityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsConfigurationInstanceConfigPersonalityArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[builtins.str],
                 path: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class AsConfigurationInstanceConfigPublicIpArgsDict(TypedDict):
        eip: pulumi.Input['AsConfigurationInstanceConfigPublicIpEipArgsDict']
elif False:
    AsConfigurationInstanceConfigPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsConfigurationInstanceConfigPublicIpArgs:
    def __init__(__self__, *,
                 eip: pulumi.Input['AsConfigurationInstanceConfigPublicIpEipArgs']):
        pulumi.set(__self__, "eip", eip)

    @property
    @pulumi.getter
    def eip(self) -> pulumi.Input['AsConfigurationInstanceConfigPublicIpEipArgs']:
        return pulumi.get(self, "eip")

    @eip.setter
    def eip(self, value: pulumi.Input['AsConfigurationInstanceConfigPublicIpEipArgs']):
        pulumi.set(self, "eip", value)


if not MYPY:
    class AsConfigurationInstanceConfigPublicIpEipArgsDict(TypedDict):
        bandwidth: pulumi.Input['AsConfigurationInstanceConfigPublicIpEipBandwidthArgsDict']
        ip_type: pulumi.Input[builtins.str]
elif False:
    AsConfigurationInstanceConfigPublicIpEipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsConfigurationInstanceConfigPublicIpEipArgs:
    def __init__(__self__, *,
                 bandwidth: pulumi.Input['AsConfigurationInstanceConfigPublicIpEipBandwidthArgs'],
                 ip_type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "bandwidth", bandwidth)
        pulumi.set(__self__, "ip_type", ip_type)

    @property
    @pulumi.getter
    def bandwidth(self) -> pulumi.Input['AsConfigurationInstanceConfigPublicIpEipBandwidthArgs']:
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: pulumi.Input['AsConfigurationInstanceConfigPublicIpEipBandwidthArgs']):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip_type")

    @ip_type.setter
    def ip_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip_type", value)


if not MYPY:
    class AsConfigurationInstanceConfigPublicIpEipBandwidthArgsDict(TypedDict):
        share_type: pulumi.Input[builtins.str]
        charging_mode: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
        size: NotRequired[pulumi.Input[builtins.int]]
elif False:
    AsConfigurationInstanceConfigPublicIpEipBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsConfigurationInstanceConfigPublicIpEipBandwidthArgs:
    def __init__(__self__, *,
                 share_type: pulumi.Input[builtins.str],
                 charging_mode: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "share_type", share_type)
        if charging_mode is not None:
            pulumi.set(__self__, "charging_mode", charging_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="shareType")
    def share_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "share_type")

    @share_type.setter
    def share_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "share_type", value)

    @property
    @pulumi.getter(name="chargingMode")
    def charging_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "charging_mode")

    @charging_mode.setter
    def charging_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "charging_mode", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class AsGroupLbaasListenerArgsDict(TypedDict):
        pool_id: pulumi.Input[builtins.str]
        protocol_port: pulumi.Input[builtins.int]
        protocol_version: NotRequired[pulumi.Input[builtins.str]]
        weight: NotRequired[pulumi.Input[builtins.int]]
elif False:
    AsGroupLbaasListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsGroupLbaasListenerArgs:
    def __init__(__self__, *,
                 pool_id: pulumi.Input[builtins.str],
                 protocol_port: pulumi.Input[builtins.int],
                 protocol_version: Optional[pulumi.Input[builtins.str]] = None,
                 weight: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "pool_id", pool_id)
        pulumi.set(__self__, "protocol_port", protocol_port)
        if protocol_version is not None:
            pulumi.set(__self__, "protocol_version", protocol_version)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "pool_id", value)

    @property
    @pulumi.getter(name="protocolPort")
    def protocol_port(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "protocol_port")

    @protocol_port.setter
    def protocol_port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "protocol_port", value)

    @property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol_version", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class AsGroupNetworkArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        ipv6_bandwidth_id: NotRequired[pulumi.Input[builtins.str]]
        ipv6_enable: NotRequired[pulumi.Input[builtins.bool]]
        source_dest_check: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    AsGroupNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsGroupNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 ipv6_bandwidth_id: Optional[pulumi.Input[builtins.str]] = None,
                 ipv6_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 source_dest_check: Optional[pulumi.Input[builtins.bool]] = None):
        pulumi.set(__self__, "id", id)
        if ipv6_bandwidth_id is not None:
            pulumi.set(__self__, "ipv6_bandwidth_id", ipv6_bandwidth_id)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipv6BandwidthId")
    def ipv6_bandwidth_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ipv6_bandwidth_id")

    @ipv6_bandwidth_id.setter
    def ipv6_bandwidth_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ipv6_bandwidth_id", value)

    @property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "ipv6_enable")

    @ipv6_enable.setter
    def ipv6_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ipv6_enable", value)

    @property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "source_dest_check")

    @source_dest_check.setter
    def source_dest_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "source_dest_check", value)


if not MYPY:
    class AsGroupSecurityGroupArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
elif False:
    AsGroupSecurityGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsGroupSecurityGroupArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AsPolicyScalingPolicyActionArgsDict(TypedDict):
        instance_number: NotRequired[pulumi.Input[builtins.int]]
        instance_percentage: NotRequired[pulumi.Input[builtins.int]]
        operation: NotRequired[pulumi.Input[builtins.str]]
elif False:
    AsPolicyScalingPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsPolicyScalingPolicyActionArgs:
    def __init__(__self__, *,
                 instance_number: Optional[pulumi.Input[builtins.int]] = None,
                 instance_percentage: Optional[pulumi.Input[builtins.int]] = None,
                 operation: Optional[pulumi.Input[builtins.str]] = None):
        if instance_number is not None:
            pulumi.set(__self__, "instance_number", instance_number)
        if instance_percentage is not None:
            pulumi.set(__self__, "instance_percentage", instance_percentage)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)

    @property
    @pulumi.getter(name="instanceNumber")
    def instance_number(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "instance_number")

    @instance_number.setter
    def instance_number(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "instance_number", value)

    @property
    @pulumi.getter(name="instancePercentage")
    def instance_percentage(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "instance_percentage")

    @instance_percentage.setter
    def instance_percentage(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "instance_percentage", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operation", value)


if not MYPY:
    class AsPolicyScheduledPolicyArgsDict(TypedDict):
        launch_time: pulumi.Input[builtins.str]
        end_time: NotRequired[pulumi.Input[builtins.str]]
        recurrence_type: NotRequired[pulumi.Input[builtins.str]]
        recurrence_value: NotRequired[pulumi.Input[builtins.str]]
        start_time: NotRequired[pulumi.Input[builtins.str]]
elif False:
    AsPolicyScheduledPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AsPolicyScheduledPolicyArgs:
    def __init__(__self__, *,
                 launch_time: pulumi.Input[builtins.str],
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 recurrence_type: Optional[pulumi.Input[builtins.str]] = None,
                 recurrence_value: Optional[pulumi.Input[builtins.str]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "launch_time", launch_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence_type is not None:
            pulumi.set(__self__, "recurrence_type", recurrence_type)
        if recurrence_value is not None:
            pulumi.set(__self__, "recurrence_value", recurrence_value)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="launchTime")
    def launch_time(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "launch_time")

    @launch_time.setter
    def launch_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "launch_time", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "recurrence_type", value)

    @property
    @pulumi.getter(name="recurrenceValue")
    def recurrence_value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "recurrence_value")

    @recurrence_value.setter
    def recurrence_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "recurrence_value", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class CbrBackupShareMemberArgsDict(TypedDict):
        dest_project_id: pulumi.Input[builtins.str]
        """
        The ID of the project with which the backup is shared.
        """
        created_at: NotRequired[pulumi.Input[builtins.str]]
        """
        The creation time of the backup shared member.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the backup shared member record.
        """
        image_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the image registered with the shared backup copy.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        The backup shared status.
        """
        updated_at: NotRequired[pulumi.Input[builtins.str]]
        """
        The latest update time of the backup shared member.
        """
        vault_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the vault where the shared backup is stored.
        """
elif False:
    CbrBackupShareMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CbrBackupShareMemberArgs:
    def __init__(__self__, *,
                 dest_project_id: pulumi.Input[builtins.str],
                 created_at: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 image_id: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[builtins.str]] = None,
                 vault_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] dest_project_id: The ID of the project with which the backup is shared.
        :param pulumi.Input[builtins.str] created_at: The creation time of the backup shared member.
        :param pulumi.Input[builtins.str] id: The ID of the backup shared member record.
        :param pulumi.Input[builtins.str] image_id: The ID of the image registered with the shared backup copy.
        :param pulumi.Input[builtins.str] status: The backup shared status.
        :param pulumi.Input[builtins.str] updated_at: The latest update time of the backup shared member.
        :param pulumi.Input[builtins.str] vault_id: The ID of the vault where the shared backup is stored.
        """
        pulumi.set(__self__, "dest_project_id", dest_project_id)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="destProjectId")
    def dest_project_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the project with which the backup is shared.
        """
        return pulumi.get(self, "dest_project_id")

    @dest_project_id.setter
    def dest_project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "dest_project_id", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The creation time of the backup shared member.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the backup shared member record.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the image registered with the shared backup copy.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backup shared status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The latest update time of the backup shared member.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the vault where the shared backup is stored.
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vault_id", value)


if not MYPY:
    class CbrCheckpointBackupArgsDict(TypedDict):
        resource_id: pulumi.Input[builtins.str]
        """
        The ID of backup resource.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the backup resource.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The backup ID.
        """
        protected_at: NotRequired[pulumi.Input[builtins.str]]
        """
        The backup time.
        """
        resource_size: NotRequired[pulumi.Input[builtins.int]]
        """
        The backup resource size.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        The backup status.
        """
        updated_at: NotRequired[pulumi.Input[builtins.str]]
        """
        The latest update time of the backup.
        """
elif False:
    CbrCheckpointBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CbrCheckpointBackupArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 protected_at: Optional[pulumi.Input[builtins.str]] = None,
                 resource_size: Optional[pulumi.Input[builtins.int]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] resource_id: The ID of backup resource.
        :param pulumi.Input[builtins.str] type: The type of the backup resource.
        :param pulumi.Input[builtins.str] id: The backup ID.
        :param pulumi.Input[builtins.str] protected_at: The backup time.
        :param pulumi.Input[builtins.int] resource_size: The backup resource size.
        :param pulumi.Input[builtins.str] status: The backup status.
        :param pulumi.Input[builtins.str] updated_at: The latest update time of the backup.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if protected_at is not None:
            pulumi.set(__self__, "protected_at", protected_at)
        if resource_size is not None:
            pulumi.set(__self__, "resource_size", resource_size)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of backup resource.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the backup resource.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backup ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="protectedAt")
    def protected_at(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backup time.
        """
        return pulumi.get(self, "protected_at")

    @protected_at.setter
    def protected_at(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protected_at", value)

    @property
    @pulumi.getter(name="resourceSize")
    def resource_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The backup resource size.
        """
        return pulumi.get(self, "resource_size")

    @resource_size.setter
    def resource_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "resource_size", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The backup status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The latest update time of the backup.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class CbrPolicyBackupCycleArgsDict(TypedDict):
        execution_times: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The execution time of the policy.
        """
        days: NotRequired[pulumi.Input[builtins.str]]
        """
        The weekly backup time.
        """
        interval: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of days between each backup.
        """
elif False:
    CbrPolicyBackupCycleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CbrPolicyBackupCycleArgs:
    def __init__(__self__, *,
                 execution_times: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 days: Optional[pulumi.Input[builtins.str]] = None,
                 interval: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] execution_times: The execution time of the policy.
        :param pulumi.Input[builtins.str] days: The weekly backup time.
        :param pulumi.Input[builtins.int] interval: The number of days between each backup.
        """
        pulumi.set(__self__, "execution_times", execution_times)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter(name="executionTimes")
    def execution_times(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The execution time of the policy.
        """
        return pulumi.get(self, "execution_times")

    @execution_times.setter
    def execution_times(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "execution_times", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The weekly backup time.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of days between each backup.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class CbrPolicyLongTermRetentionArgsDict(TypedDict):
        daily: NotRequired[pulumi.Input[builtins.int]]
        """
        The latest backup of each day is saved in the long term.
        """
        full_backup_interval: NotRequired[pulumi.Input[builtins.int]]
        """
        How often (after how many incremental backups) a full backup is performed.
        """
        monthly: NotRequired[pulumi.Input[builtins.int]]
        """
        The latest backup of each month is saved in the long term.
        """
        weekly: NotRequired[pulumi.Input[builtins.int]]
        """
        The latest backup of each week is saved in the long term.
        """
        yearly: NotRequired[pulumi.Input[builtins.int]]
        """
        The latest backup of each year is saved in the long term.
        """
elif False:
    CbrPolicyLongTermRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CbrPolicyLongTermRetentionArgs:
    def __init__(__self__, *,
                 daily: Optional[pulumi.Input[builtins.int]] = None,
                 full_backup_interval: Optional[pulumi.Input[builtins.int]] = None,
                 monthly: Optional[pulumi.Input[builtins.int]] = None,
                 weekly: Optional[pulumi.Input[builtins.int]] = None,
                 yearly: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] daily: The latest backup of each day is saved in the long term.
        :param pulumi.Input[builtins.int] full_backup_interval: How often (after how many incremental backups) a full backup is performed.
        :param pulumi.Input[builtins.int] monthly: The latest backup of each month is saved in the long term.
        :param pulumi.Input[builtins.int] weekly: The latest backup of each week is saved in the long term.
        :param pulumi.Input[builtins.int] yearly: The latest backup of each year is saved in the long term.
        """
        if daily is not None:
            pulumi.set(__self__, "daily", daily)
        if full_backup_interval is not None:
            pulumi.set(__self__, "full_backup_interval", full_backup_interval)
        if monthly is not None:
            pulumi.set(__self__, "monthly", monthly)
        if weekly is not None:
            pulumi.set(__self__, "weekly", weekly)
        if yearly is not None:
            pulumi.set(__self__, "yearly", yearly)

    @property
    @pulumi.getter
    def daily(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The latest backup of each day is saved in the long term.
        """
        return pulumi.get(self, "daily")

    @daily.setter
    def daily(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "daily", value)

    @property
    @pulumi.getter(name="fullBackupInterval")
    def full_backup_interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How often (after how many incremental backups) a full backup is performed.
        """
        return pulumi.get(self, "full_backup_interval")

    @full_backup_interval.setter
    def full_backup_interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "full_backup_interval", value)

    @property
    @pulumi.getter
    def monthly(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The latest backup of each month is saved in the long term.
        """
        return pulumi.get(self, "monthly")

    @monthly.setter
    def monthly(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "monthly", value)

    @property
    @pulumi.getter
    def weekly(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The latest backup of each week is saved in the long term.
        """
        return pulumi.get(self, "weekly")

    @weekly.setter
    def weekly(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "weekly", value)

    @property
    @pulumi.getter
    def yearly(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The latest backup of each year is saved in the long term.
        """
        return pulumi.get(self, "yearly")

    @yearly.setter
    def yearly(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "yearly", value)


if not MYPY:
    class CbrVaultPolicyArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        """
        The policy ID.
        """
        destination_vault_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of destination vault to which the replication policy will associated.
        """
elif False:
    CbrVaultPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CbrVaultPolicyArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 destination_vault_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: The policy ID.
        :param pulumi.Input[builtins.str] destination_vault_id: The ID of destination vault to which the replication policy will associated.
        """
        pulumi.set(__self__, "id", id)
        if destination_vault_id is not None:
            pulumi.set(__self__, "destination_vault_id", destination_vault_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        """
        The policy ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="destinationVaultId")
    def destination_vault_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of destination vault to which the replication policy will associated.
        """
        return pulumi.get(self, "destination_vault_id")

    @destination_vault_id.setter
    def destination_vault_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination_vault_id", value)


if not MYPY:
    class CbrVaultResourceArgsDict(TypedDict):
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The array of disk IDs which will be excluded in the backup.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The array of disk or SFS file systems which will be included in the backup.
        """
        server_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the ECS instance to be backed up.
        """
elif False:
    CbrVaultResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CbrVaultResourceArgs:
    def __init__(__self__, *,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 server_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: The array of disk IDs which will be excluded in the backup.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: The array of disk or SFS file systems which will be included in the backup.
        :param pulumi.Input[builtins.str] server_id: The ID of the ECS instance to be backed up.
        """
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)
        if server_id is not None:
            pulumi.set(__self__, "server_id", server_id)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The array of disk IDs which will be excluded in the backup.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The array of disk or SFS file systems which will be included in the backup.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)

    @property
    @pulumi.getter(name="serverId")
    def server_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the ECS instance to be backed up.
        """
        return pulumi.get(self, "server_id")

    @server_id.setter
    def server_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_id", value)


if not MYPY:
    class CceAddonValuesArgsDict(TypedDict):
        basic: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        basic_json: NotRequired[pulumi.Input[builtins.str]]
        custom: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        custom_json: NotRequired[pulumi.Input[builtins.str]]
        flavor: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        flavor_json: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceAddonValuesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceAddonValuesArgs:
    def __init__(__self__, *,
                 basic: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 basic_json: Optional[pulumi.Input[builtins.str]] = None,
                 custom: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 custom_json: Optional[pulumi.Input[builtins.str]] = None,
                 flavor: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 flavor_json: Optional[pulumi.Input[builtins.str]] = None):
        if basic is not None:
            pulumi.set(__self__, "basic", basic)
        if basic_json is not None:
            pulumi.set(__self__, "basic_json", basic_json)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if custom_json is not None:
            pulumi.set(__self__, "custom_json", custom_json)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if flavor_json is not None:
            pulumi.set(__self__, "flavor_json", flavor_json)

    @property
    @pulumi.getter
    def basic(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "basic")

    @basic.setter
    def basic(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "basic", value)

    @property
    @pulumi.getter(name="basicJson")
    def basic_json(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "basic_json")

    @basic_json.setter
    def basic_json(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "basic_json", value)

    @property
    @pulumi.getter
    def custom(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "custom")

    @custom.setter
    def custom(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "custom", value)

    @property
    @pulumi.getter(name="customJson")
    def custom_json(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "custom_json")

    @custom_json.setter
    def custom_json(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "custom_json", value)

    @property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "flavor", value)

    @property
    @pulumi.getter(name="flavorJson")
    def flavor_json(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "flavor_json")

    @flavor_json.setter
    def flavor_json(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "flavor_json", value)


if not MYPY:
    class CceClusterCertificateClusterArgsDict(TypedDict):
        certificate_authority_data: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        server: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceClusterCertificateClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceClusterCertificateClusterArgs:
    def __init__(__self__, *,
                 certificate_authority_data: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 server: Optional[pulumi.Input[builtins.str]] = None):
        if certificate_authority_data is not None:
            pulumi.set(__self__, "certificate_authority_data", certificate_authority_data)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter(name="certificateAuthorityData")
    def certificate_authority_data(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "certificate_authority_data")

    @certificate_authority_data.setter
    def certificate_authority_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_authority_data", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server", value)


if not MYPY:
    class CceClusterCertificateUserArgsDict(TypedDict):
        client_certificate_data: NotRequired[pulumi.Input[builtins.str]]
        client_key_data: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceClusterCertificateUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceClusterCertificateUserArgs:
    def __init__(__self__, *,
                 client_certificate_data: Optional[pulumi.Input[builtins.str]] = None,
                 client_key_data: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        if client_certificate_data is not None:
            pulumi.set(__self__, "client_certificate_data", client_certificate_data)
        if client_key_data is not None:
            pulumi.set(__self__, "client_key_data", client_key_data)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="clientCertificateData")
    def client_certificate_data(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_certificate_data")

    @client_certificate_data.setter
    def client_certificate_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_certificate_data", value)

    @property
    @pulumi.getter(name="clientKeyData")
    def client_key_data(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_key_data")

    @client_key_data.setter
    def client_key_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_key_data", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CceClusterComponentConfigurationArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        configurations: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceClusterComponentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceClusterComponentConfigurationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 configurations: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "configurations", value)


if not MYPY:
    class CceClusterExtendParamArgsDict(TypedDict):
        cluster_az: NotRequired[pulumi.Input[builtins.str]]
        cpu_manager_policy: NotRequired[pulumi.Input[builtins.str]]
        dec_master_flavor: NotRequired[pulumi.Input[builtins.str]]
        docker_umask_mode: NotRequired[pulumi.Input[builtins.str]]
        dss_master_volumes: NotRequired[pulumi.Input[builtins.str]]
        fix_pool_mask: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceClusterExtendParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceClusterExtendParamArgs:
    def __init__(__self__, *,
                 cluster_az: Optional[pulumi.Input[builtins.str]] = None,
                 cpu_manager_policy: Optional[pulumi.Input[builtins.str]] = None,
                 dec_master_flavor: Optional[pulumi.Input[builtins.str]] = None,
                 docker_umask_mode: Optional[pulumi.Input[builtins.str]] = None,
                 dss_master_volumes: Optional[pulumi.Input[builtins.str]] = None,
                 fix_pool_mask: Optional[pulumi.Input[builtins.str]] = None):
        if cluster_az is not None:
            pulumi.set(__self__, "cluster_az", cluster_az)
        if cpu_manager_policy is not None:
            pulumi.set(__self__, "cpu_manager_policy", cpu_manager_policy)
        if dec_master_flavor is not None:
            pulumi.set(__self__, "dec_master_flavor", dec_master_flavor)
        if docker_umask_mode is not None:
            pulumi.set(__self__, "docker_umask_mode", docker_umask_mode)
        if dss_master_volumes is not None:
            pulumi.set(__self__, "dss_master_volumes", dss_master_volumes)
        if fix_pool_mask is not None:
            pulumi.set(__self__, "fix_pool_mask", fix_pool_mask)

    @property
    @pulumi.getter(name="clusterAz")
    def cluster_az(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cluster_az")

    @cluster_az.setter
    def cluster_az(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_az", value)

    @property
    @pulumi.getter(name="cpuManagerPolicy")
    def cpu_manager_policy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cpu_manager_policy")

    @cpu_manager_policy.setter
    def cpu_manager_policy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cpu_manager_policy", value)

    @property
    @pulumi.getter(name="decMasterFlavor")
    def dec_master_flavor(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dec_master_flavor")

    @dec_master_flavor.setter
    def dec_master_flavor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dec_master_flavor", value)

    @property
    @pulumi.getter(name="dockerUmaskMode")
    def docker_umask_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "docker_umask_mode")

    @docker_umask_mode.setter
    def docker_umask_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "docker_umask_mode", value)

    @property
    @pulumi.getter(name="dssMasterVolumes")
    def dss_master_volumes(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dss_master_volumes")

    @dss_master_volumes.setter
    def dss_master_volumes(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dss_master_volumes", value)

    @property
    @pulumi.getter(name="fixPoolMask")
    def fix_pool_mask(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "fix_pool_mask")

    @fix_pool_mask.setter
    def fix_pool_mask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fix_pool_mask", value)


if not MYPY:
    class CceClusterMasterArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceClusterMasterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceClusterMasterArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[builtins.str]] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_zone", value)


if not MYPY:
    class CceNodeAttachDataVolumeArgsDict(TypedDict):
        dss_pool_id: NotRequired[pulumi.Input[builtins.str]]
        extend_param: NotRequired[pulumi.Input[builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        hw_passthrough: NotRequired[pulumi.Input[builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[builtins.str]]
        size: NotRequired[pulumi.Input[builtins.int]]
        throughput: NotRequired[pulumi.Input[builtins.int]]
        volumetype: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodeAttachDataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeAttachDataVolumeArgs:
    def __init__(__self__, *,
                 dss_pool_id: Optional[pulumi.Input[builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[builtins.bool]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None,
                 volumetype: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] hw_passthrough: schema: Internal
        """
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volumetype is not None:
            pulumi.set(__self__, "volumetype", volumetype)

    @property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter
    def volumetype(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "volumetype", value)


if not MYPY:
    class CceNodeAttachHostnameConfigArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
elif False:
    CceNodeAttachHostnameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeAttachHostnameConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CceNodeAttachRootVolumeArgsDict(TypedDict):
        dss_pool_id: NotRequired[pulumi.Input[builtins.str]]
        extend_param: NotRequired[pulumi.Input[builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        hw_passthrough: NotRequired[pulumi.Input[builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[builtins.str]]
        size: NotRequired[pulumi.Input[builtins.int]]
        throughput: NotRequired[pulumi.Input[builtins.int]]
        volumetype: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodeAttachRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeAttachRootVolumeArgs:
    def __init__(__self__, *,
                 dss_pool_id: Optional[pulumi.Input[builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[builtins.bool]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None,
                 volumetype: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] hw_passthrough: schema: Internal
        """
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volumetype is not None:
            pulumi.set(__self__, "volumetype", volumetype)

    @property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)

    @property
    @pulumi.getter
    def volumetype(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "volumetype", value)


if not MYPY:
    class CceNodeAttachStorageArgsDict(TypedDict):
        groups: pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageGroupArgsDict']]]
        selectors: pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageSelectorArgsDict']]]
elif False:
    CceNodeAttachStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeAttachStorageArgs:
    def __init__(__self__, *,
                 groups: pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageGroupArgs']]],
                 selectors: pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageSelectorArgs']]]):
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageGroupArgs']]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageGroupArgs']]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageSelectorArgs']]]:
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageSelectorArgs']]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class CceNodeAttachStorageGroupArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        selector_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        virtual_spaces: pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageGroupVirtualSpaceArgsDict']]]
        cce_managed: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    CceNodeAttachStorageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeAttachStorageGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 selector_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 virtual_spaces: pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageGroupVirtualSpaceArgs']]],
                 cce_managed: Optional[pulumi.Input[builtins.bool]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "selector_names")

    @selector_names.setter
    def selector_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "selector_names", value)

    @property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageGroupVirtualSpaceArgs']]]:
        return pulumi.get(self, "virtual_spaces")

    @virtual_spaces.setter
    def virtual_spaces(self, value: pulumi.Input[Sequence[pulumi.Input['CceNodeAttachStorageGroupVirtualSpaceArgs']]]):
        pulumi.set(self, "virtual_spaces", value)

    @property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "cce_managed")

    @cce_managed.setter
    def cce_managed(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cce_managed", value)


if not MYPY:
    class CceNodeAttachStorageGroupVirtualSpaceArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        size: pulumi.Input[builtins.str]
        lvm_lv_type: NotRequired[pulumi.Input[builtins.str]]
        lvm_path: NotRequired[pulumi.Input[builtins.str]]
        runtime_lv_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodeAttachStorageGroupVirtualSpaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeAttachStorageGroupVirtualSpaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 size: pulumi.Input[builtins.str],
                 lvm_lv_type: Optional[pulumi.Input[builtins.str]] = None,
                 lvm_path: Optional[pulumi.Input[builtins.str]] = None,
                 runtime_lv_type: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "lvm_lv_type")

    @lvm_lv_type.setter
    def lvm_lv_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lvm_lv_type", value)

    @property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "lvm_path")

    @lvm_path.setter
    def lvm_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lvm_path", value)

    @property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "runtime_lv_type")

    @runtime_lv_type.setter
    def runtime_lv_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "runtime_lv_type", value)


if not MYPY:
    class CceNodeAttachStorageSelectorArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        match_label_count: NotRequired[pulumi.Input[builtins.str]]
        match_label_metadata_cmkid: NotRequired[pulumi.Input[builtins.str]]
        match_label_metadata_encrypted: NotRequired[pulumi.Input[builtins.str]]
        match_label_size: NotRequired[pulumi.Input[builtins.str]]
        match_label_volume_type: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodeAttachStorageSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeAttachStorageSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 match_label_count: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_metadata_cmkid: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_metadata_encrypted: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_size: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_volume_type: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_count")

    @match_label_count.setter
    def match_label_count(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_count", value)

    @property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_metadata_cmkid")

    @match_label_metadata_cmkid.setter
    def match_label_metadata_cmkid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_metadata_cmkid", value)

    @property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_metadata_encrypted")

    @match_label_metadata_encrypted.setter
    def match_label_metadata_encrypted(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_metadata_encrypted", value)

    @property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_size")

    @match_label_size.setter
    def match_label_size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_size", value)

    @property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_volume_type")

    @match_label_volume_type.setter
    def match_label_volume_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_volume_type", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CceNodeAttachTaintArgsDict(TypedDict):
        effect: pulumi.Input[builtins.str]
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    CceNodeAttachTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeAttachTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[builtins.str],
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CceNodeDataVolumeArgsDict(TypedDict):
        size: pulumi.Input[builtins.int]
        volumetype: pulumi.Input[builtins.str]
        dss_pool_id: NotRequired[pulumi.Input[builtins.str]]
        extend_param: NotRequired[pulumi.Input[builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        hw_passthrough: NotRequired[pulumi.Input[builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[builtins.str]]
        throughput: NotRequired[pulumi.Input[builtins.int]]
elif False:
    CceNodeDataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeDataVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[builtins.int],
                 volumetype: pulumi.Input[builtins.str],
                 dss_pool_id: Optional[pulumi.Input[builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[builtins.bool]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] hw_passthrough: schema: Internal
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "volumetype", value)

    @property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class CceNodeExtendParamsArgsDict(TypedDict):
        agency_name: NotRequired[pulumi.Input[builtins.str]]
        docker_base_size: NotRequired[pulumi.Input[builtins.int]]
        kube_reserved_mem: NotRequired[pulumi.Input[builtins.int]]
        market_type: NotRequired[pulumi.Input[builtins.str]]
        max_pods: NotRequired[pulumi.Input[builtins.int]]
        nic_threshold: NotRequired[pulumi.Input[builtins.str]]
        node_image_id: NotRequired[pulumi.Input[builtins.str]]
        node_multi_queue: NotRequired[pulumi.Input[builtins.str]]
        postinstall: NotRequired[pulumi.Input[builtins.str]]
        preinstall: NotRequired[pulumi.Input[builtins.str]]
        security_reinforcement_type: NotRequired[pulumi.Input[builtins.str]]
        spot_price: NotRequired[pulumi.Input[builtins.str]]
        system_reserved_mem: NotRequired[pulumi.Input[builtins.int]]
elif False:
    CceNodeExtendParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeExtendParamsArgs:
    def __init__(__self__, *,
                 agency_name: Optional[pulumi.Input[builtins.str]] = None,
                 docker_base_size: Optional[pulumi.Input[builtins.int]] = None,
                 kube_reserved_mem: Optional[pulumi.Input[builtins.int]] = None,
                 market_type: Optional[pulumi.Input[builtins.str]] = None,
                 max_pods: Optional[pulumi.Input[builtins.int]] = None,
                 nic_threshold: Optional[pulumi.Input[builtins.str]] = None,
                 node_image_id: Optional[pulumi.Input[builtins.str]] = None,
                 node_multi_queue: Optional[pulumi.Input[builtins.str]] = None,
                 postinstall: Optional[pulumi.Input[builtins.str]] = None,
                 preinstall: Optional[pulumi.Input[builtins.str]] = None,
                 security_reinforcement_type: Optional[pulumi.Input[builtins.str]] = None,
                 spot_price: Optional[pulumi.Input[builtins.str]] = None,
                 system_reserved_mem: Optional[pulumi.Input[builtins.int]] = None):
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if docker_base_size is not None:
            pulumi.set(__self__, "docker_base_size", docker_base_size)
        if kube_reserved_mem is not None:
            pulumi.set(__self__, "kube_reserved_mem", kube_reserved_mem)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if nic_threshold is not None:
            pulumi.set(__self__, "nic_threshold", nic_threshold)
        if node_image_id is not None:
            pulumi.set(__self__, "node_image_id", node_image_id)
        if node_multi_queue is not None:
            pulumi.set(__self__, "node_multi_queue", node_multi_queue)
        if postinstall is not None:
            pulumi.set(__self__, "postinstall", postinstall)
        if preinstall is not None:
            pulumi.set(__self__, "preinstall", preinstall)
        if security_reinforcement_type is not None:
            pulumi.set(__self__, "security_reinforcement_type", security_reinforcement_type)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if system_reserved_mem is not None:
            pulumi.set(__self__, "system_reserved_mem", system_reserved_mem)

    @property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "agency_name")

    @agency_name.setter
    def agency_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "agency_name", value)

    @property
    @pulumi.getter(name="dockerBaseSize")
    def docker_base_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "docker_base_size")

    @docker_base_size.setter
    def docker_base_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "docker_base_size", value)

    @property
    @pulumi.getter(name="kubeReservedMem")
    def kube_reserved_mem(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "kube_reserved_mem")

    @kube_reserved_mem.setter
    def kube_reserved_mem(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "kube_reserved_mem", value)

    @property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "market_type")

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "market_type", value)

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_pods")

    @max_pods.setter
    def max_pods(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_pods", value)

    @property
    @pulumi.getter(name="nicThreshold")
    def nic_threshold(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "nic_threshold")

    @nic_threshold.setter
    def nic_threshold(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nic_threshold", value)

    @property
    @pulumi.getter(name="nodeImageId")
    def node_image_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "node_image_id")

    @node_image_id.setter
    def node_image_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "node_image_id", value)

    @property
    @pulumi.getter(name="nodeMultiQueue")
    def node_multi_queue(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "node_multi_queue")

    @node_multi_queue.setter
    def node_multi_queue(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "node_multi_queue", value)

    @property
    @pulumi.getter
    def postinstall(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "postinstall")

    @postinstall.setter
    def postinstall(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "postinstall", value)

    @property
    @pulumi.getter
    def preinstall(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "preinstall")

    @preinstall.setter
    def preinstall(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preinstall", value)

    @property
    @pulumi.getter(name="securityReinforcementType")
    def security_reinforcement_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "security_reinforcement_type")

    @security_reinforcement_type.setter
    def security_reinforcement_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "security_reinforcement_type", value)

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spot_price", value)

    @property
    @pulumi.getter(name="systemReservedMem")
    def system_reserved_mem(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "system_reserved_mem")

    @system_reserved_mem.setter
    def system_reserved_mem(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "system_reserved_mem", value)


if not MYPY:
    class CceNodeExtensionNicArgsDict(TypedDict):
        subnet_id: pulumi.Input[builtins.str]
elif False:
    CceNodeExtensionNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeExtensionNicArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class CceNodeHostnameConfigArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
elif False:
    CceNodeHostnameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeHostnameConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CceNodePoolDataVolumeArgsDict(TypedDict):
        size: pulumi.Input[builtins.int]
        volumetype: pulumi.Input[builtins.str]
        dss_pool_id: NotRequired[pulumi.Input[builtins.str]]
        extend_param: NotRequired[pulumi.Input[builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        hw_passthrough: NotRequired[pulumi.Input[builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[builtins.str]]
        throughput: NotRequired[pulumi.Input[builtins.int]]
elif False:
    CceNodePoolDataVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolDataVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[builtins.int],
                 volumetype: pulumi.Input[builtins.str],
                 dss_pool_id: Optional[pulumi.Input[builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[builtins.bool]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] hw_passthrough: schema: Internal
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "volumetype", value)

    @property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class CceNodePoolExtendParamsArgsDict(TypedDict):
        agency_name: NotRequired[pulumi.Input[builtins.str]]
        docker_base_size: NotRequired[pulumi.Input[builtins.int]]
        kube_reserved_mem: NotRequired[pulumi.Input[builtins.int]]
        market_type: NotRequired[pulumi.Input[builtins.str]]
        max_pods: NotRequired[pulumi.Input[builtins.int]]
        nic_threshold: NotRequired[pulumi.Input[builtins.str]]
        node_image_id: NotRequired[pulumi.Input[builtins.str]]
        node_multi_queue: NotRequired[pulumi.Input[builtins.str]]
        postinstall: NotRequired[pulumi.Input[builtins.str]]
        preinstall: NotRequired[pulumi.Input[builtins.str]]
        security_reinforcement_type: NotRequired[pulumi.Input[builtins.str]]
        spot_price: NotRequired[pulumi.Input[builtins.str]]
        system_reserved_mem: NotRequired[pulumi.Input[builtins.int]]
elif False:
    CceNodePoolExtendParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolExtendParamsArgs:
    def __init__(__self__, *,
                 agency_name: Optional[pulumi.Input[builtins.str]] = None,
                 docker_base_size: Optional[pulumi.Input[builtins.int]] = None,
                 kube_reserved_mem: Optional[pulumi.Input[builtins.int]] = None,
                 market_type: Optional[pulumi.Input[builtins.str]] = None,
                 max_pods: Optional[pulumi.Input[builtins.int]] = None,
                 nic_threshold: Optional[pulumi.Input[builtins.str]] = None,
                 node_image_id: Optional[pulumi.Input[builtins.str]] = None,
                 node_multi_queue: Optional[pulumi.Input[builtins.str]] = None,
                 postinstall: Optional[pulumi.Input[builtins.str]] = None,
                 preinstall: Optional[pulumi.Input[builtins.str]] = None,
                 security_reinforcement_type: Optional[pulumi.Input[builtins.str]] = None,
                 spot_price: Optional[pulumi.Input[builtins.str]] = None,
                 system_reserved_mem: Optional[pulumi.Input[builtins.int]] = None):
        if agency_name is not None:
            pulumi.set(__self__, "agency_name", agency_name)
        if docker_base_size is not None:
            pulumi.set(__self__, "docker_base_size", docker_base_size)
        if kube_reserved_mem is not None:
            pulumi.set(__self__, "kube_reserved_mem", kube_reserved_mem)
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if nic_threshold is not None:
            pulumi.set(__self__, "nic_threshold", nic_threshold)
        if node_image_id is not None:
            pulumi.set(__self__, "node_image_id", node_image_id)
        if node_multi_queue is not None:
            pulumi.set(__self__, "node_multi_queue", node_multi_queue)
        if postinstall is not None:
            pulumi.set(__self__, "postinstall", postinstall)
        if preinstall is not None:
            pulumi.set(__self__, "preinstall", preinstall)
        if security_reinforcement_type is not None:
            pulumi.set(__self__, "security_reinforcement_type", security_reinforcement_type)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if system_reserved_mem is not None:
            pulumi.set(__self__, "system_reserved_mem", system_reserved_mem)

    @property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "agency_name")

    @agency_name.setter
    def agency_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "agency_name", value)

    @property
    @pulumi.getter(name="dockerBaseSize")
    def docker_base_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "docker_base_size")

    @docker_base_size.setter
    def docker_base_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "docker_base_size", value)

    @property
    @pulumi.getter(name="kubeReservedMem")
    def kube_reserved_mem(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "kube_reserved_mem")

    @kube_reserved_mem.setter
    def kube_reserved_mem(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "kube_reserved_mem", value)

    @property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "market_type")

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "market_type", value)

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_pods")

    @max_pods.setter
    def max_pods(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_pods", value)

    @property
    @pulumi.getter(name="nicThreshold")
    def nic_threshold(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "nic_threshold")

    @nic_threshold.setter
    def nic_threshold(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nic_threshold", value)

    @property
    @pulumi.getter(name="nodeImageId")
    def node_image_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "node_image_id")

    @node_image_id.setter
    def node_image_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "node_image_id", value)

    @property
    @pulumi.getter(name="nodeMultiQueue")
    def node_multi_queue(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "node_multi_queue")

    @node_multi_queue.setter
    def node_multi_queue(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "node_multi_queue", value)

    @property
    @pulumi.getter
    def postinstall(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "postinstall")

    @postinstall.setter
    def postinstall(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "postinstall", value)

    @property
    @pulumi.getter
    def preinstall(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "preinstall")

    @preinstall.setter
    def preinstall(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preinstall", value)

    @property
    @pulumi.getter(name="securityReinforcementType")
    def security_reinforcement_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "security_reinforcement_type")

    @security_reinforcement_type.setter
    def security_reinforcement_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "security_reinforcement_type", value)

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spot_price", value)

    @property
    @pulumi.getter(name="systemReservedMem")
    def system_reserved_mem(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "system_reserved_mem")

    @system_reserved_mem.setter
    def system_reserved_mem(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "system_reserved_mem", value)


if not MYPY:
    class CceNodePoolExtensionScaleGroupArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input['CceNodePoolExtensionScaleGroupMetadataArgsDict']]
        spec: NotRequired[pulumi.Input['CceNodePoolExtensionScaleGroupSpecArgsDict']]
elif False:
    CceNodePoolExtensionScaleGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolExtensionScaleGroupArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input['CceNodePoolExtensionScaleGroupMetadataArgs']] = None,
                 spec: Optional[pulumi.Input['CceNodePoolExtensionScaleGroupSpecArgs']] = None):
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['CceNodePoolExtensionScaleGroupMetadataArgs']]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['CceNodePoolExtensionScaleGroupMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['CceNodePoolExtensionScaleGroupSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['CceNodePoolExtensionScaleGroupSpecArgs']]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class CceNodePoolExtensionScaleGroupMetadataArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodePoolExtensionScaleGroupMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolExtensionScaleGroupMetadataArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CceNodePoolExtensionScaleGroupSpecArgsDict(TypedDict):
        autoscaling: NotRequired[pulumi.Input['CceNodePoolExtensionScaleGroupSpecAutoscalingArgsDict']]
        az: NotRequired[pulumi.Input[builtins.str]]
        capacity_reservation_specification: NotRequired[pulumi.Input['CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgsDict']]
        flavor: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodePoolExtensionScaleGroupSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolExtensionScaleGroupSpecArgs:
    def __init__(__self__, *,
                 autoscaling: Optional[pulumi.Input['CceNodePoolExtensionScaleGroupSpecAutoscalingArgs']] = None,
                 az: Optional[pulumi.Input[builtins.str]] = None,
                 capacity_reservation_specification: Optional[pulumi.Input['CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs']] = None,
                 flavor: Optional[pulumi.Input[builtins.str]] = None):
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if az is not None:
            pulumi.set(__self__, "az", az)
        if capacity_reservation_specification is not None:
            pulumi.set(__self__, "capacity_reservation_specification", capacity_reservation_specification)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)

    @property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['CceNodePoolExtensionScaleGroupSpecAutoscalingArgs']]:
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['CceNodePoolExtensionScaleGroupSpecAutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @property
    @pulumi.getter
    def az(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "az")

    @az.setter
    def az(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "az", value)

    @property
    @pulumi.getter(name="capacityReservationSpecification")
    def capacity_reservation_specification(self) -> Optional[pulumi.Input['CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs']]:
        return pulumi.get(self, "capacity_reservation_specification")

    @capacity_reservation_specification.setter
    def capacity_reservation_specification(self, value: Optional[pulumi.Input['CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs']]):
        pulumi.set(self, "capacity_reservation_specification", value)

    @property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "flavor", value)


if not MYPY:
    class CceNodePoolExtensionScaleGroupSpecAutoscalingArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[builtins.bool]]
        extension_priority: NotRequired[pulumi.Input[builtins.int]]
        max_node_count: NotRequired[pulumi.Input[builtins.int]]
        min_node_count: NotRequired[pulumi.Input[builtins.int]]
elif False:
    CceNodePoolExtensionScaleGroupSpecAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolExtensionScaleGroupSpecAutoscalingArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 extension_priority: Optional[pulumi.Input[builtins.int]] = None,
                 max_node_count: Optional[pulumi.Input[builtins.int]] = None,
                 min_node_count: Optional[pulumi.Input[builtins.int]] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if extension_priority is not None:
            pulumi.set(__self__, "extension_priority", extension_priority)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="extensionPriority")
    def extension_priority(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "extension_priority")

    @extension_priority.setter
    def extension_priority(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "extension_priority", value)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_node_count", value)

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_node_count", value)


if not MYPY:
    class CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        preference: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolExtensionScaleGroupSpecCapacityReservationSpecificationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 preference: Optional[pulumi.Input[builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preference", value)


if not MYPY:
    class CceNodePoolHostnameConfigArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
elif False:
    CceNodePoolHostnameConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolHostnameConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CceNodePoolRootVolumeArgsDict(TypedDict):
        size: pulumi.Input[builtins.int]
        volumetype: pulumi.Input[builtins.str]
        dss_pool_id: NotRequired[pulumi.Input[builtins.str]]
        extend_param: NotRequired[pulumi.Input[builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        hw_passthrough: NotRequired[pulumi.Input[builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[builtins.str]]
        throughput: NotRequired[pulumi.Input[builtins.int]]
elif False:
    CceNodePoolRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolRootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[builtins.int],
                 volumetype: pulumi.Input[builtins.str],
                 dss_pool_id: Optional[pulumi.Input[builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[builtins.bool]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] hw_passthrough: schema: Internal
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "volumetype", value)

    @property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class CceNodePoolStorageArgsDict(TypedDict):
        groups: pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageGroupArgsDict']]]
        selectors: pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageSelectorArgsDict']]]
elif False:
    CceNodePoolStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolStorageArgs:
    def __init__(__self__, *,
                 groups: pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageGroupArgs']]],
                 selectors: pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageSelectorArgs']]]):
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageGroupArgs']]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageGroupArgs']]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageSelectorArgs']]]:
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageSelectorArgs']]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class CceNodePoolStorageGroupArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        selector_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        virtual_spaces: pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageGroupVirtualSpaceArgsDict']]]
        cce_managed: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    CceNodePoolStorageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolStorageGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 selector_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 virtual_spaces: pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageGroupVirtualSpaceArgs']]],
                 cce_managed: Optional[pulumi.Input[builtins.bool]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "selector_names")

    @selector_names.setter
    def selector_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "selector_names", value)

    @property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageGroupVirtualSpaceArgs']]]:
        return pulumi.get(self, "virtual_spaces")

    @virtual_spaces.setter
    def virtual_spaces(self, value: pulumi.Input[Sequence[pulumi.Input['CceNodePoolStorageGroupVirtualSpaceArgs']]]):
        pulumi.set(self, "virtual_spaces", value)

    @property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "cce_managed")

    @cce_managed.setter
    def cce_managed(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cce_managed", value)


if not MYPY:
    class CceNodePoolStorageGroupVirtualSpaceArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        size: pulumi.Input[builtins.str]
        lvm_lv_type: NotRequired[pulumi.Input[builtins.str]]
        lvm_path: NotRequired[pulumi.Input[builtins.str]]
        runtime_lv_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodePoolStorageGroupVirtualSpaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolStorageGroupVirtualSpaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 size: pulumi.Input[builtins.str],
                 lvm_lv_type: Optional[pulumi.Input[builtins.str]] = None,
                 lvm_path: Optional[pulumi.Input[builtins.str]] = None,
                 runtime_lv_type: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "lvm_lv_type")

    @lvm_lv_type.setter
    def lvm_lv_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lvm_lv_type", value)

    @property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "lvm_path")

    @lvm_path.setter
    def lvm_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lvm_path", value)

    @property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "runtime_lv_type")

    @runtime_lv_type.setter
    def runtime_lv_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "runtime_lv_type", value)


if not MYPY:
    class CceNodePoolStorageSelectorArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        match_label_count: NotRequired[pulumi.Input[builtins.str]]
        match_label_metadata_cmkid: NotRequired[pulumi.Input[builtins.str]]
        match_label_metadata_encrypted: NotRequired[pulumi.Input[builtins.str]]
        match_label_size: NotRequired[pulumi.Input[builtins.str]]
        match_label_volume_type: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodePoolStorageSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolStorageSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 match_label_count: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_metadata_cmkid: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_metadata_encrypted: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_size: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_volume_type: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_count")

    @match_label_count.setter
    def match_label_count(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_count", value)

    @property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_metadata_cmkid")

    @match_label_metadata_cmkid.setter
    def match_label_metadata_cmkid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_metadata_cmkid", value)

    @property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_metadata_encrypted")

    @match_label_metadata_encrypted.setter
    def match_label_metadata_encrypted(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_metadata_encrypted", value)

    @property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_size")

    @match_label_size.setter
    def match_label_size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_size", value)

    @property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_volume_type")

    @match_label_volume_type.setter
    def match_label_volume_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_volume_type", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CceNodePoolTaintArgsDict(TypedDict):
        effect: pulumi.Input[builtins.str]
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    CceNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[builtins.str],
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CceNodeRootVolumeArgsDict(TypedDict):
        size: pulumi.Input[builtins.int]
        volumetype: pulumi.Input[builtins.str]
        dss_pool_id: NotRequired[pulumi.Input[builtins.str]]
        extend_param: NotRequired[pulumi.Input[builtins.str]]
        extend_params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        hw_passthrough: NotRequired[pulumi.Input[builtins.bool]]
        """
        schema: Internal
        """
        iops: NotRequired[pulumi.Input[builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[builtins.str]]
        throughput: NotRequired[pulumi.Input[builtins.int]]
elif False:
    CceNodeRootVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeRootVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[builtins.int],
                 volumetype: pulumi.Input[builtins.str],
                 dss_pool_id: Optional[pulumi.Input[builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[builtins.str]] = None,
                 extend_params: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 hw_passthrough: Optional[pulumi.Input[builtins.bool]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.bool] hw_passthrough: schema: Internal
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volumetype", volumetype)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if extend_param is not None:
            warnings.warn("""use extend_params instead""", DeprecationWarning)
            pulumi.log.warn("""extend_param is deprecated: use extend_params instead""")
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if extend_params is not None:
            pulumi.set(__self__, "extend_params", extend_params)
        if hw_passthrough is not None:
            pulumi.set(__self__, "hw_passthrough", hw_passthrough)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def volumetype(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "volumetype")

    @volumetype.setter
    def volumetype(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "volumetype", value)

    @property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @property
    @pulumi.getter(name="extendParam")
    @_utilities.deprecated("""use extend_params instead""")
    def extend_param(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "extend_param", value)

    @property
    @pulumi.getter(name="extendParams")
    def extend_params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "extend_params")

    @extend_params.setter
    def extend_params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extend_params", value)

    @property
    @pulumi.getter(name="hwPassthrough")
    def hw_passthrough(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "hw_passthrough")

    @hw_passthrough.setter
    def hw_passthrough(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "hw_passthrough", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class CceNodeStorageArgsDict(TypedDict):
        groups: pulumi.Input[Sequence[pulumi.Input['CceNodeStorageGroupArgsDict']]]
        selectors: pulumi.Input[Sequence[pulumi.Input['CceNodeStorageSelectorArgsDict']]]
elif False:
    CceNodeStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeStorageArgs:
    def __init__(__self__, *,
                 groups: pulumi.Input[Sequence[pulumi.Input['CceNodeStorageGroupArgs']]],
                 selectors: pulumi.Input[Sequence[pulumi.Input['CceNodeStorageSelectorArgs']]]):
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "selectors", selectors)

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Input[Sequence[pulumi.Input['CceNodeStorageGroupArgs']]]:
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: pulumi.Input[Sequence[pulumi.Input['CceNodeStorageGroupArgs']]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def selectors(self) -> pulumi.Input[Sequence[pulumi.Input['CceNodeStorageSelectorArgs']]]:
        return pulumi.get(self, "selectors")

    @selectors.setter
    def selectors(self, value: pulumi.Input[Sequence[pulumi.Input['CceNodeStorageSelectorArgs']]]):
        pulumi.set(self, "selectors", value)


if not MYPY:
    class CceNodeStorageGroupArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        selector_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        virtual_spaces: pulumi.Input[Sequence[pulumi.Input['CceNodeStorageGroupVirtualSpaceArgsDict']]]
        cce_managed: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    CceNodeStorageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeStorageGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 selector_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 virtual_spaces: pulumi.Input[Sequence[pulumi.Input['CceNodeStorageGroupVirtualSpaceArgs']]],
                 cce_managed: Optional[pulumi.Input[builtins.bool]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "selector_names", selector_names)
        pulumi.set(__self__, "virtual_spaces", virtual_spaces)
        if cce_managed is not None:
            pulumi.set(__self__, "cce_managed", cce_managed)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="selectorNames")
    def selector_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "selector_names")

    @selector_names.setter
    def selector_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "selector_names", value)

    @property
    @pulumi.getter(name="virtualSpaces")
    def virtual_spaces(self) -> pulumi.Input[Sequence[pulumi.Input['CceNodeStorageGroupVirtualSpaceArgs']]]:
        return pulumi.get(self, "virtual_spaces")

    @virtual_spaces.setter
    def virtual_spaces(self, value: pulumi.Input[Sequence[pulumi.Input['CceNodeStorageGroupVirtualSpaceArgs']]]):
        pulumi.set(self, "virtual_spaces", value)

    @property
    @pulumi.getter(name="cceManaged")
    def cce_managed(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "cce_managed")

    @cce_managed.setter
    def cce_managed(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cce_managed", value)


if not MYPY:
    class CceNodeStorageGroupVirtualSpaceArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        size: pulumi.Input[builtins.str]
        lvm_lv_type: NotRequired[pulumi.Input[builtins.str]]
        lvm_path: NotRequired[pulumi.Input[builtins.str]]
        runtime_lv_type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodeStorageGroupVirtualSpaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeStorageGroupVirtualSpaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 size: pulumi.Input[builtins.str],
                 lvm_lv_type: Optional[pulumi.Input[builtins.str]] = None,
                 lvm_path: Optional[pulumi.Input[builtins.str]] = None,
                 runtime_lv_type: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if lvm_lv_type is not None:
            pulumi.set(__self__, "lvm_lv_type", lvm_lv_type)
        if lvm_path is not None:
            pulumi.set(__self__, "lvm_path", lvm_path)
        if runtime_lv_type is not None:
            pulumi.set(__self__, "runtime_lv_type", runtime_lv_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="lvmLvType")
    def lvm_lv_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "lvm_lv_type")

    @lvm_lv_type.setter
    def lvm_lv_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lvm_lv_type", value)

    @property
    @pulumi.getter(name="lvmPath")
    def lvm_path(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "lvm_path")

    @lvm_path.setter
    def lvm_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lvm_path", value)

    @property
    @pulumi.getter(name="runtimeLvType")
    def runtime_lv_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "runtime_lv_type")

    @runtime_lv_type.setter
    def runtime_lv_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "runtime_lv_type", value)


if not MYPY:
    class CceNodeStorageSelectorArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        match_label_count: NotRequired[pulumi.Input[builtins.str]]
        match_label_metadata_cmkid: NotRequired[pulumi.Input[builtins.str]]
        match_label_metadata_encrypted: NotRequired[pulumi.Input[builtins.str]]
        match_label_size: NotRequired[pulumi.Input[builtins.str]]
        match_label_volume_type: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodeStorageSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeStorageSelectorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 match_label_count: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_metadata_cmkid: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_metadata_encrypted: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_size: Optional[pulumi.Input[builtins.str]] = None,
                 match_label_volume_type: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if match_label_count is not None:
            pulumi.set(__self__, "match_label_count", match_label_count)
        if match_label_metadata_cmkid is not None:
            pulumi.set(__self__, "match_label_metadata_cmkid", match_label_metadata_cmkid)
        if match_label_metadata_encrypted is not None:
            pulumi.set(__self__, "match_label_metadata_encrypted", match_label_metadata_encrypted)
        if match_label_size is not None:
            pulumi.set(__self__, "match_label_size", match_label_size)
        if match_label_volume_type is not None:
            pulumi.set(__self__, "match_label_volume_type", match_label_volume_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="matchLabelCount")
    def match_label_count(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_count")

    @match_label_count.setter
    def match_label_count(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_count", value)

    @property
    @pulumi.getter(name="matchLabelMetadataCmkid")
    def match_label_metadata_cmkid(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_metadata_cmkid")

    @match_label_metadata_cmkid.setter
    def match_label_metadata_cmkid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_metadata_cmkid", value)

    @property
    @pulumi.getter(name="matchLabelMetadataEncrypted")
    def match_label_metadata_encrypted(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_metadata_encrypted")

    @match_label_metadata_encrypted.setter
    def match_label_metadata_encrypted(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_metadata_encrypted", value)

    @property
    @pulumi.getter(name="matchLabelSize")
    def match_label_size(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_size")

    @match_label_size.setter
    def match_label_size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_size", value)

    @property
    @pulumi.getter(name="matchLabelVolumeType")
    def match_label_volume_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "match_label_volume_type")

    @match_label_volume_type.setter
    def match_label_volume_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_label_volume_type", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CceNodeTaintArgsDict(TypedDict):
        effect: pulumi.Input[builtins.str]
        key: pulumi.Input[builtins.str]
        value: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CceNodeTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CceNodeTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[builtins.str],
                 key: pulumi.Input[builtins.str],
                 value: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CdmClusterInstanceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        manage_ip: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        private_ip: NotRequired[pulumi.Input[builtins.str]]
        public_ip: NotRequired[pulumi.Input[builtins.str]]
        role: NotRequired[pulumi.Input[builtins.str]]
        traffic_ip: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CdmClusterInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CdmClusterInstanceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 manage_ip: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 traffic_ip: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if manage_ip is not None:
            pulumi.set(__self__, "manage_ip", manage_ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if traffic_ip is not None:
            pulumi.set(__self__, "traffic_ip", traffic_ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="manageIp")
    def manage_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "manage_ip")

    @manage_ip.setter
    def manage_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "manage_ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="trafficIp")
    def traffic_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "traffic_ip")

    @traffic_ip.setter
    def traffic_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "traffic_ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CesAlarmruleAlarmActionArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        type: pulumi.Input[builtins.str]
elif False:
    CesAlarmruleAlarmActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CesAlarmruleAlarmActionArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CesAlarmruleConditionArgsDict(TypedDict):
        comparison_operator: pulumi.Input[builtins.str]
        count: pulumi.Input[builtins.int]
        filter: pulumi.Input[builtins.str]
        period: pulumi.Input[builtins.int]
        value: pulumi.Input[builtins.int]
        suppress_duration: NotRequired[pulumi.Input[builtins.int]]
        unit: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CesAlarmruleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CesAlarmruleConditionArgs:
    def __init__(__self__, *,
                 comparison_operator: pulumi.Input[builtins.str],
                 count: pulumi.Input[builtins.int],
                 filter: pulumi.Input[builtins.str],
                 period: pulumi.Input[builtins.int],
                 value: pulumi.Input[builtins.int],
                 suppress_duration: Optional[pulumi.Input[builtins.int]] = None,
                 unit: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "comparison_operator", comparison_operator)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "value", value)
        if suppress_duration is not None:
            pulumi.set(__self__, "suppress_duration", suppress_duration)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="suppressDuration")
    def suppress_duration(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "suppress_duration")

    @suppress_duration.setter
    def suppress_duration(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "suppress_duration", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class CesAlarmruleInsufficientdataActionArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        type: pulumi.Input[builtins.str]
elif False:
    CesAlarmruleInsufficientdataActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CesAlarmruleInsufficientdataActionArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CesAlarmruleMetricArgsDict(TypedDict):
        metric_name: pulumi.Input[builtins.str]
        namespace: pulumi.Input[builtins.str]
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CesAlarmruleMetricDimensionArgsDict']]]]
elif False:
    CesAlarmruleMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CesAlarmruleMetricArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[builtins.str],
                 namespace: pulumi.Input[builtins.str],
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['CesAlarmruleMetricDimensionArgs']]]] = None):
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "namespace", namespace)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CesAlarmruleMetricDimensionArgs']]]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CesAlarmruleMetricDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)


if not MYPY:
    class CesAlarmruleMetricDimensionArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    CesAlarmruleMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CesAlarmruleMetricDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CesAlarmruleOkActionArgsDict(TypedDict):
        notification_lists: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        type: pulumi.Input[builtins.str]
elif False:
    CesAlarmruleOkActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CesAlarmruleOkActionArgs:
    def __init__(__self__, *,
                 notification_lists: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "notification_lists", notification_lists)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="notificationLists")
    def notification_lists(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "notification_lists")

    @notification_lists.setter
    def notification_lists(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "notification_lists", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ComputeInstanceBandwidthArgsDict(TypedDict):
        share_type: pulumi.Input[builtins.str]
        charge_mode: NotRequired[pulumi.Input[builtins.str]]
        extend_param: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        id: NotRequired[pulumi.Input[builtins.str]]
        size: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ComputeInstanceBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceBandwidthArgs:
    def __init__(__self__, *,
                 share_type: pulumi.Input[builtins.str],
                 charge_mode: Optional[pulumi.Input[builtins.str]] = None,
                 extend_param: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "share_type", share_type)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if extend_param is not None:
            pulumi.set(__self__, "extend_param", extend_param)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="shareType")
    def share_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "share_type")

    @share_type.setter
    def share_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "share_type", value)

    @property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @property
    @pulumi.getter(name="extendParam")
    def extend_param(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "extend_param")

    @extend_param.setter
    def extend_param(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "extend_param", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class ComputeInstanceDataDiskArgsDict(TypedDict):
        size: pulumi.Input[builtins.int]
        type: pulumi.Input[builtins.str]
        dss_pool_id: NotRequired[pulumi.Input[builtins.str]]
        iops: NotRequired[pulumi.Input[builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[builtins.str]]
        snapshot_id: NotRequired[pulumi.Input[builtins.str]]
        throughput: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ComputeInstanceDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceDataDiskArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[builtins.int],
                 type: pulumi.Input[builtins.str],
                 dss_pool_id: Optional[pulumi.Input[builtins.str]] = None,
                 iops: Optional[pulumi.Input[builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[builtins.str]] = None,
                 throughput: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if dss_pool_id is not None:
            pulumi.set(__self__, "dss_pool_id", dss_pool_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dssPoolId")
    def dss_pool_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "dss_pool_id")

    @dss_pool_id.setter
    def dss_pool_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dss_pool_id", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class ComputeInstanceNetworkArgsDict(TypedDict):
        access_network: NotRequired[pulumi.Input[builtins.bool]]
        fixed_ip_v4: NotRequired[pulumi.Input[builtins.str]]
        fixed_ip_v6: NotRequired[pulumi.Input[builtins.str]]
        """
        schema: Computed
        """
        ipv6_enable: NotRequired[pulumi.Input[builtins.bool]]
        mac: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        """
        schema: Computed
        """
        source_dest_check: NotRequired[pulumi.Input[builtins.bool]]
        uuid: NotRequired[pulumi.Input[builtins.str]]
        """
        schema: Required
        """
elif False:
    ComputeInstanceNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceNetworkArgs:
    def __init__(__self__, *,
                 access_network: Optional[pulumi.Input[builtins.bool]] = None,
                 fixed_ip_v4: Optional[pulumi.Input[builtins.str]] = None,
                 fixed_ip_v6: Optional[pulumi.Input[builtins.str]] = None,
                 ipv6_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 mac: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 source_dest_check: Optional[pulumi.Input[builtins.bool]] = None,
                 uuid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] fixed_ip_v6: schema: Computed
        :param pulumi.Input[builtins.str] port: schema: Computed
        :param pulumi.Input[builtins.str] uuid: schema: Required
        """
        if access_network is not None:
            pulumi.set(__self__, "access_network", access_network)
        if fixed_ip_v4 is not None:
            pulumi.set(__self__, "fixed_ip_v4", fixed_ip_v4)
        if fixed_ip_v6 is not None:
            pulumi.set(__self__, "fixed_ip_v6", fixed_ip_v6)
        if ipv6_enable is not None:
            pulumi.set(__self__, "ipv6_enable", ipv6_enable)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if source_dest_check is not None:
            pulumi.set(__self__, "source_dest_check", source_dest_check)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter(name="accessNetwork")
    def access_network(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "access_network")

    @access_network.setter
    def access_network(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "access_network", value)

    @property
    @pulumi.getter(name="fixedIpV4")
    def fixed_ip_v4(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "fixed_ip_v4")

    @fixed_ip_v4.setter
    def fixed_ip_v4(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fixed_ip_v4", value)

    @property
    @pulumi.getter(name="fixedIpV6")
    def fixed_ip_v6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        schema: Computed
        """
        return pulumi.get(self, "fixed_ip_v6")

    @fixed_ip_v6.setter
    def fixed_ip_v6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fixed_ip_v6", value)

    @property
    @pulumi.getter(name="ipv6Enable")
    def ipv6_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "ipv6_enable")

    @ipv6_enable.setter
    def ipv6_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ipv6_enable", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        schema: Computed
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sourceDestCheck")
    def source_dest_check(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "source_dest_check")

    @source_dest_check.setter
    def source_dest_check(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "source_dest_check", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        schema: Required
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ComputeInstanceSchedulerHintArgsDict(TypedDict):
        deh_id: NotRequired[pulumi.Input[builtins.str]]
        fault_domain: NotRequired[pulumi.Input[builtins.str]]
        """
        schema: Internal
        """
        group: NotRequired[pulumi.Input[builtins.str]]
        tenancy: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ComputeInstanceSchedulerHintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceSchedulerHintArgs:
    def __init__(__self__, *,
                 deh_id: Optional[pulumi.Input[builtins.str]] = None,
                 fault_domain: Optional[pulumi.Input[builtins.str]] = None,
                 group: Optional[pulumi.Input[builtins.str]] = None,
                 tenancy: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] fault_domain: schema: Internal
        """
        if deh_id is not None:
            pulumi.set(__self__, "deh_id", deh_id)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter(name="dehId")
    def deh_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "deh_id")

    @deh_id.setter
    def deh_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "deh_id", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        schema: Internal
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenancy", value)


if not MYPY:
    class ComputeInstanceVolumeAttachedArgsDict(TypedDict):
        boot_index: NotRequired[pulumi.Input[builtins.int]]
        kms_key_id: NotRequired[pulumi.Input[builtins.str]]
        pci_address: NotRequired[pulumi.Input[builtins.str]]
        size: NotRequired[pulumi.Input[builtins.int]]
        type: NotRequired[pulumi.Input[builtins.str]]
        volume_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ComputeInstanceVolumeAttachedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ComputeInstanceVolumeAttachedArgs:
    def __init__(__self__, *,
                 boot_index: Optional[pulumi.Input[builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 pci_address: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 volume_id: Optional[pulumi.Input[builtins.str]] = None):
        if boot_index is not None:
            pulumi.set(__self__, "boot_index", boot_index)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if pci_address is not None:
            pulumi.set(__self__, "pci_address", pci_address)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)

    @property
    @pulumi.getter(name="bootIndex")
    def boot_index(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "boot_index")

    @boot_index.setter
    def boot_index(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "boot_index", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="pciAddress")
    def pci_address(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "pci_address")

    @pci_address.setter
    def pci_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pci_address", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class CssClusterBackupStrategyArgsDict(TypedDict):
        start_time: pulumi.Input[builtins.str]
        agency: NotRequired[pulumi.Input[builtins.str]]
        backup_path: NotRequired[pulumi.Input[builtins.str]]
        bucket: NotRequired[pulumi.Input[builtins.str]]
        keep_days: NotRequired[pulumi.Input[builtins.int]]
        prefix: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CssClusterBackupStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CssClusterBackupStrategyArgs:
    def __init__(__self__, *,
                 start_time: pulumi.Input[builtins.str],
                 agency: Optional[pulumi.Input[builtins.str]] = None,
                 backup_path: Optional[pulumi.Input[builtins.str]] = None,
                 bucket: Optional[pulumi.Input[builtins.str]] = None,
                 keep_days: Optional[pulumi.Input[builtins.int]] = None,
                 prefix: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "start_time", start_time)
        if agency is not None:
            pulumi.set(__self__, "agency", agency)
        if backup_path is not None:
            pulumi.set(__self__, "backup_path", backup_path)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if keep_days is not None:
            pulumi.set(__self__, "keep_days", keep_days)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def agency(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "agency")

    @agency.setter
    def agency(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "agency", value)

    @property
    @pulumi.getter(name="backupPath")
    def backup_path(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "backup_path")

    @backup_path.setter
    def backup_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_path", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="keepDays")
    def keep_days(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "keep_days")

    @keep_days.setter
    def keep_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "keep_days", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class CssClusterNodeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CssClusterNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CssClusterNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CssClusterNodeConfigArgsDict(TypedDict):
        flavor: pulumi.Input[builtins.str]
        network_info: pulumi.Input['CssClusterNodeConfigNetworkInfoArgsDict']
        volume: pulumi.Input['CssClusterNodeConfigVolumeArgsDict']
        availability_zone: NotRequired[pulumi.Input[builtins.str]]
elif False:
    CssClusterNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CssClusterNodeConfigArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[builtins.str],
                 network_info: pulumi.Input['CssClusterNodeConfigNetworkInfoArgs'],
                 volume: pulumi.Input['CssClusterNodeConfigVolumeArgs'],
                 availability_zone: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "network_info", network_info)
        pulumi.set(__self__, "volume", volume)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)

    @property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "flavor", value)

    @property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> pulumi.Input['CssClusterNodeConfigNetworkInfoArgs']:
        return pulumi.get(self, "network_info")

    @network_info.setter
    def network_info(self, value: pulumi.Input['CssClusterNodeConfigNetworkInfoArgs']):
        pulumi.set(self, "network_info", value)

    @property
    @pulumi.getter
    def volume(self) -> pulumi.Input['CssClusterNodeConfigVolumeArgs']:
        return pulumi.get(self, "volume")

    @volume.setter
    def volume(self, value: pulumi.Input['CssClusterNodeConfigVolumeArgs']):
        pulumi.set(self, "volume", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_zone", value)


if not MYPY:
    class CssClusterNodeConfigNetworkInfoArgsDict(TypedDict):
        security_group_id: pulumi.Input[builtins.str]
        subnet_id: pulumi.Input[builtins.str]
        vpc_id: pulumi.Input[builtins.str]
elif False:
    CssClusterNodeConfigNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CssClusterNodeConfigNetworkInfoArgs:
    def __init__(__self__, *,
                 security_group_id: pulumi.Input[builtins.str],
                 subnet_id: pulumi.Input[builtins.str],
                 vpc_id: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "security_group_id", security_group_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "security_group_id")

    @security_group_id.setter
    def security_group_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "security_group_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class CssClusterNodeConfigVolumeArgsDict(TypedDict):
        size: pulumi.Input[builtins.int]
        volume_type: pulumi.Input[builtins.str]
elif False:
    CssClusterNodeConfigVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CssClusterNodeConfigVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[builtins.int],
                 volume_type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class CtsNotificationFilterArgsDict(TypedDict):
        condition: pulumi.Input[builtins.str]
        rules: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    CtsNotificationFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CtsNotificationFilterArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[builtins.str],
                 rules: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class CtsNotificationOperationArgsDict(TypedDict):
        resource: pulumi.Input[builtins.str]
        service: pulumi.Input[builtins.str]
        trace_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    CtsNotificationOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CtsNotificationOperationArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input[builtins.str],
                 service: pulumi.Input[builtins.str],
                 trace_names: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "trace_names", trace_names)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="traceNames")
    def trace_names(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "trace_names")

    @trace_names.setter
    def trace_names(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "trace_names", value)


if not MYPY:
    class CtsNotificationOperationUserArgsDict(TypedDict):
        group: pulumi.Input[builtins.str]
        users: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    CtsNotificationOperationUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CtsNotificationOperationUserArgs:
    def __init__(__self__, *,
                 group: pulumi.Input[builtins.str],
                 users: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "users", users)

    @property
    @pulumi.getter
    def group(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def users(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "users", value)


if not MYPY:
    class DcsInstanceBackupPolicyArgsDict(TypedDict):
        backup_ats: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]
        begin_at: pulumi.Input[builtins.str]
        backup_type: NotRequired[pulumi.Input[builtins.str]]
        period_type: NotRequired[pulumi.Input[builtins.str]]
        save_days: NotRequired[pulumi.Input[builtins.int]]
elif False:
    DcsInstanceBackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DcsInstanceBackupPolicyArgs:
    def __init__(__self__, *,
                 backup_ats: pulumi.Input[Sequence[pulumi.Input[builtins.int]]],
                 begin_at: pulumi.Input[builtins.str],
                 backup_type: Optional[pulumi.Input[builtins.str]] = None,
                 period_type: Optional[pulumi.Input[builtins.str]] = None,
                 save_days: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "backup_ats", backup_ats)
        pulumi.set(__self__, "begin_at", begin_at)
        if backup_type is not None:
            pulumi.set(__self__, "backup_type", backup_type)
        if period_type is not None:
            pulumi.set(__self__, "period_type", period_type)
        if save_days is not None:
            pulumi.set(__self__, "save_days", save_days)

    @property
    @pulumi.getter(name="backupAts")
    def backup_ats(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.int]]]:
        return pulumi.get(self, "backup_ats")

    @backup_ats.setter
    def backup_ats(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.int]]]):
        pulumi.set(self, "backup_ats", value)

    @property
    @pulumi.getter(name="beginAt")
    def begin_at(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "begin_at")

    @begin_at.setter
    def begin_at(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "begin_at", value)

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "backup_type")

    @backup_type.setter
    def backup_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_type", value)

    @property
    @pulumi.getter(name="periodType")
    def period_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "period_type")

    @period_type.setter
    def period_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "period_type", value)

    @property
    @pulumi.getter(name="saveDays")
    def save_days(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "save_days")

    @save_days.setter
    def save_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "save_days", value)


if not MYPY:
    class DcsInstanceBandwidthInfoArgsDict(TypedDict):
        bandwidth: NotRequired[pulumi.Input[builtins.int]]
        begin_time: NotRequired[pulumi.Input[builtins.str]]
        current_time: NotRequired[pulumi.Input[builtins.str]]
        end_time: NotRequired[pulumi.Input[builtins.str]]
        expand_count: NotRequired[pulumi.Input[builtins.int]]
        expand_effect_time: NotRequired[pulumi.Input[builtins.int]]
        expand_interval_time: NotRequired[pulumi.Input[builtins.int]]
        max_expand_count: NotRequired[pulumi.Input[builtins.int]]
        next_expand_time: NotRequired[pulumi.Input[builtins.str]]
        task_running: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    DcsInstanceBandwidthInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DcsInstanceBandwidthInfoArgs:
    def __init__(__self__, *,
                 bandwidth: Optional[pulumi.Input[builtins.int]] = None,
                 begin_time: Optional[pulumi.Input[builtins.str]] = None,
                 current_time: Optional[pulumi.Input[builtins.str]] = None,
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 expand_count: Optional[pulumi.Input[builtins.int]] = None,
                 expand_effect_time: Optional[pulumi.Input[builtins.int]] = None,
                 expand_interval_time: Optional[pulumi.Input[builtins.int]] = None,
                 max_expand_count: Optional[pulumi.Input[builtins.int]] = None,
                 next_expand_time: Optional[pulumi.Input[builtins.str]] = None,
                 task_running: Optional[pulumi.Input[builtins.bool]] = None):
        if bandwidth is not None:
            pulumi.set(__self__, "bandwidth", bandwidth)
        if begin_time is not None:
            pulumi.set(__self__, "begin_time", begin_time)
        if current_time is not None:
            pulumi.set(__self__, "current_time", current_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if expand_count is not None:
            pulumi.set(__self__, "expand_count", expand_count)
        if expand_effect_time is not None:
            pulumi.set(__self__, "expand_effect_time", expand_effect_time)
        if expand_interval_time is not None:
            pulumi.set(__self__, "expand_interval_time", expand_interval_time)
        if max_expand_count is not None:
            pulumi.set(__self__, "max_expand_count", max_expand_count)
        if next_expand_time is not None:
            pulumi.set(__self__, "next_expand_time", next_expand_time)
        if task_running is not None:
            pulumi.set(__self__, "task_running", task_running)

    @property
    @pulumi.getter
    def bandwidth(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "bandwidth")

    @bandwidth.setter
    def bandwidth(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth", value)

    @property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "begin_time")

    @begin_time.setter
    def begin_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "begin_time", value)

    @property
    @pulumi.getter(name="currentTime")
    def current_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "current_time")

    @current_time.setter
    def current_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "current_time", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="expandCount")
    def expand_count(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "expand_count")

    @expand_count.setter
    def expand_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "expand_count", value)

    @property
    @pulumi.getter(name="expandEffectTime")
    def expand_effect_time(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "expand_effect_time")

    @expand_effect_time.setter
    def expand_effect_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "expand_effect_time", value)

    @property
    @pulumi.getter(name="expandIntervalTime")
    def expand_interval_time(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "expand_interval_time")

    @expand_interval_time.setter
    def expand_interval_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "expand_interval_time", value)

    @property
    @pulumi.getter(name="maxExpandCount")
    def max_expand_count(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_expand_count")

    @max_expand_count.setter
    def max_expand_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_expand_count", value)

    @property
    @pulumi.getter(name="nextExpandTime")
    def next_expand_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "next_expand_time")

    @next_expand_time.setter
    def next_expand_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "next_expand_time", value)

    @property
    @pulumi.getter(name="taskRunning")
    def task_running(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "task_running")

    @task_running.setter
    def task_running(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "task_running", value)


if not MYPY:
    class DcsInstanceParameterArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        name: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    DcsInstanceParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DcsInstanceParameterArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DcsInstanceWhitelistArgsDict(TypedDict):
        group_name: pulumi.Input[builtins.str]
        ip_addresses: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    DcsInstanceWhitelistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DcsInstanceWhitelistArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[builtins.str],
                 ip_addresses: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class DcsParametersConfigurationParameterArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        need_restart: NotRequired[pulumi.Input[builtins.bool]]
        type: NotRequired[pulumi.Input[builtins.str]]
        user_permission: NotRequired[pulumi.Input[builtins.str]]
        value: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DcsParametersConfigurationParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DcsParametersConfigurationParameterArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 need_restart: Optional[pulumi.Input[builtins.bool]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 user_permission: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if need_restart is not None:
            pulumi.set(__self__, "need_restart", need_restart)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_permission is not None:
            pulumi.set(__self__, "user_permission", user_permission)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="needRestart")
    def need_restart(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "need_restart")

    @need_restart.setter
    def need_restart(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "need_restart", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userPermission")
    def user_permission(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "user_permission")

    @user_permission.setter
    def user_permission(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_permission", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DcsRestoreRestoreRecordArgsDict(TypedDict):
        backup_id: NotRequired[pulumi.Input[builtins.str]]
        backup_name: NotRequired[pulumi.Input[builtins.str]]
        backup_remark: NotRequired[pulumi.Input[builtins.str]]
        created_at: NotRequired[pulumi.Input[builtins.str]]
        error_code: NotRequired[pulumi.Input[builtins.str]]
        progress: NotRequired[pulumi.Input[builtins.str]]
        restore_id: NotRequired[pulumi.Input[builtins.str]]
        restore_name: NotRequired[pulumi.Input[builtins.str]]
        restore_remark: NotRequired[pulumi.Input[builtins.str]]
        source_instance_id: NotRequired[pulumi.Input[builtins.str]]
        source_instance_name: NotRequired[pulumi.Input[builtins.str]]
        status: NotRequired[pulumi.Input[builtins.str]]
        updated_at: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DcsRestoreRestoreRecordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DcsRestoreRestoreRecordArgs:
    def __init__(__self__, *,
                 backup_id: Optional[pulumi.Input[builtins.str]] = None,
                 backup_name: Optional[pulumi.Input[builtins.str]] = None,
                 backup_remark: Optional[pulumi.Input[builtins.str]] = None,
                 created_at: Optional[pulumi.Input[builtins.str]] = None,
                 error_code: Optional[pulumi.Input[builtins.str]] = None,
                 progress: Optional[pulumi.Input[builtins.str]] = None,
                 restore_id: Optional[pulumi.Input[builtins.str]] = None,
                 restore_name: Optional[pulumi.Input[builtins.str]] = None,
                 restore_remark: Optional[pulumi.Input[builtins.str]] = None,
                 source_instance_id: Optional[pulumi.Input[builtins.str]] = None,
                 source_instance_name: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[builtins.str]] = None):
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_name is not None:
            pulumi.set(__self__, "backup_name", backup_name)
        if backup_remark is not None:
            pulumi.set(__self__, "backup_remark", backup_remark)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if error_code is not None:
            pulumi.set(__self__, "error_code", error_code)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if restore_id is not None:
            pulumi.set(__self__, "restore_id", restore_id)
        if restore_name is not None:
            pulumi.set(__self__, "restore_name", restore_name)
        if restore_remark is not None:
            pulumi.set(__self__, "restore_remark", restore_remark)
        if source_instance_id is not None:
            pulumi.set(__self__, "source_instance_id", source_instance_id)
        if source_instance_name is not None:
            pulumi.set(__self__, "source_instance_name", source_instance_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "backup_name")

    @backup_name.setter
    def backup_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_name", value)

    @property
    @pulumi.getter(name="backupRemark")
    def backup_remark(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "backup_remark")

    @backup_remark.setter
    def backup_remark(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "backup_remark", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="errorCode")
    def error_code(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "error_code")

    @error_code.setter
    def error_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "error_code", value)

    @property
    @pulumi.getter
    def progress(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "progress")

    @progress.setter
    def progress(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "progress", value)

    @property
    @pulumi.getter(name="restoreId")
    def restore_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "restore_id")

    @restore_id.setter
    def restore_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restore_id", value)

    @property
    @pulumi.getter(name="restoreName")
    def restore_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "restore_name")

    @restore_name.setter
    def restore_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restore_name", value)

    @property
    @pulumi.getter(name="restoreRemark")
    def restore_remark(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "restore_remark")

    @restore_remark.setter
    def restore_remark(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "restore_remark", value)

    @property
    @pulumi.getter(name="sourceInstanceId")
    def source_instance_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "source_instance_id")

    @source_instance_id.setter
    def source_instance_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_instance_id", value)

    @property
    @pulumi.getter(name="sourceInstanceName")
    def source_instance_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "source_instance_name")

    @source_instance_name.setter
    def source_instance_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_instance_name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class DdsInstanceBackupStrategyArgsDict(TypedDict):
        keep_days: pulumi.Input[builtins.int]
        start_time: pulumi.Input[builtins.str]
        period: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DdsInstanceBackupStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsInstanceBackupStrategyArgs:
    def __init__(__self__, *,
                 keep_days: pulumi.Input[builtins.int],
                 start_time: pulumi.Input[builtins.str],
                 period: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "keep_days", keep_days)
        pulumi.set(__self__, "start_time", start_time)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @property
    @pulumi.getter(name="keepDays")
    def keep_days(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "keep_days")

    @keep_days.setter
    def keep_days(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "keep_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "period", value)


if not MYPY:
    class DdsInstanceConfigurationArgsDict(TypedDict):
        id: pulumi.Input[builtins.str]
        type: pulumi.Input[builtins.str]
elif False:
    DdsInstanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsInstanceConfigurationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DdsInstanceDatastoreArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        version: pulumi.Input[builtins.str]
        storage_engine: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DdsInstanceDatastoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsInstanceDatastoreArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 version: pulumi.Input[builtins.str],
                 storage_engine: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        if storage_engine is not None:
            pulumi.set(__self__, "storage_engine", storage_engine)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="storageEngine")
    def storage_engine(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "storage_engine")

    @storage_engine.setter
    def storage_engine(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_engine", value)


if not MYPY:
    class DdsInstanceFlavorArgsDict(TypedDict):
        num: pulumi.Input[builtins.int]
        spec_code: pulumi.Input[builtins.str]
        type: pulumi.Input[builtins.str]
        size: NotRequired[pulumi.Input[builtins.int]]
        storage: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DdsInstanceFlavorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsInstanceFlavorArgs:
    def __init__(__self__, *,
                 num: pulumi.Input[builtins.int],
                 spec_code: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 size: Optional[pulumi.Input[builtins.int]] = None,
                 storage: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "num", num)
        pulumi.set(__self__, "spec_code", spec_code)
        pulumi.set(__self__, "type", type)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def num(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "num")

    @num.setter
    def num(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "num", value)

    @property
    @pulumi.getter(name="specCode")
    def spec_code(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "spec_code")

    @spec_code.setter
    def spec_code(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "spec_code", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class DdsInstanceGroupArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['DdsInstanceGroupNodeArgsDict']]]]
        size: NotRequired[pulumi.Input[builtins.str]]
        status: NotRequired[pulumi.Input[builtins.str]]
        type: NotRequired[pulumi.Input[builtins.str]]
        used: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DdsInstanceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsInstanceGroupArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['DdsInstanceGroupNodeArgs']]]] = None,
                 size: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 used: Optional[pulumi.Input[builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if used is not None:
            pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DdsInstanceGroupNodeArgs']]]]:
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DdsInstanceGroupNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def used(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "used")

    @used.setter
    def used(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "used", value)


if not MYPY:
    class DdsInstanceGroupNodeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node ID.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node name.
        """
        private_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the private IP address of a node.
        """
        public_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the EIP that has been bound on a node.
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node role.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node status.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node type.
        """
elif False:
    DdsInstanceGroupNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsInstanceGroupNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: Indicates the node ID.
        :param pulumi.Input[builtins.str] name: Indicates the node name.
        :param pulumi.Input[builtins.str] private_ip: Indicates the private IP address of a node.
        :param pulumi.Input[builtins.str] public_ip: Indicates the EIP that has been bound on a node.
        :param pulumi.Input[builtins.str] role: Indicates the node role.
        :param pulumi.Input[builtins.str] status: Indicates the node status.
        :param pulumi.Input[builtins.str] type: Indicates the node type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the private IP address of a node.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the EIP that has been bound on a node.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node role.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DdsInstanceNodeArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node ID.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node name.
        """
        private_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the private IP address of a node.
        """
        public_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the EIP that has been bound on a node.
        """
        role: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node role.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node status.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Indicates the node type.
        """
elif False:
    DdsInstanceNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DdsInstanceNodeArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: Indicates the node ID.
        :param pulumi.Input[builtins.str] name: Indicates the node name.
        :param pulumi.Input[builtins.str] private_ip: Indicates the private IP address of a node.
        :param pulumi.Input[builtins.str] public_ip: Indicates the EIP that has been bound on a node.
        :param pulumi.Input[builtins.str] role: Indicates the node role.
        :param pulumi.Input[builtins.str] status: Indicates the node status.
        :param pulumi.Input[builtins.str] type: Indicates the node type.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the private IP address of a node.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the EIP that has been bound on a node.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node role.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Indicates the node type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DisStreamPartitionArgsDict(TypedDict):
        hash_range: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
        sequence_number_range: NotRequired[pulumi.Input[builtins.str]]
        status: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DisStreamPartitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DisStreamPartitionArgs:
    def __init__(__self__, *,
                 hash_range: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 sequence_number_range: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        if hash_range is not None:
            pulumi.set(__self__, "hash_range", hash_range)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if sequence_number_range is not None:
            pulumi.set(__self__, "sequence_number_range", sequence_number_range)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="hashRange")
    def hash_range(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "hash_range")

    @hash_range.setter
    def hash_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hash_range", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="sequenceNumberRange")
    def sequence_number_range(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sequence_number_range")

    @sequence_number_range.setter
    def sequence_number_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sequence_number_range", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DliQueueScalingPolicyArgsDict(TypedDict):
        impact_start_time: pulumi.Input[builtins.str]
        impact_stop_time: pulumi.Input[builtins.str]
        max_cu: pulumi.Input[builtins.int]
        min_cu: pulumi.Input[builtins.int]
        priority: pulumi.Input[builtins.int]
elif False:
    DliQueueScalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DliQueueScalingPolicyArgs:
    def __init__(__self__, *,
                 impact_start_time: pulumi.Input[builtins.str],
                 impact_stop_time: pulumi.Input[builtins.str],
                 max_cu: pulumi.Input[builtins.int],
                 min_cu: pulumi.Input[builtins.int],
                 priority: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "impact_start_time", impact_start_time)
        pulumi.set(__self__, "impact_stop_time", impact_stop_time)
        pulumi.set(__self__, "max_cu", max_cu)
        pulumi.set(__self__, "min_cu", min_cu)
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="impactStartTime")
    def impact_start_time(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "impact_start_time")

    @impact_start_time.setter
    def impact_start_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "impact_start_time", value)

    @property
    @pulumi.getter(name="impactStopTime")
    def impact_stop_time(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "impact_stop_time")

    @impact_stop_time.setter
    def impact_stop_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "impact_stop_time", value)

    @property
    @pulumi.getter(name="maxCu")
    def max_cu(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "max_cu")

    @max_cu.setter
    def max_cu(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "max_cu", value)

    @property
    @pulumi.getter(name="minCu")
    def min_cu(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "min_cu")

    @min_cu.setter
    def min_cu(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "min_cu", value)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class DliQueueSparkDriverArgsDict(TypedDict):
        max_concurrent: NotRequired[pulumi.Input[builtins.int]]
        max_instance: NotRequired[pulumi.Input[builtins.int]]
        max_prefetch_instance: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DliQueueSparkDriverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DliQueueSparkDriverArgs:
    def __init__(__self__, *,
                 max_concurrent: Optional[pulumi.Input[builtins.int]] = None,
                 max_instance: Optional[pulumi.Input[builtins.int]] = None,
                 max_prefetch_instance: Optional[pulumi.Input[builtins.str]] = None):
        if max_concurrent is not None:
            pulumi.set(__self__, "max_concurrent", max_concurrent)
        if max_instance is not None:
            pulumi.set(__self__, "max_instance", max_instance)
        if max_prefetch_instance is not None:
            pulumi.set(__self__, "max_prefetch_instance", max_prefetch_instance)

    @property
    @pulumi.getter(name="maxConcurrent")
    def max_concurrent(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_concurrent")

    @max_concurrent.setter
    def max_concurrent(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_concurrent", value)

    @property
    @pulumi.getter(name="maxInstance")
    def max_instance(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_instance")

    @max_instance.setter
    def max_instance(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_instance", value)

    @property
    @pulumi.getter(name="maxPrefetchInstance")
    def max_prefetch_instance(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "max_prefetch_instance")

    @max_prefetch_instance.setter
    def max_prefetch_instance(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "max_prefetch_instance", value)


if not MYPY:
    class DliSparkJobDependentPackageArgsDict(TypedDict):
        group_name: pulumi.Input[builtins.str]
        packages: pulumi.Input[Sequence[pulumi.Input['DliSparkJobDependentPackagePackageArgsDict']]]
elif False:
    DliSparkJobDependentPackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DliSparkJobDependentPackageArgs:
    def __init__(__self__, *,
                 group_name: pulumi.Input[builtins.str],
                 packages: pulumi.Input[Sequence[pulumi.Input['DliSparkJobDependentPackagePackageArgs']]]):
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "packages", packages)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter
    def packages(self) -> pulumi.Input[Sequence[pulumi.Input['DliSparkJobDependentPackagePackageArgs']]]:
        return pulumi.get(self, "packages")

    @packages.setter
    def packages(self, value: pulumi.Input[Sequence[pulumi.Input['DliSparkJobDependentPackagePackageArgs']]]):
        pulumi.set(self, "packages", value)


if not MYPY:
    class DliSparkJobDependentPackagePackageArgsDict(TypedDict):
        package_name: pulumi.Input[builtins.str]
        type: pulumi.Input[builtins.str]
elif False:
    DliSparkJobDependentPackagePackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DliSparkJobDependentPackagePackageArgs:
    def __init__(__self__, *,
                 package_name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "package_name", package_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="packageName")
    def package_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "package_name")

    @package_name.setter
    def package_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "package_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class DmsKafkaInstanceCrossVpcAccessArgsDict(TypedDict):
        advertised_ip: NotRequired[pulumi.Input[builtins.str]]
        lisenter_ip: NotRequired[pulumi.Input[builtins.str]]
        listener_ip: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.int]]
        port_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DmsKafkaInstanceCrossVpcAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsKafkaInstanceCrossVpcAccessArgs:
    def __init__(__self__, *,
                 advertised_ip: Optional[pulumi.Input[builtins.str]] = None,
                 lisenter_ip: Optional[pulumi.Input[builtins.str]] = None,
                 listener_ip: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 port_id: Optional[pulumi.Input[builtins.str]] = None):
        if advertised_ip is not None:
            pulumi.set(__self__, "advertised_ip", advertised_ip)
        if lisenter_ip is not None:
            warnings.warn("""typo in lisenter_ip, please use \"listener_ip\" instead.""", DeprecationWarning)
            pulumi.log.warn("""lisenter_ip is deprecated: typo in lisenter_ip, please use \"listener_ip\" instead.""")
        if lisenter_ip is not None:
            pulumi.set(__self__, "lisenter_ip", lisenter_ip)
        if listener_ip is not None:
            pulumi.set(__self__, "listener_ip", listener_ip)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)

    @property
    @pulumi.getter(name="advertisedIp")
    def advertised_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "advertised_ip")

    @advertised_ip.setter
    def advertised_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "advertised_ip", value)

    @property
    @pulumi.getter(name="lisenterIp")
    @_utilities.deprecated("""typo in lisenter_ip, please use \"listener_ip\" instead.""")
    def lisenter_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "lisenter_ip")

    @lisenter_ip.setter
    def lisenter_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "lisenter_ip", value)

    @property
    @pulumi.getter(name="listenerIp")
    def listener_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "listener_ip")

    @listener_ip.setter
    def listener_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "listener_ip", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port_id")

    @port_id.setter
    def port_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_id", value)


if not MYPY:
    class DmsKafkaInstanceParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    DmsKafkaInstanceParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsKafkaInstanceParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DmsKafkaInstancePortProtocolArgsDict(TypedDict):
        private_plain_address: NotRequired[pulumi.Input[builtins.str]]
        private_plain_domain_name: NotRequired[pulumi.Input[builtins.str]]
        private_plain_enable: NotRequired[pulumi.Input[builtins.bool]]
        private_sasl_plaintext_address: NotRequired[pulumi.Input[builtins.str]]
        private_sasl_plaintext_domain_name: NotRequired[pulumi.Input[builtins.str]]
        private_sasl_plaintext_enable: NotRequired[pulumi.Input[builtins.bool]]
        private_sasl_ssl_address: NotRequired[pulumi.Input[builtins.str]]
        private_sasl_ssl_domain_name: NotRequired[pulumi.Input[builtins.str]]
        private_sasl_ssl_enable: NotRequired[pulumi.Input[builtins.bool]]
        public_plain_address: NotRequired[pulumi.Input[builtins.str]]
        public_plain_domain_name: NotRequired[pulumi.Input[builtins.str]]
        public_plain_enable: NotRequired[pulumi.Input[builtins.bool]]
        public_sasl_plaintext_address: NotRequired[pulumi.Input[builtins.str]]
        public_sasl_plaintext_domain_name: NotRequired[pulumi.Input[builtins.str]]
        public_sasl_plaintext_enable: NotRequired[pulumi.Input[builtins.bool]]
        public_sasl_ssl_address: NotRequired[pulumi.Input[builtins.str]]
        public_sasl_ssl_domain_name: NotRequired[pulumi.Input[builtins.str]]
        public_sasl_ssl_enable: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    DmsKafkaInstancePortProtocolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsKafkaInstancePortProtocolArgs:
    def __init__(__self__, *,
                 private_plain_address: Optional[pulumi.Input[builtins.str]] = None,
                 private_plain_domain_name: Optional[pulumi.Input[builtins.str]] = None,
                 private_plain_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 private_sasl_plaintext_address: Optional[pulumi.Input[builtins.str]] = None,
                 private_sasl_plaintext_domain_name: Optional[pulumi.Input[builtins.str]] = None,
                 private_sasl_plaintext_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 private_sasl_ssl_address: Optional[pulumi.Input[builtins.str]] = None,
                 private_sasl_ssl_domain_name: Optional[pulumi.Input[builtins.str]] = None,
                 private_sasl_ssl_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 public_plain_address: Optional[pulumi.Input[builtins.str]] = None,
                 public_plain_domain_name: Optional[pulumi.Input[builtins.str]] = None,
                 public_plain_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 public_sasl_plaintext_address: Optional[pulumi.Input[builtins.str]] = None,
                 public_sasl_plaintext_domain_name: Optional[pulumi.Input[builtins.str]] = None,
                 public_sasl_plaintext_enable: Optional[pulumi.Input[builtins.bool]] = None,
                 public_sasl_ssl_address: Optional[pulumi.Input[builtins.str]] = None,
                 public_sasl_ssl_domain_name: Optional[pulumi.Input[builtins.str]] = None,
                 public_sasl_ssl_enable: Optional[pulumi.Input[builtins.bool]] = None):
        if private_plain_address is not None:
            pulumi.set(__self__, "private_plain_address", private_plain_address)
        if private_plain_domain_name is not None:
            pulumi.set(__self__, "private_plain_domain_name", private_plain_domain_name)
        if private_plain_enable is not None:
            pulumi.set(__self__, "private_plain_enable", private_plain_enable)
        if private_sasl_plaintext_address is not None:
            pulumi.set(__self__, "private_sasl_plaintext_address", private_sasl_plaintext_address)
        if private_sasl_plaintext_domain_name is not None:
            pulumi.set(__self__, "private_sasl_plaintext_domain_name", private_sasl_plaintext_domain_name)
        if private_sasl_plaintext_enable is not None:
            pulumi.set(__self__, "private_sasl_plaintext_enable", private_sasl_plaintext_enable)
        if private_sasl_ssl_address is not None:
            pulumi.set(__self__, "private_sasl_ssl_address", private_sasl_ssl_address)
        if private_sasl_ssl_domain_name is not None:
            pulumi.set(__self__, "private_sasl_ssl_domain_name", private_sasl_ssl_domain_name)
        if private_sasl_ssl_enable is not None:
            pulumi.set(__self__, "private_sasl_ssl_enable", private_sasl_ssl_enable)
        if public_plain_address is not None:
            pulumi.set(__self__, "public_plain_address", public_plain_address)
        if public_plain_domain_name is not None:
            pulumi.set(__self__, "public_plain_domain_name", public_plain_domain_name)
        if public_plain_enable is not None:
            pulumi.set(__self__, "public_plain_enable", public_plain_enable)
        if public_sasl_plaintext_address is not None:
            pulumi.set(__self__, "public_sasl_plaintext_address", public_sasl_plaintext_address)
        if public_sasl_plaintext_domain_name is not None:
            pulumi.set(__self__, "public_sasl_plaintext_domain_name", public_sasl_plaintext_domain_name)
        if public_sasl_plaintext_enable is not None:
            pulumi.set(__self__, "public_sasl_plaintext_enable", public_sasl_plaintext_enable)
        if public_sasl_ssl_address is not None:
            pulumi.set(__self__, "public_sasl_ssl_address", public_sasl_ssl_address)
        if public_sasl_ssl_domain_name is not None:
            pulumi.set(__self__, "public_sasl_ssl_domain_name", public_sasl_ssl_domain_name)
        if public_sasl_ssl_enable is not None:
            pulumi.set(__self__, "public_sasl_ssl_enable", public_sasl_ssl_enable)

    @property
    @pulumi.getter(name="privatePlainAddress")
    def private_plain_address(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "private_plain_address")

    @private_plain_address.setter
    def private_plain_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_plain_address", value)

    @property
    @pulumi.getter(name="privatePlainDomainName")
    def private_plain_domain_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "private_plain_domain_name")

    @private_plain_domain_name.setter
    def private_plain_domain_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_plain_domain_name", value)

    @property
    @pulumi.getter(name="privatePlainEnable")
    def private_plain_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "private_plain_enable")

    @private_plain_enable.setter
    def private_plain_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "private_plain_enable", value)

    @property
    @pulumi.getter(name="privateSaslPlaintextAddress")
    def private_sasl_plaintext_address(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "private_sasl_plaintext_address")

    @private_sasl_plaintext_address.setter
    def private_sasl_plaintext_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_sasl_plaintext_address", value)

    @property
    @pulumi.getter(name="privateSaslPlaintextDomainName")
    def private_sasl_plaintext_domain_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "private_sasl_plaintext_domain_name")

    @private_sasl_plaintext_domain_name.setter
    def private_sasl_plaintext_domain_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_sasl_plaintext_domain_name", value)

    @property
    @pulumi.getter(name="privateSaslPlaintextEnable")
    def private_sasl_plaintext_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "private_sasl_plaintext_enable")

    @private_sasl_plaintext_enable.setter
    def private_sasl_plaintext_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "private_sasl_plaintext_enable", value)

    @property
    @pulumi.getter(name="privateSaslSslAddress")
    def private_sasl_ssl_address(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "private_sasl_ssl_address")

    @private_sasl_ssl_address.setter
    def private_sasl_ssl_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_sasl_ssl_address", value)

    @property
    @pulumi.getter(name="privateSaslSslDomainName")
    def private_sasl_ssl_domain_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "private_sasl_ssl_domain_name")

    @private_sasl_ssl_domain_name.setter
    def private_sasl_ssl_domain_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_sasl_ssl_domain_name", value)

    @property
    @pulumi.getter(name="privateSaslSslEnable")
    def private_sasl_ssl_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "private_sasl_ssl_enable")

    @private_sasl_ssl_enable.setter
    def private_sasl_ssl_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "private_sasl_ssl_enable", value)

    @property
    @pulumi.getter(name="publicPlainAddress")
    def public_plain_address(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "public_plain_address")

    @public_plain_address.setter
    def public_plain_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_plain_address", value)

    @property
    @pulumi.getter(name="publicPlainDomainName")
    def public_plain_domain_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "public_plain_domain_name")

    @public_plain_domain_name.setter
    def public_plain_domain_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_plain_domain_name", value)

    @property
    @pulumi.getter(name="publicPlainEnable")
    def public_plain_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "public_plain_enable")

    @public_plain_enable.setter
    def public_plain_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "public_plain_enable", value)

    @property
    @pulumi.getter(name="publicSaslPlaintextAddress")
    def public_sasl_plaintext_address(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "public_sasl_plaintext_address")

    @public_sasl_plaintext_address.setter
    def public_sasl_plaintext_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_sasl_plaintext_address", value)

    @property
    @pulumi.getter(name="publicSaslPlaintextDomainName")
    def public_sasl_plaintext_domain_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "public_sasl_plaintext_domain_name")

    @public_sasl_plaintext_domain_name.setter
    def public_sasl_plaintext_domain_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_sasl_plaintext_domain_name", value)

    @property
    @pulumi.getter(name="publicSaslPlaintextEnable")
    def public_sasl_plaintext_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "public_sasl_plaintext_enable")

    @public_sasl_plaintext_enable.setter
    def public_sasl_plaintext_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "public_sasl_plaintext_enable", value)

    @property
    @pulumi.getter(name="publicSaslSslAddress")
    def public_sasl_ssl_address(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "public_sasl_ssl_address")

    @public_sasl_ssl_address.setter
    def public_sasl_ssl_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_sasl_ssl_address", value)

    @property
    @pulumi.getter(name="publicSaslSslDomainName")
    def public_sasl_ssl_domain_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "public_sasl_ssl_domain_name")

    @public_sasl_ssl_domain_name.setter
    def public_sasl_ssl_domain_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_sasl_ssl_domain_name", value)

    @property
    @pulumi.getter(name="publicSaslSslEnable")
    def public_sasl_ssl_enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "public_sasl_ssl_enable")

    @public_sasl_ssl_enable.setter
    def public_sasl_ssl_enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "public_sasl_ssl_enable", value)


if not MYPY:
    class DmsKafkaMessageProducePropertyListArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    DmsKafkaMessageProducePropertyListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsKafkaMessageProducePropertyListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DmsKafkaPermissionsPolicyArgsDict(TypedDict):
        access_policy: pulumi.Input[builtins.str]
        user_name: pulumi.Input[builtins.str]
elif False:
    DmsKafkaPermissionsPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsKafkaPermissionsPolicyArgs:
    def __init__(__self__, *,
                 access_policy: pulumi.Input[builtins.str],
                 user_name: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "access_policy", access_policy)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="accessPolicy")
    def access_policy(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "access_policy")

    @access_policy.setter
    def access_policy(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "access_policy", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class DmsKafkaTopicConfigArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    DmsKafkaTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DmsKafkaTopicConfigArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DnsZoneRouterArgsDict(TypedDict):
        router_id: pulumi.Input[builtins.str]
        """
        The ID of the associated VPC.
        """
        router_region: NotRequired[pulumi.Input[builtins.str]]
        """
        The region of the VPC.
        """
elif False:
    DnsZoneRouterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsZoneRouterArgs:
    def __init__(__self__, *,
                 router_id: pulumi.Input[builtins.str],
                 router_region: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] router_id: The ID of the associated VPC.
        :param pulumi.Input[builtins.str] router_region: The region of the VPC.
        """
        pulumi.set(__self__, "router_id", router_id)
        if router_region is not None:
            pulumi.set(__self__, "router_region", router_region)

    @property
    @pulumi.getter(name="routerId")
    def router_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the associated VPC.
        """
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "router_id", value)

    @property
    @pulumi.getter(name="routerRegion")
    def router_region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The region of the VPC.
        """
        return pulumi.get(self, "router_region")

    @router_region.setter
    def router_region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "router_region", value)


if not MYPY:
    class DrsJobDestinationDbArgsDict(TypedDict):
        engine_type: pulumi.Input[builtins.str]
        ip: pulumi.Input[builtins.str]
        password: pulumi.Input[builtins.str]
        port: pulumi.Input[builtins.int]
        user: pulumi.Input[builtins.str]
        instance_id: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        region: NotRequired[pulumi.Input[builtins.str]]
        ssl_cert_check_sum: NotRequired[pulumi.Input[builtins.str]]
        ssl_cert_key: NotRequired[pulumi.Input[builtins.str]]
        ssl_cert_name: NotRequired[pulumi.Input[builtins.str]]
        ssl_cert_password: NotRequired[pulumi.Input[builtins.str]]
        ssl_enabled: NotRequired[pulumi.Input[builtins.bool]]
        subnet_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DrsJobDestinationDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DrsJobDestinationDbArgs:
    def __init__(__self__, *,
                 engine_type: pulumi.Input[builtins.str],
                 ip: pulumi.Input[builtins.str],
                 password: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int],
                 user: pulumi.Input[builtins.str],
                 instance_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_cert_check_sum: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_cert_key: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_cert_name: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_cert_password: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 subnet_id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "engine_type", engine_type)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "user", user)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if ssl_cert_check_sum is not None:
            pulumi.set(__self__, "ssl_cert_check_sum", ssl_cert_check_sum)
        if ssl_cert_key is not None:
            pulumi.set(__self__, "ssl_cert_key", ssl_cert_key)
        if ssl_cert_name is not None:
            pulumi.set(__self__, "ssl_cert_name", ssl_cert_name)
        if ssl_cert_password is not None:
            pulumi.set(__self__, "ssl_cert_password", ssl_cert_password)
        if ssl_enabled is not None:
            pulumi.set(__self__, "ssl_enabled", ssl_enabled)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "engine_type")

    @engine_type.setter
    def engine_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "engine_type", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="sslCertCheckSum")
    def ssl_cert_check_sum(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ssl_cert_check_sum")

    @ssl_cert_check_sum.setter
    def ssl_cert_check_sum(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_cert_check_sum", value)

    @property
    @pulumi.getter(name="sslCertKey")
    def ssl_cert_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ssl_cert_key")

    @ssl_cert_key.setter
    def ssl_cert_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_cert_key", value)

    @property
    @pulumi.getter(name="sslCertName")
    def ssl_cert_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ssl_cert_name")

    @ssl_cert_name.setter
    def ssl_cert_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_cert_name", value)

    @property
    @pulumi.getter(name="sslCertPassword")
    def ssl_cert_password(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ssl_cert_password")

    @ssl_cert_password.setter
    def ssl_cert_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_cert_password", value)

    @property
    @pulumi.getter(name="sslEnabled")
    def ssl_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "ssl_enabled")

    @ssl_enabled.setter
    def ssl_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssl_enabled", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DrsJobLimitSpeedArgsDict(TypedDict):
        end_time: pulumi.Input[builtins.str]
        speed: pulumi.Input[builtins.str]
        start_time: pulumi.Input[builtins.str]
elif False:
    DrsJobLimitSpeedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DrsJobLimitSpeedArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[builtins.str],
                 speed: pulumi.Input[builtins.str],
                 start_time: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "speed", speed)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def speed(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "speed")

    @speed.setter
    def speed(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "speed", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class DrsJobSourceDbArgsDict(TypedDict):
        engine_type: pulumi.Input[builtins.str]
        ip: pulumi.Input[builtins.str]
        password: pulumi.Input[builtins.str]
        port: pulumi.Input[builtins.int]
        user: pulumi.Input[builtins.str]
        instance_id: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        region: NotRequired[pulumi.Input[builtins.str]]
        ssl_cert_check_sum: NotRequired[pulumi.Input[builtins.str]]
        ssl_cert_key: NotRequired[pulumi.Input[builtins.str]]
        ssl_cert_name: NotRequired[pulumi.Input[builtins.str]]
        ssl_cert_password: NotRequired[pulumi.Input[builtins.str]]
        ssl_enabled: NotRequired[pulumi.Input[builtins.bool]]
        subnet_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    DrsJobSourceDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DrsJobSourceDbArgs:
    def __init__(__self__, *,
                 engine_type: pulumi.Input[builtins.str],
                 ip: pulumi.Input[builtins.str],
                 password: pulumi.Input[builtins.str],
                 port: pulumi.Input[builtins.int],
                 user: pulumi.Input[builtins.str],
                 instance_id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_cert_check_sum: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_cert_key: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_cert_name: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_cert_password: Optional[pulumi.Input[builtins.str]] = None,
                 ssl_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 subnet_id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "engine_type", engine_type)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "user", user)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if ssl_cert_check_sum is not None:
            pulumi.set(__self__, "ssl_cert_check_sum", ssl_cert_check_sum)
        if ssl_cert_key is not None:
            pulumi.set(__self__, "ssl_cert_key", ssl_cert_key)
        if ssl_cert_name is not None:
            pulumi.set(__self__, "ssl_cert_name", ssl_cert_name)
        if ssl_cert_password is not None:
            pulumi.set(__self__, "ssl_cert_password", ssl_cert_password)
        if ssl_enabled is not None:
            pulumi.set(__self__, "ssl_enabled", ssl_enabled)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "engine_type")

    @engine_type.setter
    def engine_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "engine_type", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="sslCertCheckSum")
    def ssl_cert_check_sum(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ssl_cert_check_sum")

    @ssl_cert_check_sum.setter
    def ssl_cert_check_sum(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_cert_check_sum", value)

    @property
    @pulumi.getter(name="sslCertKey")
    def ssl_cert_key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ssl_cert_key")

    @ssl_cert_key.setter
    def ssl_cert_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_cert_key", value)

    @property
    @pulumi.getter(name="sslCertName")
    def ssl_cert_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ssl_cert_name")

    @ssl_cert_name.setter
    def ssl_cert_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_cert_name", value)

    @property
    @pulumi.getter(name="sslCertPassword")
    def ssl_cert_password(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ssl_cert_password")

    @ssl_cert_password.setter
    def ssl_cert_password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssl_cert_password", value)

    @property
    @pulumi.getter(name="sslEnabled")
    def ssl_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "ssl_enabled")

    @ssl_enabled.setter
    def ssl_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ssl_enabled", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class DwsClusterElbArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the ELB load balancer.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the ELB load balancer.
        """
        private_endpoint: NotRequired[pulumi.Input[builtins.str]]
        """
        The private endpoint of the ELB load balancer.
        """
        private_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        The private IP address of the ELB load balancer.
        """
        private_ip_v6: NotRequired[pulumi.Input[builtins.str]]
        """
        The IPv6 address of the ELB load balancer.
        """
        public_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        The public IP address of the ELB load balancer.
        """
        vpc_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of VPC to which the ELB load balancer belongs.
        """
elif False:
    DwsClusterElbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DwsClusterElbArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 private_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 private_ip: Optional[pulumi.Input[builtins.str]] = None,
                 private_ip_v6: Optional[pulumi.Input[builtins.str]] = None,
                 public_ip: Optional[pulumi.Input[builtins.str]] = None,
                 vpc_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] id: The ID of the ELB load balancer.
        :param pulumi.Input[builtins.str] name: The name of the ELB load balancer.
        :param pulumi.Input[builtins.str] private_endpoint: The private endpoint of the ELB load balancer.
        :param pulumi.Input[builtins.str] private_ip: The private IP address of the ELB load balancer.
        :param pulumi.Input[builtins.str] private_ip_v6: The IPv6 address of the ELB load balancer.
        :param pulumi.Input[builtins.str] public_ip: The public IP address of the ELB load balancer.
        :param pulumi.Input[builtins.str] vpc_id: The ID of VPC to which the ELB load balancer belongs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if private_ip_v6 is not None:
            pulumi.set(__self__, "private_ip_v6", private_ip_v6)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the ELB load balancer.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the ELB load balancer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The private endpoint of the ELB load balancer.
        """
        return pulumi.get(self, "private_endpoint")

    @private_endpoint.setter
    def private_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_endpoint", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The private IP address of the ELB load balancer.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="privateIpV6")
    def private_ip_v6(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The IPv6 address of the ELB load balancer.
        """
        return pulumi.get(self, "private_ip_v6")

    @private_ip_v6.setter
    def private_ip_v6(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "private_ip_v6", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The public IP address of the ELB load balancer.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of VPC to which the ELB load balancer belongs.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class DwsClusterEndpointArgsDict(TypedDict):
        connect_info: NotRequired[pulumi.Input[builtins.str]]
        """
        Private network connection information.
        """
        jdbc_url: NotRequired[pulumi.Input[builtins.str]]
        """
        JDBC URL. Format: jdbc:postgresql://<connect_info>/<YOUR_DATABASE_NAME>
        """
elif False:
    DwsClusterEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DwsClusterEndpointArgs:
    def __init__(__self__, *,
                 connect_info: Optional[pulumi.Input[builtins.str]] = None,
                 jdbc_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] connect_info: Private network connection information.
        :param pulumi.Input[builtins.str] jdbc_url: JDBC URL. Format: jdbc:postgresql://<connect_info>/<YOUR_DATABASE_NAME>
        """
        if connect_info is not None:
            pulumi.set(__self__, "connect_info", connect_info)
        if jdbc_url is not None:
            pulumi.set(__self__, "jdbc_url", jdbc_url)

    @property
    @pulumi.getter(name="connectInfo")
    def connect_info(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Private network connection information.
        """
        return pulumi.get(self, "connect_info")

    @connect_info.setter
    def connect_info(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connect_info", value)

    @property
    @pulumi.getter(name="jdbcUrl")
    def jdbc_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        JDBC URL. Format: jdbc:postgresql://<connect_info>/<YOUR_DATABASE_NAME>
        """
        return pulumi.get(self, "jdbc_url")

    @jdbc_url.setter
    def jdbc_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jdbc_url", value)


if not MYPY:
    class DwsClusterMaintainWindowArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[builtins.str]]
        """
        Maintenance time in each week in the unit of day.
        """
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Maintenance end time in HH:mm format. The time zone is GMT+0.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Maintenance start time in HH:mm format. The time zone is GMT+0.
        """
elif False:
    DwsClusterMaintainWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DwsClusterMaintainWindowArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[builtins.str]] = None,
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] day: Maintenance time in each week in the unit of day.
        :param pulumi.Input[builtins.str] end_time: Maintenance end time in HH:mm format. The time zone is GMT+0.
        :param pulumi.Input[builtins.str] start_time: Maintenance start time in HH:mm format. The time zone is GMT+0.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Maintenance time in each week in the unit of day.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Maintenance end time in HH:mm format. The time zone is GMT+0.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Maintenance start time in HH:mm format. The time zone is GMT+0.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class DwsClusterPublicEndpointArgsDict(TypedDict):
        jdbc_url: NotRequired[pulumi.Input[builtins.str]]
        """
        JDBC URL. Format: jdbc:postgresql://<public_connect_info>/<YOUR_DATABASE_NAME>
        """
        public_connect_info: NotRequired[pulumi.Input[builtins.str]]
        """
        Public network connection information.
        """
elif False:
    DwsClusterPublicEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DwsClusterPublicEndpointArgs:
    def __init__(__self__, *,
                 jdbc_url: Optional[pulumi.Input[builtins.str]] = None,
                 public_connect_info: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] jdbc_url: JDBC URL. Format: jdbc:postgresql://<public_connect_info>/<YOUR_DATABASE_NAME>
        :param pulumi.Input[builtins.str] public_connect_info: Public network connection information.
        """
        if jdbc_url is not None:
            pulumi.set(__self__, "jdbc_url", jdbc_url)
        if public_connect_info is not None:
            pulumi.set(__self__, "public_connect_info", public_connect_info)

    @property
    @pulumi.getter(name="jdbcUrl")
    def jdbc_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        JDBC URL. Format: jdbc:postgresql://<public_connect_info>/<YOUR_DATABASE_NAME>
        """
        return pulumi.get(self, "jdbc_url")

    @jdbc_url.setter
    def jdbc_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "jdbc_url", value)

    @property
    @pulumi.getter(name="publicConnectInfo")
    def public_connect_info(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Public network connection information.
        """
        return pulumi.get(self, "public_connect_info")

    @public_connect_info.setter
    def public_connect_info(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_connect_info", value)


if not MYPY:
    class DwsClusterPublicIpArgsDict(TypedDict):
        eip_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The EIP ID.
        """
        public_bind_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The bind type of public IP.
        """
elif False:
    DwsClusterPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DwsClusterPublicIpArgs:
    def __init__(__self__, *,
                 eip_id: Optional[pulumi.Input[builtins.str]] = None,
                 public_bind_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] eip_id: The EIP ID.
        :param pulumi.Input[builtins.str] public_bind_type: The bind type of public IP.
        """
        if eip_id is not None:
            pulumi.set(__self__, "eip_id", eip_id)
        if public_bind_type is not None:
            pulumi.set(__self__, "public_bind_type", public_bind_type)

    @property
    @pulumi.getter(name="eipId")
    def eip_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The EIP ID.
        """
        return pulumi.get(self, "eip_id")

    @eip_id.setter
    def eip_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "eip_id", value)

    @property
    @pulumi.getter(name="publicBindType")
    def public_bind_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bind type of public IP.
        """
        return pulumi.get(self, "public_bind_type")

    @public_bind_type.setter
    def public_bind_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_bind_type", value)


if not MYPY:
    class DwsClusterVolumeArgsDict(TypedDict):
        capacity: NotRequired[pulumi.Input[builtins.str]]
        """
        The capacity size, in GB.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The volume type.
        """
elif False:
    DwsClusterVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DwsClusterVolumeArgs:
    def __init__(__self__, *,
                 capacity: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] capacity: The capacity size, in GB.
        :param pulumi.Input[builtins.str] type: The volume type.
        """
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The capacity size, in GB.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The volume type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ElbIpgroupIpListArgsDict(TypedDict):
        ip: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElbIpgroupIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbIpgroupIpListArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "ip", ip)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigArgsDict(TypedDict):
        status_code: pulumi.Input[builtins.str]
        content_type: NotRequired[pulumi.Input[builtins.str]]
        insert_headers_config: NotRequired[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigArgsDict']]
        message_body: NotRequired[pulumi.Input[builtins.str]]
        remove_headers_config: NotRequired[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigArgsDict']]
        traffic_limit_config: NotRequired[pulumi.Input['ElbL7policyFixedResponseConfigTrafficLimitConfigArgsDict']]
elif False:
    ElbL7policyFixedResponseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[builtins.str],
                 content_type: Optional[pulumi.Input[builtins.str]] = None,
                 insert_headers_config: Optional[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigArgs']] = None,
                 message_body: Optional[pulumi.Input[builtins.str]] = None,
                 remove_headers_config: Optional[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs']] = None,
                 traffic_limit_config: Optional[pulumi.Input['ElbL7policyFixedResponseConfigTrafficLimitConfigArgs']] = None):
        pulumi.set(__self__, "status_code", status_code)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if insert_headers_config is not None:
            pulumi.set(__self__, "insert_headers_config", insert_headers_config)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if remove_headers_config is not None:
            pulumi.set(__self__, "remove_headers_config", remove_headers_config)
        if traffic_limit_config is not None:
            pulumi.set(__self__, "traffic_limit_config", traffic_limit_config)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="insertHeadersConfig")
    def insert_headers_config(self) -> Optional[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigArgs']]:
        return pulumi.get(self, "insert_headers_config")

    @insert_headers_config.setter
    def insert_headers_config(self, value: Optional[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigArgs']]):
        pulumi.set(self, "insert_headers_config", value)

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "message_body")

    @message_body.setter
    def message_body(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message_body", value)

    @property
    @pulumi.getter(name="removeHeadersConfig")
    def remove_headers_config(self) -> Optional[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs']]:
        return pulumi.get(self, "remove_headers_config")

    @remove_headers_config.setter
    def remove_headers_config(self, value: Optional[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs']]):
        pulumi.set(self, "remove_headers_config", value)

    @property
    @pulumi.getter(name="trafficLimitConfig")
    def traffic_limit_config(self) -> Optional[pulumi.Input['ElbL7policyFixedResponseConfigTrafficLimitConfigArgs']]:
        return pulumi.get(self, "traffic_limit_config")

    @traffic_limit_config.setter
    def traffic_limit_config(self, value: Optional[pulumi.Input['ElbL7policyFixedResponseConfigTrafficLimitConfigArgs']]):
        pulumi.set(self, "traffic_limit_config", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigInsertHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyFixedResponseConfigInsertHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigInsertHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
        value_type: pulumi.Input[builtins.str]
elif False:
    ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigInsertHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 value_type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigRemoveHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyFixedResponseConfigRemoveHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigRemoveHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
elif False:
    ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigRemoveHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ElbL7policyFixedResponseConfigTrafficLimitConfigArgsDict(TypedDict):
        burst: NotRequired[pulumi.Input[builtins.int]]
        per_source_ip_qps: NotRequired[pulumi.Input[builtins.int]]
        qps: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ElbL7policyFixedResponseConfigTrafficLimitConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyFixedResponseConfigTrafficLimitConfigArgs:
    def __init__(__self__, *,
                 burst: Optional[pulumi.Input[builtins.int]] = None,
                 per_source_ip_qps: Optional[pulumi.Input[builtins.int]] = None,
                 qps: Optional[pulumi.Input[builtins.int]] = None):
        if burst is not None:
            pulumi.set(__self__, "burst", burst)
        if per_source_ip_qps is not None:
            pulumi.set(__self__, "per_source_ip_qps", per_source_ip_qps)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @property
    @pulumi.getter
    def burst(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "burst")

    @burst.setter
    def burst(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "burst", value)

    @property
    @pulumi.getter(name="perSourceIpQps")
    def per_source_ip_qps(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "per_source_ip_qps")

    @per_source_ip_qps.setter
    def per_source_ip_qps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "per_source_ip_qps", value)

    @property
    @pulumi.getter
    def qps(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "qps")

    @qps.setter
    def qps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "qps", value)


if not MYPY:
    class ElbL7policyRedirectPoolsConfigArgsDict(TypedDict):
        pool_id: pulumi.Input[builtins.str]
        weight: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ElbL7policyRedirectPoolsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsConfigArgs:
    def __init__(__self__, *,
                 pool_id: pulumi.Input[builtins.str],
                 weight: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "pool_id", pool_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="poolId")
    def pool_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "pool_id")

    @pool_id.setter
    def pool_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "pool_id", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigArgsDict(TypedDict):
        insert_headers_config: NotRequired[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgsDict']]
        remove_headers_config: NotRequired[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgsDict']]
        rewrite_url_config: NotRequired[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgsDict']]
        rewrite_url_enabled: NotRequired[pulumi.Input[builtins.bool]]
        traffic_limit_config: NotRequired[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgsDict']]
elif False:
    ElbL7policyRedirectPoolsExtendConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigArgs:
    def __init__(__self__, *,
                 insert_headers_config: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs']] = None,
                 remove_headers_config: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs']] = None,
                 rewrite_url_config: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs']] = None,
                 rewrite_url_enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 traffic_limit_config: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs']] = None):
        if insert_headers_config is not None:
            pulumi.set(__self__, "insert_headers_config", insert_headers_config)
        if remove_headers_config is not None:
            pulumi.set(__self__, "remove_headers_config", remove_headers_config)
        if rewrite_url_config is not None:
            pulumi.set(__self__, "rewrite_url_config", rewrite_url_config)
        if rewrite_url_enabled is not None:
            pulumi.set(__self__, "rewrite_url_enabled", rewrite_url_enabled)
        if traffic_limit_config is not None:
            pulumi.set(__self__, "traffic_limit_config", traffic_limit_config)

    @property
    @pulumi.getter(name="insertHeadersConfig")
    def insert_headers_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs']]:
        return pulumi.get(self, "insert_headers_config")

    @insert_headers_config.setter
    def insert_headers_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs']]):
        pulumi.set(self, "insert_headers_config", value)

    @property
    @pulumi.getter(name="removeHeadersConfig")
    def remove_headers_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs']]:
        return pulumi.get(self, "remove_headers_config")

    @remove_headers_config.setter
    def remove_headers_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs']]):
        pulumi.set(self, "remove_headers_config", value)

    @property
    @pulumi.getter(name="rewriteUrlConfig")
    def rewrite_url_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs']]:
        return pulumi.get(self, "rewrite_url_config")

    @rewrite_url_config.setter
    def rewrite_url_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs']]):
        pulumi.set(self, "rewrite_url_config", value)

    @property
    @pulumi.getter(name="rewriteUrlEnabled")
    def rewrite_url_enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "rewrite_url_enabled")

    @rewrite_url_enabled.setter
    def rewrite_url_enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rewrite_url_enabled", value)

    @property
    @pulumi.getter(name="trafficLimitConfig")
    def traffic_limit_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs']]:
        return pulumi.get(self, "traffic_limit_config")

    @traffic_limit_config.setter
    def traffic_limit_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs']]):
        pulumi.set(self, "traffic_limit_config", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
        value_type: pulumi.Input[builtins.str]
elif False:
    ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigInsertHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 value_type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
elif False:
    ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigRemoveHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[builtins.str]]
        path: NotRequired[pulumi.Input[builtins.str]]
        query: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigRewriteUrlConfigArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 query: Optional[pulumi.Input[builtins.str]] = None):
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgsDict(TypedDict):
        burst: NotRequired[pulumi.Input[builtins.int]]
        per_source_ip_qps: NotRequired[pulumi.Input[builtins.int]]
        qps: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsExtendConfigTrafficLimitConfigArgs:
    def __init__(__self__, *,
                 burst: Optional[pulumi.Input[builtins.int]] = None,
                 per_source_ip_qps: Optional[pulumi.Input[builtins.int]] = None,
                 qps: Optional[pulumi.Input[builtins.int]] = None):
        if burst is not None:
            pulumi.set(__self__, "burst", burst)
        if per_source_ip_qps is not None:
            pulumi.set(__self__, "per_source_ip_qps", per_source_ip_qps)
        if qps is not None:
            pulumi.set(__self__, "qps", qps)

    @property
    @pulumi.getter
    def burst(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "burst")

    @burst.setter
    def burst(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "burst", value)

    @property
    @pulumi.getter(name="perSourceIpQps")
    def per_source_ip_qps(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "per_source_ip_qps")

    @per_source_ip_qps.setter
    def per_source_ip_qps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "per_source_ip_qps", value)

    @property
    @pulumi.getter
    def qps(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "qps")

    @qps.setter
    def qps(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "qps", value)


if not MYPY:
    class ElbL7policyRedirectPoolsStickySessionConfigArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[builtins.bool]]
        timeout: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ElbL7policyRedirectPoolsStickySessionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectPoolsStickySessionConfigArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigArgsDict(TypedDict):
        status_code: pulumi.Input[builtins.str]
        host: NotRequired[pulumi.Input[builtins.str]]
        insert_headers_config: NotRequired[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigArgsDict']]
        path: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.str]]
        protocol: NotRequired[pulumi.Input[builtins.str]]
        query: NotRequired[pulumi.Input[builtins.str]]
        remove_headers_config: NotRequired[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgsDict']]
elif False:
    ElbL7policyRedirectUrlConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[builtins.str],
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 insert_headers_config: Optional[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs']] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.str]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None,
                 query: Optional[pulumi.Input[builtins.str]] = None,
                 remove_headers_config: Optional[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs']] = None):
        pulumi.set(__self__, "status_code", status_code)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if insert_headers_config is not None:
            pulumi.set(__self__, "insert_headers_config", insert_headers_config)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if remove_headers_config is not None:
            pulumi.set(__self__, "remove_headers_config", remove_headers_config)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="insertHeadersConfig")
    def insert_headers_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs']]:
        return pulumi.get(self, "insert_headers_config")

    @insert_headers_config.setter
    def insert_headers_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs']]):
        pulumi.set(self, "insert_headers_config", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="removeHeadersConfig")
    def remove_headers_config(self) -> Optional[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs']]:
        return pulumi.get(self, "remove_headers_config")

    @remove_headers_config.setter
    def remove_headers_config(self, value: Optional[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs']]):
        pulumi.set(self, "remove_headers_config", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigInsertHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyRedirectUrlConfigInsertHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigInsertHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
        value_type: pulumi.Input[builtins.str]
elif False:
    ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigInsertHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 value_type: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgsDict']]]
elif False:
    ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigRemoveHeadersConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
elif False:
    ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7policyRedirectUrlConfigRemoveHeadersConfigConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ElbL7ruleConditionArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        key: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElbL7ruleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbL7ruleConditionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str],
                 key: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "value", value)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ElbListenerPortRangeArgsDict(TypedDict):
        end_port: pulumi.Input[builtins.int]
        start_port: pulumi.Input[builtins.int]
elif False:
    ElbListenerPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbListenerPortRangeArgs:
    def __init__(__self__, *,
                 end_port: pulumi.Input[builtins.int],
                 start_port: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class ElbPoolPersistenceArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        cookie_name: NotRequired[pulumi.Input[builtins.str]]
        timeout: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ElbPoolPersistenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbPoolPersistenceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 cookie_name: Optional[pulumi.Input[builtins.str]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "type", type)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ElbSecurityPolicyListenerArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ElbSecurityPolicyListenerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbSecurityPolicyListenerArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class EvsVolumeAttachmentArgsDict(TypedDict):
        device: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
        instance_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    EvsVolumeAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EvsVolumeAttachmentArgs:
    def __init__(__self__, *,
                 device: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 instance_id: Optional[pulumi.Input[builtins.str]] = None):
        if device is not None:
            pulumi.set(__self__, "device", device)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance_id", value)


if not MYPY:
    class FgsFunctionCustomImageArgsDict(TypedDict):
        url: pulumi.Input[builtins.str]
        """
        The URL of SWR image.
        """
        args: NotRequired[pulumi.Input[builtins.str]]
        """
        The command line arguments used to start the SWR image.
        """
        command: NotRequired[pulumi.Input[builtins.str]]
        """
        The startup commands of the SWR image.
        """
        user_group_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The user group ID that used to run SWR image.
        """
        user_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The user ID that used to run SWR image.
        """
        working_dir: NotRequired[pulumi.Input[builtins.str]]
        """
        The working directory of the SWR image.
        """
elif False:
    FgsFunctionCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionCustomImageArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[builtins.str],
                 args: Optional[pulumi.Input[builtins.str]] = None,
                 command: Optional[pulumi.Input[builtins.str]] = None,
                 user_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 user_id: Optional[pulumi.Input[builtins.str]] = None,
                 working_dir: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] url: The URL of SWR image.
        :param pulumi.Input[builtins.str] args: The command line arguments used to start the SWR image.
        :param pulumi.Input[builtins.str] command: The startup commands of the SWR image.
        :param pulumi.Input[builtins.str] user_group_id: The user group ID that used to run SWR image.
        :param pulumi.Input[builtins.str] user_id: The user ID that used to run SWR image.
        :param pulumi.Input[builtins.str] working_dir: The working directory of the SWR image.
        """
        pulumi.set(__self__, "url", url)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if user_group_id is not None:
            pulumi.set(__self__, "user_group_id", user_group_id)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if working_dir is not None:
            pulumi.set(__self__, "working_dir", working_dir)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[builtins.str]:
        """
        The URL of SWR image.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The command line arguments used to start the SWR image.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The startup commands of the SWR image.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter(name="userGroupId")
    def user_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The user group ID that used to run SWR image.
        """
        return pulumi.get(self, "user_group_id")

    @user_group_id.setter
    def user_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_group_id", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The user ID that used to run SWR image.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_id", value)

    @property
    @pulumi.getter(name="workingDir")
    def working_dir(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The working directory of the SWR image.
        """
        return pulumi.get(self, "working_dir")

    @working_dir.setter
    def working_dir(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "working_dir", value)


if not MYPY:
    class FgsFunctionFuncMountArgsDict(TypedDict):
        local_mount_path: pulumi.Input[builtins.str]
        """
        The function access path.
        """
        mount_resource: pulumi.Input[builtins.str]
        """
        The ID of the mounted resource (corresponding cloud service).
        """
        mount_share_path: pulumi.Input[builtins.str]
        """
        The remote mount path.
        """
        mount_type: pulumi.Input[builtins.str]
        """
        The mount type.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        The mount status.
        """
elif False:
    FgsFunctionFuncMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionFuncMountArgs:
    def __init__(__self__, *,
                 local_mount_path: pulumi.Input[builtins.str],
                 mount_resource: pulumi.Input[builtins.str],
                 mount_share_path: pulumi.Input[builtins.str],
                 mount_type: pulumi.Input[builtins.str],
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] local_mount_path: The function access path.
        :param pulumi.Input[builtins.str] mount_resource: The ID of the mounted resource (corresponding cloud service).
        :param pulumi.Input[builtins.str] mount_share_path: The remote mount path.
        :param pulumi.Input[builtins.str] mount_type: The mount type.
        :param pulumi.Input[builtins.str] status: The mount status.
        """
        pulumi.set(__self__, "local_mount_path", local_mount_path)
        pulumi.set(__self__, "mount_resource", mount_resource)
        pulumi.set(__self__, "mount_share_path", mount_share_path)
        pulumi.set(__self__, "mount_type", mount_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="localMountPath")
    def local_mount_path(self) -> pulumi.Input[builtins.str]:
        """
        The function access path.
        """
        return pulumi.get(self, "local_mount_path")

    @local_mount_path.setter
    def local_mount_path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "local_mount_path", value)

    @property
    @pulumi.getter(name="mountResource")
    def mount_resource(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the mounted resource (corresponding cloud service).
        """
        return pulumi.get(self, "mount_resource")

    @mount_resource.setter
    def mount_resource(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "mount_resource", value)

    @property
    @pulumi.getter(name="mountSharePath")
    def mount_share_path(self) -> pulumi.Input[builtins.str]:
        """
        The remote mount path.
        """
        return pulumi.get(self, "mount_share_path")

    @mount_share_path.setter
    def mount_share_path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "mount_share_path", value)

    @property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> pulumi.Input[builtins.str]:
        """
        The mount type.
        """
        return pulumi.get(self, "mount_type")

    @mount_type.setter
    def mount_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "mount_type", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The mount status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FgsFunctionNetworkControllerArgsDict(TypedDict):
        trigger_access_vpcs: pulumi.Input[Sequence[pulumi.Input['FgsFunctionNetworkControllerTriggerAccessVpcArgsDict']]]
        """
        The configuration of the VPCs that can trigger the function.
        """
        disable_public_network: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to disable the public network access.
        """
elif False:
    FgsFunctionNetworkControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionNetworkControllerArgs:
    def __init__(__self__, *,
                 trigger_access_vpcs: pulumi.Input[Sequence[pulumi.Input['FgsFunctionNetworkControllerTriggerAccessVpcArgs']]],
                 disable_public_network: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FgsFunctionNetworkControllerTriggerAccessVpcArgs']]] trigger_access_vpcs: The configuration of the VPCs that can trigger the function.
        :param pulumi.Input[builtins.bool] disable_public_network: Whether to disable the public network access.
        """
        pulumi.set(__self__, "trigger_access_vpcs", trigger_access_vpcs)
        if disable_public_network is not None:
            pulumi.set(__self__, "disable_public_network", disable_public_network)

    @property
    @pulumi.getter(name="triggerAccessVpcs")
    def trigger_access_vpcs(self) -> pulumi.Input[Sequence[pulumi.Input['FgsFunctionNetworkControllerTriggerAccessVpcArgs']]]:
        """
        The configuration of the VPCs that can trigger the function.
        """
        return pulumi.get(self, "trigger_access_vpcs")

    @trigger_access_vpcs.setter
    def trigger_access_vpcs(self, value: pulumi.Input[Sequence[pulumi.Input['FgsFunctionNetworkControllerTriggerAccessVpcArgs']]]):
        pulumi.set(self, "trigger_access_vpcs", value)

    @property
    @pulumi.getter(name="disablePublicNetwork")
    def disable_public_network(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to disable the public network access.
        """
        return pulumi.get(self, "disable_public_network")

    @disable_public_network.setter
    def disable_public_network(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_public_network", value)


if not MYPY:
    class FgsFunctionNetworkControllerTriggerAccessVpcArgsDict(TypedDict):
        vpc_id: pulumi.Input[builtins.str]
        """
        The ID of the VPC that can trigger the function.
        """
elif False:
    FgsFunctionNetworkControllerTriggerAccessVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionNetworkControllerTriggerAccessVpcArgs:
    def __init__(__self__, *,
                 vpc_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] vpc_id: The ID of the VPC that can trigger the function.
        """
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the VPC that can trigger the function.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class FgsFunctionReservedInstanceArgsDict(TypedDict):
        count: pulumi.Input[builtins.int]
        """
        The number of reserved instance.
        """
        qualifier_name: pulumi.Input[builtins.str]
        """
        The version name or alias name.
        """
        qualifier_type: pulumi.Input[builtins.str]
        """
        The qualifier type of reserved instance.
        """
        idle_mode: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable the idle mode.
        """
        tactics_config: NotRequired[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigArgsDict']]
        """
        The auto scaling policies for reserved instance.
        """
elif False:
    FgsFunctionReservedInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionReservedInstanceArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[builtins.int],
                 qualifier_name: pulumi.Input[builtins.str],
                 qualifier_type: pulumi.Input[builtins.str],
                 idle_mode: Optional[pulumi.Input[builtins.bool]] = None,
                 tactics_config: Optional[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigArgs']] = None):
        """
        :param pulumi.Input[builtins.int] count: The number of reserved instance.
        :param pulumi.Input[builtins.str] qualifier_name: The version name or alias name.
        :param pulumi.Input[builtins.str] qualifier_type: The qualifier type of reserved instance.
        :param pulumi.Input[builtins.bool] idle_mode: Whether to enable the idle mode.
        :param pulumi.Input['FgsFunctionReservedInstanceTacticsConfigArgs'] tactics_config: The auto scaling policies for reserved instance.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "qualifier_name", qualifier_name)
        pulumi.set(__self__, "qualifier_type", qualifier_type)
        if idle_mode is not None:
            pulumi.set(__self__, "idle_mode", idle_mode)
        if tactics_config is not None:
            pulumi.set(__self__, "tactics_config", tactics_config)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[builtins.int]:
        """
        The number of reserved instance.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="qualifierName")
    def qualifier_name(self) -> pulumi.Input[builtins.str]:
        """
        The version name or alias name.
        """
        return pulumi.get(self, "qualifier_name")

    @qualifier_name.setter
    def qualifier_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "qualifier_name", value)

    @property
    @pulumi.getter(name="qualifierType")
    def qualifier_type(self) -> pulumi.Input[builtins.str]:
        """
        The qualifier type of reserved instance.
        """
        return pulumi.get(self, "qualifier_type")

    @qualifier_type.setter
    def qualifier_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "qualifier_type", value)

    @property
    @pulumi.getter(name="idleMode")
    def idle_mode(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable the idle mode.
        """
        return pulumi.get(self, "idle_mode")

    @idle_mode.setter
    def idle_mode(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "idle_mode", value)

    @property
    @pulumi.getter(name="tacticsConfig")
    def tactics_config(self) -> Optional[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigArgs']]:
        """
        The auto scaling policies for reserved instance.
        """
        return pulumi.get(self, "tactics_config")

    @tactics_config.setter
    def tactics_config(self, value: Optional[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigArgs']]):
        pulumi.set(self, "tactics_config", value)


if not MYPY:
    class FgsFunctionReservedInstanceTacticsConfigArgsDict(TypedDict):
        cron_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigCronConfigArgsDict']]]]
        """
        The list of scheduled policy configurations.
        """
        metric_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigMetricConfigArgsDict']]]]
        """
        The list of metric policy configurations.
        """
elif False:
    FgsFunctionReservedInstanceTacticsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionReservedInstanceTacticsConfigArgs:
    def __init__(__self__, *,
                 cron_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigCronConfigArgs']]]] = None,
                 metric_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigMetricConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigCronConfigArgs']]] cron_configs: The list of scheduled policy configurations.
        :param pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigMetricConfigArgs']]] metric_configs: The list of metric policy configurations.
        """
        if cron_configs is not None:
            pulumi.set(__self__, "cron_configs", cron_configs)
        if metric_configs is not None:
            pulumi.set(__self__, "metric_configs", metric_configs)

    @property
    @pulumi.getter(name="cronConfigs")
    def cron_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigCronConfigArgs']]]]:
        """
        The list of scheduled policy configurations.
        """
        return pulumi.get(self, "cron_configs")

    @cron_configs.setter
    def cron_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigCronConfigArgs']]]]):
        pulumi.set(self, "cron_configs", value)

    @property
    @pulumi.getter(name="metricConfigs")
    def metric_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigMetricConfigArgs']]]]:
        """
        The list of metric policy configurations.
        """
        return pulumi.get(self, "metric_configs")

    @metric_configs.setter
    def metric_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FgsFunctionReservedInstanceTacticsConfigMetricConfigArgs']]]]):
        pulumi.set(self, "metric_configs", value)


if not MYPY:
    class FgsFunctionReservedInstanceTacticsConfigCronConfigArgsDict(TypedDict):
        count: pulumi.Input[builtins.int]
        """
        The number of reserved instance to which the policy belongs.
        """
        cron: pulumi.Input[builtins.str]
        """
        The cron expression.
        """
        expired_time: pulumi.Input[builtins.int]
        """
        The expiration timestamp of the policy.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of scheduled policy configuration.
        """
        start_time: pulumi.Input[builtins.int]
        """
        The effective timestamp of policy.
        """
elif False:
    FgsFunctionReservedInstanceTacticsConfigCronConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionReservedInstanceTacticsConfigCronConfigArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[builtins.int],
                 cron: pulumi.Input[builtins.str],
                 expired_time: pulumi.Input[builtins.int],
                 name: pulumi.Input[builtins.str],
                 start_time: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] count: The number of reserved instance to which the policy belongs.
        :param pulumi.Input[builtins.str] cron: The cron expression.
        :param pulumi.Input[builtins.int] expired_time: The expiration timestamp of the policy.
        :param pulumi.Input[builtins.str] name: The name of scheduled policy configuration.
        :param pulumi.Input[builtins.int] start_time: The effective timestamp of policy.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "cron", cron)
        pulumi.set(__self__, "expired_time", expired_time)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[builtins.int]:
        """
        The number of reserved instance to which the policy belongs.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def cron(self) -> pulumi.Input[builtins.str]:
        """
        The cron expression.
        """
        return pulumi.get(self, "cron")

    @cron.setter
    def cron(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cron", value)

    @property
    @pulumi.getter(name="expiredTime")
    def expired_time(self) -> pulumi.Input[builtins.int]:
        """
        The expiration timestamp of the policy.
        """
        return pulumi.get(self, "expired_time")

    @expired_time.setter
    def expired_time(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "expired_time", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of scheduled policy configuration.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[builtins.int]:
        """
        The effective timestamp of policy.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class FgsFunctionReservedInstanceTacticsConfigMetricConfigArgsDict(TypedDict):
        min: pulumi.Input[builtins.int]
        """
        The minimun of traffic.
        """
        name: pulumi.Input[builtins.str]
        """
        The name of metric policy.
        """
        threshold: pulumi.Input[builtins.int]
        """
        The metric policy threshold.
        """
        type: pulumi.Input[builtins.str]
        """
        The type of metric policy.
        """
elif False:
    FgsFunctionReservedInstanceTacticsConfigMetricConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionReservedInstanceTacticsConfigMetricConfigArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[builtins.int],
                 name: pulumi.Input[builtins.str],
                 threshold: pulumi.Input[builtins.int],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.int] min: The minimun of traffic.
        :param pulumi.Input[builtins.str] name: The name of metric policy.
        :param pulumi.Input[builtins.int] threshold: The metric policy threshold.
        :param pulumi.Input[builtins.str] type: The type of metric policy.
        """
        pulumi.set(__self__, "min", min)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[builtins.int]:
        """
        The minimun of traffic.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of metric policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[builtins.int]:
        """
        The metric policy threshold.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of metric policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FgsFunctionVersionArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The version name.
        """
        aliases: NotRequired[pulumi.Input['FgsFunctionVersionAliasesArgsDict']]
        """
        The aliases management for specified version.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the version.
        """
elif False:
    FgsFunctionVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionVersionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 aliases: Optional[pulumi.Input['FgsFunctionVersionAliasesArgs']] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: The version name.
        :param pulumi.Input['FgsFunctionVersionAliasesArgs'] aliases: The aliases management for specified version.
        :param pulumi.Input[builtins.str] description: The description of the version.
        """
        pulumi.set(__self__, "name", name)
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The version name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input['FgsFunctionVersionAliasesArgs']]:
        """
        The aliases management for specified version.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input['FgsFunctionVersionAliasesArgs']]):
        pulumi.set(self, "aliases", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FgsFunctionVersionAliasesArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the version alias.
        """
        additional_version_strategy: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the version alias.
        """
        additional_version_weights: NotRequired[pulumi.Input[builtins.str]]
        """
        The percentage grayscale configuration of the version alias.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        The description of the version alias.
        """
elif False:
    FgsFunctionVersionAliasesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FgsFunctionVersionAliasesArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 additional_version_strategy: Optional[pulumi.Input[builtins.str]] = None,
                 additional_version_weights: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the version alias.
        :param pulumi.Input[builtins.str] additional_version_strategy: The description of the version alias.
        :param pulumi.Input[builtins.str] additional_version_weights: The percentage grayscale configuration of the version alias.
        :param pulumi.Input[builtins.str] description: The description of the version alias.
        """
        pulumi.set(__self__, "name", name)
        if additional_version_strategy is not None:
            pulumi.set(__self__, "additional_version_strategy", additional_version_strategy)
        if additional_version_weights is not None:
            pulumi.set(__self__, "additional_version_weights", additional_version_weights)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the version alias.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="additionalVersionStrategy")
    def additional_version_strategy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the version alias.
        """
        return pulumi.get(self, "additional_version_strategy")

    @additional_version_strategy.setter
    def additional_version_strategy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "additional_version_strategy", value)

    @property
    @pulumi.getter(name="additionalVersionWeights")
    def additional_version_weights(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The percentage grayscale configuration of the version alias.
        """
        return pulumi.get(self, "additional_version_weights")

    @additional_version_weights.setter
    def additional_version_weights(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "additional_version_weights", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The description of the version alias.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class GesGraphEncryptionArgsDict(TypedDict):
        enable: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable data encryption The value can be true or false. The default value is false.
        """
        master_key_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the customer master key created by DEW in the project corresponding to the graph creation.
        """
elif False:
    GesGraphEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GesGraphEncryptionArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[builtins.bool]] = None,
                 master_key_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enable: Whether to enable data encryption The value can be true or false. The default value is false.
        :param pulumi.Input[builtins.str] master_key_id: ID of the customer master key created by DEW in the project corresponding to the graph creation.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if master_key_id is not None:
            pulumi.set(__self__, "master_key_id", master_key_id)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable data encryption The value can be true or false. The default value is false.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="masterKeyId")
    def master_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the customer master key created by DEW in the project corresponding to the graph creation.
        """
        return pulumi.get(self, "master_key_id")

    @master_key_id.setter
    def master_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "master_key_id", value)


if not MYPY:
    class GesGraphLtsOperationTraceArgsDict(TypedDict):
        audit_log_group_name: NotRequired[pulumi.Input[builtins.str]]
        """
        LTS log group name.
        """
        enable_audit: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to enable graph audit. The default value is false.
        """
elif False:
    GesGraphLtsOperationTraceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GesGraphLtsOperationTraceArgs:
    def __init__(__self__, *,
                 audit_log_group_name: Optional[pulumi.Input[builtins.str]] = None,
                 enable_audit: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] audit_log_group_name: LTS log group name.
        :param pulumi.Input[builtins.bool] enable_audit: Whether to enable graph audit. The default value is false.
        """
        if audit_log_group_name is not None:
            pulumi.set(__self__, "audit_log_group_name", audit_log_group_name)
        if enable_audit is not None:
            pulumi.set(__self__, "enable_audit", enable_audit)

    @property
    @pulumi.getter(name="auditLogGroupName")
    def audit_log_group_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        LTS log group name.
        """
        return pulumi.get(self, "audit_log_group_name")

    @audit_log_group_name.setter
    def audit_log_group_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "audit_log_group_name", value)

    @property
    @pulumi.getter(name="enableAudit")
    def enable_audit(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to enable graph audit. The default value is false.
        """
        return pulumi.get(self, "enable_audit")

    @enable_audit.setter
    def enable_audit(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_audit", value)


if not MYPY:
    class GesGraphPublicIpArgsDict(TypedDict):
        eip_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The EIP ID.
        """
        public_bind_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The bind type of public IP.
        """
elif False:
    GesGraphPublicIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GesGraphPublicIpArgs:
    def __init__(__self__, *,
                 eip_id: Optional[pulumi.Input[builtins.str]] = None,
                 public_bind_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] eip_id: The EIP ID.
        :param pulumi.Input[builtins.str] public_bind_type: The bind type of public IP.
        """
        if eip_id is not None:
            pulumi.set(__self__, "eip_id", eip_id)
        if public_bind_type is not None:
            pulumi.set(__self__, "public_bind_type", public_bind_type)

    @property
    @pulumi.getter(name="eipId")
    def eip_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The EIP ID.
        """
        return pulumi.get(self, "eip_id")

    @eip_id.setter
    def eip_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "eip_id", value)

    @property
    @pulumi.getter(name="publicBindType")
    def public_bind_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bind type of public IP.
        """
        return pulumi.get(self, "public_bind_type")

    @public_bind_type.setter
    def public_bind_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "public_bind_type", value)


if not MYPY:
    class GesGraphVertexIdTypeArgsDict(TypedDict):
        id_length: NotRequired[pulumi.Input[builtins.int]]
        """
        The length of ID.
        """
        id_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Vertex ID type.
        """
elif False:
    GesGraphVertexIdTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GesGraphVertexIdTypeArgs:
    def __init__(__self__, *,
                 id_length: Optional[pulumi.Input[builtins.int]] = None,
                 id_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] id_length: The length of ID.
        :param pulumi.Input[builtins.str] id_type: Vertex ID type.
        """
        if id_length is not None:
            pulumi.set(__self__, "id_length", id_length)
        if id_type is not None:
            pulumi.set(__self__, "id_type", id_type)

    @property
    @pulumi.getter(name="idLength")
    def id_length(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The length of ID.
        """
        return pulumi.get(self, "id_length")

    @id_length.setter
    def id_length(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "id_length", value)

    @property
    @pulumi.getter(name="idType")
    def id_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Vertex ID type.
        """
        return pulumi.get(self, "id_type")

    @id_type.setter
    def id_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id_type", value)


if not MYPY:
    class IdentityAclIpCidrArgsDict(TypedDict):
        cidr: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    IdentityAclIpCidrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityAclIpCidrArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "cidr", cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class IdentityAclIpRangeArgsDict(TypedDict):
        range: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    IdentityAclIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityAclIpRangeArgs:
    def __init__(__self__, *,
                 range: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "range", range)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def range(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class IdentityAgencyProjectRoleArgsDict(TypedDict):
        project: pulumi.Input[builtins.str]
        roles: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
elif False:
    IdentityAgencyProjectRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityAgencyProjectRoleArgs:
    def __init__(__self__, *,
                 project: pulumi.Input[builtins.str],
                 roles: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter
    def project(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter
    def roles(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class IdentityProviderAccessConfigArgsDict(TypedDict):
        access_type: pulumi.Input[builtins.str]
        client_id: pulumi.Input[builtins.str]
        provider_url: pulumi.Input[builtins.str]
        signing_key: pulumi.Input[builtins.str]
        authorization_endpoint: NotRequired[pulumi.Input[builtins.str]]
        response_mode: NotRequired[pulumi.Input[builtins.str]]
        response_type: NotRequired[pulumi.Input[builtins.str]]
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    IdentityProviderAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProviderAccessConfigArgs:
    def __init__(__self__, *,
                 access_type: pulumi.Input[builtins.str],
                 client_id: pulumi.Input[builtins.str],
                 provider_url: pulumi.Input[builtins.str],
                 signing_key: pulumi.Input[builtins.str],
                 authorization_endpoint: Optional[pulumi.Input[builtins.str]] = None,
                 response_mode: Optional[pulumi.Input[builtins.str]] = None,
                 response_type: Optional[pulumi.Input[builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "access_type", access_type)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "provider_url", provider_url)
        pulumi.set(__self__, "signing_key", signing_key)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if response_mode is not None:
            pulumi.set(__self__, "response_mode", response_mode)
        if response_type is not None:
            pulumi.set(__self__, "response_type", response_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "access_type", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="providerUrl")
    def provider_url(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "provider_url")

    @provider_url.setter
    def provider_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider_url", value)

    @property
    @pulumi.getter(name="signingKey")
    def signing_key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "signing_key")

    @signing_key.setter
    def signing_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "signing_key", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @property
    @pulumi.getter(name="responseMode")
    def response_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "response_mode")

    @response_mode.setter
    def response_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "response_mode", value)

    @property
    @pulumi.getter(name="responseType")
    def response_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "response_type")

    @response_type.setter
    def response_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "response_type", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class IdentityProviderConversionConversionRuleArgsDict(TypedDict):
        locals: pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionConversionRuleLocalArgsDict']]]
        remotes: pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionConversionRuleRemoteArgsDict']]]
elif False:
    IdentityProviderConversionConversionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProviderConversionConversionRuleArgs:
    def __init__(__self__, *,
                 locals: pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionConversionRuleLocalArgs']]],
                 remotes: pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionConversionRuleRemoteArgs']]]):
        pulumi.set(__self__, "locals", locals)
        pulumi.set(__self__, "remotes", remotes)

    @property
    @pulumi.getter
    def locals(self) -> pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionConversionRuleLocalArgs']]]:
        return pulumi.get(self, "locals")

    @locals.setter
    def locals(self, value: pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionConversionRuleLocalArgs']]]):
        pulumi.set(self, "locals", value)

    @property
    @pulumi.getter
    def remotes(self) -> pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionConversionRuleRemoteArgs']]]:
        return pulumi.get(self, "remotes")

    @remotes.setter
    def remotes(self, value: pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionConversionRuleRemoteArgs']]]):
        pulumi.set(self, "remotes", value)


if not MYPY:
    class IdentityProviderConversionConversionRuleLocalArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[builtins.str]]
        username: NotRequired[pulumi.Input[builtins.str]]
elif False:
    IdentityProviderConversionConversionRuleLocalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProviderConversionConversionRuleLocalArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        if group is not None:
            pulumi.set(__self__, "group", group)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class IdentityProviderConversionConversionRuleRemoteArgsDict(TypedDict):
        attribute: pulumi.Input[builtins.str]
        condition: NotRequired[pulumi.Input[builtins.str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    IdentityProviderConversionConversionRuleRemoteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProviderConversionConversionRuleRemoteArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input[builtins.str],
                 condition: Optional[pulumi.Input[builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "attribute", attribute)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "attribute", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class IdentityProviderConversionRuleArgsDict(TypedDict):
        locals: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionRuleLocalArgsDict']]]]
        remotes: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionRuleRemoteArgsDict']]]]
elif False:
    IdentityProviderConversionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProviderConversionRuleArgs:
    def __init__(__self__, *,
                 locals: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionRuleLocalArgs']]]] = None,
                 remotes: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionRuleRemoteArgs']]]] = None):
        if locals is not None:
            pulumi.set(__self__, "locals", locals)
        if remotes is not None:
            pulumi.set(__self__, "remotes", remotes)

    @property
    @pulumi.getter
    def locals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionRuleLocalArgs']]]]:
        return pulumi.get(self, "locals")

    @locals.setter
    def locals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionRuleLocalArgs']]]]):
        pulumi.set(self, "locals", value)

    @property
    @pulumi.getter
    def remotes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionRuleRemoteArgs']]]]:
        return pulumi.get(self, "remotes")

    @remotes.setter
    def remotes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityProviderConversionRuleRemoteArgs']]]]):
        pulumi.set(self, "remotes", value)


if not MYPY:
    class IdentityProviderConversionRuleLocalArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[builtins.str]]
        username: NotRequired[pulumi.Input[builtins.str]]
elif False:
    IdentityProviderConversionRuleLocalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProviderConversionRuleLocalArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        if group is not None:
            pulumi.set(__self__, "group", group)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class IdentityProviderConversionRuleRemoteArgsDict(TypedDict):
        attribute: NotRequired[pulumi.Input[builtins.str]]
        condition: NotRequired[pulumi.Input[builtins.str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    IdentityProviderConversionRuleRemoteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityProviderConversionRuleRemoteArgs:
    def __init__(__self__, *,
                 attribute: Optional[pulumi.Input[builtins.str]] = None,
                 condition: Optional[pulumi.Input[builtins.str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def attribute(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "attribute", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class LbPoolPersistenceArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        cookie_name: NotRequired[pulumi.Input[builtins.str]]
        timeout: NotRequired[pulumi.Input[builtins.int]]
elif False:
    LbPoolPersistenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbPoolPersistenceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 cookie_name: Optional[pulumi.Input[builtins.str]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "type", type)
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class MapreduceClusterAnalysisCoreNodesArgsDict(TypedDict):
        data_volume_count: pulumi.Input[builtins.int]
        flavor: pulumi.Input[builtins.str]
        node_number: pulumi.Input[builtins.int]
        root_volume_size: pulumi.Input[builtins.int]
        root_volume_type: pulumi.Input[builtins.str]
        assigned_roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        data_volume_size: NotRequired[pulumi.Input[builtins.int]]
        data_volume_type: NotRequired[pulumi.Input[builtins.str]]
        host_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    MapreduceClusterAnalysisCoreNodesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterAnalysisCoreNodesArgs:
    def __init__(__self__, *,
                 data_volume_count: pulumi.Input[builtins.int],
                 flavor: pulumi.Input[builtins.str],
                 node_number: pulumi.Input[builtins.int],
                 root_volume_size: pulumi.Input[builtins.int],
                 root_volume_type: pulumi.Input[builtins.str],
                 assigned_roles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 data_volume_size: Optional[pulumi.Input[builtins.int]] = None,
                 data_volume_type: Optional[pulumi.Input[builtins.str]] = None,
                 host_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "data_volume_count", data_volume_count)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "node_number", node_number)
        pulumi.set(__self__, "root_volume_size", root_volume_size)
        pulumi.set(__self__, "root_volume_type", root_volume_type)
        if assigned_roles is not None:
            pulumi.set(__self__, "assigned_roles", assigned_roles)
        if data_volume_size is not None:
            pulumi.set(__self__, "data_volume_size", data_volume_size)
        if data_volume_type is not None:
            pulumi.set(__self__, "data_volume_type", data_volume_type)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)

    @property
    @pulumi.getter(name="dataVolumeCount")
    def data_volume_count(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "data_volume_count")

    @data_volume_count.setter
    def data_volume_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "data_volume_count", value)

    @property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "flavor", value)

    @property
    @pulumi.getter(name="nodeNumber")
    def node_number(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "node_number")

    @node_number.setter
    def node_number(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "node_number", value)

    @property
    @pulumi.getter(name="rootVolumeSize")
    def root_volume_size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "root_volume_size")

    @root_volume_size.setter
    def root_volume_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "root_volume_size", value)

    @property
    @pulumi.getter(name="rootVolumeType")
    def root_volume_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "root_volume_type")

    @root_volume_type.setter
    def root_volume_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "root_volume_type", value)

    @property
    @pulumi.getter(name="assignedRoles")
    def assigned_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "assigned_roles")

    @assigned_roles.setter
    def assigned_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "assigned_roles", value)

    @property
    @pulumi.getter(name="dataVolumeSize")
    def data_volume_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "data_volume_size")

    @data_volume_size.setter
    def data_volume_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_volume_size", value)

    @property
    @pulumi.getter(name="dataVolumeType")
    def data_volume_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "data_volume_type")

    @data_volume_type.setter
    def data_volume_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_volume_type", value)

    @property
    @pulumi.getter(name="hostIps")
    def host_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "host_ips")

    @host_ips.setter
    def host_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "host_ips", value)


if not MYPY:
    class MapreduceClusterAnalysisTaskNodesArgsDict(TypedDict):
        data_volume_count: pulumi.Input[builtins.int]
        flavor: pulumi.Input[builtins.str]
        node_number: pulumi.Input[builtins.int]
        root_volume_size: pulumi.Input[builtins.int]
        root_volume_type: pulumi.Input[builtins.str]
        assigned_roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        data_volume_size: NotRequired[pulumi.Input[builtins.int]]
        data_volume_type: NotRequired[pulumi.Input[builtins.str]]
        host_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    MapreduceClusterAnalysisTaskNodesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterAnalysisTaskNodesArgs:
    def __init__(__self__, *,
                 data_volume_count: pulumi.Input[builtins.int],
                 flavor: pulumi.Input[builtins.str],
                 node_number: pulumi.Input[builtins.int],
                 root_volume_size: pulumi.Input[builtins.int],
                 root_volume_type: pulumi.Input[builtins.str],
                 assigned_roles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 data_volume_size: Optional[pulumi.Input[builtins.int]] = None,
                 data_volume_type: Optional[pulumi.Input[builtins.str]] = None,
                 host_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "data_volume_count", data_volume_count)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "node_number", node_number)
        pulumi.set(__self__, "root_volume_size", root_volume_size)
        pulumi.set(__self__, "root_volume_type", root_volume_type)
        if assigned_roles is not None:
            pulumi.set(__self__, "assigned_roles", assigned_roles)
        if data_volume_size is not None:
            pulumi.set(__self__, "data_volume_size", data_volume_size)
        if data_volume_type is not None:
            pulumi.set(__self__, "data_volume_type", data_volume_type)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)

    @property
    @pulumi.getter(name="dataVolumeCount")
    def data_volume_count(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "data_volume_count")

    @data_volume_count.setter
    def data_volume_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "data_volume_count", value)

    @property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "flavor", value)

    @property
    @pulumi.getter(name="nodeNumber")
    def node_number(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "node_number")

    @node_number.setter
    def node_number(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "node_number", value)

    @property
    @pulumi.getter(name="rootVolumeSize")
    def root_volume_size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "root_volume_size")

    @root_volume_size.setter
    def root_volume_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "root_volume_size", value)

    @property
    @pulumi.getter(name="rootVolumeType")
    def root_volume_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "root_volume_type")

    @root_volume_type.setter
    def root_volume_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "root_volume_type", value)

    @property
    @pulumi.getter(name="assignedRoles")
    def assigned_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "assigned_roles")

    @assigned_roles.setter
    def assigned_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "assigned_roles", value)

    @property
    @pulumi.getter(name="dataVolumeSize")
    def data_volume_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "data_volume_size")

    @data_volume_size.setter
    def data_volume_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_volume_size", value)

    @property
    @pulumi.getter(name="dataVolumeType")
    def data_volume_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "data_volume_type")

    @data_volume_type.setter
    def data_volume_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_volume_type", value)

    @property
    @pulumi.getter(name="hostIps")
    def host_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "host_ips")

    @host_ips.setter
    def host_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "host_ips", value)


if not MYPY:
    class MapreduceClusterBootstrapScriptArgsDict(TypedDict):
        fail_action: pulumi.Input[builtins.str]
        """
        The action after the bootstrap action script fails to be executed.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of a bootstrap action script.
        """
        nodes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Name of the node group where the bootstrap action script is executed.
        """
        uri: pulumi.Input[builtins.str]
        """
        Path of a bootstrap action script. Set this parameter to an OBS bucket path or a local VM path.
        """
        active_master: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the bootstrap action script runs only on active master nodes.
        """
        before_component_start: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the bootstrap action script is executed before component start.
        """
        execute_need_sudo_root: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the bootstrap action script involves root user operations.
        """
        parameters: NotRequired[pulumi.Input[builtins.str]]
        """
        Bootstrap action script parameters.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The execution time of one bootstrap action script, in RFC-3339 format.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        The status of one bootstrap action script.
        """
elif False:
    MapreduceClusterBootstrapScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterBootstrapScriptArgs:
    def __init__(__self__, *,
                 fail_action: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 nodes: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 uri: pulumi.Input[builtins.str],
                 active_master: Optional[pulumi.Input[builtins.bool]] = None,
                 before_component_start: Optional[pulumi.Input[builtins.bool]] = None,
                 execute_need_sudo_root: Optional[pulumi.Input[builtins.bool]] = None,
                 parameters: Optional[pulumi.Input[builtins.str]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] fail_action: The action after the bootstrap action script fails to be executed.
        :param pulumi.Input[builtins.str] name: Name of a bootstrap action script.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] nodes: Name of the node group where the bootstrap action script is executed.
        :param pulumi.Input[builtins.str] uri: Path of a bootstrap action script. Set this parameter to an OBS bucket path or a local VM path.
        :param pulumi.Input[builtins.bool] active_master: Whether the bootstrap action script runs only on active master nodes.
        :param pulumi.Input[builtins.bool] before_component_start: Whether the bootstrap action script is executed before component start.
        :param pulumi.Input[builtins.bool] execute_need_sudo_root: Whether the bootstrap action script involves root user operations.
        :param pulumi.Input[builtins.str] parameters: Bootstrap action script parameters.
        :param pulumi.Input[builtins.str] start_time: The execution time of one bootstrap action script, in RFC-3339 format.
        :param pulumi.Input[builtins.str] state: The status of one bootstrap action script.
        """
        pulumi.set(__self__, "fail_action", fail_action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "uri", uri)
        if active_master is not None:
            pulumi.set(__self__, "active_master", active_master)
        if before_component_start is not None:
            pulumi.set(__self__, "before_component_start", before_component_start)
        if execute_need_sudo_root is not None:
            pulumi.set(__self__, "execute_need_sudo_root", execute_need_sudo_root)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="failAction")
    def fail_action(self) -> pulumi.Input[builtins.str]:
        """
        The action after the bootstrap action script fails to be executed.
        """
        return pulumi.get(self, "fail_action")

    @fail_action.setter
    def fail_action(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "fail_action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of a bootstrap action script.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Name of the node group where the bootstrap action script is executed.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[builtins.str]:
        """
        Path of a bootstrap action script. Set this parameter to an OBS bucket path or a local VM path.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="activeMaster")
    def active_master(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the bootstrap action script runs only on active master nodes.
        """
        return pulumi.get(self, "active_master")

    @active_master.setter
    def active_master(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "active_master", value)

    @property
    @pulumi.getter(name="beforeComponentStart")
    def before_component_start(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the bootstrap action script is executed before component start.
        """
        return pulumi.get(self, "before_component_start")

    @before_component_start.setter
    def before_component_start(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "before_component_start", value)

    @property
    @pulumi.getter(name="executeNeedSudoRoot")
    def execute_need_sudo_root(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the bootstrap action script involves root user operations.
        """
        return pulumi.get(self, "execute_need_sudo_root")

    @execute_need_sudo_root.setter
    def execute_need_sudo_root(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "execute_need_sudo_root", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Bootstrap action script parameters.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The execution time of one bootstrap action script, in RFC-3339 format.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The status of one bootstrap action script.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MapreduceClusterComponentConfigArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['MapreduceClusterComponentConfigConfigArgsDict']]]
        name: pulumi.Input[builtins.str]
elif False:
    MapreduceClusterComponentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterComponentConfigArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['MapreduceClusterComponentConfigConfigArgs']]],
                 name: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['MapreduceClusterComponentConfigConfigArgs']]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['MapreduceClusterComponentConfigConfigArgs']]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MapreduceClusterComponentConfigConfigArgsDict(TypedDict):
        config_file_name: pulumi.Input[builtins.str]
        key: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    MapreduceClusterComponentConfigConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterComponentConfigConfigArgs:
    def __init__(__self__, *,
                 config_file_name: pulumi.Input[builtins.str],
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "config_file_name", config_file_name)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="configFileName")
    def config_file_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "config_file_name")

    @config_file_name.setter
    def config_file_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "config_file_name", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MapreduceClusterCustomNodeArgsDict(TypedDict):
        data_volume_count: pulumi.Input[builtins.int]
        flavor: pulumi.Input[builtins.str]
        group_name: pulumi.Input[builtins.str]
        node_number: pulumi.Input[builtins.int]
        root_volume_size: pulumi.Input[builtins.int]
        root_volume_type: pulumi.Input[builtins.str]
        assigned_roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        data_volume_size: NotRequired[pulumi.Input[builtins.int]]
        data_volume_type: NotRequired[pulumi.Input[builtins.str]]
        host_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    MapreduceClusterCustomNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterCustomNodeArgs:
    def __init__(__self__, *,
                 data_volume_count: pulumi.Input[builtins.int],
                 flavor: pulumi.Input[builtins.str],
                 group_name: pulumi.Input[builtins.str],
                 node_number: pulumi.Input[builtins.int],
                 root_volume_size: pulumi.Input[builtins.int],
                 root_volume_type: pulumi.Input[builtins.str],
                 assigned_roles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 data_volume_size: Optional[pulumi.Input[builtins.int]] = None,
                 data_volume_type: Optional[pulumi.Input[builtins.str]] = None,
                 host_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "data_volume_count", data_volume_count)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "node_number", node_number)
        pulumi.set(__self__, "root_volume_size", root_volume_size)
        pulumi.set(__self__, "root_volume_type", root_volume_type)
        if assigned_roles is not None:
            pulumi.set(__self__, "assigned_roles", assigned_roles)
        if data_volume_size is not None:
            pulumi.set(__self__, "data_volume_size", data_volume_size)
        if data_volume_type is not None:
            pulumi.set(__self__, "data_volume_type", data_volume_type)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)

    @property
    @pulumi.getter(name="dataVolumeCount")
    def data_volume_count(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "data_volume_count")

    @data_volume_count.setter
    def data_volume_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "data_volume_count", value)

    @property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "flavor", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="nodeNumber")
    def node_number(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "node_number")

    @node_number.setter
    def node_number(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "node_number", value)

    @property
    @pulumi.getter(name="rootVolumeSize")
    def root_volume_size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "root_volume_size")

    @root_volume_size.setter
    def root_volume_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "root_volume_size", value)

    @property
    @pulumi.getter(name="rootVolumeType")
    def root_volume_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "root_volume_type")

    @root_volume_type.setter
    def root_volume_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "root_volume_type", value)

    @property
    @pulumi.getter(name="assignedRoles")
    def assigned_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "assigned_roles")

    @assigned_roles.setter
    def assigned_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "assigned_roles", value)

    @property
    @pulumi.getter(name="dataVolumeSize")
    def data_volume_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "data_volume_size")

    @data_volume_size.setter
    def data_volume_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_volume_size", value)

    @property
    @pulumi.getter(name="dataVolumeType")
    def data_volume_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "data_volume_type")

    @data_volume_type.setter
    def data_volume_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_volume_type", value)

    @property
    @pulumi.getter(name="hostIps")
    def host_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "host_ips")

    @host_ips.setter
    def host_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "host_ips", value)


if not MYPY:
    class MapreduceClusterExternalDatasourceArgsDict(TypedDict):
        component_name: pulumi.Input[builtins.str]
        role_type: pulumi.Input[builtins.str]
        source_type: pulumi.Input[builtins.str]
        data_connection_id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    MapreduceClusterExternalDatasourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterExternalDatasourceArgs:
    def __init__(__self__, *,
                 component_name: pulumi.Input[builtins.str],
                 role_type: pulumi.Input[builtins.str],
                 source_type: pulumi.Input[builtins.str],
                 data_connection_id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "component_name", component_name)
        pulumi.set(__self__, "role_type", role_type)
        pulumi.set(__self__, "source_type", source_type)
        if data_connection_id is not None:
            pulumi.set(__self__, "data_connection_id", data_connection_id)

    @property
    @pulumi.getter(name="componentName")
    def component_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "component_name")

    @component_name.setter
    def component_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "component_name", value)

    @property
    @pulumi.getter(name="roleType")
    def role_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "role_type")

    @role_type.setter
    def role_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role_type", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="dataConnectionId")
    def data_connection_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "data_connection_id")

    @data_connection_id.setter
    def data_connection_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_connection_id", value)


if not MYPY:
    class MapreduceClusterMasterNodesArgsDict(TypedDict):
        data_volume_count: pulumi.Input[builtins.int]
        flavor: pulumi.Input[builtins.str]
        node_number: pulumi.Input[builtins.int]
        root_volume_size: pulumi.Input[builtins.int]
        root_volume_type: pulumi.Input[builtins.str]
        assigned_roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        data_volume_size: NotRequired[pulumi.Input[builtins.int]]
        data_volume_type: NotRequired[pulumi.Input[builtins.str]]
        host_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    MapreduceClusterMasterNodesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterMasterNodesArgs:
    def __init__(__self__, *,
                 data_volume_count: pulumi.Input[builtins.int],
                 flavor: pulumi.Input[builtins.str],
                 node_number: pulumi.Input[builtins.int],
                 root_volume_size: pulumi.Input[builtins.int],
                 root_volume_type: pulumi.Input[builtins.str],
                 assigned_roles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 data_volume_size: Optional[pulumi.Input[builtins.int]] = None,
                 data_volume_type: Optional[pulumi.Input[builtins.str]] = None,
                 host_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "data_volume_count", data_volume_count)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "node_number", node_number)
        pulumi.set(__self__, "root_volume_size", root_volume_size)
        pulumi.set(__self__, "root_volume_type", root_volume_type)
        if assigned_roles is not None:
            pulumi.set(__self__, "assigned_roles", assigned_roles)
        if data_volume_size is not None:
            pulumi.set(__self__, "data_volume_size", data_volume_size)
        if data_volume_type is not None:
            pulumi.set(__self__, "data_volume_type", data_volume_type)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)

    @property
    @pulumi.getter(name="dataVolumeCount")
    def data_volume_count(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "data_volume_count")

    @data_volume_count.setter
    def data_volume_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "data_volume_count", value)

    @property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "flavor", value)

    @property
    @pulumi.getter(name="nodeNumber")
    def node_number(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "node_number")

    @node_number.setter
    def node_number(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "node_number", value)

    @property
    @pulumi.getter(name="rootVolumeSize")
    def root_volume_size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "root_volume_size")

    @root_volume_size.setter
    def root_volume_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "root_volume_size", value)

    @property
    @pulumi.getter(name="rootVolumeType")
    def root_volume_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "root_volume_type")

    @root_volume_type.setter
    def root_volume_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "root_volume_type", value)

    @property
    @pulumi.getter(name="assignedRoles")
    def assigned_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "assigned_roles")

    @assigned_roles.setter
    def assigned_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "assigned_roles", value)

    @property
    @pulumi.getter(name="dataVolumeSize")
    def data_volume_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "data_volume_size")

    @data_volume_size.setter
    def data_volume_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_volume_size", value)

    @property
    @pulumi.getter(name="dataVolumeType")
    def data_volume_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "data_volume_type")

    @data_volume_type.setter
    def data_volume_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_volume_type", value)

    @property
    @pulumi.getter(name="hostIps")
    def host_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "host_ips")

    @host_ips.setter
    def host_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "host_ips", value)


if not MYPY:
    class MapreduceClusterSmnNotifyArgsDict(TypedDict):
        subscription_name: pulumi.Input[builtins.str]
        """
        The subscription rule name.
        """
        topic_urn: pulumi.Input[builtins.str]
        """
        The Uniform Resource Name (URN) of the topic.
        """
elif False:
    MapreduceClusterSmnNotifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterSmnNotifyArgs:
    def __init__(__self__, *,
                 subscription_name: pulumi.Input[builtins.str],
                 topic_urn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] subscription_name: The subscription rule name.
        :param pulumi.Input[builtins.str] topic_urn: The Uniform Resource Name (URN) of the topic.
        """
        pulumi.set(__self__, "subscription_name", subscription_name)
        pulumi.set(__self__, "topic_urn", topic_urn)

    @property
    @pulumi.getter(name="subscriptionName")
    def subscription_name(self) -> pulumi.Input[builtins.str]:
        """
        The subscription rule name.
        """
        return pulumi.get(self, "subscription_name")

    @subscription_name.setter
    def subscription_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subscription_name", value)

    @property
    @pulumi.getter(name="topicUrn")
    def topic_urn(self) -> pulumi.Input[builtins.str]:
        """
        The Uniform Resource Name (URN) of the topic.
        """
        return pulumi.get(self, "topic_urn")

    @topic_urn.setter
    def topic_urn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "topic_urn", value)


if not MYPY:
    class MapreduceClusterStreamingCoreNodesArgsDict(TypedDict):
        data_volume_count: pulumi.Input[builtins.int]
        flavor: pulumi.Input[builtins.str]
        node_number: pulumi.Input[builtins.int]
        root_volume_size: pulumi.Input[builtins.int]
        root_volume_type: pulumi.Input[builtins.str]
        assigned_roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        data_volume_size: NotRequired[pulumi.Input[builtins.int]]
        data_volume_type: NotRequired[pulumi.Input[builtins.str]]
        host_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    MapreduceClusterStreamingCoreNodesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterStreamingCoreNodesArgs:
    def __init__(__self__, *,
                 data_volume_count: pulumi.Input[builtins.int],
                 flavor: pulumi.Input[builtins.str],
                 node_number: pulumi.Input[builtins.int],
                 root_volume_size: pulumi.Input[builtins.int],
                 root_volume_type: pulumi.Input[builtins.str],
                 assigned_roles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 data_volume_size: Optional[pulumi.Input[builtins.int]] = None,
                 data_volume_type: Optional[pulumi.Input[builtins.str]] = None,
                 host_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "data_volume_count", data_volume_count)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "node_number", node_number)
        pulumi.set(__self__, "root_volume_size", root_volume_size)
        pulumi.set(__self__, "root_volume_type", root_volume_type)
        if assigned_roles is not None:
            pulumi.set(__self__, "assigned_roles", assigned_roles)
        if data_volume_size is not None:
            pulumi.set(__self__, "data_volume_size", data_volume_size)
        if data_volume_type is not None:
            pulumi.set(__self__, "data_volume_type", data_volume_type)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)

    @property
    @pulumi.getter(name="dataVolumeCount")
    def data_volume_count(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "data_volume_count")

    @data_volume_count.setter
    def data_volume_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "data_volume_count", value)

    @property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "flavor", value)

    @property
    @pulumi.getter(name="nodeNumber")
    def node_number(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "node_number")

    @node_number.setter
    def node_number(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "node_number", value)

    @property
    @pulumi.getter(name="rootVolumeSize")
    def root_volume_size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "root_volume_size")

    @root_volume_size.setter
    def root_volume_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "root_volume_size", value)

    @property
    @pulumi.getter(name="rootVolumeType")
    def root_volume_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "root_volume_type")

    @root_volume_type.setter
    def root_volume_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "root_volume_type", value)

    @property
    @pulumi.getter(name="assignedRoles")
    def assigned_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "assigned_roles")

    @assigned_roles.setter
    def assigned_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "assigned_roles", value)

    @property
    @pulumi.getter(name="dataVolumeSize")
    def data_volume_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "data_volume_size")

    @data_volume_size.setter
    def data_volume_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_volume_size", value)

    @property
    @pulumi.getter(name="dataVolumeType")
    def data_volume_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "data_volume_type")

    @data_volume_type.setter
    def data_volume_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_volume_type", value)

    @property
    @pulumi.getter(name="hostIps")
    def host_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "host_ips")

    @host_ips.setter
    def host_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "host_ips", value)


if not MYPY:
    class MapreduceClusterStreamingTaskNodesArgsDict(TypedDict):
        data_volume_count: pulumi.Input[builtins.int]
        flavor: pulumi.Input[builtins.str]
        node_number: pulumi.Input[builtins.int]
        root_volume_size: pulumi.Input[builtins.int]
        root_volume_type: pulumi.Input[builtins.str]
        assigned_roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        data_volume_size: NotRequired[pulumi.Input[builtins.int]]
        data_volume_type: NotRequired[pulumi.Input[builtins.str]]
        host_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    MapreduceClusterStreamingTaskNodesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MapreduceClusterStreamingTaskNodesArgs:
    def __init__(__self__, *,
                 data_volume_count: pulumi.Input[builtins.int],
                 flavor: pulumi.Input[builtins.str],
                 node_number: pulumi.Input[builtins.int],
                 root_volume_size: pulumi.Input[builtins.int],
                 root_volume_type: pulumi.Input[builtins.str],
                 assigned_roles: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 data_volume_size: Optional[pulumi.Input[builtins.int]] = None,
                 data_volume_type: Optional[pulumi.Input[builtins.str]] = None,
                 host_ips: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "data_volume_count", data_volume_count)
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "node_number", node_number)
        pulumi.set(__self__, "root_volume_size", root_volume_size)
        pulumi.set(__self__, "root_volume_type", root_volume_type)
        if assigned_roles is not None:
            pulumi.set(__self__, "assigned_roles", assigned_roles)
        if data_volume_size is not None:
            pulumi.set(__self__, "data_volume_size", data_volume_size)
        if data_volume_type is not None:
            pulumi.set(__self__, "data_volume_type", data_volume_type)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)

    @property
    @pulumi.getter(name="dataVolumeCount")
    def data_volume_count(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "data_volume_count")

    @data_volume_count.setter
    def data_volume_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "data_volume_count", value)

    @property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "flavor", value)

    @property
    @pulumi.getter(name="nodeNumber")
    def node_number(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "node_number")

    @node_number.setter
    def node_number(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "node_number", value)

    @property
    @pulumi.getter(name="rootVolumeSize")
    def root_volume_size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "root_volume_size")

    @root_volume_size.setter
    def root_volume_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "root_volume_size", value)

    @property
    @pulumi.getter(name="rootVolumeType")
    def root_volume_type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "root_volume_type")

    @root_volume_type.setter
    def root_volume_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "root_volume_type", value)

    @property
    @pulumi.getter(name="assignedRoles")
    def assigned_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "assigned_roles")

    @assigned_roles.setter
    def assigned_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "assigned_roles", value)

    @property
    @pulumi.getter(name="dataVolumeSize")
    def data_volume_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "data_volume_size")

    @data_volume_size.setter
    def data_volume_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_volume_size", value)

    @property
    @pulumi.getter(name="dataVolumeType")
    def data_volume_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "data_volume_type")

    @data_volume_type.setter
    def data_volume_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_volume_type", value)

    @property
    @pulumi.getter(name="hostIps")
    def host_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "host_ips")

    @host_ips.setter
    def host_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "host_ips", value)


if not MYPY:
    class NatGatewaySessionConfArgsDict(TypedDict):
        icmp_session_expire_time: NotRequired[pulumi.Input[builtins.int]]
        """
        The ICMP session expiration time.
        """
        tcp_session_expire_time: NotRequired[pulumi.Input[builtins.int]]
        """
        The TCP session expiration time.
        """
        tcp_time_wait_time: NotRequired[pulumi.Input[builtins.int]]
        """
        The duration of TIME_WAIT state when TCP connection is closed.
        """
        udp_session_expire_time: NotRequired[pulumi.Input[builtins.int]]
        """
        The UDP session expiration time.
        """
elif False:
    NatGatewaySessionConfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NatGatewaySessionConfArgs:
    def __init__(__self__, *,
                 icmp_session_expire_time: Optional[pulumi.Input[builtins.int]] = None,
                 tcp_session_expire_time: Optional[pulumi.Input[builtins.int]] = None,
                 tcp_time_wait_time: Optional[pulumi.Input[builtins.int]] = None,
                 udp_session_expire_time: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] icmp_session_expire_time: The ICMP session expiration time.
        :param pulumi.Input[builtins.int] tcp_session_expire_time: The TCP session expiration time.
        :param pulumi.Input[builtins.int] tcp_time_wait_time: The duration of TIME_WAIT state when TCP connection is closed.
        :param pulumi.Input[builtins.int] udp_session_expire_time: The UDP session expiration time.
        """
        if icmp_session_expire_time is not None:
            pulumi.set(__self__, "icmp_session_expire_time", icmp_session_expire_time)
        if tcp_session_expire_time is not None:
            pulumi.set(__self__, "tcp_session_expire_time", tcp_session_expire_time)
        if tcp_time_wait_time is not None:
            pulumi.set(__self__, "tcp_time_wait_time", tcp_time_wait_time)
        if udp_session_expire_time is not None:
            pulumi.set(__self__, "udp_session_expire_time", udp_session_expire_time)

    @property
    @pulumi.getter(name="icmpSessionExpireTime")
    def icmp_session_expire_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The ICMP session expiration time.
        """
        return pulumi.get(self, "icmp_session_expire_time")

    @icmp_session_expire_time.setter
    def icmp_session_expire_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "icmp_session_expire_time", value)

    @property
    @pulumi.getter(name="tcpSessionExpireTime")
    def tcp_session_expire_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The TCP session expiration time.
        """
        return pulumi.get(self, "tcp_session_expire_time")

    @tcp_session_expire_time.setter
    def tcp_session_expire_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "tcp_session_expire_time", value)

    @property
    @pulumi.getter(name="tcpTimeWaitTime")
    def tcp_time_wait_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The duration of TIME_WAIT state when TCP connection is closed.
        """
        return pulumi.get(self, "tcp_time_wait_time")

    @tcp_time_wait_time.setter
    def tcp_time_wait_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "tcp_time_wait_time", value)

    @property
    @pulumi.getter(name="udpSessionExpireTime")
    def udp_session_expire_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The UDP session expiration time.
        """
        return pulumi.get(self, "udp_session_expire_time")

    @udp_session_expire_time.setter
    def udp_session_expire_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "udp_session_expire_time", value)


if not MYPY:
    class NetworkingSecgroupRuleArgsDict(TypedDict):
        action: NotRequired[pulumi.Input[builtins.str]]
        description: NotRequired[pulumi.Input[builtins.str]]
        direction: NotRequired[pulumi.Input[builtins.str]]
        ethertype: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
        port_range_max: NotRequired[pulumi.Input[builtins.int]]
        """
        schema: Deprecated
        """
        port_range_min: NotRequired[pulumi.Input[builtins.int]]
        """
        schema: Deprecated
        """
        ports: NotRequired[pulumi.Input[builtins.str]]
        priority: NotRequired[pulumi.Input[builtins.int]]
        protocol: NotRequired[pulumi.Input[builtins.str]]
        remote_address_group_id: NotRequired[pulumi.Input[builtins.str]]
        remote_group_id: NotRequired[pulumi.Input[builtins.str]]
        remote_ip_prefix: NotRequired[pulumi.Input[builtins.str]]
elif False:
    NetworkingSecgroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkingSecgroupRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[builtins.str]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 direction: Optional[pulumi.Input[builtins.str]] = None,
                 ethertype: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 port_range_max: Optional[pulumi.Input[builtins.int]] = None,
                 port_range_min: Optional[pulumi.Input[builtins.int]] = None,
                 ports: Optional[pulumi.Input[builtins.str]] = None,
                 priority: Optional[pulumi.Input[builtins.int]] = None,
                 protocol: Optional[pulumi.Input[builtins.str]] = None,
                 remote_address_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 remote_group_id: Optional[pulumi.Input[builtins.str]] = None,
                 remote_ip_prefix: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] port_range_max: schema: Deprecated
        :param pulumi.Input[builtins.int] port_range_min: schema: Deprecated
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if ethertype is not None:
            pulumi.set(__self__, "ethertype", ethertype)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port_range_max is not None:
            pulumi.set(__self__, "port_range_max", port_range_max)
        if port_range_min is not None:
            pulumi.set(__self__, "port_range_min", port_range_min)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if remote_address_group_id is not None:
            pulumi.set(__self__, "remote_address_group_id", remote_address_group_id)
        if remote_group_id is not None:
            pulumi.set(__self__, "remote_group_id", remote_group_id)
        if remote_ip_prefix is not None:
            pulumi.set(__self__, "remote_ip_prefix", remote_ip_prefix)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def ethertype(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ethertype")

    @ethertype.setter
    def ethertype(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ethertype", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="portRangeMax")
    def port_range_max(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "port_range_max")

    @port_range_max.setter
    def port_range_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port_range_max", value)

    @property
    @pulumi.getter(name="portRangeMin")
    def port_range_min(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "port_range_min")

    @port_range_min.setter
    def port_range_min(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port_range_min", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="remoteAddressGroupId")
    def remote_address_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "remote_address_group_id")

    @remote_address_group_id.setter
    def remote_address_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "remote_address_group_id", value)

    @property
    @pulumi.getter(name="remoteGroupId")
    def remote_group_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "remote_group_id")

    @remote_group_id.setter
    def remote_group_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "remote_group_id", value)

    @property
    @pulumi.getter(name="remoteIpPrefix")
    def remote_ip_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "remote_ip_prefix")

    @remote_ip_prefix.setter
    def remote_ip_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "remote_ip_prefix", value)


if not MYPY:
    class ObsBucketAclAccountPermissionArgsDict(TypedDict):
        account_id: pulumi.Input[builtins.str]
        """
        Specifies the account id to authorize. The account id cannot be the bucket owner, 
        and must be unique.
        """
        access_to_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        access_to_buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
elif False:
    ObsBucketAclAccountPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketAclAccountPermissionArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[builtins.str],
                 access_to_acls: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 access_to_buckets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] account_id: Specifies the account id to authorize. The account id cannot be the bucket owner, 
               and must be unique.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] access_to_acls: Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] access_to_buckets: Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        pulumi.set(__self__, "account_id", account_id)
        if access_to_acls is not None:
            pulumi.set(__self__, "access_to_acls", access_to_acls)
        if access_to_buckets is not None:
            pulumi.set(__self__, "access_to_buckets", access_to_buckets)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the account id to authorize. The account id cannot be the bucket owner, 
        and must be unique.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="accessToAcls")
    def access_to_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        return pulumi.get(self, "access_to_acls")

    @access_to_acls.setter
    def access_to_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "access_to_acls", value)

    @property
    @pulumi.getter(name="accessToBuckets")
    def access_to_buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        return pulumi.get(self, "access_to_buckets")

    @access_to_buckets.setter
    def access_to_buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "access_to_buckets", value)


if not MYPY:
    class ObsBucketAclLogDeliveryUserPermissionArgsDict(TypedDict):
        access_to_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        access_to_buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
elif False:
    ObsBucketAclLogDeliveryUserPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketAclLogDeliveryUserPermissionArgs:
    def __init__(__self__, *,
                 access_to_acls: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 access_to_buckets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] access_to_acls: Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] access_to_buckets: Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        if access_to_acls is not None:
            pulumi.set(__self__, "access_to_acls", access_to_acls)
        if access_to_buckets is not None:
            pulumi.set(__self__, "access_to_buckets", access_to_buckets)

    @property
    @pulumi.getter(name="accessToAcls")
    def access_to_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        return pulumi.get(self, "access_to_acls")

    @access_to_acls.setter
    def access_to_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "access_to_acls", value)

    @property
    @pulumi.getter(name="accessToBuckets")
    def access_to_buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        return pulumi.get(self, "access_to_buckets")

    @access_to_buckets.setter
    def access_to_buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "access_to_buckets", value)


if not MYPY:
    class ObsBucketAclOwnerPermissionArgsDict(TypedDict):
        access_to_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        access_to_buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
elif False:
    ObsBucketAclOwnerPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketAclOwnerPermissionArgs:
    def __init__(__self__, *,
                 access_to_acls: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 access_to_buckets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] access_to_acls: Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] access_to_buckets: Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        if access_to_acls is not None:
            pulumi.set(__self__, "access_to_acls", access_to_acls)
        if access_to_buckets is not None:
            pulumi.set(__self__, "access_to_buckets", access_to_buckets)

    @property
    @pulumi.getter(name="accessToAcls")
    def access_to_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        return pulumi.get(self, "access_to_acls")

    @access_to_acls.setter
    def access_to_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "access_to_acls", value)

    @property
    @pulumi.getter(name="accessToBuckets")
    def access_to_buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        return pulumi.get(self, "access_to_buckets")

    @access_to_buckets.setter
    def access_to_buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "access_to_buckets", value)


if not MYPY:
    class ObsBucketAclPublicPermissionArgsDict(TypedDict):
        access_to_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        access_to_buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
elif False:
    ObsBucketAclPublicPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketAclPublicPermissionArgs:
    def __init__(__self__, *,
                 access_to_acls: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 access_to_buckets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] access_to_acls: Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] access_to_buckets: Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        if access_to_acls is not None:
            pulumi.set(__self__, "access_to_acls", access_to_acls)
        if access_to_buckets is not None:
            pulumi.set(__self__, "access_to_buckets", access_to_buckets)

    @property
    @pulumi.getter(name="accessToAcls")
    def access_to_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the access to acl. Valid values are **READ_ACP** and **WRITE_ACP**.
        """
        return pulumi.get(self, "access_to_acls")

    @access_to_acls.setter
    def access_to_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "access_to_acls", value)

    @property
    @pulumi.getter(name="accessToBuckets")
    def access_to_buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies the access to bucket. Valid values are **READ** and **WRITE**.
        """
        return pulumi.get(self, "access_to_buckets")

    @access_to_buckets.setter
    def access_to_buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "access_to_buckets", value)


if not MYPY:
    class ObsBucketCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        max_age_seconds: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ObsBucketCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class ObsBucketLifecycleRuleArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        name: pulumi.Input[builtins.str]
        abort_incomplete_multipart_uploads: NotRequired[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleAbortIncompleteMultipartUploadArgsDict']]]]
        expirations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleExpirationArgsDict']]]]
        noncurrent_version_expirations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleNoncurrentVersionExpirationArgsDict']]]]
        noncurrent_version_transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleNoncurrentVersionTransitionArgsDict']]]]
        prefix: NotRequired[pulumi.Input[builtins.str]]
        transitions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleTransitionArgsDict']]]]
elif False:
    ObsBucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 name: pulumi.Input[builtins.str],
                 abort_incomplete_multipart_uploads: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleAbortIncompleteMultipartUploadArgs']]]] = None,
                 expirations: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleExpirationArgs']]]] = None,
                 noncurrent_version_expirations: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleNoncurrentVersionExpirationArgs']]]] = None,
                 noncurrent_version_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleNoncurrentVersionTransitionArgs']]]] = None,
                 prefix: Optional[pulumi.Input[builtins.str]] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleTransitionArgs']]]] = None):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "name", name)
        if abort_incomplete_multipart_uploads is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_uploads", abort_incomplete_multipart_uploads)
        if expirations is not None:
            pulumi.set(__self__, "expirations", expirations)
        if noncurrent_version_expirations is not None:
            pulumi.set(__self__, "noncurrent_version_expirations", noncurrent_version_expirations)
        if noncurrent_version_transitions is not None:
            pulumi.set(__self__, "noncurrent_version_transitions", noncurrent_version_transitions)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if transitions is not None:
            pulumi.set(__self__, "transitions", transitions)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploads")
    def abort_incomplete_multipart_uploads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleAbortIncompleteMultipartUploadArgs']]]]:
        return pulumi.get(self, "abort_incomplete_multipart_uploads")

    @abort_incomplete_multipart_uploads.setter
    def abort_incomplete_multipart_uploads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleAbortIncompleteMultipartUploadArgs']]]]):
        pulumi.set(self, "abort_incomplete_multipart_uploads", value)

    @property
    @pulumi.getter
    def expirations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleExpirationArgs']]]]:
        return pulumi.get(self, "expirations")

    @expirations.setter
    def expirations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleExpirationArgs']]]]):
        pulumi.set(self, "expirations", value)

    @property
    @pulumi.getter(name="noncurrentVersionExpirations")
    def noncurrent_version_expirations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleNoncurrentVersionExpirationArgs']]]]:
        return pulumi.get(self, "noncurrent_version_expirations")

    @noncurrent_version_expirations.setter
    def noncurrent_version_expirations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleNoncurrentVersionExpirationArgs']]]]):
        pulumi.set(self, "noncurrent_version_expirations", value)

    @property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleNoncurrentVersionTransitionArgs']]]]:
        return pulumi.get(self, "noncurrent_version_transitions")

    @noncurrent_version_transitions.setter
    def noncurrent_version_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleNoncurrentVersionTransitionArgs']]]]):
        pulumi.set(self, "noncurrent_version_transitions", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleTransitionArgs']]]]:
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObsBucketLifecycleRuleTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


if not MYPY:
    class ObsBucketLifecycleRuleAbortIncompleteMultipartUploadArgsDict(TypedDict):
        days: pulumi.Input[builtins.int]
elif False:
    ObsBucketLifecycleRuleAbortIncompleteMultipartUploadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketLifecycleRuleAbortIncompleteMultipartUploadArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "days", value)


if not MYPY:
    class ObsBucketLifecycleRuleExpirationArgsDict(TypedDict):
        days: pulumi.Input[builtins.int]
elif False:
    ObsBucketLifecycleRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketLifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "days", value)


if not MYPY:
    class ObsBucketLifecycleRuleNoncurrentVersionExpirationArgsDict(TypedDict):
        days: pulumi.Input[builtins.int]
elif False:
    ObsBucketLifecycleRuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketLifecycleRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[builtins.int]):
        pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "days", value)


if not MYPY:
    class ObsBucketLifecycleRuleNoncurrentVersionTransitionArgsDict(TypedDict):
        days: pulumi.Input[builtins.int]
        storage_class: pulumi.Input[builtins.str]
elif False:
    ObsBucketLifecycleRuleNoncurrentVersionTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketLifecycleRuleNoncurrentVersionTransitionArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[builtins.int],
                 storage_class: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class ObsBucketLifecycleRuleTransitionArgsDict(TypedDict):
        days: pulumi.Input[builtins.int]
        storage_class: pulumi.Input[builtins.str]
elif False:
    ObsBucketLifecycleRuleTransitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketLifecycleRuleTransitionArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[builtins.int],
                 storage_class: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class ObsBucketLoggingArgsDict(TypedDict):
        target_bucket: pulumi.Input[builtins.str]
        agency: NotRequired[pulumi.Input[builtins.str]]
        """
        schema: Required
        """
        target_prefix: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ObsBucketLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketLoggingArgs:
    def __init__(__self__, *,
                 target_bucket: pulumi.Input[builtins.str],
                 agency: Optional[pulumi.Input[builtins.str]] = None,
                 target_prefix: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] agency: schema: Required
        """
        pulumi.set(__self__, "target_bucket", target_bucket)
        if agency is not None:
            pulumi.set(__self__, "agency", agency)
        if target_prefix is not None:
            pulumi.set(__self__, "target_prefix", target_prefix)

    @property
    @pulumi.getter(name="targetBucket")
    def target_bucket(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "target_bucket")

    @target_bucket.setter
    def target_bucket(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target_bucket", value)

    @property
    @pulumi.getter
    def agency(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        schema: Required
        """
        return pulumi.get(self, "agency")

    @agency.setter
    def agency(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "agency", value)

    @property
    @pulumi.getter(name="targetPrefix")
    def target_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "target_prefix")

    @target_prefix.setter
    def target_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_prefix", value)


if not MYPY:
    class ObsBucketStorageInfoArgsDict(TypedDict):
        object_number: NotRequired[pulumi.Input[builtins.int]]
        size: NotRequired[pulumi.Input[builtins.int]]
elif False:
    ObsBucketStorageInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketStorageInfoArgs:
    def __init__(__self__, *,
                 object_number: Optional[pulumi.Input[builtins.int]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None):
        if object_number is not None:
            pulumi.set(__self__, "object_number", object_number)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="objectNumber")
    def object_number(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "object_number")

    @object_number.setter
    def object_number(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "object_number", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class ObsBucketWebsiteArgsDict(TypedDict):
        error_document: NotRequired[pulumi.Input[builtins.str]]
        index_document: NotRequired[pulumi.Input[builtins.str]]
        redirect_all_requests_to: NotRequired[pulumi.Input[builtins.str]]
        routing_rules: NotRequired[pulumi.Input[builtins.str]]
elif False:
    ObsBucketWebsiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObsBucketWebsiteArgs:
    def __init__(__self__, *,
                 error_document: Optional[pulumi.Input[builtins.str]] = None,
                 index_document: Optional[pulumi.Input[builtins.str]] = None,
                 redirect_all_requests_to: Optional[pulumi.Input[builtins.str]] = None,
                 routing_rules: Optional[pulumi.Input[builtins.str]] = None):
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if redirect_all_requests_to is not None:
            pulumi.set(__self__, "redirect_all_requests_to", redirect_all_requests_to)
        if routing_rules is not None:
            pulumi.set(__self__, "routing_rules", routing_rules)

    @property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "error_document")

    @error_document.setter
    def error_document(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "error_document", value)

    @property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "index_document")

    @index_document.setter
    def index_document(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "index_document", value)

    @property
    @pulumi.getter(name="redirectAllRequestsTo")
    def redirect_all_requests_to(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "redirect_all_requests_to")

    @redirect_all_requests_to.setter
    def redirect_all_requests_to(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "redirect_all_requests_to", value)

    @property
    @pulumi.getter(name="routingRules")
    def routing_rules(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "routing_rules")

    @routing_rules.setter
    def routing_rules(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "routing_rules", value)


if not MYPY:
    class ProviderAssumeRoleArgsDict(TypedDict):
        agency_name: pulumi.Input[builtins.str]
        domain_name: pulumi.Input[builtins.str]
elif False:
    ProviderAssumeRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderAssumeRoleArgs:
    def __init__(__self__, *,
                 agency_name: pulumi.Input[builtins.str],
                 domain_name: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "agency_name", agency_name)
        pulumi.set(__self__, "domain_name", domain_name)

    @property
    @pulumi.getter(name="agencyName")
    def agency_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "agency_name")

    @agency_name.setter
    def agency_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "agency_name", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "domain_name", value)


if not MYPY:
    class RdsBackupDatabaseArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Database to be backed up for Microsoft SQL Server.
        """
elif False:
    RdsBackupDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsBackupDatabaseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: Database to be backed up for Microsoft SQL Server.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Database to be backed up for Microsoft SQL Server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RdsInstanceBackupStrategyArgsDict(TypedDict):
        start_time: pulumi.Input[builtins.str]
        keep_days: NotRequired[pulumi.Input[builtins.int]]
        """
        schema: Required
        """
        period: NotRequired[pulumi.Input[builtins.str]]
elif False:
    RdsInstanceBackupStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsInstanceBackupStrategyArgs:
    def __init__(__self__, *,
                 start_time: pulumi.Input[builtins.str],
                 keep_days: Optional[pulumi.Input[builtins.int]] = None,
                 period: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] keep_days: schema: Required
        """
        pulumi.set(__self__, "start_time", start_time)
        if keep_days is not None:
            pulumi.set(__self__, "keep_days", keep_days)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="keepDays")
    def keep_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        schema: Required
        """
        return pulumi.get(self, "keep_days")

    @keep_days.setter
    def keep_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "keep_days", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "period", value)


if not MYPY:
    class RdsInstanceDbArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        version: pulumi.Input[builtins.str]
        password: NotRequired[pulumi.Input[builtins.str]]
        port: NotRequired[pulumi.Input[builtins.int]]
        user_name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    RdsInstanceDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsInstanceDbArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 version: pulumi.Input[builtins.str],
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 user_name: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class RdsInstanceMsdtcHostArgsDict(TypedDict):
        host_name: pulumi.Input[builtins.str]
        ip: pulumi.Input[builtins.str]
        id: NotRequired[pulumi.Input[builtins.str]]
elif False:
    RdsInstanceMsdtcHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsInstanceMsdtcHostArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[builtins.str],
                 ip: pulumi.Input[builtins.str],
                 id: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "ip", ip)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class RdsInstanceNodeArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[builtins.str]]
        id: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        role: NotRequired[pulumi.Input[builtins.str]]
        status: NotRequired[pulumi.Input[builtins.str]]
elif False:
    RdsInstanceNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsInstanceNodeArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 role: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class RdsInstanceParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    RdsInstanceParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsInstanceParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RdsInstanceRestoreArgsDict(TypedDict):
        backup_id: pulumi.Input[builtins.str]
        instance_id: pulumi.Input[builtins.str]
        database_name: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
elif False:
    RdsInstanceRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsInstanceRestoreArgs:
    def __init__(__self__, *,
                 backup_id: pulumi.Input[builtins.str],
                 instance_id: pulumi.Input[builtins.str],
                 database_name: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        pulumi.set(__self__, "backup_id", backup_id)
        pulumi.set(__self__, "instance_id", instance_id)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class RdsInstanceVolumeArgsDict(TypedDict):
        size: pulumi.Input[builtins.int]
        type: pulumi.Input[builtins.str]
        disk_encryption_id: NotRequired[pulumi.Input[builtins.str]]
        limit_size: NotRequired[pulumi.Input[builtins.int]]
        trigger_threshold: NotRequired[pulumi.Input[builtins.int]]
elif False:
    RdsInstanceVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsInstanceVolumeArgs:
    def __init__(__self__, *,
                 size: pulumi.Input[builtins.int],
                 type: pulumi.Input[builtins.str],
                 disk_encryption_id: Optional[pulumi.Input[builtins.str]] = None,
                 limit_size: Optional[pulumi.Input[builtins.int]] = None,
                 trigger_threshold: Optional[pulumi.Input[builtins.int]] = None):
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if disk_encryption_id is not None:
            pulumi.set(__self__, "disk_encryption_id", disk_encryption_id)
        if limit_size is not None:
            pulumi.set(__self__, "limit_size", limit_size)
        if trigger_threshold is not None:
            pulumi.set(__self__, "trigger_threshold", trigger_threshold)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[builtins.int]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="diskEncryptionId")
    def disk_encryption_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "disk_encryption_id")

    @disk_encryption_id.setter
    def disk_encryption_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "disk_encryption_id", value)

    @property
    @pulumi.getter(name="limitSize")
    def limit_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "limit_size")

    @limit_size.setter
    def limit_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "limit_size", value)

    @property
    @pulumi.getter(name="triggerThreshold")
    def trigger_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "trigger_threshold")

    @trigger_threshold.setter
    def trigger_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "trigger_threshold", value)


if not MYPY:
    class RdsMysqlDatabasePrivilegeUserArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Specifies the username of the database account.
        """
        readonly: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies the read-only permission.
        """
elif False:
    RdsMysqlDatabasePrivilegeUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsMysqlDatabasePrivilegeUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 readonly: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] name: Specifies the username of the database account.
        :param pulumi.Input[builtins.bool] readonly: Specifies the read-only permission.
        """
        pulumi.set(__self__, "name", name)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the username of the database account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies the read-only permission.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "readonly", value)


if not MYPY:
    class RdsMysqlDatabaseTableRestoreDatabaseArgsDict(TypedDict):
        new_name: pulumi.Input[builtins.str]
        """
        Specifies the name of the database after restoration.
        """
        old_name: pulumi.Input[builtins.str]
        """
        Specifies the name of the database before restoration.
        """
elif False:
    RdsMysqlDatabaseTableRestoreDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsMysqlDatabaseTableRestoreDatabaseArgs:
    def __init__(__self__, *,
                 new_name: pulumi.Input[builtins.str],
                 old_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] new_name: Specifies the name of the database after restoration.
        :param pulumi.Input[builtins.str] old_name: Specifies the name of the database before restoration.
        """
        pulumi.set(__self__, "new_name", new_name)
        pulumi.set(__self__, "old_name", old_name)

    @property
    @pulumi.getter(name="newName")
    def new_name(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the name of the database after restoration.
        """
        return pulumi.get(self, "new_name")

    @new_name.setter
    def new_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "new_name", value)

    @property
    @pulumi.getter(name="oldName")
    def old_name(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the name of the database before restoration.
        """
        return pulumi.get(self, "old_name")

    @old_name.setter
    def old_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "old_name", value)


if not MYPY:
    class RdsMysqlDatabaseTableRestoreRestoreTableArgsDict(TypedDict):
        database: pulumi.Input[builtins.str]
        """
        Specifies the database name.
        """
        tables: pulumi.Input[Sequence[pulumi.Input['RdsMysqlDatabaseTableRestoreRestoreTableTableArgsDict']]]
        """
        Specifies the tables.
        """
elif False:
    RdsMysqlDatabaseTableRestoreRestoreTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsMysqlDatabaseTableRestoreRestoreTableArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[builtins.str],
                 tables: pulumi.Input[Sequence[pulumi.Input['RdsMysqlDatabaseTableRestoreRestoreTableTableArgs']]]):
        """
        :param pulumi.Input[builtins.str] database: Specifies the database name.
        :param pulumi.Input[Sequence[pulumi.Input['RdsMysqlDatabaseTableRestoreRestoreTableTableArgs']]] tables: Specifies the tables.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def tables(self) -> pulumi.Input[Sequence[pulumi.Input['RdsMysqlDatabaseTableRestoreRestoreTableTableArgs']]]:
        """
        Specifies the tables.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: pulumi.Input[Sequence[pulumi.Input['RdsMysqlDatabaseTableRestoreRestoreTableTableArgs']]]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class RdsMysqlDatabaseTableRestoreRestoreTableTableArgsDict(TypedDict):
        new_name: pulumi.Input[builtins.str]
        """
        Specifies the name of the table after restoration.
        """
        old_name: pulumi.Input[builtins.str]
        """
        Specifies the name of the table before restoration.
        """
elif False:
    RdsMysqlDatabaseTableRestoreRestoreTableTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsMysqlDatabaseTableRestoreRestoreTableTableArgs:
    def __init__(__self__, *,
                 new_name: pulumi.Input[builtins.str],
                 old_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] new_name: Specifies the name of the table after restoration.
        :param pulumi.Input[builtins.str] old_name: Specifies the name of the table before restoration.
        """
        pulumi.set(__self__, "new_name", new_name)
        pulumi.set(__self__, "old_name", old_name)

    @property
    @pulumi.getter(name="newName")
    def new_name(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the name of the table after restoration.
        """
        return pulumi.get(self, "new_name")

    @new_name.setter
    def new_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "new_name", value)

    @property
    @pulumi.getter(name="oldName")
    def old_name(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the name of the table before restoration.
        """
        return pulumi.get(self, "old_name")

    @old_name.setter
    def old_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "old_name", value)


if not MYPY:
    class RdsParametergroupConfigurationParameterArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[builtins.str]]
        name: NotRequired[pulumi.Input[builtins.str]]
        readonly: NotRequired[pulumi.Input[builtins.bool]]
        restart_required: NotRequired[pulumi.Input[builtins.bool]]
        type: NotRequired[pulumi.Input[builtins.str]]
        value: NotRequired[pulumi.Input[builtins.str]]
        value_range: NotRequired[pulumi.Input[builtins.str]]
elif False:
    RdsParametergroupConfigurationParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsParametergroupConfigurationParameterArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 readonly: Optional[pulumi.Input[builtins.bool]] = None,
                 restart_required: Optional[pulumi.Input[builtins.bool]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None,
                 value_range: Optional[pulumi.Input[builtins.str]] = None):
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if restart_required is not None:
            pulumi.set(__self__, "restart_required", restart_required)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_range is not None:
            pulumi.set(__self__, "value_range", value_range)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "readonly", value)

    @property
    @pulumi.getter(name="restartRequired")
    def restart_required(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "restart_required")

    @restart_required.setter
    def restart_required(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "restart_required", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueRange")
    def value_range(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "value_range")

    @value_range.setter
    def value_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value_range", value)


if not MYPY:
    class RdsParametergroupDatastoreArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        version: pulumi.Input[builtins.str]
elif False:
    RdsParametergroupDatastoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsParametergroupDatastoreArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 version: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RdsPgAccountAttributeArgsDict(TypedDict):
        rol_bypass_rls: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether a user bypasses each row-level security policy.
        """
        rol_can_login: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether a user can log in to the database.
        """
        rol_conn_limit: NotRequired[pulumi.Input[builtins.int]]
        """
        Indicates the maximum number of concurrent connections to a DB instance.
        """
        rol_create_db: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether a user can create a database.
        """
        rol_create_role: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether a user can create other sub-users.
        """
        rol_inherit: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether a user automatically inherits the permissions of the role to which the
        user belongs.
        """
        rol_replication: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether the user is a replication role.
        """
        rol_super: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether a user has the super-user permission.
        """
elif False:
    RdsPgAccountAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsPgAccountAttributeArgs:
    def __init__(__self__, *,
                 rol_bypass_rls: Optional[pulumi.Input[builtins.bool]] = None,
                 rol_can_login: Optional[pulumi.Input[builtins.bool]] = None,
                 rol_conn_limit: Optional[pulumi.Input[builtins.int]] = None,
                 rol_create_db: Optional[pulumi.Input[builtins.bool]] = None,
                 rol_create_role: Optional[pulumi.Input[builtins.bool]] = None,
                 rol_inherit: Optional[pulumi.Input[builtins.bool]] = None,
                 rol_replication: Optional[pulumi.Input[builtins.bool]] = None,
                 rol_super: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] rol_bypass_rls: Indicates whether a user bypasses each row-level security policy.
        :param pulumi.Input[builtins.bool] rol_can_login: Indicates whether a user can log in to the database.
        :param pulumi.Input[builtins.int] rol_conn_limit: Indicates the maximum number of concurrent connections to a DB instance.
        :param pulumi.Input[builtins.bool] rol_create_db: Indicates whether a user can create a database.
        :param pulumi.Input[builtins.bool] rol_create_role: Indicates whether a user can create other sub-users.
        :param pulumi.Input[builtins.bool] rol_inherit: Indicates whether a user automatically inherits the permissions of the role to which the
               user belongs.
        :param pulumi.Input[builtins.bool] rol_replication: Indicates whether the user is a replication role.
        :param pulumi.Input[builtins.bool] rol_super: Indicates whether a user has the super-user permission.
        """
        if rol_bypass_rls is not None:
            pulumi.set(__self__, "rol_bypass_rls", rol_bypass_rls)
        if rol_can_login is not None:
            pulumi.set(__self__, "rol_can_login", rol_can_login)
        if rol_conn_limit is not None:
            pulumi.set(__self__, "rol_conn_limit", rol_conn_limit)
        if rol_create_db is not None:
            pulumi.set(__self__, "rol_create_db", rol_create_db)
        if rol_create_role is not None:
            pulumi.set(__self__, "rol_create_role", rol_create_role)
        if rol_inherit is not None:
            pulumi.set(__self__, "rol_inherit", rol_inherit)
        if rol_replication is not None:
            pulumi.set(__self__, "rol_replication", rol_replication)
        if rol_super is not None:
            pulumi.set(__self__, "rol_super", rol_super)

    @property
    @pulumi.getter(name="rolBypassRls")
    def rol_bypass_rls(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether a user bypasses each row-level security policy.
        """
        return pulumi.get(self, "rol_bypass_rls")

    @rol_bypass_rls.setter
    def rol_bypass_rls(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rol_bypass_rls", value)

    @property
    @pulumi.getter(name="rolCanLogin")
    def rol_can_login(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether a user can log in to the database.
        """
        return pulumi.get(self, "rol_can_login")

    @rol_can_login.setter
    def rol_can_login(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rol_can_login", value)

    @property
    @pulumi.getter(name="rolConnLimit")
    def rol_conn_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Indicates the maximum number of concurrent connections to a DB instance.
        """
        return pulumi.get(self, "rol_conn_limit")

    @rol_conn_limit.setter
    def rol_conn_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rol_conn_limit", value)

    @property
    @pulumi.getter(name="rolCreateDb")
    def rol_create_db(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether a user can create a database.
        """
        return pulumi.get(self, "rol_create_db")

    @rol_create_db.setter
    def rol_create_db(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rol_create_db", value)

    @property
    @pulumi.getter(name="rolCreateRole")
    def rol_create_role(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether a user can create other sub-users.
        """
        return pulumi.get(self, "rol_create_role")

    @rol_create_role.setter
    def rol_create_role(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rol_create_role", value)

    @property
    @pulumi.getter(name="rolInherit")
    def rol_inherit(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether a user automatically inherits the permissions of the role to which the
        user belongs.
        """
        return pulumi.get(self, "rol_inherit")

    @rol_inherit.setter
    def rol_inherit(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rol_inherit", value)

    @property
    @pulumi.getter(name="rolReplication")
    def rol_replication(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether the user is a replication role.
        """
        return pulumi.get(self, "rol_replication")

    @rol_replication.setter
    def rol_replication(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rol_replication", value)

    @property
    @pulumi.getter(name="rolSuper")
    def rol_super(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether a user has the super-user permission.
        """
        return pulumi.get(self, "rol_super")

    @rol_super.setter
    def rol_super(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "rol_super", value)


if not MYPY:
    class RdsPgHbaHostBasedAuthenticationArgsDict(TypedDict):
        address: pulumi.Input[builtins.str]
        """
        Specifies the client IP address.
        """
        database: pulumi.Input[builtins.str]
        """
        Specifies the database name.
        """
        method: pulumi.Input[builtins.str]
        """
        Specifies the authentication mode.
        """
        type: pulumi.Input[builtins.str]
        """
        Specifies the connection type.
        """
        user: pulumi.Input[builtins.str]
        """
        Specifies the Name of a user.
        """
        mask: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the subnet mask.
        """
elif False:
    RdsPgHbaHostBasedAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsPgHbaHostBasedAuthenticationArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str],
                 database: pulumi.Input[builtins.str],
                 method: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 user: pulumi.Input[builtins.str],
                 mask: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] address: Specifies the client IP address.
        :param pulumi.Input[builtins.str] database: Specifies the database name.
        :param pulumi.Input[builtins.str] method: Specifies the authentication mode.
        :param pulumi.Input[builtins.str] type: Specifies the connection type.
        :param pulumi.Input[builtins.str] user: Specifies the Name of a user.
        :param pulumi.Input[builtins.str] mask: Specifies the subnet mask.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user", user)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the client IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the authentication mode.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the connection type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the Name of a user.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the subnet mask.
        """
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class RdsReadReplicaInstanceDbArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[builtins.int]]
        type: NotRequired[pulumi.Input[builtins.str]]
        user_name: NotRequired[pulumi.Input[builtins.str]]
        version: NotRequired[pulumi.Input[builtins.str]]
elif False:
    RdsReadReplicaInstanceDbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsReadReplicaInstanceDbArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 user_name: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class RdsReadReplicaInstanceParameterArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        value: pulumi.Input[builtins.str]
elif False:
    RdsReadReplicaInstanceParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsReadReplicaInstanceParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RdsReadReplicaInstanceVolumeArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        disk_encryption_id: NotRequired[pulumi.Input[builtins.str]]
        """
        schema: Computed
        """
        limit_size: NotRequired[pulumi.Input[builtins.int]]
        size: NotRequired[pulumi.Input[builtins.int]]
        trigger_threshold: NotRequired[pulumi.Input[builtins.int]]
elif False:
    RdsReadReplicaInstanceVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsReadReplicaInstanceVolumeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 disk_encryption_id: Optional[pulumi.Input[builtins.str]] = None,
                 limit_size: Optional[pulumi.Input[builtins.int]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None,
                 trigger_threshold: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] disk_encryption_id: schema: Computed
        """
        pulumi.set(__self__, "type", type)
        if disk_encryption_id is not None:
            pulumi.set(__self__, "disk_encryption_id", disk_encryption_id)
        if limit_size is not None:
            pulumi.set(__self__, "limit_size", limit_size)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if trigger_threshold is not None:
            pulumi.set(__self__, "trigger_threshold", trigger_threshold)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="diskEncryptionId")
    def disk_encryption_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        schema: Computed
        """
        return pulumi.get(self, "disk_encryption_id")

    @disk_encryption_id.setter
    def disk_encryption_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "disk_encryption_id", value)

    @property
    @pulumi.getter(name="limitSize")
    def limit_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "limit_size")

    @limit_size.setter
    def limit_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "limit_size", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="triggerThreshold")
    def trigger_threshold(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "trigger_threshold")

    @trigger_threshold.setter
    def trigger_threshold(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "trigger_threshold", value)


if not MYPY:
    class RdsSqlserverDatabasePrivilegeUserArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Specifies the username of the database account.
        """
        readonly: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies the read-only permission.
        """
elif False:
    RdsSqlserverDatabasePrivilegeUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdsSqlserverDatabasePrivilegeUserArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 readonly: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] name: Specifies the username of the database account.
        :param pulumi.Input[builtins.bool] readonly: Specifies the read-only permission.
        """
        pulumi.set(__self__, "name", name)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the username of the database account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies the read-only permission.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "readonly", value)


if not MYPY:
    class SfsFileSystemAccessRuleArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[builtins.str]]
        access_rule_id: NotRequired[pulumi.Input[builtins.str]]
        access_to: NotRequired[pulumi.Input[builtins.str]]
        access_type: NotRequired[pulumi.Input[builtins.str]]
        status: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SfsFileSystemAccessRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsFileSystemAccessRuleArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[builtins.str]] = None,
                 access_rule_id: Optional[pulumi.Input[builtins.str]] = None,
                 access_to: Optional[pulumi.Input[builtins.str]] = None,
                 access_type: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if access_rule_id is not None:
            pulumi.set(__self__, "access_rule_id", access_rule_id)
        if access_to is not None:
            pulumi.set(__self__, "access_to", access_to)
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="accessRuleId")
    def access_rule_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "access_rule_id")

    @access_rule_id.setter
    def access_rule_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_rule_id", value)

    @property
    @pulumi.getter(name="accessTo")
    def access_to(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "access_to")

    @access_to.setter
    def access_to(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_to", value)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_type", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class SfsTurboDuTaskDirUsageArgsDict(TypedDict):
        file_counts: NotRequired[pulumi.Input[Sequence[pulumi.Input['SfsTurboDuTaskDirUsageFileCountArgsDict']]]]
        message: NotRequired[pulumi.Input[builtins.str]]
        path: NotRequired[pulumi.Input[builtins.str]]
        used_capacity: NotRequired[pulumi.Input[builtins.int]]
elif False:
    SfsTurboDuTaskDirUsageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsTurboDuTaskDirUsageArgs:
    def __init__(__self__, *,
                 file_counts: Optional[pulumi.Input[Sequence[pulumi.Input['SfsTurboDuTaskDirUsageFileCountArgs']]]] = None,
                 message: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 used_capacity: Optional[pulumi.Input[builtins.int]] = None):
        if file_counts is not None:
            pulumi.set(__self__, "file_counts", file_counts)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if used_capacity is not None:
            pulumi.set(__self__, "used_capacity", used_capacity)

    @property
    @pulumi.getter(name="fileCounts")
    def file_counts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SfsTurboDuTaskDirUsageFileCountArgs']]]]:
        return pulumi.get(self, "file_counts")

    @file_counts.setter
    def file_counts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SfsTurboDuTaskDirUsageFileCountArgs']]]]):
        pulumi.set(self, "file_counts", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="usedCapacity")
    def used_capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "used_capacity")

    @used_capacity.setter
    def used_capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "used_capacity", value)


if not MYPY:
    class SfsTurboDuTaskDirUsageFileCountArgsDict(TypedDict):
        block: NotRequired[pulumi.Input[builtins.int]]
        char: NotRequired[pulumi.Input[builtins.int]]
        dir: NotRequired[pulumi.Input[builtins.int]]
        pipe: NotRequired[pulumi.Input[builtins.int]]
        regular: NotRequired[pulumi.Input[builtins.int]]
        socket: NotRequired[pulumi.Input[builtins.int]]
        symlink: NotRequired[pulumi.Input[builtins.int]]
elif False:
    SfsTurboDuTaskDirUsageFileCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsTurboDuTaskDirUsageFileCountArgs:
    def __init__(__self__, *,
                 block: Optional[pulumi.Input[builtins.int]] = None,
                 char: Optional[pulumi.Input[builtins.int]] = None,
                 dir: Optional[pulumi.Input[builtins.int]] = None,
                 pipe: Optional[pulumi.Input[builtins.int]] = None,
                 regular: Optional[pulumi.Input[builtins.int]] = None,
                 socket: Optional[pulumi.Input[builtins.int]] = None,
                 symlink: Optional[pulumi.Input[builtins.int]] = None):
        if block is not None:
            pulumi.set(__self__, "block", block)
        if char is not None:
            pulumi.set(__self__, "char", char)
        if dir is not None:
            pulumi.set(__self__, "dir", dir)
        if pipe is not None:
            pulumi.set(__self__, "pipe", pipe)
        if regular is not None:
            pulumi.set(__self__, "regular", regular)
        if socket is not None:
            pulumi.set(__self__, "socket", socket)
        if symlink is not None:
            pulumi.set(__self__, "symlink", symlink)

    @property
    @pulumi.getter
    def block(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "block")

    @block.setter
    def block(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "block", value)

    @property
    @pulumi.getter
    def char(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "char")

    @char.setter
    def char(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "char", value)

    @property
    @pulumi.getter
    def dir(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "dir")

    @dir.setter
    def dir(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "dir", value)

    @property
    @pulumi.getter
    def pipe(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "pipe")

    @pipe.setter
    def pipe(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "pipe", value)

    @property
    @pulumi.getter
    def regular(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "regular")

    @regular.setter
    def regular(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "regular", value)

    @property
    @pulumi.getter
    def socket(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "socket")

    @socket.setter
    def socket(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "socket", value)

    @property
    @pulumi.getter
    def symlink(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "symlink")

    @symlink.setter
    def symlink(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "symlink", value)


if not MYPY:
    class SfsTurboObsTargetObsArgsDict(TypedDict):
        bucket: pulumi.Input[builtins.str]
        endpoint: pulumi.Input[builtins.str]
elif False:
    SfsTurboObsTargetObsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SfsTurboObsTargetObsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[builtins.str],
                 endpoint: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class SmnSubscriptionExtensionArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[builtins.str]]
        client_secret: NotRequired[pulumi.Input[builtins.str]]
        keyword: NotRequired[pulumi.Input[builtins.str]]
        sign_secret: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SmnSubscriptionExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmnSubscriptionExtensionArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[builtins.str]] = None,
                 keyword: Optional[pulumi.Input[builtins.str]] = None,
                 sign_secret: Optional[pulumi.Input[builtins.str]] = None):
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if keyword is not None:
            pulumi.set(__self__, "keyword", keyword)
        if sign_secret is not None:
            pulumi.set(__self__, "sign_secret", sign_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def keyword(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "keyword", value)

    @property
    @pulumi.getter(name="signSecret")
    def sign_secret(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "sign_secret")

    @sign_secret.setter
    def sign_secret(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sign_secret", value)


if not MYPY:
    class SmnSubscriptionFilterPolicyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The filter policy name. The policy name must be unique.
        """
        string_equals: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The string array for exact match.
        """
elif False:
    SmnSubscriptionFilterPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SmnSubscriptionFilterPolicyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 string_equals: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] name: The filter policy name. The policy name must be unique.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] string_equals: The string array for exact match.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if string_equals is not None:
            pulumi.set(__self__, "string_equals", string_equals)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The filter policy name. The policy name must be unique.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="stringEquals")
    def string_equals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The string array for exact match.
        """
        return pulumi.get(self, "string_equals")

    @string_equals.setter
    def string_equals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "string_equals", value)


if not MYPY:
    class SwrOrganizationPermissionsSelfPermissionArgsDict(TypedDict):
        permission: NotRequired[pulumi.Input[builtins.str]]
        user_id: NotRequired[pulumi.Input[builtins.str]]
        user_name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SwrOrganizationPermissionsSelfPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwrOrganizationPermissionsSelfPermissionArgs:
    def __init__(__self__, *,
                 permission: Optional[pulumi.Input[builtins.str]] = None,
                 user_id: Optional[pulumi.Input[builtins.str]] = None,
                 user_name: Optional[pulumi.Input[builtins.str]] = None):
        if permission is not None:
            pulumi.set(__self__, "permission", permission)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def permission(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class SwrOrganizationPermissionsUserArgsDict(TypedDict):
        permission: pulumi.Input[builtins.str]
        user_id: pulumi.Input[builtins.str]
        user_name: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SwrOrganizationPermissionsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SwrOrganizationPermissionsUserArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[builtins.str],
                 user_id: pulumi.Input[builtins.str],
                 user_name: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "user_id", user_id)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class VpcAddressGroupIpExtraSetArgsDict(TypedDict):
        ip: pulumi.Input[builtins.str]
        remarks: NotRequired[pulumi.Input[builtins.str]]
elif False:
    VpcAddressGroupIpExtraSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcAddressGroupIpExtraSetArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[builtins.str],
                 remarks: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "ip", ip)
        if remarks is not None:
            pulumi.set(__self__, "remarks", remarks)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def remarks(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "remarks")

    @remarks.setter
    def remarks(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "remarks", value)


if not MYPY:
    class VpcBandwidthPublicipArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[builtins.str]]
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        ip_version: NotRequired[pulumi.Input[builtins.int]]
        type: NotRequired[pulumi.Input[builtins.str]]
elif False:
    VpcBandwidthPublicipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcBandwidthPublicipArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VpcEipBandwidthArgsDict(TypedDict):
        share_type: pulumi.Input[builtins.str]
        """
        Whether the bandwidth is dedicated or shared.
        """
        charge_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Whether the bandwidth is billed by traffic or by bandwidth size.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The shared bandwidth ID.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The dedicated bandwidth name.
        """
        size: NotRequired[pulumi.Input[builtins.int]]
        """
        The dedicated bandwidth size.
        """
elif False:
    VpcEipBandwidthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcEipBandwidthArgs:
    def __init__(__self__, *,
                 share_type: pulumi.Input[builtins.str],
                 charge_mode: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 size: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] share_type: Whether the bandwidth is dedicated or shared.
        :param pulumi.Input[builtins.str] charge_mode: Whether the bandwidth is billed by traffic or by bandwidth size.
        :param pulumi.Input[builtins.str] id: The shared bandwidth ID.
        :param pulumi.Input[builtins.str] name: The dedicated bandwidth name.
        :param pulumi.Input[builtins.int] size: The dedicated bandwidth size.
        """
        pulumi.set(__self__, "share_type", share_type)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="shareType")
    def share_type(self) -> pulumi.Input[builtins.str]:
        """
        Whether the bandwidth is dedicated or shared.
        """
        return pulumi.get(self, "share_type")

    @share_type.setter
    def share_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "share_type", value)

    @property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Whether the bandwidth is billed by traffic or by bandwidth size.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The shared bandwidth ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The dedicated bandwidth name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The dedicated bandwidth size.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class VpcEipPublicipArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The EIP address to be assigned.
        """
        ip_version: NotRequired[pulumi.Input[builtins.int]]
        """
        The IP version.
        """
        port_id: NotRequired[pulumi.Input[builtins.str]]
        """
        schema: Deprecated
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The EIP type.
        """
elif False:
    VpcEipPublicipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcEipPublicipArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[builtins.int]] = None,
                 port_id: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] ip_address: The EIP address to be assigned.
        :param pulumi.Input[builtins.int] ip_version: The IP version.
        :param pulumi.Input[builtins.str] port_id: schema: Deprecated
        :param pulumi.Input[builtins.str] type: The EIP type.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if port_id is not None:
            pulumi.set(__self__, "port_id", port_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The EIP address to be assigned.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter(name="portId")
    def port_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        schema: Deprecated
        """
        return pulumi.get(self, "port_id")

    @port_id.setter
    def port_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "port_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The EIP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VpcRouteArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input[builtins.str]]
        nexthop: NotRequired[pulumi.Input[builtins.str]]
elif False:
    VpcRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcRouteArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[builtins.str]] = None,
                 nexthop: Optional[pulumi.Input[builtins.str]] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if nexthop is not None:
            pulumi.set(__self__, "nexthop", nexthop)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def nexthop(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "nexthop", value)


if not MYPY:
    class VpcRouteTableRouteArgsDict(TypedDict):
        destination: pulumi.Input[builtins.str]
        nexthop: pulumi.Input[builtins.str]
        type: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    VpcRouteTableRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcRouteTableRouteArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[builtins.str],
                 nexthop: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "nexthop", nexthop)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def nexthop(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "nexthop")

    @nexthop.setter
    def nexthop(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "nexthop", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class VpcepServiceConnectionArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[builtins.str]]
        domain_id: NotRequired[pulumi.Input[builtins.str]]
        endpoint_id: NotRequired[pulumi.Input[builtins.str]]
        packet_id: NotRequired[pulumi.Input[builtins.int]]
        status: NotRequired[pulumi.Input[builtins.str]]
elif False:
    VpcepServiceConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcepServiceConnectionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 domain_id: Optional[pulumi.Input[builtins.str]] = None,
                 endpoint_id: Optional[pulumi.Input[builtins.str]] = None,
                 packet_id: Optional[pulumi.Input[builtins.int]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        if description is not None:
            pulumi.set(__self__, "description", description)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if packet_id is not None:
            pulumi.set(__self__, "packet_id", packet_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter(name="packetId")
    def packet_id(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "packet_id")

    @packet_id.setter
    def packet_id(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "packet_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class VpcepServicePortMappingArgsDict(TypedDict):
        protocol: NotRequired[pulumi.Input[builtins.str]]
        service_port: NotRequired[pulumi.Input[builtins.int]]
        """
        schema: Required
        """
        terminal_port: NotRequired[pulumi.Input[builtins.int]]
        """
        schema: Required
        """
elif False:
    VpcepServicePortMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcepServicePortMappingArgs:
    def __init__(__self__, *,
                 protocol: Optional[pulumi.Input[builtins.str]] = None,
                 service_port: Optional[pulumi.Input[builtins.int]] = None,
                 terminal_port: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] service_port: schema: Required
        :param pulumi.Input[builtins.int] terminal_port: schema: Required
        """
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_port is not None:
            pulumi.set(__self__, "service_port", service_port)
        if terminal_port is not None:
            pulumi.set(__self__, "terminal_port", terminal_port)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="servicePort")
    def service_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        schema: Required
        """
        return pulumi.get(self, "service_port")

    @service_port.setter
    def service_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "service_port", value)

    @property
    @pulumi.getter(name="terminalPort")
    def terminal_port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        schema: Required
        """
        return pulumi.get(self, "terminal_port")

    @terminal_port.setter
    def terminal_port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "terminal_port", value)


if not MYPY:
    class VpnConnectionIkepolicyArgsDict(TypedDict):
        authentication_algorithm: NotRequired[pulumi.Input[builtins.str]]
        """
        The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
        """
        authentication_method: NotRequired[pulumi.Input[builtins.str]]
        """
        The authentication method during IKE negotiation.
        """
        dh_group: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the DH group used for key exchange in phase 1.
        """
        dpd: NotRequired[pulumi.Input['VpnConnectionIkepolicyDpdArgsDict']]
        """
        Specifies the dead peer detection (DPD) object.
        """
        encryption_algorithm: NotRequired[pulumi.Input[builtins.str]]
        """
        The encryption algorithm, 3DES is less secure, please use them with caution.
        """
        ike_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The IKE negotiation version.
        """
        lifetime_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The life cycle of SA in seconds, when the life cycle expires, IKE SA will be automatically updated.
        """
        local_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The local ID.
        """
        local_id_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The local ID type.
        """
        peer_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The peer ID.
        """
        peer_id_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The peer ID type.
        """
        pfs: NotRequired[pulumi.Input[builtins.str]]
        """
        The DH key group used by PFS.
        """
        phase1_negotiation_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The negotiation mode, only works when the ike_version is v1.
        """
elif False:
    VpnConnectionIkepolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionIkepolicyArgs:
    def __init__(__self__, *,
                 authentication_algorithm: Optional[pulumi.Input[builtins.str]] = None,
                 authentication_method: Optional[pulumi.Input[builtins.str]] = None,
                 dh_group: Optional[pulumi.Input[builtins.str]] = None,
                 dpd: Optional[pulumi.Input['VpnConnectionIkepolicyDpdArgs']] = None,
                 encryption_algorithm: Optional[pulumi.Input[builtins.str]] = None,
                 ike_version: Optional[pulumi.Input[builtins.str]] = None,
                 lifetime_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 local_id: Optional[pulumi.Input[builtins.str]] = None,
                 local_id_type: Optional[pulumi.Input[builtins.str]] = None,
                 peer_id: Optional[pulumi.Input[builtins.str]] = None,
                 peer_id_type: Optional[pulumi.Input[builtins.str]] = None,
                 pfs: Optional[pulumi.Input[builtins.str]] = None,
                 phase1_negotiation_mode: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] authentication_algorithm: The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
        :param pulumi.Input[builtins.str] authentication_method: The authentication method during IKE negotiation.
        :param pulumi.Input[builtins.str] dh_group: Specifies the DH group used for key exchange in phase 1.
        :param pulumi.Input['VpnConnectionIkepolicyDpdArgs'] dpd: Specifies the dead peer detection (DPD) object.
        :param pulumi.Input[builtins.str] encryption_algorithm: The encryption algorithm, 3DES is less secure, please use them with caution.
        :param pulumi.Input[builtins.str] ike_version: The IKE negotiation version.
        :param pulumi.Input[builtins.int] lifetime_seconds: The life cycle of SA in seconds, when the life cycle expires, IKE SA will be automatically updated.
        :param pulumi.Input[builtins.str] local_id: The local ID.
        :param pulumi.Input[builtins.str] local_id_type: The local ID type.
        :param pulumi.Input[builtins.str] peer_id: The peer ID.
        :param pulumi.Input[builtins.str] peer_id_type: The peer ID type.
        :param pulumi.Input[builtins.str] pfs: The DH key group used by PFS.
        :param pulumi.Input[builtins.str] phase1_negotiation_mode: The negotiation mode, only works when the ike_version is v1.
        """
        if authentication_algorithm is not None:
            pulumi.set(__self__, "authentication_algorithm", authentication_algorithm)
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if dh_group is not None:
            pulumi.set(__self__, "dh_group", dh_group)
        if dpd is not None:
            pulumi.set(__self__, "dpd", dpd)
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        if ike_version is not None:
            pulumi.set(__self__, "ike_version", ike_version)
        if lifetime_seconds is not None:
            pulumi.set(__self__, "lifetime_seconds", lifetime_seconds)
        if local_id is not None:
            pulumi.set(__self__, "local_id", local_id)
        if local_id_type is not None:
            pulumi.set(__self__, "local_id_type", local_id_type)
        if peer_id is not None:
            pulumi.set(__self__, "peer_id", peer_id)
        if peer_id_type is not None:
            pulumi.set(__self__, "peer_id_type", peer_id_type)
        if pfs is not None:
            pulumi.set(__self__, "pfs", pfs)
        if phase1_negotiation_mode is not None:
            pulumi.set(__self__, "phase1_negotiation_mode", phase1_negotiation_mode)

    @property
    @pulumi.getter(name="authenticationAlgorithm")
    def authentication_algorithm(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
        """
        return pulumi.get(self, "authentication_algorithm")

    @authentication_algorithm.setter
    def authentication_algorithm(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authentication_algorithm", value)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The authentication method during IKE negotiation.
        """
        return pulumi.get(self, "authentication_method")

    @authentication_method.setter
    def authentication_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authentication_method", value)

    @property
    @pulumi.getter(name="dhGroup")
    def dh_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the DH group used for key exchange in phase 1.
        """
        return pulumi.get(self, "dh_group")

    @dh_group.setter
    def dh_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dh_group", value)

    @property
    @pulumi.getter
    def dpd(self) -> Optional[pulumi.Input['VpnConnectionIkepolicyDpdArgs']]:
        """
        Specifies the dead peer detection (DPD) object.
        """
        return pulumi.get(self, "dpd")

    @dpd.setter
    def dpd(self, value: Optional[pulumi.Input['VpnConnectionIkepolicyDpdArgs']]):
        pulumi.set(self, "dpd", value)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The encryption algorithm, 3DES is less secure, please use them with caution.
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encryption_algorithm", value)

    @property
    @pulumi.getter(name="ikeVersion")
    def ike_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The IKE negotiation version.
        """
        return pulumi.get(self, "ike_version")

    @ike_version.setter
    def ike_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ike_version", value)

    @property
    @pulumi.getter(name="lifetimeSeconds")
    def lifetime_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The life cycle of SA in seconds, when the life cycle expires, IKE SA will be automatically updated.
        """
        return pulumi.get(self, "lifetime_seconds")

    @lifetime_seconds.setter
    def lifetime_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "lifetime_seconds", value)

    @property
    @pulumi.getter(name="localId")
    def local_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The local ID.
        """
        return pulumi.get(self, "local_id")

    @local_id.setter
    def local_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_id", value)

    @property
    @pulumi.getter(name="localIdType")
    def local_id_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The local ID type.
        """
        return pulumi.get(self, "local_id_type")

    @local_id_type.setter
    def local_id_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "local_id_type", value)

    @property
    @pulumi.getter(name="peerId")
    def peer_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The peer ID.
        """
        return pulumi.get(self, "peer_id")

    @peer_id.setter
    def peer_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "peer_id", value)

    @property
    @pulumi.getter(name="peerIdType")
    def peer_id_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The peer ID type.
        """
        return pulumi.get(self, "peer_id_type")

    @peer_id_type.setter
    def peer_id_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "peer_id_type", value)

    @property
    @pulumi.getter
    def pfs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The DH key group used by PFS.
        """
        return pulumi.get(self, "pfs")

    @pfs.setter
    def pfs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pfs", value)

    @property
    @pulumi.getter(name="phase1NegotiationMode")
    def phase1_negotiation_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The negotiation mode, only works when the ike_version is v1.
        """
        return pulumi.get(self, "phase1_negotiation_mode")

    @phase1_negotiation_mode.setter
    def phase1_negotiation_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "phase1_negotiation_mode", value)


if not MYPY:
    class VpnConnectionIkepolicyDpdArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the DPD idle timeout period.
        """
        msg: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the format of DPD packets.
        """
        timeout: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies the interval for retransmitting DPD packets.
        """
elif False:
    VpnConnectionIkepolicyDpdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionIkepolicyDpdArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[builtins.int]] = None,
                 msg: Optional[pulumi.Input[builtins.str]] = None,
                 timeout: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] interval: Specifies the DPD idle timeout period.
        :param pulumi.Input[builtins.str] msg: Specifies the format of DPD packets.
        :param pulumi.Input[builtins.int] timeout: Specifies the interval for retransmitting DPD packets.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if msg is not None:
            pulumi.set(__self__, "msg", msg)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the DPD idle timeout period.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def msg(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the format of DPD packets.
        """
        return pulumi.get(self, "msg")

    @msg.setter
    def msg(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "msg", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies the interval for retransmitting DPD packets.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class VpnConnectionIpsecpolicyArgsDict(TypedDict):
        authentication_algorithm: NotRequired[pulumi.Input[builtins.str]]
        """
        The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
        """
        encapsulation_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The encapsulation mode, only **tunnel** supported for now.
        """
        encryption_algorithm: NotRequired[pulumi.Input[builtins.str]]
        """
        The encryption algorithm, 3DES is less secure, please use them with caution.
        """
        lifetime_seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        The lifecycle time of Ipsec tunnel in seconds.
        """
        pfs: NotRequired[pulumi.Input[builtins.str]]
        """
        The DH key group used by PFS.
        """
        transform_protocol: NotRequired[pulumi.Input[builtins.str]]
        """
        The transform protocol. Only **esp** supported for now.
        """
elif False:
    VpnConnectionIpsecpolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionIpsecpolicyArgs:
    def __init__(__self__, *,
                 authentication_algorithm: Optional[pulumi.Input[builtins.str]] = None,
                 encapsulation_mode: Optional[pulumi.Input[builtins.str]] = None,
                 encryption_algorithm: Optional[pulumi.Input[builtins.str]] = None,
                 lifetime_seconds: Optional[pulumi.Input[builtins.int]] = None,
                 pfs: Optional[pulumi.Input[builtins.str]] = None,
                 transform_protocol: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] authentication_algorithm: The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
        :param pulumi.Input[builtins.str] encapsulation_mode: The encapsulation mode, only **tunnel** supported for now.
        :param pulumi.Input[builtins.str] encryption_algorithm: The encryption algorithm, 3DES is less secure, please use them with caution.
        :param pulumi.Input[builtins.int] lifetime_seconds: The lifecycle time of Ipsec tunnel in seconds.
        :param pulumi.Input[builtins.str] pfs: The DH key group used by PFS.
        :param pulumi.Input[builtins.str] transform_protocol: The transform protocol. Only **esp** supported for now.
        """
        if authentication_algorithm is not None:
            pulumi.set(__self__, "authentication_algorithm", authentication_algorithm)
        if encapsulation_mode is not None:
            pulumi.set(__self__, "encapsulation_mode", encapsulation_mode)
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)
        if lifetime_seconds is not None:
            pulumi.set(__self__, "lifetime_seconds", lifetime_seconds)
        if pfs is not None:
            pulumi.set(__self__, "pfs", pfs)
        if transform_protocol is not None:
            pulumi.set(__self__, "transform_protocol", transform_protocol)

    @property
    @pulumi.getter(name="authenticationAlgorithm")
    def authentication_algorithm(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The authentication algorithm, SHA1 and MD5 are less secure, please use them with caution.
        """
        return pulumi.get(self, "authentication_algorithm")

    @authentication_algorithm.setter
    def authentication_algorithm(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "authentication_algorithm", value)

    @property
    @pulumi.getter(name="encapsulationMode")
    def encapsulation_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The encapsulation mode, only **tunnel** supported for now.
        """
        return pulumi.get(self, "encapsulation_mode")

    @encapsulation_mode.setter
    def encapsulation_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encapsulation_mode", value)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The encryption algorithm, 3DES is less secure, please use them with caution.
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encryption_algorithm", value)

    @property
    @pulumi.getter(name="lifetimeSeconds")
    def lifetime_seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The lifecycle time of Ipsec tunnel in seconds.
        """
        return pulumi.get(self, "lifetime_seconds")

    @lifetime_seconds.setter
    def lifetime_seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "lifetime_seconds", value)

    @property
    @pulumi.getter
    def pfs(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The DH key group used by PFS.
        """
        return pulumi.get(self, "pfs")

    @pfs.setter
    def pfs(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pfs", value)

    @property
    @pulumi.getter(name="transformProtocol")
    def transform_protocol(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The transform protocol. Only **esp** supported for now.
        """
        return pulumi.get(self, "transform_protocol")

    @transform_protocol.setter
    def transform_protocol(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "transform_protocol", value)


if not MYPY:
    class VpnConnectionPolicyRuleArgsDict(TypedDict):
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The list of destination CIDRs.
        """
        rule_index: NotRequired[pulumi.Input[builtins.int]]
        """
        The rule index.
        """
        source: NotRequired[pulumi.Input[builtins.str]]
        """
        The source CIDR.
        """
elif False:
    VpnConnectionPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionPolicyRuleArgs:
    def __init__(__self__, *,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 rule_index: Optional[pulumi.Input[builtins.int]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] destinations: The list of destination CIDRs.
        :param pulumi.Input[builtins.int] rule_index: The rule index.
        :param pulumi.Input[builtins.str] source: The source CIDR.
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if rule_index is not None:
            pulumi.set(__self__, "rule_index", rule_index)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The list of destination CIDRs.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="ruleIndex")
    def rule_index(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The rule index.
        """
        return pulumi.get(self, "rule_index")

    @rule_index.setter
    def rule_index(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "rule_index", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The source CIDR.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class VpnGatewayCertificateArgsDict(TypedDict):
        certificate_chain: pulumi.Input[builtins.str]
        content: pulumi.Input[builtins.str]
        enc_certificate: pulumi.Input[builtins.str]
        enc_private_key: pulumi.Input[builtins.str]
        name: pulumi.Input[builtins.str]
        private_key: pulumi.Input[builtins.str]
        certificate_chain_expire_time: NotRequired[pulumi.Input[builtins.str]]
        certificate_chain_serial_number: NotRequired[pulumi.Input[builtins.str]]
        certificate_chain_subject: NotRequired[pulumi.Input[builtins.str]]
        certificate_expire_time: NotRequired[pulumi.Input[builtins.str]]
        certificate_id: NotRequired[pulumi.Input[builtins.str]]
        certificate_serial_number: NotRequired[pulumi.Input[builtins.str]]
        certificate_subject: NotRequired[pulumi.Input[builtins.str]]
        created_at: NotRequired[pulumi.Input[builtins.str]]
        enc_certificate_expire_time: NotRequired[pulumi.Input[builtins.str]]
        enc_certificate_serial_number: NotRequired[pulumi.Input[builtins.str]]
        enc_certificate_subject: NotRequired[pulumi.Input[builtins.str]]
        issuer: NotRequired[pulumi.Input[builtins.str]]
        signature_algorithm: NotRequired[pulumi.Input[builtins.str]]
        status: NotRequired[pulumi.Input[builtins.str]]
        updated_at: NotRequired[pulumi.Input[builtins.str]]
elif False:
    VpnGatewayCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewayCertificateArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[builtins.str],
                 content: pulumi.Input[builtins.str],
                 enc_certificate: pulumi.Input[builtins.str],
                 enc_private_key: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 private_key: pulumi.Input[builtins.str],
                 certificate_chain_expire_time: Optional[pulumi.Input[builtins.str]] = None,
                 certificate_chain_serial_number: Optional[pulumi.Input[builtins.str]] = None,
                 certificate_chain_subject: Optional[pulumi.Input[builtins.str]] = None,
                 certificate_expire_time: Optional[pulumi.Input[builtins.str]] = None,
                 certificate_id: Optional[pulumi.Input[builtins.str]] = None,
                 certificate_serial_number: Optional[pulumi.Input[builtins.str]] = None,
                 certificate_subject: Optional[pulumi.Input[builtins.str]] = None,
                 created_at: Optional[pulumi.Input[builtins.str]] = None,
                 enc_certificate_expire_time: Optional[pulumi.Input[builtins.str]] = None,
                 enc_certificate_serial_number: Optional[pulumi.Input[builtins.str]] = None,
                 enc_certificate_subject: Optional[pulumi.Input[builtins.str]] = None,
                 issuer: Optional[pulumi.Input[builtins.str]] = None,
                 signature_algorithm: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "certificate_chain", certificate_chain)
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "enc_certificate", enc_certificate)
        pulumi.set(__self__, "enc_private_key", enc_private_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private_key", private_key)
        if certificate_chain_expire_time is not None:
            pulumi.set(__self__, "certificate_chain_expire_time", certificate_chain_expire_time)
        if certificate_chain_serial_number is not None:
            pulumi.set(__self__, "certificate_chain_serial_number", certificate_chain_serial_number)
        if certificate_chain_subject is not None:
            pulumi.set(__self__, "certificate_chain_subject", certificate_chain_subject)
        if certificate_expire_time is not None:
            pulumi.set(__self__, "certificate_expire_time", certificate_expire_time)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_serial_number is not None:
            pulumi.set(__self__, "certificate_serial_number", certificate_serial_number)
        if certificate_subject is not None:
            pulumi.set(__self__, "certificate_subject", certificate_subject)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if enc_certificate_expire_time is not None:
            pulumi.set(__self__, "enc_certificate_expire_time", enc_certificate_expire_time)
        if enc_certificate_serial_number is not None:
            pulumi.set(__self__, "enc_certificate_serial_number", enc_certificate_serial_number)
        if enc_certificate_subject is not None:
            pulumi.set(__self__, "enc_certificate_subject", enc_certificate_subject)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if signature_algorithm is not None:
            pulumi.set(__self__, "signature_algorithm", signature_algorithm)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "certificate_chain", value)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="encCertificate")
    def enc_certificate(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "enc_certificate")

    @enc_certificate.setter
    def enc_certificate(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "enc_certificate", value)

    @property
    @pulumi.getter(name="encPrivateKey")
    def enc_private_key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "enc_private_key")

    @enc_private_key.setter
    def enc_private_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "enc_private_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="certificateChainExpireTime")
    def certificate_chain_expire_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "certificate_chain_expire_time")

    @certificate_chain_expire_time.setter
    def certificate_chain_expire_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_chain_expire_time", value)

    @property
    @pulumi.getter(name="certificateChainSerialNumber")
    def certificate_chain_serial_number(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "certificate_chain_serial_number")

    @certificate_chain_serial_number.setter
    def certificate_chain_serial_number(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_chain_serial_number", value)

    @property
    @pulumi.getter(name="certificateChainSubject")
    def certificate_chain_subject(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "certificate_chain_subject")

    @certificate_chain_subject.setter
    def certificate_chain_subject(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_chain_subject", value)

    @property
    @pulumi.getter(name="certificateExpireTime")
    def certificate_expire_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "certificate_expire_time")

    @certificate_expire_time.setter
    def certificate_expire_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_expire_time", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="certificateSerialNumber")
    def certificate_serial_number(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "certificate_serial_number")

    @certificate_serial_number.setter
    def certificate_serial_number(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_serial_number", value)

    @property
    @pulumi.getter(name="certificateSubject")
    def certificate_subject(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "certificate_subject")

    @certificate_subject.setter
    def certificate_subject(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_subject", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="encCertificateExpireTime")
    def enc_certificate_expire_time(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "enc_certificate_expire_time")

    @enc_certificate_expire_time.setter
    def enc_certificate_expire_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enc_certificate_expire_time", value)

    @property
    @pulumi.getter(name="encCertificateSerialNumber")
    def enc_certificate_serial_number(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "enc_certificate_serial_number")

    @enc_certificate_serial_number.setter
    def enc_certificate_serial_number(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enc_certificate_serial_number", value)

    @property
    @pulumi.getter(name="encCertificateSubject")
    def enc_certificate_subject(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "enc_certificate_subject")

    @enc_certificate_subject.setter
    def enc_certificate_subject(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "enc_certificate_subject", value)

    @property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "issuer", value)

    @property
    @pulumi.getter(name="signatureAlgorithm")
    def signature_algorithm(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "signature_algorithm")

    @signature_algorithm.setter
    def signature_algorithm(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "signature_algorithm", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class VpnGatewayEip1ArgsDict(TypedDict):
        bandwidth_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The bandwidth ID.
        """
        bandwidth_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The bandwidth name.
        """
        bandwidth_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        """
        charge_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The public IP ID.
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The public IP address.
        """
        ip_version: NotRequired[pulumi.Input[builtins.int]]
        """
        The public IP version.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
elif False:
    VpnGatewayEip1ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewayEip1Args:
    def __init__(__self__, *,
                 bandwidth_id: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth_name: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth_size: Optional[pulumi.Input[builtins.int]] = None,
                 charge_mode: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] bandwidth_id: The bandwidth ID.
        :param pulumi.Input[builtins.str] bandwidth_name: The bandwidth name.
        :param pulumi.Input[builtins.int] bandwidth_size: Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        :param pulumi.Input[builtins.str] charge_mode: The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        :param pulumi.Input[builtins.str] id: The public IP ID.
        :param pulumi.Input[builtins.str] ip_address: The public IP address.
        :param pulumi.Input[builtins.int] ip_version: The public IP version.
        :param pulumi.Input[builtins.str] type: The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
        if bandwidth_id is not None:
            pulumi.set(__self__, "bandwidth_id", bandwidth_id)
        if bandwidth_name is not None:
            pulumi.set(__self__, "bandwidth_name", bandwidth_name)
        if bandwidth_size is not None:
            pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bandwidthId")
    def bandwidth_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bandwidth ID.
        """
        return pulumi.get(self, "bandwidth_id")

    @bandwidth_id.setter
    def bandwidth_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bandwidth_id", value)

    @property
    @pulumi.getter(name="bandwidthName")
    def bandwidth_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bandwidth name.
        """
        return pulumi.get(self, "bandwidth_name")

    @bandwidth_name.setter
    def bandwidth_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bandwidth_name", value)

    @property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        """
        return pulumi.get(self, "bandwidth_size")

    @bandwidth_size.setter
    def bandwidth_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth_size", value)

    @property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The public IP ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The public IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The public IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VpnGatewayEip2ArgsDict(TypedDict):
        bandwidth_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The bandwidth ID.
        """
        bandwidth_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The bandwidth name.
        """
        bandwidth_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        """
        charge_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The public IP ID.
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The public IP address.
        """
        ip_version: NotRequired[pulumi.Input[builtins.int]]
        """
        The public IP version.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
elif False:
    VpnGatewayEip2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewayEip2Args:
    def __init__(__self__, *,
                 bandwidth_id: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth_name: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth_size: Optional[pulumi.Input[builtins.int]] = None,
                 charge_mode: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] bandwidth_id: The bandwidth ID.
        :param pulumi.Input[builtins.str] bandwidth_name: The bandwidth name.
        :param pulumi.Input[builtins.int] bandwidth_size: Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        :param pulumi.Input[builtins.str] charge_mode: The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        :param pulumi.Input[builtins.str] id: The public IP ID.
        :param pulumi.Input[builtins.str] ip_address: The public IP address.
        :param pulumi.Input[builtins.int] ip_version: The public IP version.
        :param pulumi.Input[builtins.str] type: The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
        if bandwidth_id is not None:
            pulumi.set(__self__, "bandwidth_id", bandwidth_id)
        if bandwidth_name is not None:
            pulumi.set(__self__, "bandwidth_name", bandwidth_name)
        if bandwidth_size is not None:
            pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bandwidthId")
    def bandwidth_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bandwidth ID.
        """
        return pulumi.get(self, "bandwidth_id")

    @bandwidth_id.setter
    def bandwidth_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bandwidth_id", value)

    @property
    @pulumi.getter(name="bandwidthName")
    def bandwidth_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bandwidth name.
        """
        return pulumi.get(self, "bandwidth_name")

    @bandwidth_name.setter
    def bandwidth_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bandwidth_name", value)

    @property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        """
        return pulumi.get(self, "bandwidth_size")

    @bandwidth_size.setter
    def bandwidth_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth_size", value)

    @property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The public IP ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The public IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The public IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VpnGatewayMasterEipArgsDict(TypedDict):
        bandwidth_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The bandwidth ID.
        """
        bandwidth_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The bandwidth name.
        """
        bandwidth_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        """
        charge_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The public IP ID.
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The public IP address.
        """
        ip_version: NotRequired[pulumi.Input[builtins.int]]
        """
        The public IP version.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
elif False:
    VpnGatewayMasterEipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewayMasterEipArgs:
    def __init__(__self__, *,
                 bandwidth_id: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth_name: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth_size: Optional[pulumi.Input[builtins.int]] = None,
                 charge_mode: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] bandwidth_id: The bandwidth ID.
        :param pulumi.Input[builtins.str] bandwidth_name: The bandwidth name.
        :param pulumi.Input[builtins.int] bandwidth_size: Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        :param pulumi.Input[builtins.str] charge_mode: The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        :param pulumi.Input[builtins.str] id: The public IP ID.
        :param pulumi.Input[builtins.str] ip_address: The public IP address.
        :param pulumi.Input[builtins.int] ip_version: The public IP version.
        :param pulumi.Input[builtins.str] type: The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
        if bandwidth_id is not None:
            pulumi.set(__self__, "bandwidth_id", bandwidth_id)
        if bandwidth_name is not None:
            pulumi.set(__self__, "bandwidth_name", bandwidth_name)
        if bandwidth_size is not None:
            pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bandwidthId")
    def bandwidth_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bandwidth ID.
        """
        return pulumi.get(self, "bandwidth_id")

    @bandwidth_id.setter
    def bandwidth_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bandwidth_id", value)

    @property
    @pulumi.getter(name="bandwidthName")
    def bandwidth_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bandwidth name.
        """
        return pulumi.get(self, "bandwidth_name")

    @bandwidth_name.setter
    def bandwidth_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bandwidth_name", value)

    @property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        """
        return pulumi.get(self, "bandwidth_size")

    @bandwidth_size.setter
    def bandwidth_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth_size", value)

    @property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The public IP ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The public IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The public IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VpnGatewaySlaveEipArgsDict(TypedDict):
        bandwidth_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The bandwidth ID.
        """
        bandwidth_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The bandwidth name.
        """
        bandwidth_size: NotRequired[pulumi.Input[builtins.int]]
        """
        Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        """
        charge_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The public IP ID.
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The public IP address.
        """
        ip_version: NotRequired[pulumi.Input[builtins.int]]
        """
        The public IP version.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
elif False:
    VpnGatewaySlaveEipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnGatewaySlaveEipArgs:
    def __init__(__self__, *,
                 bandwidth_id: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth_name: Optional[pulumi.Input[builtins.str]] = None,
                 bandwidth_size: Optional[pulumi.Input[builtins.int]] = None,
                 charge_mode: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_version: Optional[pulumi.Input[builtins.int]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] bandwidth_id: The bandwidth ID.
        :param pulumi.Input[builtins.str] bandwidth_name: The bandwidth name.
        :param pulumi.Input[builtins.int] bandwidth_size: Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        :param pulumi.Input[builtins.str] charge_mode: The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        :param pulumi.Input[builtins.str] id: The public IP ID.
        :param pulumi.Input[builtins.str] ip_address: The public IP address.
        :param pulumi.Input[builtins.int] ip_version: The public IP version.
        :param pulumi.Input[builtins.str] type: The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
        if bandwidth_id is not None:
            pulumi.set(__self__, "bandwidth_id", bandwidth_id)
        if bandwidth_name is not None:
            pulumi.set(__self__, "bandwidth_name", bandwidth_name)
        if bandwidth_size is not None:
            pulumi.set(__self__, "bandwidth_size", bandwidth_size)
        if charge_mode is not None:
            pulumi.set(__self__, "charge_mode", charge_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bandwidthId")
    def bandwidth_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bandwidth ID.
        """
        return pulumi.get(self, "bandwidth_id")

    @bandwidth_id.setter
    def bandwidth_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bandwidth_id", value)

    @property
    @pulumi.getter(name="bandwidthName")
    def bandwidth_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The bandwidth name.
        """
        return pulumi.get(self, "bandwidth_name")

    @bandwidth_name.setter
    def bandwidth_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bandwidth_name", value)

    @property
    @pulumi.getter(name="bandwidthSize")
    def bandwidth_size(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Bandwidth size in Mbit/s. When the flavor is **V300**, the value cannot be greater than **300**.
        """
        return pulumi.get(self, "bandwidth_size")

    @bandwidth_size.setter
    def bandwidth_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "bandwidth_size", value)

    @property
    @pulumi.getter(name="chargeMode")
    def charge_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The charge mode of the bandwidth. The value can be **bandwidth** and **traffic**.
        """
        return pulumi.get(self, "charge_mode")

    @charge_mode.setter
    def charge_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "charge_mode", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The public IP ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The public IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The public IP version.
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The EIP type. The value can be **5_bgp** and **5_sbgp**.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


