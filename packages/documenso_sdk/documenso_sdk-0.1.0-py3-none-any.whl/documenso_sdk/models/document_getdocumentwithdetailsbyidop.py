"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from documenso_sdk import utils
from documenso_sdk.types import BaseModel, Nullable, UNSET_SENTINEL
from documenso_sdk.utils import FieldMetadata, PathParamMetadata
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class DocumentGetDocumentWithDetailsByIDRequestTypedDict(TypedDict):
    document_id: float


class DocumentGetDocumentWithDetailsByIDRequest(BaseModel):
    document_id: Annotated[
        float,
        pydantic.Field(alias="documentId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]


class DocumentGetDocumentWithDetailsByIDInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class DocumentGetDocumentWithDetailsByIDInternalServerErrorIssue(BaseModel):
    message: str


class DocumentGetDocumentWithDetailsByIDInternalServerErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[
        List[DocumentGetDocumentWithDetailsByIDInternalServerErrorIssue]
    ] = None


class DocumentGetDocumentWithDetailsByIDInternalServerError(Exception):
    r"""Internal server error"""

    data: DocumentGetDocumentWithDetailsByIDInternalServerErrorData

    def __init__(self, data: DocumentGetDocumentWithDetailsByIDInternalServerErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, DocumentGetDocumentWithDetailsByIDInternalServerErrorData
        )


class DocumentGetDocumentWithDetailsByIDNotFoundIssueTypedDict(TypedDict):
    message: str


class DocumentGetDocumentWithDetailsByIDNotFoundIssue(BaseModel):
    message: str


class DocumentGetDocumentWithDetailsByIDNotFoundErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentGetDocumentWithDetailsByIDNotFoundIssue]] = None


class DocumentGetDocumentWithDetailsByIDNotFoundError(Exception):
    r"""Not found"""

    data: DocumentGetDocumentWithDetailsByIDNotFoundErrorData

    def __init__(self, data: DocumentGetDocumentWithDetailsByIDNotFoundErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, DocumentGetDocumentWithDetailsByIDNotFoundErrorData
        )


class DocumentGetDocumentWithDetailsByIDBadRequestIssueTypedDict(TypedDict):
    message: str


class DocumentGetDocumentWithDetailsByIDBadRequestIssue(BaseModel):
    message: str


class DocumentGetDocumentWithDetailsByIDBadRequestErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentGetDocumentWithDetailsByIDBadRequestIssue]] = None


class DocumentGetDocumentWithDetailsByIDBadRequestError(Exception):
    r"""Invalid input data"""

    data: DocumentGetDocumentWithDetailsByIDBadRequestErrorData

    def __init__(self, data: DocumentGetDocumentWithDetailsByIDBadRequestErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, DocumentGetDocumentWithDetailsByIDBadRequestErrorData
        )


class DocumentGetDocumentWithDetailsByIDVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class DocumentGetDocumentWithDetailsByIDStatus(str, Enum):
    DRAFT = "DRAFT"
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    REJECTED = "REJECTED"


class DocumentGetDocumentWithDetailsByIDSource(str, Enum):
    DOCUMENT = "DOCUMENT"
    TEMPLATE = "TEMPLATE"
    TEMPLATE_DIRECT_LINK = "TEMPLATE_DIRECT_LINK"


class DocumentGetDocumentWithDetailsByIDGlobalAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class DocumentGetDocumentWithDetailsByIDGlobalActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class DocumentGetDocumentWithDetailsByIDAuthOptionsTypedDict(TypedDict):
    global_access_auth: Nullable[DocumentGetDocumentWithDetailsByIDGlobalAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: Nullable[DocumentGetDocumentWithDetailsByIDGlobalActionAuth]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""


class DocumentGetDocumentWithDetailsByIDAuthOptions(BaseModel):
    global_access_auth: Annotated[
        Nullable[DocumentGetDocumentWithDetailsByIDGlobalAccessAuth],
        pydantic.Field(alias="globalAccessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        Nullable[DocumentGetDocumentWithDetailsByIDGlobalActionAuth],
        pydantic.Field(alias="globalActionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["globalAccessAuth", "globalActionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


DocumentGetDocumentWithDetailsByIDFormValuesTypedDict = TypeAliasType(
    "DocumentGetDocumentWithDetailsByIDFormValuesTypedDict", Union[str, bool, float]
)


DocumentGetDocumentWithDetailsByIDFormValues = TypeAliasType(
    "DocumentGetDocumentWithDetailsByIDFormValues", Union[str, bool, float]
)


class DocumentGetDocumentWithDetailsByIDDocumentDataType(str, Enum):
    S3_PATH = "S3_PATH"
    BYTES = "BYTES"
    BYTES_64 = "BYTES_64"


class DocumentGetDocumentWithDetailsByIDDocumentDataTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDDocumentDataType
    id: str
    data: str
    initial_data: str


class DocumentGetDocumentWithDetailsByIDDocumentData(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDDocumentDataType

    id: str

    data: str

    initial_data: Annotated[str, pydantic.Field(alias="initialData")]


class DocumentGetDocumentWithDetailsByIDSigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class DocumentGetDocumentWithDetailsByIDDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class DocumentGetDocumentWithDetailsByIDEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""
    recipient_removed: NotRequired[bool]
    r"""Whether to send an email to the recipient who was removed from a pending document."""
    recipient_signed: NotRequired[bool]
    r"""Whether to send an email to the document owner when a recipient has signed the document."""
    document_pending: NotRequired[bool]
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""
    document_completed: NotRequired[bool]
    r"""Whether to send an email to all recipients when the document is complete."""
    document_deleted: NotRequired[bool]
    r"""Whether to send an email to all recipients if a pending document has been deleted."""
    owner_document_completed: NotRequired[bool]
    r"""Whether to send an email to the document owner when the document is complete."""


class DocumentGetDocumentWithDetailsByIDEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True
    r"""Whether to send an email to the recipient who was removed from a pending document."""

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True
    r"""Whether to send an email to the document owner when a recipient has signed the document."""

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True
    r"""Whether to send an email to all recipients when the document is complete."""

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True
    r"""Whether to send an email to all recipients if a pending document has been deleted."""

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True
    r"""Whether to send an email to the document owner when the document is complete."""


class DocumentGetDocumentWithDetailsByIDDocumentMetaTypedDict(TypedDict):
    signing_order: DocumentGetDocumentWithDetailsByIDSigningOrder
    distribution_method: DocumentGetDocumentWithDetailsByIDDistributionMethod
    id: str
    subject: Nullable[str]
    message: Nullable[str]
    timezone: Nullable[str]
    password: Nullable[str]
    date_format: Nullable[str]
    document_id: float
    redirect_url: Nullable[str]
    typed_signature_enabled: bool
    upload_signature_enabled: bool
    draw_signature_enabled: bool
    allow_dictate_next_signer: bool
    language: str
    email_settings: Nullable[DocumentGetDocumentWithDetailsByIDEmailSettingsTypedDict]


class DocumentGetDocumentWithDetailsByIDDocumentMeta(BaseModel):
    signing_order: Annotated[
        DocumentGetDocumentWithDetailsByIDSigningOrder,
        pydantic.Field(alias="signingOrder"),
    ]

    distribution_method: Annotated[
        DocumentGetDocumentWithDetailsByIDDistributionMethod,
        pydantic.Field(alias="distributionMethod"),
    ]

    id: str

    subject: Nullable[str]

    message: Nullable[str]

    timezone: Nullable[str]

    password: Nullable[str]

    date_format: Annotated[Nullable[str], pydantic.Field(alias="dateFormat")]

    document_id: Annotated[float, pydantic.Field(alias="documentId")]

    redirect_url: Annotated[Nullable[str], pydantic.Field(alias="redirectUrl")]

    typed_signature_enabled: Annotated[
        bool, pydantic.Field(alias="typedSignatureEnabled")
    ]

    upload_signature_enabled: Annotated[
        bool, pydantic.Field(alias="uploadSignatureEnabled")
    ]

    draw_signature_enabled: Annotated[
        bool, pydantic.Field(alias="drawSignatureEnabled")
    ]

    allow_dictate_next_signer: Annotated[
        bool, pydantic.Field(alias="allowDictateNextSigner")
    ]

    language: str

    email_settings: Annotated[
        Nullable[DocumentGetDocumentWithDetailsByIDEmailSettings],
        pydantic.Field(alias="emailSettings"),
    ]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "subject",
            "message",
            "timezone",
            "password",
            "dateFormat",
            "redirectUrl",
            "emailSettings",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentGetDocumentWithDetailsByIDRole(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"
    ASSISTANT = "ASSISTANT"


class DocumentGetDocumentWithDetailsByIDReadStatus(str, Enum):
    NOT_OPENED = "NOT_OPENED"
    OPENED = "OPENED"


class DocumentGetDocumentWithDetailsByIDSigningStatus(str, Enum):
    NOT_SIGNED = "NOT_SIGNED"
    SIGNED = "SIGNED"
    REJECTED = "REJECTED"


class DocumentGetDocumentWithDetailsByIDSendStatus(str, Enum):
    NOT_SENT = "NOT_SENT"
    SENT = "SENT"


class DocumentGetDocumentWithDetailsByIDAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class DocumentGetDocumentWithDetailsByIDActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class DocumentGetDocumentWithDetailsByIDRecipientAuthOptionsTypedDict(TypedDict):
    access_auth: Nullable[DocumentGetDocumentWithDetailsByIDAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    action_auth: Nullable[DocumentGetDocumentWithDetailsByIDActionAuth]
    r"""The type of authentication required for the recipient to sign the document."""


class DocumentGetDocumentWithDetailsByIDRecipientAuthOptions(BaseModel):
    access_auth: Annotated[
        Nullable[DocumentGetDocumentWithDetailsByIDAccessAuth],
        pydantic.Field(alias="accessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    action_auth: Annotated[
        Nullable[DocumentGetDocumentWithDetailsByIDActionAuth],
        pydantic.Field(alias="actionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["accessAuth", "actionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentGetDocumentWithDetailsByIDRecipientTypedDict(TypedDict):
    role: DocumentGetDocumentWithDetailsByIDRole
    read_status: DocumentGetDocumentWithDetailsByIDReadStatus
    signing_status: DocumentGetDocumentWithDetailsByIDSigningStatus
    send_status: DocumentGetDocumentWithDetailsByIDSendStatus
    id: float
    document_id: Nullable[float]
    template_id: Nullable[float]
    email: str
    name: str
    token: str
    document_deleted_at: Nullable[str]
    expired: Nullable[str]
    signed_at: Nullable[str]
    auth_options: Nullable[
        DocumentGetDocumentWithDetailsByIDRecipientAuthOptionsTypedDict
    ]
    signing_order: Nullable[float]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""
    rejection_reason: Nullable[str]


class DocumentGetDocumentWithDetailsByIDRecipient(BaseModel):
    role: DocumentGetDocumentWithDetailsByIDRole

    read_status: Annotated[
        DocumentGetDocumentWithDetailsByIDReadStatus, pydantic.Field(alias="readStatus")
    ]

    signing_status: Annotated[
        DocumentGetDocumentWithDetailsByIDSigningStatus,
        pydantic.Field(alias="signingStatus"),
    ]

    send_status: Annotated[
        DocumentGetDocumentWithDetailsByIDSendStatus, pydantic.Field(alias="sendStatus")
    ]

    id: float

    document_id: Annotated[Nullable[float], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    email: str

    name: str

    token: str

    document_deleted_at: Annotated[
        Nullable[str], pydantic.Field(alias="documentDeletedAt")
    ]

    expired: Nullable[str]

    signed_at: Annotated[Nullable[str], pydantic.Field(alias="signedAt")]

    auth_options: Annotated[
        Nullable[DocumentGetDocumentWithDetailsByIDRecipientAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    signing_order: Annotated[Nullable[float], pydantic.Field(alias="signingOrder")]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""

    rejection_reason: Annotated[Nullable[str], pydantic.Field(alias="rejectionReason")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "documentId",
            "templateId",
            "documentDeletedAt",
            "expired",
            "signedAt",
            "authOptions",
            "signingOrder",
            "rejectionReason",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentGetDocumentWithDetailsByIDFieldType(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class DocumentGetDocumentWithDetailsByIDTypeDropdown(str, Enum):
    DROPDOWN = "dropdown"


class DocumentGetDocumentWithDetailsByIDValue3TypedDict(TypedDict):
    value: str


class DocumentGetDocumentWithDetailsByIDValue3(BaseModel):
    value: str


class DocumentGetDocumentWithDetailsByIDFieldMetaDropdownTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDTypeDropdown
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[DocumentGetDocumentWithDetailsByIDValue3TypedDict]]
    default_value: NotRequired[str]


class DocumentGetDocumentWithDetailsByIDFieldMetaDropdown(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDTypeDropdown

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[DocumentGetDocumentWithDetailsByIDValue3]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class DocumentGetDocumentWithDetailsByIDTypeCheckbox(str, Enum):
    CHECKBOX = "checkbox"


class DocumentGetDocumentWithDetailsByIDValue2TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentGetDocumentWithDetailsByIDValue2(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentGetDocumentWithDetailsByIDFieldMetaCheckboxTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDTypeCheckbox
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[DocumentGetDocumentWithDetailsByIDValue2TypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]


class DocumentGetDocumentWithDetailsByIDFieldMetaCheckbox(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDTypeCheckbox

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[DocumentGetDocumentWithDetailsByIDValue2]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None


class DocumentGetDocumentWithDetailsByIDTypeRadio(str, Enum):
    RADIO = "radio"


class DocumentGetDocumentWithDetailsByIDValue1TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentGetDocumentWithDetailsByIDValue1(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentGetDocumentWithDetailsByIDFieldMetaRadioTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDTypeRadio
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[DocumentGetDocumentWithDetailsByIDValue1TypedDict]]


class DocumentGetDocumentWithDetailsByIDFieldMetaRadio(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDTypeRadio

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[DocumentGetDocumentWithDetailsByIDValue1]] = None


class DocumentGetDocumentWithDetailsByIDTypeNumber(str, Enum):
    NUMBER = "number"


class DocumentGetDocumentWithDetailsByIDTextAlign6(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentGetDocumentWithDetailsByIDFieldMetaNumberTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDTypeNumber
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    number_format: NotRequired[str]
    value: NotRequired[str]
    min_value: NotRequired[float]
    max_value: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentGetDocumentWithDetailsByIDTextAlign6]


class DocumentGetDocumentWithDetailsByIDFieldMetaNumber(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDTypeNumber

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    number_format: Annotated[Optional[str], pydantic.Field(alias="numberFormat")] = None

    value: Optional[str] = None

    min_value: Annotated[Optional[float], pydantic.Field(alias="minValue")] = None

    max_value: Annotated[Optional[float], pydantic.Field(alias="maxValue")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentGetDocumentWithDetailsByIDTextAlign6],
        pydantic.Field(alias="textAlign"),
    ] = None


class DocumentGetDocumentWithDetailsByIDTypeText(str, Enum):
    TEXT = "text"


class DocumentGetDocumentWithDetailsByIDTextAlign5(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentGetDocumentWithDetailsByIDFieldMetaTextTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDTypeText
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentGetDocumentWithDetailsByIDTextAlign5]


class DocumentGetDocumentWithDetailsByIDFieldMetaText(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDTypeText

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentGetDocumentWithDetailsByIDTextAlign5],
        pydantic.Field(alias="textAlign"),
    ] = None


class DocumentGetDocumentWithDetailsByIDTypeDate(str, Enum):
    DATE = "date"


class DocumentGetDocumentWithDetailsByIDTextAlign4(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentGetDocumentWithDetailsByIDFieldMetaDateTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDTypeDate
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentGetDocumentWithDetailsByIDTextAlign4]


class DocumentGetDocumentWithDetailsByIDFieldMetaDate(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDTypeDate

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentGetDocumentWithDetailsByIDTextAlign4],
        pydantic.Field(alias="textAlign"),
    ] = None


class DocumentGetDocumentWithDetailsByIDTypeEmail(str, Enum):
    EMAIL = "email"


class DocumentGetDocumentWithDetailsByIDTextAlign3(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentGetDocumentWithDetailsByIDFieldMetaEmailTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDTypeEmail
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentGetDocumentWithDetailsByIDTextAlign3]


class DocumentGetDocumentWithDetailsByIDFieldMetaEmail(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDTypeEmail

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentGetDocumentWithDetailsByIDTextAlign3],
        pydantic.Field(alias="textAlign"),
    ] = None


class DocumentGetDocumentWithDetailsByIDTypeName(str, Enum):
    NAME = "name"


class DocumentGetDocumentWithDetailsByIDTextAlign2(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentGetDocumentWithDetailsByIDFieldMetaNameTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDTypeName
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentGetDocumentWithDetailsByIDTextAlign2]


class DocumentGetDocumentWithDetailsByIDFieldMetaName(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDTypeName

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentGetDocumentWithDetailsByIDTextAlign2],
        pydantic.Field(alias="textAlign"),
    ] = None


class DocumentGetDocumentWithDetailsByIDTypeInitials(str, Enum):
    INITIALS = "initials"


class DocumentGetDocumentWithDetailsByIDTextAlign1(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentGetDocumentWithDetailsByIDFieldMetaInitialsTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDTypeInitials
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentGetDocumentWithDetailsByIDTextAlign1]


class DocumentGetDocumentWithDetailsByIDFieldMetaInitials(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDTypeInitials

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentGetDocumentWithDetailsByIDTextAlign1],
        pydantic.Field(alias="textAlign"),
    ] = None


DocumentGetDocumentWithDetailsByIDFieldMetaUnionTypedDict = TypeAliasType(
    "DocumentGetDocumentWithDetailsByIDFieldMetaUnionTypedDict",
    Union[
        DocumentGetDocumentWithDetailsByIDFieldMetaRadioTypedDict,
        DocumentGetDocumentWithDetailsByIDFieldMetaInitialsTypedDict,
        DocumentGetDocumentWithDetailsByIDFieldMetaNameTypedDict,
        DocumentGetDocumentWithDetailsByIDFieldMetaEmailTypedDict,
        DocumentGetDocumentWithDetailsByIDFieldMetaDateTypedDict,
        DocumentGetDocumentWithDetailsByIDFieldMetaDropdownTypedDict,
        DocumentGetDocumentWithDetailsByIDFieldMetaCheckboxTypedDict,
        DocumentGetDocumentWithDetailsByIDFieldMetaTextTypedDict,
        DocumentGetDocumentWithDetailsByIDFieldMetaNumberTypedDict,
    ],
)


DocumentGetDocumentWithDetailsByIDFieldMetaUnion = TypeAliasType(
    "DocumentGetDocumentWithDetailsByIDFieldMetaUnion",
    Union[
        DocumentGetDocumentWithDetailsByIDFieldMetaRadio,
        DocumentGetDocumentWithDetailsByIDFieldMetaInitials,
        DocumentGetDocumentWithDetailsByIDFieldMetaName,
        DocumentGetDocumentWithDetailsByIDFieldMetaEmail,
        DocumentGetDocumentWithDetailsByIDFieldMetaDate,
        DocumentGetDocumentWithDetailsByIDFieldMetaDropdown,
        DocumentGetDocumentWithDetailsByIDFieldMetaCheckbox,
        DocumentGetDocumentWithDetailsByIDFieldMetaText,
        DocumentGetDocumentWithDetailsByIDFieldMetaNumber,
    ],
)


class DocumentGetDocumentWithDetailsByIDFieldTypedDict(TypedDict):
    type: DocumentGetDocumentWithDetailsByIDFieldType
    id: float
    secondary_id: str
    document_id: Nullable[float]
    template_id: Nullable[float]
    recipient_id: float
    page: float
    r"""The page number of the field on the document. Starts from 1."""
    custom_text: str
    inserted: bool
    field_meta: Nullable[DocumentGetDocumentWithDetailsByIDFieldMetaUnionTypedDict]
    position_x: NotRequired[Any]
    position_y: NotRequired[Any]
    width: NotRequired[Any]
    height: NotRequired[Any]


class DocumentGetDocumentWithDetailsByIDField(BaseModel):
    type: DocumentGetDocumentWithDetailsByIDFieldType

    id: float

    secondary_id: Annotated[str, pydantic.Field(alias="secondaryId")]

    document_id: Annotated[Nullable[float], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    page: float
    r"""The page number of the field on the document. Starts from 1."""

    custom_text: Annotated[str, pydantic.Field(alias="customText")]

    inserted: bool

    field_meta: Annotated[
        Nullable[DocumentGetDocumentWithDetailsByIDFieldMetaUnion],
        pydantic.Field(alias="fieldMeta"),
    ]

    position_x: Annotated[Optional[Any], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[Any], pydantic.Field(alias="positionY")] = None

    width: Optional[Any] = None

    height: Optional[Any] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["positionX", "positionY", "width", "height"]
        nullable_fields = ["documentId", "templateId", "fieldMeta"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentGetDocumentWithDetailsByIDResponseTypedDict(TypedDict):
    r"""Successful response"""

    visibility: DocumentGetDocumentWithDetailsByIDVisibility
    status: DocumentGetDocumentWithDetailsByIDStatus
    source: DocumentGetDocumentWithDetailsByIDSource
    id: float
    external_id: Nullable[str]
    r"""A custom external ID you can use to identify the document."""
    user_id: float
    r"""The ID of the user that created this document."""
    auth_options: Nullable[DocumentGetDocumentWithDetailsByIDAuthOptionsTypedDict]
    form_values: Nullable[
        Dict[str, DocumentGetDocumentWithDetailsByIDFormValuesTypedDict]
    ]
    title: str
    document_data_id: str
    created_at: str
    updated_at: str
    completed_at: Nullable[str]
    deleted_at: Nullable[str]
    team_id: Nullable[float]
    template_id: Nullable[float]
    document_data: DocumentGetDocumentWithDetailsByIDDocumentDataTypedDict
    document_meta: Nullable[DocumentGetDocumentWithDetailsByIDDocumentMetaTypedDict]
    recipients: List[DocumentGetDocumentWithDetailsByIDRecipientTypedDict]
    fields: List[DocumentGetDocumentWithDetailsByIDFieldTypedDict]


class DocumentGetDocumentWithDetailsByIDResponse(BaseModel):
    r"""Successful response"""

    visibility: DocumentGetDocumentWithDetailsByIDVisibility

    status: DocumentGetDocumentWithDetailsByIDStatus

    source: DocumentGetDocumentWithDetailsByIDSource

    id: float

    external_id: Annotated[Nullable[str], pydantic.Field(alias="externalId")]
    r"""A custom external ID you can use to identify the document."""

    user_id: Annotated[float, pydantic.Field(alias="userId")]
    r"""The ID of the user that created this document."""

    auth_options: Annotated[
        Nullable[DocumentGetDocumentWithDetailsByIDAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    form_values: Annotated[
        Nullable[Dict[str, DocumentGetDocumentWithDetailsByIDFormValues]],
        pydantic.Field(alias="formValues"),
    ]

    title: str

    document_data_id: Annotated[str, pydantic.Field(alias="documentDataId")]

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]

    completed_at: Annotated[Nullable[str], pydantic.Field(alias="completedAt")]

    deleted_at: Annotated[Nullable[str], pydantic.Field(alias="deletedAt")]

    team_id: Annotated[Nullable[float], pydantic.Field(alias="teamId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    document_data: Annotated[
        DocumentGetDocumentWithDetailsByIDDocumentData,
        pydantic.Field(alias="documentData"),
    ]

    document_meta: Annotated[
        Nullable[DocumentGetDocumentWithDetailsByIDDocumentMeta],
        pydantic.Field(alias="documentMeta"),
    ]

    recipients: List[DocumentGetDocumentWithDetailsByIDRecipient]

    fields: List[DocumentGetDocumentWithDetailsByIDField]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "externalId",
            "authOptions",
            "formValues",
            "completedAt",
            "deletedAt",
            "teamId",
            "templateId",
            "documentMeta",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
