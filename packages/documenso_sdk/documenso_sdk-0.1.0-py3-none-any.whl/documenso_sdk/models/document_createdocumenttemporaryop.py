"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from documenso_sdk import utils
from documenso_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class VisibilityAccount(str, Enum):
    r"""The visibility of the document."""

    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class DocumentCreateDocumentTemporaryGlobalAccessAuthRequest(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class GlobalActionAuthAccount(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


FormValuesRequestTypedDict = TypeAliasType(
    "FormValuesRequestTypedDict", Union[str, bool, float]
)


FormValuesRequest = TypeAliasType("FormValuesRequest", Union[str, bool, float])


class RoleAccount(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"
    ASSISTANT = "ASSISTANT"


class DocumentCreateDocumentTemporaryAccessAuthRequest(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class ActionAuthAccount(str, Enum):
    r"""The type of authentication required for the recipient to sign the document."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class TypeAccountDropdown1(str, Enum):
    DROPDOWN = "DROPDOWN"


class TypeAccountDropdown2(str, Enum):
    DROPDOWN = "dropdown"


class ValueAccountDropdownTypedDict(TypedDict):
    value: str


class ValueAccountDropdown(BaseModel):
    value: str


class FieldMetaAccountDropdownTypedDict(TypedDict):
    type: TypeAccountDropdown2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[ValueAccountDropdownTypedDict]]
    default_value: NotRequired[str]


class FieldMetaAccountDropdown(BaseModel):
    type: TypeAccountDropdown2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[ValueAccountDropdown]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class FieldAccountDropdownTypedDict(TypedDict):
    type: TypeAccountDropdown1
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaAccountDropdownTypedDict]


class FieldAccountDropdown(BaseModel):
    type: TypeAccountDropdown1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldMetaAccountDropdown], pydantic.Field(alias="fieldMeta")
    ] = None


class TypeAccountCheckbox1(str, Enum):
    CHECKBOX = "CHECKBOX"


class TypeAccountCheckbox2(str, Enum):
    CHECKBOX = "checkbox"


class ValueAccountCheckboxTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class ValueAccountCheckbox(BaseModel):
    id: float

    checked: bool

    value: str


class FieldMetaAccountCheckboxTypedDict(TypedDict):
    type: TypeAccountCheckbox2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[ValueAccountCheckboxTypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]


class FieldMetaAccountCheckbox(BaseModel):
    type: TypeAccountCheckbox2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[ValueAccountCheckbox]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None


class FieldAccountCheckboxTypedDict(TypedDict):
    type: TypeAccountCheckbox1
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaAccountCheckboxTypedDict]


class FieldAccountCheckbox(BaseModel):
    type: TypeAccountCheckbox1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldMetaAccountCheckbox], pydantic.Field(alias="fieldMeta")
    ] = None


class TypeAccountRadio1(str, Enum):
    RADIO = "RADIO"


class TypeAccountRadio2(str, Enum):
    RADIO = "radio"


class ValueAccountRadioTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class ValueAccountRadio(BaseModel):
    id: float

    checked: bool

    value: str


class FieldMetaAccountRadioTypedDict(TypedDict):
    type: TypeAccountRadio2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[ValueAccountRadioTypedDict]]


class FieldMetaAccountRadio(BaseModel):
    type: TypeAccountRadio2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[ValueAccountRadio]] = None


class FieldAccountRadioTypedDict(TypedDict):
    type: TypeAccountRadio1
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaAccountRadioTypedDict]


class FieldAccountRadio(BaseModel):
    type: TypeAccountRadio1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldMetaAccountRadio], pydantic.Field(alias="fieldMeta")
    ] = None


class TypeAccountNumber1(str, Enum):
    NUMBER = "NUMBER"


class TypeAccountNumber2(str, Enum):
    NUMBER = "number"


class TextAlignAccountNumber(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaAccountNumberTypedDict(TypedDict):
    type: TypeAccountNumber2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    number_format: NotRequired[str]
    value: NotRequired[str]
    min_value: NotRequired[float]
    max_value: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[TextAlignAccountNumber]


class FieldMetaAccountNumber(BaseModel):
    type: TypeAccountNumber2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    number_format: Annotated[Optional[str], pydantic.Field(alias="numberFormat")] = None

    value: Optional[str] = None

    min_value: Annotated[Optional[float], pydantic.Field(alias="minValue")] = None

    max_value: Annotated[Optional[float], pydantic.Field(alias="maxValue")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TextAlignAccountNumber], pydantic.Field(alias="textAlign")
    ] = None


class FieldAccountNumberTypedDict(TypedDict):
    type: TypeAccountNumber1
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaAccountNumberTypedDict]


class FieldAccountNumber(BaseModel):
    type: TypeAccountNumber1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldMetaAccountNumber], pydantic.Field(alias="fieldMeta")
    ] = None


class TypeAccountText1(str, Enum):
    TEXT = "TEXT"


class TypeAccountText2(str, Enum):
    TEXT = "text"


class TextAlignAccountText(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaAccountTextTypedDict(TypedDict):
    type: TypeAccountText2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[TextAlignAccountText]


class FieldMetaAccountText(BaseModel):
    type: TypeAccountText2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TextAlignAccountText], pydantic.Field(alias="textAlign")
    ] = None


class FieldAccountTextTypedDict(TypedDict):
    type: TypeAccountText1
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaAccountTextTypedDict]


class FieldAccountText(BaseModel):
    type: TypeAccountText1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldMetaAccountText], pydantic.Field(alias="fieldMeta")
    ] = None


class TypeAccountDate1(str, Enum):
    DATE = "DATE"


class TypeAccountDate2(str, Enum):
    DATE = "date"


class TextAlignAccountDate(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaAccountDateTypedDict(TypedDict):
    type: TypeAccountDate2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TextAlignAccountDate]


class FieldMetaAccountDate(BaseModel):
    type: TypeAccountDate2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TextAlignAccountDate], pydantic.Field(alias="textAlign")
    ] = None


class FieldAccountDateTypedDict(TypedDict):
    type: TypeAccountDate1
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaAccountDateTypedDict]


class FieldAccountDate(BaseModel):
    type: TypeAccountDate1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldMetaAccountDate], pydantic.Field(alias="fieldMeta")
    ] = None


class TypeAccountEmail1(str, Enum):
    EMAIL = "EMAIL"


class TypeAccountEmail2(str, Enum):
    EMAIL = "email"


class TextAlignAccountEmail(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaAccountEmailTypedDict(TypedDict):
    type: TypeAccountEmail2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TextAlignAccountEmail]


class FieldMetaAccountEmail(BaseModel):
    type: TypeAccountEmail2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TextAlignAccountEmail], pydantic.Field(alias="textAlign")
    ] = None


class FieldAccountEmailTypedDict(TypedDict):
    type: TypeAccountEmail1
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaAccountEmailTypedDict]


class FieldAccountEmail(BaseModel):
    type: TypeAccountEmail1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldMetaAccountEmail], pydantic.Field(alias="fieldMeta")
    ] = None


class TypeAccountName1(str, Enum):
    NAME = "NAME"


class TypeAccountName2(str, Enum):
    NAME = "name"


class TextAlignAccountName(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaAccountNameTypedDict(TypedDict):
    type: TypeAccountName2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TextAlignAccountName]


class FieldMetaAccountName(BaseModel):
    type: TypeAccountName2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TextAlignAccountName], pydantic.Field(alias="textAlign")
    ] = None


class FieldAccountNameTypedDict(TypedDict):
    type: TypeAccountName1
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaAccountNameTypedDict]


class FieldAccountName(BaseModel):
    type: TypeAccountName1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldMetaAccountName], pydantic.Field(alias="fieldMeta")
    ] = None


class TypeAccountInitials1(str, Enum):
    INITIALS = "INITIALS"


class TypeAccountInitials2(str, Enum):
    INITIALS = "initials"


class TextAlignAccountInitials(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaAccountInitialsTypedDict(TypedDict):
    type: TypeAccountInitials2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TextAlignAccountInitials]


class FieldMetaAccountInitials(BaseModel):
    type: TypeAccountInitials2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TextAlignAccountInitials], pydantic.Field(alias="textAlign")
    ] = None


class FieldAccountInitialsTypedDict(TypedDict):
    type: TypeAccountInitials1
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""
    field_meta: NotRequired[FieldMetaAccountInitialsTypedDict]


class FieldAccountInitials(BaseModel):
    type: TypeAccountInitials1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""

    field_meta: Annotated[
        Optional[FieldMetaAccountInitials], pydantic.Field(alias="fieldMeta")
    ] = None


class TypeAccountFreeSignature(str, Enum):
    FREE_SIGNATURE = "FREE_SIGNATURE"


class FieldAccountFreeSignatureTypedDict(TypedDict):
    type: TypeAccountFreeSignature
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""


class FieldAccountFreeSignature(BaseModel):
    type: TypeAccountFreeSignature

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""


class TypeAccountSignature(str, Enum):
    SIGNATURE = "SIGNATURE"


class FieldAccountSignatureTypedDict(TypedDict):
    type: TypeAccountSignature
    page_number: float
    r"""The page number the field will be on."""
    page_x: float
    r"""The X coordinate of where the field will be placed."""
    page_y: float
    r"""The Y coordinate of where the field will be placed."""
    width: float
    r"""The width of the field."""
    height: float
    r"""The height of the field."""


class FieldAccountSignature(BaseModel):
    type: TypeAccountSignature

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]
    r"""The page number the field will be on."""

    page_x: Annotated[float, pydantic.Field(alias="pageX")]
    r"""The X coordinate of where the field will be placed."""

    page_y: Annotated[float, pydantic.Field(alias="pageY")]
    r"""The Y coordinate of where the field will be placed."""

    width: float
    r"""The width of the field."""

    height: float
    r"""The height of the field."""


FieldAccountUnionTypedDict = TypeAliasType(
    "FieldAccountUnionTypedDict",
    Union[
        FieldAccountSignatureTypedDict,
        FieldAccountFreeSignatureTypedDict,
        FieldAccountInitialsTypedDict,
        FieldAccountNameTypedDict,
        FieldAccountEmailTypedDict,
        FieldAccountDateTypedDict,
        FieldAccountTextTypedDict,
        FieldAccountNumberTypedDict,
        FieldAccountRadioTypedDict,
        FieldAccountCheckboxTypedDict,
        FieldAccountDropdownTypedDict,
    ],
)


FieldAccountUnion = TypeAliasType(
    "FieldAccountUnion",
    Union[
        FieldAccountSignature,
        FieldAccountFreeSignature,
        FieldAccountInitials,
        FieldAccountName,
        FieldAccountEmail,
        FieldAccountDate,
        FieldAccountText,
        FieldAccountNumber,
        FieldAccountRadio,
        FieldAccountCheckbox,
        FieldAccountDropdown,
    ],
)


class RecipientAccountTypedDict(TypedDict):
    email: str
    name: str
    role: RoleAccount
    signing_order: NotRequired[float]
    access_auth: NotRequired[Nullable[DocumentCreateDocumentTemporaryAccessAuthRequest]]
    r"""The type of authentication required for the recipient to access the document."""
    action_auth: NotRequired[Nullable[ActionAuthAccount]]
    r"""The type of authentication required for the recipient to sign the document."""
    fields: NotRequired[List[FieldAccountUnionTypedDict]]


class RecipientAccount(BaseModel):
    email: str

    name: str

    role: RoleAccount

    signing_order: Annotated[Optional[float], pydantic.Field(alias="signingOrder")] = (
        None
    )

    access_auth: Annotated[
        OptionalNullable[DocumentCreateDocumentTemporaryAccessAuthRequest],
        pydantic.Field(alias="accessAuth"),
    ] = UNSET
    r"""The type of authentication required for the recipient to access the document."""

    action_auth: Annotated[
        OptionalNullable[ActionAuthAccount], pydantic.Field(alias="actionAuth")
    ] = UNSET
    r"""The type of authentication required for the recipient to sign the document."""

    fields: Optional[List[FieldAccountUnion]] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["signingOrder", "accessAuth", "actionAuth", "fields"]
        nullable_fields = ["accessAuth", "actionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryDateFormat(str, Enum):
    r"""The date format to use for date fields and signing the document."""

    YYYY_MM_DD_HH_MM_A = "yyyy-MM-dd hh:mm a"
    YYYY_MM_DD = "yyyy-MM-dd"
    DD_MM_YYYY_HH_MM_A = "dd/MM/yyyy hh:mm a"
    MM_DD_YYYY_HH_MM_A = "MM/dd/yyyy hh:mm a"
    YYYY_MM_DD_HH_MM = "yyyy-MM-dd HH:mm"
    YY_MM_DD_HH_MM_A = "yy-MM-dd hh:mm a"
    YYYY_MM_DD_HH_MM_SS = "yyyy-MM-dd HH:mm:ss"
    MMMM_DD_YYYY_HH_MM_A = "MMMM dd, yyyy hh:mm a"
    EEEE_MMMM_DD_YYYY_HH_MM_A = "EEEE, MMMM dd, yyyy hh:mm a"
    YYYY_MM_DD_T_HH_MM_SS_SSSXXX = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"


class DistributionMethodAccount(str, Enum):
    r"""The distribution method to use when sending the document to the recipients."""

    EMAIL = "EMAIL"
    NONE = "NONE"


class SigningOrderAccount(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class DocumentCreateDocumentTemporaryLanguage(str, Enum):
    r"""The language to use for email communications with recipients."""

    DE = "de"
    EN = "en"
    FR = "fr"
    ES = "es"
    IT = "it"
    PL = "pl"


class EmailSettingsAccountTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""
    recipient_removed: NotRequired[bool]
    r"""Whether to send an email to the recipient who was removed from a pending document."""
    recipient_signed: NotRequired[bool]
    r"""Whether to send an email to the document owner when a recipient has signed the document."""
    document_pending: NotRequired[bool]
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""
    document_completed: NotRequired[bool]
    r"""Whether to send an email to all recipients when the document is complete."""
    document_deleted: NotRequired[bool]
    r"""Whether to send an email to all recipients if a pending document has been deleted."""
    owner_document_completed: NotRequired[bool]
    r"""Whether to send an email to the document owner when the document is complete."""


class EmailSettingsAccount(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True
    r"""Whether to send an email to the recipient who was removed from a pending document."""

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True
    r"""Whether to send an email to the document owner when a recipient has signed the document."""

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True
    r"""Whether to send an email to all recipients when the document is complete."""

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True
    r"""Whether to send an email to all recipients if a pending document has been deleted."""

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True
    r"""Whether to send an email to the document owner when the document is complete."""


class DocumentCreateDocumentTemporaryMetaTypedDict(TypedDict):
    subject: NotRequired[str]
    r"""The subject of the email that will be sent to the recipients."""
    message: NotRequired[str]
    r"""The message of the email that will be sent to the recipients."""
    timezone: NotRequired[str]
    r"""The timezone to use for date fields and signing the document. Example Etc/UTC, Australia/Melbourne"""
    date_format: NotRequired[DocumentCreateDocumentTemporaryDateFormat]
    r"""The date format to use for date fields and signing the document."""
    distribution_method: NotRequired[DistributionMethodAccount]
    r"""The distribution method to use when sending the document to the recipients."""
    signing_order: NotRequired[SigningOrderAccount]
    redirect_url: NotRequired[str]
    r"""The URL to which the recipient should be redirected after signing the document."""
    language: NotRequired[DocumentCreateDocumentTemporaryLanguage]
    r"""The language to use for email communications with recipients."""
    typed_signature_enabled: NotRequired[bool]
    r"""Whether to allow recipients to sign using a typed signature."""
    draw_signature_enabled: NotRequired[bool]
    r"""Whether to allow recipients to sign using a draw signature."""
    upload_signature_enabled: NotRequired[bool]
    r"""Whether to allow recipients to sign using an uploaded signature."""
    email_settings: NotRequired[EmailSettingsAccountTypedDict]


class DocumentCreateDocumentTemporaryMeta(BaseModel):
    subject: Optional[str] = None
    r"""The subject of the email that will be sent to the recipients."""

    message: Optional[str] = None
    r"""The message of the email that will be sent to the recipients."""

    timezone: Optional[str] = None
    r"""The timezone to use for date fields and signing the document. Example Etc/UTC, Australia/Melbourne"""

    date_format: Annotated[
        Optional[DocumentCreateDocumentTemporaryDateFormat],
        pydantic.Field(alias="dateFormat"),
    ] = None
    r"""The date format to use for date fields and signing the document."""

    distribution_method: Annotated[
        Optional[DistributionMethodAccount], pydantic.Field(alias="distributionMethod")
    ] = None
    r"""The distribution method to use when sending the document to the recipients."""

    signing_order: Annotated[
        Optional[SigningOrderAccount], pydantic.Field(alias="signingOrder")
    ] = None

    redirect_url: Annotated[Optional[str], pydantic.Field(alias="redirectUrl")] = None
    r"""The URL to which the recipient should be redirected after signing the document."""

    language: Optional[DocumentCreateDocumentTemporaryLanguage] = None
    r"""The language to use for email communications with recipients."""

    typed_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="typedSignatureEnabled")
    ] = None
    r"""Whether to allow recipients to sign using a typed signature."""

    draw_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="drawSignatureEnabled")
    ] = None
    r"""Whether to allow recipients to sign using a draw signature."""

    upload_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="uploadSignatureEnabled")
    ] = None
    r"""Whether to allow recipients to sign using an uploaded signature."""

    email_settings: Annotated[
        Optional[EmailSettingsAccount], pydantic.Field(alias="emailSettings")
    ] = None


class DocumentCreateDocumentTemporaryRequestTypedDict(TypedDict):
    title: str
    r"""The title of the document."""
    external_id: NotRequired[str]
    r"""The external ID of the document."""
    visibility: NotRequired[VisibilityAccount]
    r"""The visibility of the document."""
    global_access_auth: NotRequired[
        DocumentCreateDocumentTemporaryGlobalAccessAuthRequest
    ]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: NotRequired[GlobalActionAuthAccount]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""
    form_values: NotRequired[Dict[str, FormValuesRequestTypedDict]]
    recipients: NotRequired[List[RecipientAccountTypedDict]]
    meta: NotRequired[DocumentCreateDocumentTemporaryMetaTypedDict]


class DocumentCreateDocumentTemporaryRequest(BaseModel):
    title: str
    r"""The title of the document."""

    external_id: Annotated[Optional[str], pydantic.Field(alias="externalId")] = None
    r"""The external ID of the document."""

    visibility: Optional[VisibilityAccount] = None
    r"""The visibility of the document."""

    global_access_auth: Annotated[
        Optional[DocumentCreateDocumentTemporaryGlobalAccessAuthRequest],
        pydantic.Field(alias="globalAccessAuth"),
    ] = None
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        Optional[GlobalActionAuthAccount], pydantic.Field(alias="globalActionAuth")
    ] = None
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    form_values: Annotated[
        Optional[Dict[str, FormValuesRequest]], pydantic.Field(alias="formValues")
    ] = None

    recipients: Optional[List[RecipientAccount]] = None

    meta: Optional[DocumentCreateDocumentTemporaryMeta] = None


class DocumentCreateDocumentTemporaryInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class DocumentCreateDocumentTemporaryInternalServerErrorIssue(BaseModel):
    message: str


class DocumentCreateDocumentTemporaryInternalServerErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentCreateDocumentTemporaryInternalServerErrorIssue]] = (
        None
    )


class DocumentCreateDocumentTemporaryInternalServerError(Exception):
    r"""Internal server error"""

    data: DocumentCreateDocumentTemporaryInternalServerErrorData

    def __init__(self, data: DocumentCreateDocumentTemporaryInternalServerErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, DocumentCreateDocumentTemporaryInternalServerErrorData
        )


class DocumentCreateDocumentTemporaryBadRequestIssueTypedDict(TypedDict):
    message: str


class DocumentCreateDocumentTemporaryBadRequestIssue(BaseModel):
    message: str


class DocumentCreateDocumentTemporaryBadRequestErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentCreateDocumentTemporaryBadRequestIssue]] = None


class DocumentCreateDocumentTemporaryBadRequestError(Exception):
    r"""Invalid input data"""

    data: DocumentCreateDocumentTemporaryBadRequestErrorData

    def __init__(self, data: DocumentCreateDocumentTemporaryBadRequestErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, DocumentCreateDocumentTemporaryBadRequestErrorData
        )


class DocumentVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class DocumentCreateDocumentTemporaryStatus(str, Enum):
    DRAFT = "DRAFT"
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    REJECTED = "REJECTED"


class DocumentCreateDocumentTemporarySource(str, Enum):
    DOCUMENT = "DOCUMENT"
    TEMPLATE = "TEMPLATE"
    TEMPLATE_DIRECT_LINK = "TEMPLATE_DIRECT_LINK"


class DocumentGlobalAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class DocumentGlobalActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class DocumentCreateDocumentTemporaryAuthOptionsTypedDict(TypedDict):
    global_access_auth: Nullable[DocumentGlobalAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: Nullable[DocumentGlobalActionAuth]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""


class DocumentCreateDocumentTemporaryAuthOptions(BaseModel):
    global_access_auth: Annotated[
        Nullable[DocumentGlobalAccessAuth], pydantic.Field(alias="globalAccessAuth")
    ]
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        Nullable[DocumentGlobalActionAuth], pydantic.Field(alias="globalActionAuth")
    ]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["globalAccessAuth", "globalActionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


DocumentFormValuesTypedDict = TypeAliasType(
    "DocumentFormValuesTypedDict", Union[str, bool, float]
)


DocumentFormValues = TypeAliasType("DocumentFormValues", Union[str, bool, float])


class DocumentDocumentDataType(str, Enum):
    S3_PATH = "S3_PATH"
    BYTES = "BYTES"
    BYTES_64 = "BYTES_64"


class DocumentCreateDocumentTemporaryDocumentDataTypedDict(TypedDict):
    type: DocumentDocumentDataType
    id: str
    data: str
    initial_data: str


class DocumentCreateDocumentTemporaryDocumentData(BaseModel):
    type: DocumentDocumentDataType

    id: str

    data: str

    initial_data: Annotated[str, pydantic.Field(alias="initialData")]


class DocumentSigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class DocumentDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class DocumentEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""
    recipient_removed: NotRequired[bool]
    r"""Whether to send an email to the recipient who was removed from a pending document."""
    recipient_signed: NotRequired[bool]
    r"""Whether to send an email to the document owner when a recipient has signed the document."""
    document_pending: NotRequired[bool]
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""
    document_completed: NotRequired[bool]
    r"""Whether to send an email to all recipients when the document is complete."""
    document_deleted: NotRequired[bool]
    r"""Whether to send an email to all recipients if a pending document has been deleted."""
    owner_document_completed: NotRequired[bool]
    r"""Whether to send an email to the document owner when the document is complete."""


class DocumentEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True
    r"""Whether to send an email to the recipient who was removed from a pending document."""

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True
    r"""Whether to send an email to the document owner when a recipient has signed the document."""

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True
    r"""Whether to send an email to all recipients when the document is complete."""

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True
    r"""Whether to send an email to all recipients if a pending document has been deleted."""

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True
    r"""Whether to send an email to the document owner when the document is complete."""


class DocumentCreateDocumentTemporaryDocumentMetaTypedDict(TypedDict):
    signing_order: DocumentSigningOrder
    distribution_method: DocumentDistributionMethod
    id: str
    subject: Nullable[str]
    message: Nullable[str]
    timezone: Nullable[str]
    password: Nullable[str]
    date_format: Nullable[str]
    document_id: float
    redirect_url: Nullable[str]
    typed_signature_enabled: bool
    upload_signature_enabled: bool
    draw_signature_enabled: bool
    allow_dictate_next_signer: bool
    language: str
    email_settings: Nullable[DocumentEmailSettingsTypedDict]


class DocumentCreateDocumentTemporaryDocumentMeta(BaseModel):
    signing_order: Annotated[DocumentSigningOrder, pydantic.Field(alias="signingOrder")]

    distribution_method: Annotated[
        DocumentDistributionMethod, pydantic.Field(alias="distributionMethod")
    ]

    id: str

    subject: Nullable[str]

    message: Nullable[str]

    timezone: Nullable[str]

    password: Nullable[str]

    date_format: Annotated[Nullable[str], pydantic.Field(alias="dateFormat")]

    document_id: Annotated[float, pydantic.Field(alias="documentId")]

    redirect_url: Annotated[Nullable[str], pydantic.Field(alias="redirectUrl")]

    typed_signature_enabled: Annotated[
        bool, pydantic.Field(alias="typedSignatureEnabled")
    ]

    upload_signature_enabled: Annotated[
        bool, pydantic.Field(alias="uploadSignatureEnabled")
    ]

    draw_signature_enabled: Annotated[
        bool, pydantic.Field(alias="drawSignatureEnabled")
    ]

    allow_dictate_next_signer: Annotated[
        bool, pydantic.Field(alias="allowDictateNextSigner")
    ]

    language: str

    email_settings: Annotated[
        Nullable[DocumentEmailSettings], pydantic.Field(alias="emailSettings")
    ]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "subject",
            "message",
            "timezone",
            "password",
            "dateFormat",
            "redirectUrl",
            "emailSettings",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentRole(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"
    ASSISTANT = "ASSISTANT"


class DocumentCreateDocumentTemporaryReadStatus(str, Enum):
    NOT_OPENED = "NOT_OPENED"
    OPENED = "OPENED"


class DocumentCreateDocumentTemporarySigningStatus(str, Enum):
    NOT_SIGNED = "NOT_SIGNED"
    SIGNED = "SIGNED"
    REJECTED = "REJECTED"


class DocumentCreateDocumentTemporarySendStatus(str, Enum):
    NOT_SENT = "NOT_SENT"
    SENT = "SENT"


class DocumentAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class DocumentActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class DocumentCreateDocumentTemporaryRecipientAuthOptionsTypedDict(TypedDict):
    access_auth: Nullable[DocumentAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    action_auth: Nullable[DocumentActionAuth]
    r"""The type of authentication required for the recipient to sign the document."""


class DocumentCreateDocumentTemporaryRecipientAuthOptions(BaseModel):
    access_auth: Annotated[
        Nullable[DocumentAccessAuth], pydantic.Field(alias="accessAuth")
    ]
    r"""The type of authentication required for the recipient to access the document."""

    action_auth: Annotated[
        Nullable[DocumentActionAuth], pydantic.Field(alias="actionAuth")
    ]
    r"""The type of authentication required for the recipient to sign the document."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["accessAuth", "actionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentRecipientTypedDict(TypedDict):
    role: DocumentRole
    read_status: DocumentCreateDocumentTemporaryReadStatus
    signing_status: DocumentCreateDocumentTemporarySigningStatus
    send_status: DocumentCreateDocumentTemporarySendStatus
    id: float
    document_id: Nullable[float]
    template_id: Nullable[float]
    email: str
    name: str
    token: str
    document_deleted_at: Nullable[str]
    expired: Nullable[str]
    signed_at: Nullable[str]
    auth_options: Nullable[DocumentCreateDocumentTemporaryRecipientAuthOptionsTypedDict]
    signing_order: Nullable[float]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""
    rejection_reason: Nullable[str]


class DocumentRecipient(BaseModel):
    role: DocumentRole

    read_status: Annotated[
        DocumentCreateDocumentTemporaryReadStatus, pydantic.Field(alias="readStatus")
    ]

    signing_status: Annotated[
        DocumentCreateDocumentTemporarySigningStatus,
        pydantic.Field(alias="signingStatus"),
    ]

    send_status: Annotated[
        DocumentCreateDocumentTemporarySendStatus, pydantic.Field(alias="sendStatus")
    ]

    id: float

    document_id: Annotated[Nullable[float], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    email: str

    name: str

    token: str

    document_deleted_at: Annotated[
        Nullable[str], pydantic.Field(alias="documentDeletedAt")
    ]

    expired: Nullable[str]

    signed_at: Annotated[Nullable[str], pydantic.Field(alias="signedAt")]

    auth_options: Annotated[
        Nullable[DocumentCreateDocumentTemporaryRecipientAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    signing_order: Annotated[Nullable[float], pydantic.Field(alias="signingOrder")]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""

    rejection_reason: Annotated[Nullable[str], pydantic.Field(alias="rejectionReason")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "documentId",
            "templateId",
            "documentDeletedAt",
            "expired",
            "signedAt",
            "authOptions",
            "signingOrder",
            "rejectionReason",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentFieldType(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class DocumentTypeDropdown(str, Enum):
    DROPDOWN = "dropdown"


class DocumentValue3TypedDict(TypedDict):
    value: str


class DocumentValue3(BaseModel):
    value: str


class FieldMetaDocumentDropdownTypedDict(TypedDict):
    type: DocumentTypeDropdown
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[DocumentValue3TypedDict]]
    default_value: NotRequired[str]


class FieldMetaDocumentDropdown(BaseModel):
    type: DocumentTypeDropdown

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[DocumentValue3]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class DocumentTypeCheckbox(str, Enum):
    CHECKBOX = "checkbox"


class DocumentValue2TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentValue2(BaseModel):
    id: float

    checked: bool

    value: str


class FieldMetaDocumentCheckboxTypedDict(TypedDict):
    type: DocumentTypeCheckbox
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[DocumentValue2TypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]


class FieldMetaDocumentCheckbox(BaseModel):
    type: DocumentTypeCheckbox

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[DocumentValue2]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None


class DocumentTypeRadio(str, Enum):
    RADIO = "radio"


class DocumentValue1TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentValue1(BaseModel):
    id: float

    checked: bool

    value: str


class FieldMetaDocumentRadioTypedDict(TypedDict):
    type: DocumentTypeRadio
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[DocumentValue1TypedDict]]


class FieldMetaDocumentRadio(BaseModel):
    type: DocumentTypeRadio

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[DocumentValue1]] = None


class DocumentTypeNumber(str, Enum):
    NUMBER = "number"


class DocumentTextAlign6(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentNumberTypedDict(TypedDict):
    type: DocumentTypeNumber
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    number_format: NotRequired[str]
    value: NotRequired[str]
    min_value: NotRequired[float]
    max_value: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign6]


class FieldMetaDocumentNumber(BaseModel):
    type: DocumentTypeNumber

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    number_format: Annotated[Optional[str], pydantic.Field(alias="numberFormat")] = None

    value: Optional[str] = None

    min_value: Annotated[Optional[float], pydantic.Field(alias="minValue")] = None

    max_value: Annotated[Optional[float], pydantic.Field(alias="maxValue")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentTextAlign6], pydantic.Field(alias="textAlign")
    ] = None


class DocumentTypeText(str, Enum):
    TEXT = "text"


class DocumentTextAlign5(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentTextTypedDict(TypedDict):
    type: DocumentTypeText
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign5]


class FieldMetaDocumentText(BaseModel):
    type: DocumentTypeText

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentTextAlign5], pydantic.Field(alias="textAlign")
    ] = None


class DocumentTypeDate(str, Enum):
    DATE = "date"


class DocumentTextAlign4(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentDateTypedDict(TypedDict):
    type: DocumentTypeDate
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign4]


class FieldMetaDocumentDate(BaseModel):
    type: DocumentTypeDate

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentTextAlign4], pydantic.Field(alias="textAlign")
    ] = None


class DocumentTypeEmail(str, Enum):
    EMAIL = "email"


class DocumentTextAlign3(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentEmailTypedDict(TypedDict):
    type: DocumentTypeEmail
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign3]


class FieldMetaDocumentEmail(BaseModel):
    type: DocumentTypeEmail

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentTextAlign3], pydantic.Field(alias="textAlign")
    ] = None


class DocumentTypeName(str, Enum):
    NAME = "name"


class DocumentTextAlign2(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentNameTypedDict(TypedDict):
    type: DocumentTypeName
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign2]


class FieldMetaDocumentName(BaseModel):
    type: DocumentTypeName

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentTextAlign2], pydantic.Field(alias="textAlign")
    ] = None


class DocumentTypeInitials(str, Enum):
    INITIALS = "initials"


class DocumentTextAlign1(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentInitialsTypedDict(TypedDict):
    type: DocumentTypeInitials
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign1]


class FieldMetaDocumentInitials(BaseModel):
    type: DocumentTypeInitials

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[DocumentTextAlign1], pydantic.Field(alias="textAlign")
    ] = None


DocumentFieldMetaUnionTypedDict = TypeAliasType(
    "DocumentFieldMetaUnionTypedDict",
    Union[
        FieldMetaDocumentRadioTypedDict,
        FieldMetaDocumentInitialsTypedDict,
        FieldMetaDocumentNameTypedDict,
        FieldMetaDocumentEmailTypedDict,
        FieldMetaDocumentDateTypedDict,
        FieldMetaDocumentDropdownTypedDict,
        FieldMetaDocumentCheckboxTypedDict,
        FieldMetaDocumentTextTypedDict,
        FieldMetaDocumentNumberTypedDict,
    ],
)


DocumentFieldMetaUnion = TypeAliasType(
    "DocumentFieldMetaUnion",
    Union[
        FieldMetaDocumentRadio,
        FieldMetaDocumentInitials,
        FieldMetaDocumentName,
        FieldMetaDocumentEmail,
        FieldMetaDocumentDate,
        FieldMetaDocumentDropdown,
        FieldMetaDocumentCheckbox,
        FieldMetaDocumentText,
        FieldMetaDocumentNumber,
    ],
)


class DocumentFieldTypedDict(TypedDict):
    type: DocumentFieldType
    id: float
    secondary_id: str
    document_id: Nullable[float]
    template_id: Nullable[float]
    recipient_id: float
    page: float
    r"""The page number of the field on the document. Starts from 1."""
    custom_text: str
    inserted: bool
    field_meta: Nullable[DocumentFieldMetaUnionTypedDict]
    position_x: NotRequired[Any]
    position_y: NotRequired[Any]
    width: NotRequired[Any]
    height: NotRequired[Any]


class DocumentField(BaseModel):
    type: DocumentFieldType

    id: float

    secondary_id: Annotated[str, pydantic.Field(alias="secondaryId")]

    document_id: Annotated[Nullable[float], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    page: float
    r"""The page number of the field on the document. Starts from 1."""

    custom_text: Annotated[str, pydantic.Field(alias="customText")]

    inserted: bool

    field_meta: Annotated[
        Nullable[DocumentFieldMetaUnion], pydantic.Field(alias="fieldMeta")
    ]

    position_x: Annotated[Optional[Any], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[Any], pydantic.Field(alias="positionY")] = None

    width: Optional[Any] = None

    height: Optional[Any] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["positionX", "positionY", "width", "height"]
        nullable_fields = ["documentId", "templateId", "fieldMeta"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentTypedDict(TypedDict):
    visibility: DocumentVisibility
    status: DocumentCreateDocumentTemporaryStatus
    source: DocumentCreateDocumentTemporarySource
    id: float
    external_id: Nullable[str]
    r"""A custom external ID you can use to identify the document."""
    user_id: float
    r"""The ID of the user that created this document."""
    auth_options: Nullable[DocumentCreateDocumentTemporaryAuthOptionsTypedDict]
    form_values: Nullable[Dict[str, DocumentFormValuesTypedDict]]
    title: str
    document_data_id: str
    created_at: str
    updated_at: str
    completed_at: Nullable[str]
    deleted_at: Nullable[str]
    team_id: Nullable[float]
    template_id: Nullable[float]
    document_data: DocumentCreateDocumentTemporaryDocumentDataTypedDict
    document_meta: Nullable[DocumentCreateDocumentTemporaryDocumentMetaTypedDict]
    recipients: List[DocumentRecipientTypedDict]
    fields: List[DocumentFieldTypedDict]


class Document(BaseModel):
    visibility: DocumentVisibility

    status: DocumentCreateDocumentTemporaryStatus

    source: DocumentCreateDocumentTemporarySource

    id: float

    external_id: Annotated[Nullable[str], pydantic.Field(alias="externalId")]
    r"""A custom external ID you can use to identify the document."""

    user_id: Annotated[float, pydantic.Field(alias="userId")]
    r"""The ID of the user that created this document."""

    auth_options: Annotated[
        Nullable[DocumentCreateDocumentTemporaryAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    form_values: Annotated[
        Nullable[Dict[str, DocumentFormValues]], pydantic.Field(alias="formValues")
    ]

    title: str

    document_data_id: Annotated[str, pydantic.Field(alias="documentDataId")]

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]

    completed_at: Annotated[Nullable[str], pydantic.Field(alias="completedAt")]

    deleted_at: Annotated[Nullable[str], pydantic.Field(alias="deletedAt")]

    team_id: Annotated[Nullable[float], pydantic.Field(alias="teamId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    document_data: Annotated[
        DocumentCreateDocumentTemporaryDocumentData,
        pydantic.Field(alias="documentData"),
    ]

    document_meta: Annotated[
        Nullable[DocumentCreateDocumentTemporaryDocumentMeta],
        pydantic.Field(alias="documentMeta"),
    ]

    recipients: List[DocumentRecipient]

    fields: List[DocumentField]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "externalId",
            "authOptions",
            "formValues",
            "completedAt",
            "deletedAt",
            "teamId",
            "templateId",
            "documentMeta",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryResponseTypedDict(TypedDict):
    r"""Successful response"""

    document: DocumentTypedDict
    upload_url: str
    r"""The URL to upload the document PDF to. Use a PUT request with the file via form-data"""


class DocumentCreateDocumentTemporaryResponse(BaseModel):
    r"""Successful response"""

    document: Document

    upload_url: Annotated[str, pydantic.Field(alias="uploadUrl")]
    r"""The URL to upload the document PDF to. Use a PUT request with the file via form-data"""
