"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from documenso_sdk import utils
from documenso_sdk.types import BaseModel, Nullable, UNSET_SENTINEL
from documenso_sdk.utils import FieldMetadata, PathParamMetadata
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class TemplateGetTemplateByIDRequestTypedDict(TypedDict):
    template_id: float


class TemplateGetTemplateByIDRequest(BaseModel):
    template_id: Annotated[
        float,
        pydantic.Field(alias="templateId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]


class TemplateGetTemplateByIDInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class TemplateGetTemplateByIDInternalServerErrorIssue(BaseModel):
    message: str


class TemplateGetTemplateByIDInternalServerErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[TemplateGetTemplateByIDInternalServerErrorIssue]] = None


class TemplateGetTemplateByIDInternalServerError(Exception):
    r"""Internal server error"""

    data: TemplateGetTemplateByIDInternalServerErrorData

    def __init__(self, data: TemplateGetTemplateByIDInternalServerErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, TemplateGetTemplateByIDInternalServerErrorData
        )


class TemplateGetTemplateByIDNotFoundIssueTypedDict(TypedDict):
    message: str


class TemplateGetTemplateByIDNotFoundIssue(BaseModel):
    message: str


class TemplateGetTemplateByIDNotFoundErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[TemplateGetTemplateByIDNotFoundIssue]] = None


class TemplateGetTemplateByIDNotFoundError(Exception):
    r"""Not found"""

    data: TemplateGetTemplateByIDNotFoundErrorData

    def __init__(self, data: TemplateGetTemplateByIDNotFoundErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(self.data, TemplateGetTemplateByIDNotFoundErrorData)


class TemplateGetTemplateByIDBadRequestIssueTypedDict(TypedDict):
    message: str


class TemplateGetTemplateByIDBadRequestIssue(BaseModel):
    message: str


class TemplateGetTemplateByIDBadRequestErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[TemplateGetTemplateByIDBadRequestIssue]] = None


class TemplateGetTemplateByIDBadRequestError(Exception):
    r"""Invalid input data"""

    data: TemplateGetTemplateByIDBadRequestErrorData

    def __init__(self, data: TemplateGetTemplateByIDBadRequestErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(self.data, TemplateGetTemplateByIDBadRequestErrorData)


class TemplateGetTemplateByIDType(str, Enum):
    PUBLIC = "PUBLIC"
    PRIVATE = "PRIVATE"


class TemplateGetTemplateByIDVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class TemplateGetTemplateByIDGlobalAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class TemplateGetTemplateByIDGlobalActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class TemplateGetTemplateByIDAuthOptionsTypedDict(TypedDict):
    global_access_auth: Nullable[TemplateGetTemplateByIDGlobalAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: Nullable[TemplateGetTemplateByIDGlobalActionAuth]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""


class TemplateGetTemplateByIDAuthOptions(BaseModel):
    global_access_auth: Annotated[
        Nullable[TemplateGetTemplateByIDGlobalAccessAuth],
        pydantic.Field(alias="globalAccessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        Nullable[TemplateGetTemplateByIDGlobalActionAuth],
        pydantic.Field(alias="globalActionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["globalAccessAuth", "globalActionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateDocumentDataType(str, Enum):
    S3_PATH = "S3_PATH"
    BYTES = "BYTES"
    BYTES_64 = "BYTES_64"


class TemplateDocumentDataTypedDict(TypedDict):
    type: TemplateDocumentDataType
    id: str
    data: str
    initial_data: str


class TemplateDocumentData(BaseModel):
    type: TemplateDocumentDataType

    id: str

    data: str

    initial_data: Annotated[str, pydantic.Field(alias="initialData")]


class TemplateGetTemplateByIDSigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class TemplateGetTemplateByIDDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class TemplateGetTemplateByIDEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""
    recipient_removed: NotRequired[bool]
    r"""Whether to send an email to the recipient who was removed from a pending document."""
    recipient_signed: NotRequired[bool]
    r"""Whether to send an email to the document owner when a recipient has signed the document."""
    document_pending: NotRequired[bool]
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""
    document_completed: NotRequired[bool]
    r"""Whether to send an email to all recipients when the document is complete."""
    document_deleted: NotRequired[bool]
    r"""Whether to send an email to all recipients if a pending document has been deleted."""
    owner_document_completed: NotRequired[bool]
    r"""Whether to send an email to the document owner when the document is complete."""


class TemplateGetTemplateByIDEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True
    r"""Whether to send an email to the recipient who was removed from a pending document."""

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True
    r"""Whether to send an email to the document owner when a recipient has signed the document."""

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True
    r"""Whether to send an email to all recipients when the document is complete."""

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True
    r"""Whether to send an email to all recipients if a pending document has been deleted."""

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True
    r"""Whether to send an email to the document owner when the document is complete."""


class TemplateGetTemplateByIDTemplateMetaTypedDict(TypedDict):
    id: str
    subject: Nullable[str]
    message: Nullable[str]
    timezone: Nullable[str]
    date_format: Nullable[str]
    signing_order: Nullable[TemplateGetTemplateByIDSigningOrder]
    typed_signature_enabled: bool
    upload_signature_enabled: bool
    draw_signature_enabled: bool
    allow_dictate_next_signer: bool
    distribution_method: TemplateGetTemplateByIDDistributionMethod
    template_id: float
    redirect_url: Nullable[str]
    language: str
    email_settings: Nullable[TemplateGetTemplateByIDEmailSettingsTypedDict]


class TemplateGetTemplateByIDTemplateMeta(BaseModel):
    id: str

    subject: Nullable[str]

    message: Nullable[str]

    timezone: Nullable[str]

    date_format: Annotated[Nullable[str], pydantic.Field(alias="dateFormat")]

    signing_order: Annotated[
        Nullable[TemplateGetTemplateByIDSigningOrder],
        pydantic.Field(alias="signingOrder"),
    ]

    typed_signature_enabled: Annotated[
        bool, pydantic.Field(alias="typedSignatureEnabled")
    ]

    upload_signature_enabled: Annotated[
        bool, pydantic.Field(alias="uploadSignatureEnabled")
    ]

    draw_signature_enabled: Annotated[
        bool, pydantic.Field(alias="drawSignatureEnabled")
    ]

    allow_dictate_next_signer: Annotated[
        bool, pydantic.Field(alias="allowDictateNextSigner")
    ]

    distribution_method: Annotated[
        TemplateGetTemplateByIDDistributionMethod,
        pydantic.Field(alias="distributionMethod"),
    ]

    template_id: Annotated[float, pydantic.Field(alias="templateId")]

    redirect_url: Annotated[Nullable[str], pydantic.Field(alias="redirectUrl")]

    language: str

    email_settings: Annotated[
        Nullable[TemplateGetTemplateByIDEmailSettings],
        pydantic.Field(alias="emailSettings"),
    ]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "subject",
            "message",
            "timezone",
            "dateFormat",
            "signingOrder",
            "redirectUrl",
            "emailSettings",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateGetTemplateByIDDirectLinkTypedDict(TypedDict):
    id: str
    template_id: float
    token: str
    created_at: str
    enabled: bool
    direct_template_recipient_id: float


class TemplateGetTemplateByIDDirectLink(BaseModel):
    id: str

    template_id: Annotated[float, pydantic.Field(alias="templateId")]

    token: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    enabled: bool

    direct_template_recipient_id: Annotated[
        float, pydantic.Field(alias="directTemplateRecipientId")
    ]


class TemplateGetTemplateByIDUserTypedDict(TypedDict):
    id: float
    name: Nullable[str]
    email: str


class TemplateGetTemplateByIDUser(BaseModel):
    id: float

    name: Nullable[str]

    email: str

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["name"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateGetTemplateByIDRole(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"
    ASSISTANT = "ASSISTANT"


class TemplateGetTemplateByIDReadStatus(str, Enum):
    NOT_OPENED = "NOT_OPENED"
    OPENED = "OPENED"


class TemplateGetTemplateByIDSigningStatus(str, Enum):
    NOT_SIGNED = "NOT_SIGNED"
    SIGNED = "SIGNED"
    REJECTED = "REJECTED"


class TemplateGetTemplateByIDSendStatus(str, Enum):
    NOT_SENT = "NOT_SENT"
    SENT = "SENT"


class TemplateGetTemplateByIDAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class TemplateGetTemplateByIDActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class TemplateGetTemplateByIDRecipientAuthOptionsTypedDict(TypedDict):
    access_auth: Nullable[TemplateGetTemplateByIDAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    action_auth: Nullable[TemplateGetTemplateByIDActionAuth]
    r"""The type of authentication required for the recipient to sign the document."""


class TemplateGetTemplateByIDRecipientAuthOptions(BaseModel):
    access_auth: Annotated[
        Nullable[TemplateGetTemplateByIDAccessAuth], pydantic.Field(alias="accessAuth")
    ]
    r"""The type of authentication required for the recipient to access the document."""

    action_auth: Annotated[
        Nullable[TemplateGetTemplateByIDActionAuth], pydantic.Field(alias="actionAuth")
    ]
    r"""The type of authentication required for the recipient to sign the document."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["accessAuth", "actionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateGetTemplateByIDRecipientTypedDict(TypedDict):
    role: TemplateGetTemplateByIDRole
    read_status: TemplateGetTemplateByIDReadStatus
    signing_status: TemplateGetTemplateByIDSigningStatus
    send_status: TemplateGetTemplateByIDSendStatus
    id: float
    document_id: Nullable[float]
    template_id: Nullable[float]
    email: str
    name: str
    token: str
    document_deleted_at: Nullable[str]
    expired: Nullable[str]
    signed_at: Nullable[str]
    auth_options: Nullable[TemplateGetTemplateByIDRecipientAuthOptionsTypedDict]
    signing_order: Nullable[float]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""
    rejection_reason: Nullable[str]


class TemplateGetTemplateByIDRecipient(BaseModel):
    role: TemplateGetTemplateByIDRole

    read_status: Annotated[
        TemplateGetTemplateByIDReadStatus, pydantic.Field(alias="readStatus")
    ]

    signing_status: Annotated[
        TemplateGetTemplateByIDSigningStatus, pydantic.Field(alias="signingStatus")
    ]

    send_status: Annotated[
        TemplateGetTemplateByIDSendStatus, pydantic.Field(alias="sendStatus")
    ]

    id: float

    document_id: Annotated[Nullable[float], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    email: str

    name: str

    token: str

    document_deleted_at: Annotated[
        Nullable[str], pydantic.Field(alias="documentDeletedAt")
    ]

    expired: Nullable[str]

    signed_at: Annotated[Nullable[str], pydantic.Field(alias="signedAt")]

    auth_options: Annotated[
        Nullable[TemplateGetTemplateByIDRecipientAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    signing_order: Annotated[Nullable[float], pydantic.Field(alias="signingOrder")]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""

    rejection_reason: Annotated[Nullable[str], pydantic.Field(alias="rejectionReason")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "documentId",
            "templateId",
            "documentDeletedAt",
            "expired",
            "signedAt",
            "authOptions",
            "signingOrder",
            "rejectionReason",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateGetTemplateByIDFieldType(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class TemplateGetTemplateByIDTypeDropdown(str, Enum):
    DROPDOWN = "dropdown"


class TemplateGetTemplateByIDValue3TypedDict(TypedDict):
    value: str


class TemplateGetTemplateByIDValue3(BaseModel):
    value: str


class TemplateGetTemplateByIDFieldMetaDropdownTypedDict(TypedDict):
    type: TemplateGetTemplateByIDTypeDropdown
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[TemplateGetTemplateByIDValue3TypedDict]]
    default_value: NotRequired[str]


class TemplateGetTemplateByIDFieldMetaDropdown(BaseModel):
    type: TemplateGetTemplateByIDTypeDropdown

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[TemplateGetTemplateByIDValue3]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class TemplateGetTemplateByIDTypeCheckbox(str, Enum):
    CHECKBOX = "checkbox"


class TemplateGetTemplateByIDValue2TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class TemplateGetTemplateByIDValue2(BaseModel):
    id: float

    checked: bool

    value: str


class TemplateGetTemplateByIDFieldMetaCheckboxTypedDict(TypedDict):
    type: TemplateGetTemplateByIDTypeCheckbox
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[TemplateGetTemplateByIDValue2TypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]


class TemplateGetTemplateByIDFieldMetaCheckbox(BaseModel):
    type: TemplateGetTemplateByIDTypeCheckbox

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[TemplateGetTemplateByIDValue2]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None


class TemplateGetTemplateByIDTypeRadio(str, Enum):
    RADIO = "radio"


class TemplateGetTemplateByIDValue1TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class TemplateGetTemplateByIDValue1(BaseModel):
    id: float

    checked: bool

    value: str


class TemplateGetTemplateByIDFieldMetaRadioTypedDict(TypedDict):
    type: TemplateGetTemplateByIDTypeRadio
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[TemplateGetTemplateByIDValue1TypedDict]]


class TemplateGetTemplateByIDFieldMetaRadio(BaseModel):
    type: TemplateGetTemplateByIDTypeRadio

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[TemplateGetTemplateByIDValue1]] = None


class TemplateGetTemplateByIDTypeNumber(str, Enum):
    NUMBER = "number"


class TemplateGetTemplateByIDTextAlign6(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateGetTemplateByIDFieldMetaNumberTypedDict(TypedDict):
    type: TemplateGetTemplateByIDTypeNumber
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    number_format: NotRequired[str]
    value: NotRequired[str]
    min_value: NotRequired[float]
    max_value: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateGetTemplateByIDTextAlign6]


class TemplateGetTemplateByIDFieldMetaNumber(BaseModel):
    type: TemplateGetTemplateByIDTypeNumber

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    number_format: Annotated[Optional[str], pydantic.Field(alias="numberFormat")] = None

    value: Optional[str] = None

    min_value: Annotated[Optional[float], pydantic.Field(alias="minValue")] = None

    max_value: Annotated[Optional[float], pydantic.Field(alias="maxValue")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateGetTemplateByIDTextAlign6], pydantic.Field(alias="textAlign")
    ] = None


class TemplateGetTemplateByIDTypeText(str, Enum):
    TEXT = "text"


class TemplateGetTemplateByIDTextAlign5(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateGetTemplateByIDFieldMetaTextTypedDict(TypedDict):
    type: TemplateGetTemplateByIDTypeText
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateGetTemplateByIDTextAlign5]


class TemplateGetTemplateByIDFieldMetaText(BaseModel):
    type: TemplateGetTemplateByIDTypeText

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateGetTemplateByIDTextAlign5], pydantic.Field(alias="textAlign")
    ] = None


class TemplateGetTemplateByIDTypeDate(str, Enum):
    DATE = "date"


class TemplateGetTemplateByIDTextAlign4(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateGetTemplateByIDFieldMetaDateTypedDict(TypedDict):
    type: TemplateGetTemplateByIDTypeDate
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateGetTemplateByIDTextAlign4]


class TemplateGetTemplateByIDFieldMetaDate(BaseModel):
    type: TemplateGetTemplateByIDTypeDate

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateGetTemplateByIDTextAlign4], pydantic.Field(alias="textAlign")
    ] = None


class TemplateGetTemplateByIDTypeEmail(str, Enum):
    EMAIL = "email"


class TemplateGetTemplateByIDTextAlign3(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateGetTemplateByIDFieldMetaEmailTypedDict(TypedDict):
    type: TemplateGetTemplateByIDTypeEmail
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateGetTemplateByIDTextAlign3]


class TemplateGetTemplateByIDFieldMetaEmail(BaseModel):
    type: TemplateGetTemplateByIDTypeEmail

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateGetTemplateByIDTextAlign3], pydantic.Field(alias="textAlign")
    ] = None


class TemplateGetTemplateByIDTypeName(str, Enum):
    NAME = "name"


class TemplateGetTemplateByIDTextAlign2(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateGetTemplateByIDFieldMetaNameTypedDict(TypedDict):
    type: TemplateGetTemplateByIDTypeName
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateGetTemplateByIDTextAlign2]


class TemplateGetTemplateByIDFieldMetaName(BaseModel):
    type: TemplateGetTemplateByIDTypeName

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateGetTemplateByIDTextAlign2], pydantic.Field(alias="textAlign")
    ] = None


class TemplateGetTemplateByIDTypeInitials(str, Enum):
    INITIALS = "initials"


class TemplateGetTemplateByIDTextAlign1(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateGetTemplateByIDFieldMetaInitialsTypedDict(TypedDict):
    type: TemplateGetTemplateByIDTypeInitials
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateGetTemplateByIDTextAlign1]


class TemplateGetTemplateByIDFieldMetaInitials(BaseModel):
    type: TemplateGetTemplateByIDTypeInitials

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateGetTemplateByIDTextAlign1], pydantic.Field(alias="textAlign")
    ] = None


TemplateGetTemplateByIDFieldMetaUnionTypedDict = TypeAliasType(
    "TemplateGetTemplateByIDFieldMetaUnionTypedDict",
    Union[
        TemplateGetTemplateByIDFieldMetaRadioTypedDict,
        TemplateGetTemplateByIDFieldMetaInitialsTypedDict,
        TemplateGetTemplateByIDFieldMetaNameTypedDict,
        TemplateGetTemplateByIDFieldMetaEmailTypedDict,
        TemplateGetTemplateByIDFieldMetaDateTypedDict,
        TemplateGetTemplateByIDFieldMetaDropdownTypedDict,
        TemplateGetTemplateByIDFieldMetaCheckboxTypedDict,
        TemplateGetTemplateByIDFieldMetaTextTypedDict,
        TemplateGetTemplateByIDFieldMetaNumberTypedDict,
    ],
)


TemplateGetTemplateByIDFieldMetaUnion = TypeAliasType(
    "TemplateGetTemplateByIDFieldMetaUnion",
    Union[
        TemplateGetTemplateByIDFieldMetaRadio,
        TemplateGetTemplateByIDFieldMetaInitials,
        TemplateGetTemplateByIDFieldMetaName,
        TemplateGetTemplateByIDFieldMetaEmail,
        TemplateGetTemplateByIDFieldMetaDate,
        TemplateGetTemplateByIDFieldMetaDropdown,
        TemplateGetTemplateByIDFieldMetaCheckbox,
        TemplateGetTemplateByIDFieldMetaText,
        TemplateGetTemplateByIDFieldMetaNumber,
    ],
)


class TemplateGetTemplateByIDFieldTypedDict(TypedDict):
    type: TemplateGetTemplateByIDFieldType
    id: float
    secondary_id: str
    document_id: Nullable[float]
    template_id: Nullable[float]
    recipient_id: float
    page: float
    r"""The page number of the field on the document. Starts from 1."""
    custom_text: str
    inserted: bool
    field_meta: Nullable[TemplateGetTemplateByIDFieldMetaUnionTypedDict]
    position_x: NotRequired[Any]
    position_y: NotRequired[Any]
    width: NotRequired[Any]
    height: NotRequired[Any]


class TemplateGetTemplateByIDField(BaseModel):
    type: TemplateGetTemplateByIDFieldType

    id: float

    secondary_id: Annotated[str, pydantic.Field(alias="secondaryId")]

    document_id: Annotated[Nullable[float], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    page: float
    r"""The page number of the field on the document. Starts from 1."""

    custom_text: Annotated[str, pydantic.Field(alias="customText")]

    inserted: bool

    field_meta: Annotated[
        Nullable[TemplateGetTemplateByIDFieldMetaUnion],
        pydantic.Field(alias="fieldMeta"),
    ]

    position_x: Annotated[Optional[Any], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[Any], pydantic.Field(alias="positionY")] = None

    width: Optional[Any] = None

    height: Optional[Any] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["positionX", "positionY", "width", "height"]
        nullable_fields = ["documentId", "templateId", "fieldMeta"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateGetTemplateByIDResponseTypedDict(TypedDict):
    r"""Successful response"""

    type: TemplateGetTemplateByIDType
    visibility: TemplateGetTemplateByIDVisibility
    id: float
    external_id: Nullable[str]
    title: str
    user_id: float
    team_id: Nullable[float]
    auth_options: Nullable[TemplateGetTemplateByIDAuthOptionsTypedDict]
    template_document_data_id: str
    created_at: str
    updated_at: str
    public_title: str
    public_description: str
    template_document_data: TemplateDocumentDataTypedDict
    template_meta: Nullable[TemplateGetTemplateByIDTemplateMetaTypedDict]
    direct_link: Nullable[TemplateGetTemplateByIDDirectLinkTypedDict]
    user: TemplateGetTemplateByIDUserTypedDict
    recipients: List[TemplateGetTemplateByIDRecipientTypedDict]
    fields: List[TemplateGetTemplateByIDFieldTypedDict]


class TemplateGetTemplateByIDResponse(BaseModel):
    r"""Successful response"""

    type: TemplateGetTemplateByIDType

    visibility: TemplateGetTemplateByIDVisibility

    id: float

    external_id: Annotated[Nullable[str], pydantic.Field(alias="externalId")]

    title: str

    user_id: Annotated[float, pydantic.Field(alias="userId")]

    team_id: Annotated[Nullable[float], pydantic.Field(alias="teamId")]

    auth_options: Annotated[
        Nullable[TemplateGetTemplateByIDAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    template_document_data_id: Annotated[
        str, pydantic.Field(alias="templateDocumentDataId")
    ]

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]

    public_title: Annotated[str, pydantic.Field(alias="publicTitle")]

    public_description: Annotated[str, pydantic.Field(alias="publicDescription")]

    template_document_data: Annotated[
        TemplateDocumentData, pydantic.Field(alias="templateDocumentData")
    ]

    template_meta: Annotated[
        Nullable[TemplateGetTemplateByIDTemplateMeta],
        pydantic.Field(alias="templateMeta"),
    ]

    direct_link: Annotated[
        Nullable[TemplateGetTemplateByIDDirectLink], pydantic.Field(alias="directLink")
    ]

    user: TemplateGetTemplateByIDUser

    recipients: List[TemplateGetTemplateByIDRecipient]

    fields: List[TemplateGetTemplateByIDField]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "externalId",
            "teamId",
            "authOptions",
            "templateMeta",
            "directLink",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
