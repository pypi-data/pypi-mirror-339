"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from documenso_sdk import utils
from documenso_sdk.types import BaseModel, Nullable, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class TemplateCreateDocumentFromTemplateRecipientRequestBodyTypedDict(TypedDict):
    id: float
    r"""The ID of the recipient in the template."""
    email: str
    name: NotRequired[str]


class TemplateCreateDocumentFromTemplateRecipientRequestBody(BaseModel):
    id: float
    r"""The ID of the recipient in the template."""

    email: str

    name: Optional[str] = None


class PrefillFieldTypeDropdown(str, Enum):
    DROPDOWN = "dropdown"


class PrefillFieldDropdownTypedDict(TypedDict):
    type: PrefillFieldTypeDropdown
    id: float
    label: NotRequired[str]
    value: NotRequired[str]


class PrefillFieldDropdown(BaseModel):
    type: PrefillFieldTypeDropdown

    id: float

    label: Optional[str] = None

    value: Optional[str] = None


class PrefillFieldTypeCheckbox(str, Enum):
    CHECKBOX = "checkbox"


class PrefillFieldCheckboxTypedDict(TypedDict):
    type: PrefillFieldTypeCheckbox
    id: float
    label: NotRequired[str]
    value: NotRequired[List[str]]


class PrefillFieldCheckbox(BaseModel):
    type: PrefillFieldTypeCheckbox

    id: float

    label: Optional[str] = None

    value: Optional[List[str]] = None


class PrefillFieldTypeRadio(str, Enum):
    RADIO = "radio"


class PrefillFieldRadioTypedDict(TypedDict):
    type: PrefillFieldTypeRadio
    id: float
    label: NotRequired[str]
    value: NotRequired[str]


class PrefillFieldRadio(BaseModel):
    type: PrefillFieldTypeRadio

    id: float

    label: Optional[str] = None

    value: Optional[str] = None


class PrefillFieldTypeNumber(str, Enum):
    NUMBER = "number"


class PrefillFieldNumberTypedDict(TypedDict):
    type: PrefillFieldTypeNumber
    id: float
    label: NotRequired[str]
    placeholder: NotRequired[str]
    value: NotRequired[str]


class PrefillFieldNumber(BaseModel):
    type: PrefillFieldTypeNumber

    id: float

    label: Optional[str] = None

    placeholder: Optional[str] = None

    value: Optional[str] = None


class PrefillFieldTypeText(str, Enum):
    TEXT = "text"


class PrefillFieldTextTypedDict(TypedDict):
    type: PrefillFieldTypeText
    id: float
    label: NotRequired[str]
    placeholder: NotRequired[str]
    value: NotRequired[str]


class PrefillFieldText(BaseModel):
    type: PrefillFieldTypeText

    id: float

    label: Optional[str] = None

    placeholder: Optional[str] = None

    value: Optional[str] = None


PrefillFieldTypedDict = TypeAliasType(
    "PrefillFieldTypedDict",
    Union[
        PrefillFieldRadioTypedDict,
        PrefillFieldCheckboxTypedDict,
        PrefillFieldDropdownTypedDict,
        PrefillFieldTextTypedDict,
        PrefillFieldNumberTypedDict,
    ],
)


PrefillField = TypeAliasType(
    "PrefillField",
    Union[
        PrefillFieldRadio,
        PrefillFieldCheckbox,
        PrefillFieldDropdown,
        PrefillFieldText,
        PrefillFieldNumber,
    ],
)


class TemplateCreateDocumentFromTemplateRequestTypedDict(TypedDict):
    template_id: float
    recipients: List[TemplateCreateDocumentFromTemplateRecipientRequestBodyTypedDict]
    r"""The information of the recipients to create the document with."""
    distribute_document: NotRequired[bool]
    r"""Whether to create the document as pending and distribute it to recipients."""
    custom_document_data_id: NotRequired[str]
    r"""The data ID of an alternative PDF to use when creating the document. If not provided, the PDF attached to the template will be used."""
    prefill_fields: NotRequired[List[PrefillFieldTypedDict]]
    r"""The fields to prefill on the document before sending it out. Useful when you want to create a document from an existing template and pre-fill the fields with specific values."""


class TemplateCreateDocumentFromTemplateRequest(BaseModel):
    template_id: Annotated[float, pydantic.Field(alias="templateId")]

    recipients: List[TemplateCreateDocumentFromTemplateRecipientRequestBody]
    r"""The information of the recipients to create the document with."""

    distribute_document: Annotated[
        Optional[bool], pydantic.Field(alias="distributeDocument")
    ] = None
    r"""Whether to create the document as pending and distribute it to recipients."""

    custom_document_data_id: Annotated[
        Optional[str], pydantic.Field(alias="customDocumentDataId")
    ] = None
    r"""The data ID of an alternative PDF to use when creating the document. If not provided, the PDF attached to the template will be used."""

    prefill_fields: Annotated[
        Optional[List[PrefillField]], pydantic.Field(alias="prefillFields")
    ] = None
    r"""The fields to prefill on the document before sending it out. Useful when you want to create a document from an existing template and pre-fill the fields with specific values."""


class TemplateCreateDocumentFromTemplateInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class TemplateCreateDocumentFromTemplateInternalServerErrorIssue(BaseModel):
    message: str


class TemplateCreateDocumentFromTemplateInternalServerErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[
        List[TemplateCreateDocumentFromTemplateInternalServerErrorIssue]
    ] = None


class TemplateCreateDocumentFromTemplateInternalServerError(Exception):
    r"""Internal server error"""

    data: TemplateCreateDocumentFromTemplateInternalServerErrorData

    def __init__(self, data: TemplateCreateDocumentFromTemplateInternalServerErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, TemplateCreateDocumentFromTemplateInternalServerErrorData
        )


class TemplateCreateDocumentFromTemplateBadRequestIssueTypedDict(TypedDict):
    message: str


class TemplateCreateDocumentFromTemplateBadRequestIssue(BaseModel):
    message: str


class TemplateCreateDocumentFromTemplateBadRequestErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[TemplateCreateDocumentFromTemplateBadRequestIssue]] = None


class TemplateCreateDocumentFromTemplateBadRequestError(Exception):
    r"""Invalid input data"""

    data: TemplateCreateDocumentFromTemplateBadRequestErrorData

    def __init__(self, data: TemplateCreateDocumentFromTemplateBadRequestErrorData):
        self.data = data

    def __str__(self) -> str:
        return utils.marshal_json(
            self.data, TemplateCreateDocumentFromTemplateBadRequestErrorData
        )


class TemplateCreateDocumentFromTemplateVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class TemplateCreateDocumentFromTemplateStatus(str, Enum):
    DRAFT = "DRAFT"
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    REJECTED = "REJECTED"


class TemplateCreateDocumentFromTemplateSource(str, Enum):
    DOCUMENT = "DOCUMENT"
    TEMPLATE = "TEMPLATE"
    TEMPLATE_DIRECT_LINK = "TEMPLATE_DIRECT_LINK"


class TemplateCreateDocumentFromTemplateGlobalAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class TemplateCreateDocumentFromTemplateGlobalActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class TemplateCreateDocumentFromTemplateAuthOptionsTypedDict(TypedDict):
    global_access_auth: Nullable[TemplateCreateDocumentFromTemplateGlobalAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    global_action_auth: Nullable[TemplateCreateDocumentFromTemplateGlobalActionAuth]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""


class TemplateCreateDocumentFromTemplateAuthOptions(BaseModel):
    global_access_auth: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateGlobalAccessAuth],
        pydantic.Field(alias="globalAccessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    global_action_auth: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateGlobalActionAuth],
        pydantic.Field(alias="globalActionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["globalAccessAuth", "globalActionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


TemplateCreateDocumentFromTemplateFormValuesTypedDict = TypeAliasType(
    "TemplateCreateDocumentFromTemplateFormValuesTypedDict", Union[str, bool, float]
)


TemplateCreateDocumentFromTemplateFormValues = TypeAliasType(
    "TemplateCreateDocumentFromTemplateFormValues", Union[str, bool, float]
)


class TemplateCreateDocumentFromTemplateDocumentDataType(str, Enum):
    S3_PATH = "S3_PATH"
    BYTES = "BYTES"
    BYTES_64 = "BYTES_64"


class TemplateCreateDocumentFromTemplateDocumentDataTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateDocumentDataType
    id: str
    data: str
    initial_data: str


class TemplateCreateDocumentFromTemplateDocumentData(BaseModel):
    type: TemplateCreateDocumentFromTemplateDocumentDataType

    id: str

    data: str

    initial_data: Annotated[str, pydantic.Field(alias="initialData")]


class TemplateCreateDocumentFromTemplateSigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class TemplateCreateDocumentFromTemplateDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class TemplateCreateDocumentFromTemplateEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""
    recipient_removed: NotRequired[bool]
    r"""Whether to send an email to the recipient who was removed from a pending document."""
    recipient_signed: NotRequired[bool]
    r"""Whether to send an email to the document owner when a recipient has signed the document."""
    document_pending: NotRequired[bool]
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""
    document_completed: NotRequired[bool]
    r"""Whether to send an email to all recipients when the document is complete."""
    document_deleted: NotRequired[bool]
    r"""Whether to send an email to all recipients if a pending document has been deleted."""
    owner_document_completed: NotRequired[bool]
    r"""Whether to send an email to the document owner when the document is complete."""


class TemplateCreateDocumentFromTemplateEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True
    r"""Whether to send an email to all recipients that the document is ready for them to sign."""

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True
    r"""Whether to send an email to the recipient who was removed from a pending document."""

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True
    r"""Whether to send an email to the document owner when a recipient has signed the document."""

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True
    r"""Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed."""

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True
    r"""Whether to send an email to all recipients when the document is complete."""

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True
    r"""Whether to send an email to all recipients if a pending document has been deleted."""

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True
    r"""Whether to send an email to the document owner when the document is complete."""


class TemplateCreateDocumentFromTemplateDocumentMetaTypedDict(TypedDict):
    signing_order: TemplateCreateDocumentFromTemplateSigningOrder
    distribution_method: TemplateCreateDocumentFromTemplateDistributionMethod
    id: str
    subject: Nullable[str]
    message: Nullable[str]
    timezone: Nullable[str]
    password: Nullable[str]
    date_format: Nullable[str]
    document_id: float
    redirect_url: Nullable[str]
    typed_signature_enabled: bool
    upload_signature_enabled: bool
    draw_signature_enabled: bool
    allow_dictate_next_signer: bool
    language: str
    email_settings: Nullable[TemplateCreateDocumentFromTemplateEmailSettingsTypedDict]


class TemplateCreateDocumentFromTemplateDocumentMeta(BaseModel):
    signing_order: Annotated[
        TemplateCreateDocumentFromTemplateSigningOrder,
        pydantic.Field(alias="signingOrder"),
    ]

    distribution_method: Annotated[
        TemplateCreateDocumentFromTemplateDistributionMethod,
        pydantic.Field(alias="distributionMethod"),
    ]

    id: str

    subject: Nullable[str]

    message: Nullable[str]

    timezone: Nullable[str]

    password: Nullable[str]

    date_format: Annotated[Nullable[str], pydantic.Field(alias="dateFormat")]

    document_id: Annotated[float, pydantic.Field(alias="documentId")]

    redirect_url: Annotated[Nullable[str], pydantic.Field(alias="redirectUrl")]

    typed_signature_enabled: Annotated[
        bool, pydantic.Field(alias="typedSignatureEnabled")
    ]

    upload_signature_enabled: Annotated[
        bool, pydantic.Field(alias="uploadSignatureEnabled")
    ]

    draw_signature_enabled: Annotated[
        bool, pydantic.Field(alias="drawSignatureEnabled")
    ]

    allow_dictate_next_signer: Annotated[
        bool, pydantic.Field(alias="allowDictateNextSigner")
    ]

    language: str

    email_settings: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateEmailSettings],
        pydantic.Field(alias="emailSettings"),
    ]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "subject",
            "message",
            "timezone",
            "password",
            "dateFormat",
            "redirectUrl",
            "emailSettings",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateCreateDocumentFromTemplateRole(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"
    ASSISTANT = "ASSISTANT"


class TemplateCreateDocumentFromTemplateReadStatus(str, Enum):
    NOT_OPENED = "NOT_OPENED"
    OPENED = "OPENED"


class TemplateCreateDocumentFromTemplateSigningStatus(str, Enum):
    NOT_SIGNED = "NOT_SIGNED"
    SIGNED = "SIGNED"
    REJECTED = "REJECTED"


class TemplateCreateDocumentFromTemplateSendStatus(str, Enum):
    NOT_SENT = "NOT_SENT"
    SENT = "SENT"


class TemplateCreateDocumentFromTemplateAccessAuth(str, Enum):
    r"""The type of authentication required for the recipient to access the document."""

    ACCOUNT = "ACCOUNT"


class TemplateCreateDocumentFromTemplateActionAuth(str, Enum):
    r"""The type of authentication required for the recipient to sign the document."""

    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class TemplateCreateDocumentFromTemplateRecipientAuthOptionsTypedDict(TypedDict):
    access_auth: Nullable[TemplateCreateDocumentFromTemplateAccessAuth]
    r"""The type of authentication required for the recipient to access the document."""
    action_auth: Nullable[TemplateCreateDocumentFromTemplateActionAuth]
    r"""The type of authentication required for the recipient to sign the document."""


class TemplateCreateDocumentFromTemplateRecipientAuthOptions(BaseModel):
    access_auth: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateAccessAuth],
        pydantic.Field(alias="accessAuth"),
    ]
    r"""The type of authentication required for the recipient to access the document."""

    action_auth: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateActionAuth],
        pydantic.Field(alias="actionAuth"),
    ]
    r"""The type of authentication required for the recipient to sign the document."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["accessAuth", "actionAuth"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateCreateDocumentFromTemplateRecipientResponseTypedDict(TypedDict):
    role: TemplateCreateDocumentFromTemplateRole
    read_status: TemplateCreateDocumentFromTemplateReadStatus
    signing_status: TemplateCreateDocumentFromTemplateSigningStatus
    send_status: TemplateCreateDocumentFromTemplateSendStatus
    id: float
    document_id: Nullable[float]
    template_id: Nullable[float]
    email: str
    name: str
    token: str
    document_deleted_at: Nullable[str]
    expired: Nullable[str]
    signed_at: Nullable[str]
    auth_options: Nullable[
        TemplateCreateDocumentFromTemplateRecipientAuthOptionsTypedDict
    ]
    signing_order: Nullable[float]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""
    rejection_reason: Nullable[str]


class TemplateCreateDocumentFromTemplateRecipientResponse(BaseModel):
    role: TemplateCreateDocumentFromTemplateRole

    read_status: Annotated[
        TemplateCreateDocumentFromTemplateReadStatus, pydantic.Field(alias="readStatus")
    ]

    signing_status: Annotated[
        TemplateCreateDocumentFromTemplateSigningStatus,
        pydantic.Field(alias="signingStatus"),
    ]

    send_status: Annotated[
        TemplateCreateDocumentFromTemplateSendStatus, pydantic.Field(alias="sendStatus")
    ]

    id: float

    document_id: Annotated[Nullable[float], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    email: str

    name: str

    token: str

    document_deleted_at: Annotated[
        Nullable[str], pydantic.Field(alias="documentDeletedAt")
    ]

    expired: Nullable[str]

    signed_at: Annotated[Nullable[str], pydantic.Field(alias="signedAt")]

    auth_options: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateRecipientAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    signing_order: Annotated[Nullable[float], pydantic.Field(alias="signingOrder")]
    r"""The order in which the recipient should sign the document. Only works if the document is set to sequential signing."""

    rejection_reason: Annotated[Nullable[str], pydantic.Field(alias="rejectionReason")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "documentId",
            "templateId",
            "documentDeletedAt",
            "expired",
            "signedAt",
            "authOptions",
            "signingOrder",
            "rejectionReason",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateCreateDocumentFromTemplateFieldType(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class TemplateCreateDocumentFromTemplateFieldMetaTypeDropdown(str, Enum):
    DROPDOWN = "dropdown"


class TemplateCreateDocumentFromTemplateValue3TypedDict(TypedDict):
    value: str


class TemplateCreateDocumentFromTemplateValue3(BaseModel):
    value: str


class TemplateCreateDocumentFromTemplateFieldMetaDropdownTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeDropdown
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[TemplateCreateDocumentFromTemplateValue3TypedDict]]
    default_value: NotRequired[str]


class TemplateCreateDocumentFromTemplateFieldMetaDropdown(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeDropdown

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[TemplateCreateDocumentFromTemplateValue3]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class TemplateCreateDocumentFromTemplateFieldMetaTypeCheckbox(str, Enum):
    CHECKBOX = "checkbox"


class TemplateCreateDocumentFromTemplateValue2TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class TemplateCreateDocumentFromTemplateValue2(BaseModel):
    id: float

    checked: bool

    value: str


class TemplateCreateDocumentFromTemplateFieldMetaCheckboxTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeCheckbox
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[TemplateCreateDocumentFromTemplateValue2TypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]


class TemplateCreateDocumentFromTemplateFieldMetaCheckbox(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeCheckbox

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[TemplateCreateDocumentFromTemplateValue2]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None


class TemplateCreateDocumentFromTemplateFieldMetaTypeRadio(str, Enum):
    RADIO = "radio"


class TemplateCreateDocumentFromTemplateValue1TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class TemplateCreateDocumentFromTemplateValue1(BaseModel):
    id: float

    checked: bool

    value: str


class TemplateCreateDocumentFromTemplateFieldMetaRadioTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeRadio
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    values: NotRequired[List[TemplateCreateDocumentFromTemplateValue1TypedDict]]


class TemplateCreateDocumentFromTemplateFieldMetaRadio(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeRadio

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    values: Optional[List[TemplateCreateDocumentFromTemplateValue1]] = None


class TemplateCreateDocumentFromTemplateFieldMetaTypeNumber(str, Enum):
    NUMBER = "number"


class TemplateCreateDocumentFromTemplateTextAlign6(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateCreateDocumentFromTemplateFieldMetaNumberTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeNumber
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    number_format: NotRequired[str]
    value: NotRequired[str]
    min_value: NotRequired[float]
    max_value: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateCreateDocumentFromTemplateTextAlign6]


class TemplateCreateDocumentFromTemplateFieldMetaNumber(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeNumber

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    number_format: Annotated[Optional[str], pydantic.Field(alias="numberFormat")] = None

    value: Optional[str] = None

    min_value: Annotated[Optional[float], pydantic.Field(alias="minValue")] = None

    max_value: Annotated[Optional[float], pydantic.Field(alias="maxValue")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateCreateDocumentFromTemplateTextAlign6],
        pydantic.Field(alias="textAlign"),
    ] = None


class TemplateCreateDocumentFromTemplateFieldMetaTypeText(str, Enum):
    TEXT = "text"


class TemplateCreateDocumentFromTemplateTextAlign5(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateCreateDocumentFromTemplateFieldMetaTextTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeText
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateCreateDocumentFromTemplateTextAlign5]


class TemplateCreateDocumentFromTemplateFieldMetaText(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldMetaTypeText

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateCreateDocumentFromTemplateTextAlign5],
        pydantic.Field(alias="textAlign"),
    ] = None


class TemplateCreateDocumentFromTemplateTypeDate(str, Enum):
    DATE = "date"


class TemplateCreateDocumentFromTemplateTextAlign4(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateCreateDocumentFromTemplateFieldMetaDateTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateTypeDate
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateCreateDocumentFromTemplateTextAlign4]


class TemplateCreateDocumentFromTemplateFieldMetaDate(BaseModel):
    type: TemplateCreateDocumentFromTemplateTypeDate

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateCreateDocumentFromTemplateTextAlign4],
        pydantic.Field(alias="textAlign"),
    ] = None


class TemplateCreateDocumentFromTemplateTypeEmail(str, Enum):
    EMAIL = "email"


class TemplateCreateDocumentFromTemplateTextAlign3(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateCreateDocumentFromTemplateFieldMetaEmailTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateTypeEmail
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateCreateDocumentFromTemplateTextAlign3]


class TemplateCreateDocumentFromTemplateFieldMetaEmail(BaseModel):
    type: TemplateCreateDocumentFromTemplateTypeEmail

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateCreateDocumentFromTemplateTextAlign3],
        pydantic.Field(alias="textAlign"),
    ] = None


class TemplateCreateDocumentFromTemplateTypeName(str, Enum):
    NAME = "name"


class TemplateCreateDocumentFromTemplateTextAlign2(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateCreateDocumentFromTemplateFieldMetaNameTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateTypeName
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateCreateDocumentFromTemplateTextAlign2]


class TemplateCreateDocumentFromTemplateFieldMetaName(BaseModel):
    type: TemplateCreateDocumentFromTemplateTypeName

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateCreateDocumentFromTemplateTextAlign2],
        pydantic.Field(alias="textAlign"),
    ] = None


class TemplateCreateDocumentFromTemplateTypeInitials(str, Enum):
    INITIALS = "initials"


class TemplateCreateDocumentFromTemplateTextAlign1(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class TemplateCreateDocumentFromTemplateFieldMetaInitialsTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateTypeInitials
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[TemplateCreateDocumentFromTemplateTextAlign1]


class TemplateCreateDocumentFromTemplateFieldMetaInitials(BaseModel):
    type: TemplateCreateDocumentFromTemplateTypeInitials

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = None

    text_align: Annotated[
        Optional[TemplateCreateDocumentFromTemplateTextAlign1],
        pydantic.Field(alias="textAlign"),
    ] = None


TemplateCreateDocumentFromTemplateFieldMetaUnionTypedDict = TypeAliasType(
    "TemplateCreateDocumentFromTemplateFieldMetaUnionTypedDict",
    Union[
        TemplateCreateDocumentFromTemplateFieldMetaRadioTypedDict,
        TemplateCreateDocumentFromTemplateFieldMetaInitialsTypedDict,
        TemplateCreateDocumentFromTemplateFieldMetaNameTypedDict,
        TemplateCreateDocumentFromTemplateFieldMetaEmailTypedDict,
        TemplateCreateDocumentFromTemplateFieldMetaDateTypedDict,
        TemplateCreateDocumentFromTemplateFieldMetaDropdownTypedDict,
        TemplateCreateDocumentFromTemplateFieldMetaCheckboxTypedDict,
        TemplateCreateDocumentFromTemplateFieldMetaTextTypedDict,
        TemplateCreateDocumentFromTemplateFieldMetaNumberTypedDict,
    ],
)


TemplateCreateDocumentFromTemplateFieldMetaUnion = TypeAliasType(
    "TemplateCreateDocumentFromTemplateFieldMetaUnion",
    Union[
        TemplateCreateDocumentFromTemplateFieldMetaRadio,
        TemplateCreateDocumentFromTemplateFieldMetaInitials,
        TemplateCreateDocumentFromTemplateFieldMetaName,
        TemplateCreateDocumentFromTemplateFieldMetaEmail,
        TemplateCreateDocumentFromTemplateFieldMetaDate,
        TemplateCreateDocumentFromTemplateFieldMetaDropdown,
        TemplateCreateDocumentFromTemplateFieldMetaCheckbox,
        TemplateCreateDocumentFromTemplateFieldMetaText,
        TemplateCreateDocumentFromTemplateFieldMetaNumber,
    ],
)


class TemplateCreateDocumentFromTemplateFieldTypedDict(TypedDict):
    type: TemplateCreateDocumentFromTemplateFieldType
    id: float
    secondary_id: str
    document_id: Nullable[float]
    template_id: Nullable[float]
    recipient_id: float
    page: float
    r"""The page number of the field on the document. Starts from 1."""
    custom_text: str
    inserted: bool
    field_meta: Nullable[TemplateCreateDocumentFromTemplateFieldMetaUnionTypedDict]
    position_x: NotRequired[Any]
    position_y: NotRequired[Any]
    width: NotRequired[Any]
    height: NotRequired[Any]


class TemplateCreateDocumentFromTemplateField(BaseModel):
    type: TemplateCreateDocumentFromTemplateFieldType

    id: float

    secondary_id: Annotated[str, pydantic.Field(alias="secondaryId")]

    document_id: Annotated[Nullable[float], pydantic.Field(alias="documentId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    page: float
    r"""The page number of the field on the document. Starts from 1."""

    custom_text: Annotated[str, pydantic.Field(alias="customText")]

    inserted: bool

    field_meta: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateFieldMetaUnion],
        pydantic.Field(alias="fieldMeta"),
    ]

    position_x: Annotated[Optional[Any], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[Any], pydantic.Field(alias="positionY")] = None

    width: Optional[Any] = None

    height: Optional[Any] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["positionX", "positionY", "width", "height"]
        nullable_fields = ["documentId", "templateId", "fieldMeta"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TemplateCreateDocumentFromTemplateResponseTypedDict(TypedDict):
    r"""Successful response"""

    visibility: TemplateCreateDocumentFromTemplateVisibility
    status: TemplateCreateDocumentFromTemplateStatus
    source: TemplateCreateDocumentFromTemplateSource
    id: float
    external_id: Nullable[str]
    r"""A custom external ID you can use to identify the document."""
    user_id: float
    r"""The ID of the user that created this document."""
    auth_options: Nullable[TemplateCreateDocumentFromTemplateAuthOptionsTypedDict]
    form_values: Nullable[
        Dict[str, TemplateCreateDocumentFromTemplateFormValuesTypedDict]
    ]
    title: str
    document_data_id: str
    created_at: str
    updated_at: str
    completed_at: Nullable[str]
    deleted_at: Nullable[str]
    team_id: Nullable[float]
    template_id: Nullable[float]
    document_data: TemplateCreateDocumentFromTemplateDocumentDataTypedDict
    document_meta: Nullable[TemplateCreateDocumentFromTemplateDocumentMetaTypedDict]
    recipients: List[TemplateCreateDocumentFromTemplateRecipientResponseTypedDict]
    fields: List[TemplateCreateDocumentFromTemplateFieldTypedDict]


class TemplateCreateDocumentFromTemplateResponse(BaseModel):
    r"""Successful response"""

    visibility: TemplateCreateDocumentFromTemplateVisibility

    status: TemplateCreateDocumentFromTemplateStatus

    source: TemplateCreateDocumentFromTemplateSource

    id: float

    external_id: Annotated[Nullable[str], pydantic.Field(alias="externalId")]
    r"""A custom external ID you can use to identify the document."""

    user_id: Annotated[float, pydantic.Field(alias="userId")]
    r"""The ID of the user that created this document."""

    auth_options: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    form_values: Annotated[
        Nullable[Dict[str, TemplateCreateDocumentFromTemplateFormValues]],
        pydantic.Field(alias="formValues"),
    ]

    title: str

    document_data_id: Annotated[str, pydantic.Field(alias="documentDataId")]

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]

    completed_at: Annotated[Nullable[str], pydantic.Field(alias="completedAt")]

    deleted_at: Annotated[Nullable[str], pydantic.Field(alias="deletedAt")]

    team_id: Annotated[Nullable[float], pydantic.Field(alias="teamId")]

    template_id: Annotated[Nullable[float], pydantic.Field(alias="templateId")]

    document_data: Annotated[
        TemplateCreateDocumentFromTemplateDocumentData,
        pydantic.Field(alias="documentData"),
    ]

    document_meta: Annotated[
        Nullable[TemplateCreateDocumentFromTemplateDocumentMeta],
        pydantic.Field(alias="documentMeta"),
    ]

    recipients: List[TemplateCreateDocumentFromTemplateRecipientResponse]

    fields: List[TemplateCreateDocumentFromTemplateField]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "externalId",
            "authOptions",
            "formValues",
            "completedAt",
            "deletedAt",
            "teamId",
            "templateId",
            "documentMeta",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
