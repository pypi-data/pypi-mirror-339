# /// script
# requires-python = ">=3.8"
# ///
# pyright: reportDeprecated=false, reportInvalidTypeForm=false

"""
Type stubs for gmpy2 - GNU Multiple Precision Arithmetic Library interface (version 2.2.1)

Stub file version: 2.2.1.5

This file provides type hints for the gmpy2 library functions. Initially it was created and used in Post-Quantum Feldman's VSS.

The gmpy2 library is a C-API wrapper around the GMP, MPFR, and MPC multiple-precision
libraries. These type stubs provide Python type hints for better IDE support and type checking
while working with arbitrary-precision arithmetic.

Key Features:

*   **Comprehensive Type Hints:** Provides type hints for the vast majority of the gmpy2 API, including:
    *   `mpz`, `mpq`, `mpfr`, and `mpc` classes.
    *   `context` manager.
    *   Core arithmetic functions.
    *   Extensive number-theoretic functions.
    *   Random number generators.
    *   Utility functions.
    *   MPFR-specific functions and constants.
    *   Exception types.
*   **Improved Development Experience:** Enables static type checking with tools like mypy and pyright, leading to:
    *   Earlier detection of type errors.
    *   Better code completion and suggestions in IDEs.
    *   Improved code maintainability.
*   **No Runtime Overhead:** Because this is a stub-only package, it has *no* impact on the runtime performance of your code.
The stubs are only used during development and type checking.
*   **Version Specificity:** These stubs are specifically designed for gmpy2 version 2.2.1.

Limitations:

*   **`inspect.signature()`:** These stubs are intended for *static* type checking. They will *not* improve the information
provided by the runtime introspection tool `inspect.signature()`.
This is a limitation of how C extension modules expose their signatures in Python, and is not a limitation of the stubs themselves.
For more details, see [gmpy2 issue #496](https://github.com/aleaxit/gmpy/issues/496) and
[CPython issue #121945](https://github.com/python/cpython/issues/121945).

Usage:

Install the `gmpy2-stubs` package alongside `gmpy2`. Type checkers will automatically use the stubs.
You do *not* need to import anything from `gmpy2-stubs` directly in your code.

System Requirements:

*   Python 3.8+ (matches gmpy2's requirements)

Repository: https://github.com/DavidOsipov/gmpy2-stubs
PyPI: https://pypi.org/project/gmpy2-stubs/

Developer: David Osipov
    Github Profile: https://github.com/DavidOsipov
    Email: personal@david-osipov.vision
    PGP key: https://openpgpkey.david-osipov.vision/.well-known/openpgpkey/david-osipov.vision/D3FC4983E500AC3F7F136EB80E55C4A47454E82E.asc
    PGP fingerprint: D3FC 4983 E500 AC3F 7F13 6EB8 0E55 C4A4 7454 E82E
    Website: https://david-osipov.vision
    LinkedIn: https://www.linkedin.com/in/david-osipov/
"""

from types import TracebackType
from typing import Any, Iterable, Iterator, List, Optional, Tuple, Type, Union, final, overload

# --- Type Aliases ---
_IntLike = Union[int, "mpz", "xmpz"]
_RatLike = Union[_IntLike, float, "mpq", "mpfr"]
_RealLike = Union[_IntLike, float, "mpq", "mpfr"]
_ComplexLike = Union[_RealLike, complex, "mpc"]
_StrLike = Union[str, bytes]
_NumericIn = Union[_ComplexLike, complex]  # Broad input type

# --- Constants ---

# Rounding modes for mpfr/mpc (runtime names, documented public API)
RoundToNearest: int = 0
RoundToZero: int = 1
RoundUp: int = 2
RoundDown: int = 3
RoundAwayZero: int = 4
Default: int = -1 # Used for context settings (e.g., imag_prec) to inherit from default

# --- Exception types ---
class InexactResultError(Exception): ...
class UnderflowResultError(InexactResultError): ...
class OverflowResultError(Exception): ...
class InvalidOperationError(ValueError): ...
class DivisionByZeroError(ZeroDivisionError): ...
class RangeError(ValueError): ...

@final
class mpz:
    """Multiple precision integer type"""

    @overload
    def __new__(cls, n: Union[_RealLike, _StrLike, "mpc", complex] = 0, /) -> "mpz": ...
    @overload
    def __new__(cls, s: _StrLike, /, base: int) -> "mpz": ...
    # No implementation signature in stubs
    def __str__(self) -> str: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __format__(self, format_spec: str) -> str: ...
    def __lt__(self, other: _RealLike) -> bool: ...
    def __le__(self, other: _RealLike) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: _RealLike) -> bool: ...
    def __ge__(self, other: _RealLike) -> bool: ...

    # --- Arithmetic Operations (Refined Overloads) ---
    # __add__
    @overload
    def __add__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __add__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __add__(self, other: "mpq") -> "mpq": ...
    @overload
    def __add__(self, other: _IntLike) -> "mpz": ...
    # No implementation signature in stubs
    # __radd__
    @overload
    def __radd__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __radd__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __radd__(self, other: "mpq") -> "mpq": ...
    # Removed redundant int overload
    # No implementation signature in stubs
    # __sub__
    @overload
    def __sub__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __sub__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __sub__(self, other: "mpq") -> "mpq": ...
    @overload
    def __sub__(self, other: _IntLike) -> "mpz": ...
    # No implementation signature in stubs
    # __rsub__
    @overload
    def __rsub__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rsub__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __rsub__(self, other: "mpq") -> "mpq": ...
    # Removed redundant int overload
    # No implementation signature in stubs
    # __mul__
    @overload
    def __mul__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __mul__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __mul__(self, other: "mpq") -> "mpq": ...
    @overload
    def __mul__(self, other: _IntLike) -> "mpz": ...
    # No implementation signature in stubs
    # __rmul__
    @overload
    def __rmul__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rmul__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __rmul__(self, other: "mpq") -> "mpq": ...
    # Removed redundant int overload
    # No implementation signature in stubs
    # __floordiv__
    def __floordiv__(self, other: _IntLike) -> "mpz": ...
    def __rfloordiv__(self, other: _IntLike) -> "mpz": ...

    # __truediv__
    @overload
    def __truediv__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __truediv__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __truediv__(self, other: "mpq") -> "mpq": ...
    @overload
    def __truediv__(self, other: _IntLike) -> Union["mpq", "mpfr"]: ...
    # No implementation signature in stubs
    # __rtruediv__
    @overload
    def __rtruediv__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rtruediv__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __rtruediv__(self, other: "mpq") -> "mpq": ...
    # Removed redundant int overload
    # No implementation signature in stubs
    # __divmod__
    def __divmod__(self, other: _IntLike) -> Tuple["mpz", "mpz"]: ...
    def __rdivmod__(self, other: _IntLike) -> Tuple["mpz", "mpz"]: ...
    def __mod__(self, other: _IntLike) -> "mpz": ...
    def __rmod__(self, other: _IntLike) -> "mpz": ...

    # __pow__
    @overload
    def __pow__(self, other: Union["mpc", complex], mod: None = None) -> "mpc": ...
    @overload
    def __pow__(self, other: Union["mpfr", float, "mpq"], mod: None = None) -> "mpfr": ...
    @overload
    def __pow__(self, other: _IntLike, mod: None = None) -> "mpz": ...
    @overload
    def __pow__(self, other: _IntLike, mod: _IntLike) -> "mpz": ...
    # No implementation signature in stubs

    # __rpow__ (Stub does not include 'mod', add to allowlist if checker complains)
    @overload
    def __rpow__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rpow__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...  # type: ignore[misc] # Acceptable overlap
    # Removed redundant int overload
    # No implementation signature in stubs

    # --- Bitwise and Unary ---
    def __lshift__(self, other: _IntLike) -> "mpz": ...
    def __rlshift__(self, other: _IntLike) -> "mpz": ...
    def __rshift__(self, other: _IntLike) -> "mpz": ...
    def __rrshift__(self, other: _IntLike) -> "mpz": ...
    def __and__(self, other: _IntLike) -> "mpz": ...
    def __rand__(self, other: _IntLike) -> "mpz": ...
    def __or__(self, other: _IntLike) -> "mpz": ...
    def __ror__(self, other: _IntLike) -> "mpz": ...
    def __xor__(self, other: _IntLike) -> "mpz": ...
    def __rxor__(self, other: _IntLike) -> "mpz": ...
    def __neg__(self) -> "mpz": ...
    def __pos__(self) -> "mpz": ...
    def __abs__(self) -> "mpz": ...
    def __invert__(self) -> "mpz": ...
    def __ceil__(self, /) -> "mpz": ...
    def __floor__(self, /) -> "mpz": ...
    def __round__(self, ndigits: Optional[int] = None, /) -> "mpz": ...
    def __trunc__(self, /) -> "mpz": ...

    # --- Other Methods ---
    def bit_length(self) -> int: ...
    def bit_test(self, n: int, /) -> bool: ...
    def bit_set(self, n: int, /) -> "mpz": ...
    def bit_clear(self, n: int, /) -> "mpz": ...
    def bit_flip(self, n: int, /) -> "mpz": ...
    def bit_scan0(self, starting_bit: int = 0, /) -> Optional[int]: ...
    def bit_scan1(self, starting_bit: int = 0, /) -> Optional[int]: ...
    def bit_count(self) -> int: ...
    def num_digits(self, base: int = 10, /) -> int: ...
    def is_square(self) -> bool: ...
    def is_power(self) -> bool: ...
    def is_prime(self, n: int = 25, /) -> bool: ...
    def is_probab_prime(self, n: int = 25, /) -> int: ...
    def is_congruent(self, other: _IntLike, mod: _IntLike, /) -> bool: ...
    def is_divisible(self, d: _IntLike, /) -> bool: ...
    def is_even(self) -> bool: ...
    def is_odd(self) -> bool: ...
    def to_bytes(self, length: int, byteorder: str, *, signed: bool = False) -> bytes: ...
    @classmethod
    def from_bytes(cls, bytes_val: bytes, byteorder: str, *, signed: bool = False) -> "mpz": ...
    def as_integer_ratio(self) -> Tuple["mpz", "mpz"]: ...
    def conjugate(self) -> "mpz": ...
    def digits(self, base: int = 10, /) -> str: ...
    @property
    def denominator(self) -> "mpz": ...
    @property
    def imag(self) -> "mpz": ...
    @property
    def numerator(self) -> "mpz": ...
    @property
    def real(self) -> "mpz": ...

@final
class mpq:
    """Multiple precision rational type"""

    @overload
    def __new__(cls, num: Union[_RatLike, _StrLike, complex, "mpc"] = 0, /) -> "mpq": ...
    @overload
    def __new__(cls, s: _StrLike, /, base: int) -> "mpq": ...
    @overload
    def __new__(cls, num: _IntLike, den: _IntLike, /) -> "mpq": ...
    @overload
    def __new__(cls, num: _IntLike, den: _IntLike, /, base: int) -> "mpq": ...
    # No implementation signature in stubs
    def __str__(self) -> str: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: _RealLike) -> bool: ...
    def __le__(self, other: _RealLike) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: _RealLike) -> bool: ...
    def __ge__(self, other: _RealLike) -> bool: ...

    # --- Arithmetic Operations (Refined Overloads) ---
    # __add__
    @overload
    def __add__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __add__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __add__(self, other: Union["mpq", _IntLike]) -> "mpq": ...
    # No implementation signature in stubs
    # __radd__
    @overload
    def __radd__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __radd__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __radd__(self, other: _IntLike) -> "mpq": ...  # type: ignore[misc] # Acceptable overlap
    # No implementation signature in stubs
    # __sub__
    @overload
    def __sub__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __sub__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __sub__(self, other: Union["mpq", _IntLike]) -> "mpq": ...
    # No implementation signature in stubs
    # __rsub__
    @overload
    def __rsub__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rsub__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __rsub__(self, other: _IntLike) -> "mpq": ...  # type: ignore[misc] # Acceptable overlap
    # No implementation signature in stubs
    # __mul__
    @overload
    def __mul__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __mul__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __mul__(self, other: Union["mpq", _IntLike]) -> "mpq": ...
    # No implementation signature in stubs
    # __rmul__
    @overload
    def __rmul__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rmul__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __rmul__(self, other: _IntLike) -> "mpq": ...  # type: ignore[misc] # Acceptable overlap
    # No implementation signature in stubs
    # __truediv__
    @overload
    def __truediv__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __truediv__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __truediv__(self, other: Union["mpq", _IntLike]) -> "mpq": ...
    # No implementation signature in stubs
    # __rtruediv__
    @overload
    def __rtruediv__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rtruediv__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __rtruediv__(self, other: _IntLike) -> "mpq": ...  # type: ignore[misc] # Acceptable overlap
    # No implementation signature in stubs

    # __pow__
    @overload
    def __pow__(self, other: Union["mpc", complex], mod: None = None) -> "mpc": ...
    @overload
    def __pow__(self, other: Union["mpfr", float, "mpq"], mod: None = None) -> "mpfr": ...
    @overload
    def __pow__(self, other: _IntLike, mod: None = None) -> "mpq": ...
    # No implementation signature in stubs

    # __rpow__ (Stub does not include 'mod', add to allowlist if checker complains)
    @overload
    def __rpow__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rpow__(self, other: Union["mpfr", float]) -> "mpfr": ...
    @overload
    def __rpow__(self, other: _IntLike) -> "mpfr": ...
    # No implementation signature in stubs

    # --- Unary and Other ---
    def __neg__(self) -> "mpq": ...
    def __pos__(self) -> "mpq": ...
    def __abs__(self) -> "mpq": ...
    def __ceil__(self, /) -> "mpz": ...
    def __floor__(self, /) -> "mpz": ...
    def __round__(self, ndigits: Optional[int] = None, /) -> "mpz": ...
    def __trunc__(self, /) -> "mpz": ...
    @property
    def numerator(self) -> "mpz": ...
    @property
    def denominator(self) -> "mpz": ...
    @classmethod
    def from_float(cls, f: float, /) -> "mpq": ...
    @classmethod
    def from_decimal(cls, d: Any, /) -> "mpq": ...
    def as_integer_ratio(self) -> Tuple["mpz", "mpz"]: ...
    def conjugate(self) -> "mpq": ...
    def digits(self, base: int = 10, /) -> str: ...
    @property
    def real(self) -> "mpq": ...
    @property
    def imag(self) -> "mpz": ...

@final
class mpfr:
    """Multiple precision floating-point type (Based on MPFR library)"""

    @overload
    def __new__(cls, n: Union[_RealLike, "mpc", complex] = 0, /, precision: int = 0, context: Optional["context"] = None) -> "mpfr": ...
    @overload
    def __new__(cls, s: _StrLike, /, precision: int = 0, base: int = 0, context: Optional["context"] = None) -> "mpfr": ...
    # No implementation signature in stubs
    def __str__(self) -> str: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __format__(self, format_spec: str) -> str: ...
    def __lt__(self, other: _RealLike) -> bool: ...
    def __le__(self, other: _RealLike) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: _RealLike) -> bool: ...
    def __ge__(self, other: _RealLike) -> bool: ...

    # --- Arithmetic Operations (Refined Overloads) ---
    # __add__
    @overload
    def __add__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __add__(self, other: _RealLike) -> "mpfr": ...
    # No implementation signature in stubs
    # __radd__
    @overload
    def __radd__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __radd__(self, other: _RealLike) -> "mpfr": ...
    # No implementation signature in stubs
    # __sub__
    @overload
    def __sub__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __sub__(self, other: _RealLike) -> "mpfr": ...
    # No implementation signature in stubs
    # __rsub__
    @overload
    def __rsub__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rsub__(self, other: _RealLike) -> "mpfr": ...
    # No implementation signature in stubs
    # __mul__
    @overload
    def __mul__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __mul__(self, other: _RealLike) -> "mpfr": ...
    # No implementation signature in stubs
    # __rmul__
    @overload
    def __rmul__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rmul__(self, other: _RealLike) -> "mpfr": ...
    # No implementation signature in stubs
    # __truediv__
    @overload
    def __truediv__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __truediv__(self, other: _RealLike) -> "mpfr": ...
    # No implementation signature in stubs
    # __rtruediv__
    @overload
    def __rtruediv__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rtruediv__(self, other: _RealLike) -> "mpfr": ...
    # No implementation signature in stubs

    # __pow__
    @overload
    def __pow__(self, other: Union["mpc", complex], mod: None = None) -> "mpc": ...
    @overload
    def __pow__(self, other: _RealLike, mod: None = None) -> "mpfr": ...
    # No implementation signature in stubs

    # __rpow__ (Stub does not include 'mod', add to allowlist if checker complains)
    @overload
    def __rpow__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rpow__(self, other: _RealLike) -> "mpfr": ...
    # No implementation signature in stubs

    # --- Unary and Other ---
    def __neg__(self) -> "mpfr": ...
    def __pos__(self) -> "mpfr": ...
    def __abs__(self) -> "mpfr": ...
    def __ceil__(self, /) -> "mpfr": ...
    def __floor__(self, /) -> "mpfr": ...
    def __round__(self, ndigits: Optional[int] = None, /) -> "mpfr": ...
    def __trunc__(self, /) -> "mpfr": ...
    def is_integer(self) -> bool: ...
    def is_zero(self) -> bool: ...
    def is_nan(self) -> bool: ...
    def is_infinite(self) -> bool: ...
    def is_finite(self) -> bool: ...
    def is_signed(self) -> bool: ...
    def is_regular(self) -> bool: ...
    def digits(self, base: int = 10, prec: int = 0, /) -> Tuple[str, int, int]: ...
    @property
    def precision(self) -> int: ...
    def as_integer_ratio(self) -> Tuple["mpz", "mpz"]: ...
    def as_mantissa_exp(self) -> Tuple["mpz", int]: ...
    def as_simple_fraction(self, precision: int = 0, /) -> "mpq": ...
    def conjugate(self) -> "mpfr": ...
    @property
    def real(self) -> "mpfr": ...
    @property
    def imag(self) -> "mpfr": ...
    @property
    def rc(self) -> int: ...

@final
class mpc:
    """Multi-precision complex number type (Based on MPC library)"""

    @overload
    def __new__(cls, c: _ComplexLike = 0, /, precision: Union[int, Tuple[int, int]] = 0, context: Optional["context"] = None) -> "mpc": ...
    @overload
    def __new__(
        cls,
        real: _RealLike,
        imag: _RealLike = 0,
        /,
        precision: Union[int, Tuple[int, int]] = 0,
        context: Optional["context"] = None,
    ) -> "mpc": ...
    @overload
    def __new__(
        cls, s: _StrLike, /, precision: Union[int, Tuple[int, int]] = 0, base: int = 10, context: Optional["context"] = None
    ) -> "mpc": ...
    # No implementation signature in stubs
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __format__(self, format_spec: str) -> str: ...
    def __lt__(self, other: _ComplexLike) -> bool: ...
    def __le__(self, other: _ComplexLike) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: _ComplexLike) -> bool: ...
    def __ge__(self, other: _ComplexLike) -> bool: ...

    # --- Arithmetic Operations (Generally return mpc) ---
    def __add__(self, other: _ComplexLike) -> "mpc": ...
    def __radd__(self, other: _ComplexLike) -> "mpc": ...
    def __sub__(self, other: _ComplexLike) -> "mpc": ...
    def __rsub__(self, other: _ComplexLike) -> "mpc": ...
    def __mul__(self, other: _ComplexLike) -> "mpc": ...
    def __rmul__(self, other: _ComplexLike) -> "mpc": ...
    def __truediv__(self, other: _ComplexLike) -> "mpc": ...
    def __rtruediv__(self, other: _ComplexLike) -> "mpc": ...

    # __pow__
    def __pow__(self, other: _ComplexLike, mod: None = None) -> "mpc": ...

    # __rpow__ (Stub does not include 'mod', add to allowlist if checker complains)
    def __rpow__(self, other: _ComplexLike) -> "mpc": ...

    # --- Unary and Other ---
    def __neg__(self) -> "mpc": ...
    def __pos__(self) -> "mpc": ...
    def __abs__(self) -> "mpfr": ...
    def __complex__(self, /) -> complex: ...
    def conjugate(self) -> "mpc": ...
    def digits(self, base: int = 10, prec: int = 0, /) -> Tuple[Tuple[str, int, int], Tuple[str, int, int]]: ...
    @property
    def real(self: "mpc") -> "mpfr": ...
    @property
    def imag(self: "mpc") -> "mpfr": ...
    def is_finite(self) -> bool: ...
    def is_infinite(self) -> bool: ...
    def is_nan(self) -> bool: ...
    def is_zero(self) -> bool: ...
    @property
    def precision(self) -> Tuple[int, int]: ...
    @property
    def rc(self) -> Tuple[int, int]: ...

@final
class xmpz:
    """Mutable multiple precision integer type (EXPERIMENTAL)."""

    limb_size: int

    @overload
    def __new__(cls, n: Union[_RealLike, _StrLike, "mpc", complex] = 0, /) -> "xmpz": ...
    @overload
    def __new__(cls, s: _StrLike, /, base: int) -> "xmpz": ...
    # No implementation signature in stubs
    def __str__(self) -> str: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __format__(self, format_spec: str) -> str: ...
    def __lt__(self, other: _RealLike) -> bool: ...
    def __le__(self, other: _RealLike) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: _RealLike) -> bool: ...
    def __ge__(self, other: _RealLike) -> bool: ...

    # --- Arithmetic (Standard - Return immutable, Refined Overloads) ---
    # __add__
    @overload
    def __add__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __add__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...
    @overload
    def __add__(self, other: _IntLike) -> "mpz": ...
    # No implementation signature in stubs
    # __radd__
    @overload
    def __radd__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __radd__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...  # type: ignore[misc] # Acceptable overlap
    # Removed redundant int overload
    # No implementation signature in stubs
    # __sub__
    @overload
    def __sub__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __sub__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...
    @overload
    def __sub__(self, other: _IntLike) -> "mpz": ...
    # No implementation signature in stubs
    # __rsub__
    @overload
    def __rsub__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rsub__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...  # type: ignore[misc] # Acceptable overlap
    # Removed redundant int overload
    # No implementation signature in stubs
    # __mul__
    @overload
    def __mul__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __mul__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...
    @overload
    def __mul__(self, other: _IntLike) -> "mpz": ...
    # No implementation signature in stubs
    # __rmul__
    @overload
    def __rmul__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rmul__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...  # type: ignore[misc] # Acceptable overlap
    # Removed redundant int overload
    # No implementation signature in stubs
    # __floordiv__
    def __floordiv__(self, other: _IntLike) -> "mpz": ...
    def __rfloordiv__(self, other: _IntLike) -> "mpz": ...

    # __truediv__
    @overload
    def __truediv__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __truediv__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...
    @overload
    def __truediv__(self, other: _IntLike) -> Union["mpq", "mpfr"]: ...
    # No implementation signature in stubs
    # __rtruediv__
    @overload
    def __rtruediv__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rtruediv__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...  # type: ignore[misc] # Acceptable overlap
    # Removed redundant int overload
    # No implementation signature in stubs
    # __divmod__
    def __divmod__(self, other: _IntLike) -> Tuple["mpz", "mpz"]: ...
    def __rdivmod__(self, other: _IntLike) -> Tuple["mpz", "mpz"]: ...
    def __mod__(self, other: _IntLike) -> "mpz": ...
    def __rmod__(self, other: _IntLike) -> "mpz": ...

    # __pow__
    @overload
    def __pow__(self, other: Union["mpc", complex], mod: None = None) -> "mpc": ...
    @overload
    def __pow__(self, other: Union["mpfr", float, "mpq"], mod: None = None) -> "mpfr": ...
    @overload
    def __pow__(self, other: _IntLike, mod: None = None) -> "mpz": ...
    @overload
    def __pow__(self, other: _IntLike, mod: _IntLike) -> "mpz": ...
    # No implementation signature in stubs

    # __rpow__ (Stub does not include 'mod', add to allowlist if checker complains)
    @overload
    def __rpow__(self, other: Union["mpc", complex]) -> "mpc": ...
    @overload
    def __rpow__(self, other: Union["mpfr", float, "mpq"]) -> "mpfr": ...  # type: ignore[misc] # Acceptable overlap
    # Removed redundant int overload
    # No implementation signature in stubs

    # --- Arithmetic (In-place - Modify self, return self) ---
    def __iadd__(self, other: _IntLike) -> "xmpz": ...  # type: ignore[misc] # Intentional signature difference
    def __isub__(self, other: _IntLike) -> "xmpz": ...  # type: ignore[misc] # Intentional signature difference
    def __imul__(self, other: _IntLike) -> "xmpz": ...  # type: ignore[misc] # Intentional signature difference
    def __ifloordiv__(self, other: _IntLike) -> "xmpz": ...
    def __imod__(self, other: _IntLike) -> "xmpz": ...
    def __ipow__(self, other: _IntLike, /) -> "xmpz": ...  # type: ignore[misc] # Intentional signature difference

    # --- Bitwise (Standard - Return immutable mpz) ---
    def __lshift__(self, other: _IntLike) -> "mpz": ...
    def __rlshift__(self, other: _IntLike) -> "mpz": ...
    def __rshift__(self, other: _IntLike) -> "mpz": ...
    def __rrshift__(self, other: _IntLike) -> "mpz": ...
    def __and__(self, other: _IntLike) -> "mpz": ...
    def __rand__(self, other: _IntLike) -> "mpz": ...
    def __or__(self, other: _IntLike) -> "mpz": ...
    def __ror__(self, other: _IntLike) -> "mpz": ...
    def __xor__(self, other: _IntLike) -> "mpz": ...
    def __rxor__(self, other: _IntLike) -> "mpz": ...

    # --- Bitwise (In-place - Modify self, return self) ---
    def __ilshift__(self, other: _IntLike) -> "xmpz": ...
    def __irshift__(self, other: _IntLike) -> "xmpz": ...
    def __iand__(self, other: _IntLike) -> "xmpz": ...
    def __ior__(self, other: _IntLike) -> "xmpz": ...
    def __ixor__(self, other: _IntLike) -> "xmpz": ...

    # --- Unary (Return immutable mpz) ---
    def __neg__(self) -> "mpz": ...
    def __pos__(self) -> "mpz": ...
    def __abs__(self) -> "mpz": ...
    def __invert__(self) -> "mpz": ...

    # --- Slice access ---
    @overload
    def __getitem__(self, key: int) -> int: ...
    @overload
    def __getitem__(self, key: slice) -> int: ...
    # No implementation signature in stubs
    def __setitem__(self, key: Union[int, slice], value: int) -> None: ...

    # --- Regular Methods ---
    def bit_clear(self, n: int, /) -> "xmpz": ...
    def bit_count(self) -> int: ...
    def bit_flip(self, n: int, /) -> "xmpz": ...
    def bit_length(self) -> int: ...
    def bit_scan0(self, n: int = 0, /) -> Optional[int]: ...
    def bit_scan1(self, n: int = 0, /) -> Optional[int]: ...
    def bit_set(self, n: int, /) -> "xmpz": ...
    def bit_test(self, n: int, /) -> bool: ...
    def conjugate(self) -> "xmpz": ...
    def copy(self) -> "xmpz": ...
    def digits(self, base: int = 10, /) -> str: ...
    def iter_bits(self, start: int = 0, stop: int = -1) -> Iterator[bool]: ...
    def iter_clear(self, start: int = 0, stop: int = -1) -> Iterator[int]: ...
    def iter_set(self, start: int = 0, stop: int = -1) -> Iterator[int]: ...
    def limbs_finish(self, n: int, /) -> None: ...
    def limbs_modify(self, n: int, /) -> int: ...
    def limbs_read(self) -> int: ...
    def limbs_write(self, n: int, /) -> int: ...
    def make_mpz(self) -> "mpz": ...
    def num_digits(self, base: int = 10, /) -> int: ...
    def num_limbs(self) -> int: ...

    # --- Properties ---
    @property
    def denominator(self) -> "mpz": ...
    @property
    def numerator(self) -> "xmpz": ...
    @property
    def real(self) -> "xmpz": ...

# --- General functions ---
def version() -> str: ...
def mp_version() -> str: ...
def mpc_version() -> str: ...
def mpfr_version() -> str: ...
def get_max_precision() -> int: ...
def get_emax_max() -> int: ...
def get_emin_min() -> int: ...

# --- Context ---
@final
class context:
    """Context manager for changing precision and rounding modes locally."""

    @overload
    def __init__(
        self,
        *,
        precision: Optional[int] = None,
        real_prec: Optional[int] = None,
        imag_prec: Optional[int] = None,
        round: Optional[int] = None,
        real_round: Optional[int] = None,
        imag_round: Optional[int] = None,
        emin: Optional[int] = None,
        emax: Optional[int] = None,
        subnormalize: Optional[bool] = None,
        trap_underflow: Optional[bool] = None,
        trap_overflow: Optional[bool] = None,
        trap_inexact: Optional[bool] = None,
        trap_invalid: Optional[bool] = None,
        trap_erange: Optional[bool] = None,
        trap_divzero: Optional[bool] = None,
        allow_complex: Optional[bool] = None,
        allow_release_gil: Optional[bool] = None,
        rational_division: Optional[bool] = None,
    ) -> None: ...
    @overload
    def __init__(
        self,
        ctx: "context",
        /,
        *,
        precision: Optional[int] = None,
        real_prec: Optional[int] = None,
        imag_prec: Optional[int] = None,
        round: Optional[int] = None,
        real_round: Optional[int] = None,
        imag_round: Optional[int] = None,
        emin: Optional[int] = None,
        emax: Optional[int] = None,
        subnormalize: Optional[bool] = None,
        trap_underflow: Optional[bool] = None,
        trap_overflow: Optional[bool] = None,
        trap_inexact: Optional[bool] = None,
        trap_invalid: Optional[bool] = None,
        trap_erange: Optional[bool] = None,
        trap_divzero: Optional[bool] = None,
        allow_complex: Optional[bool] = None,
        allow_release_gil: Optional[bool] = None,
        rational_division: Optional[bool] = None,
    ) -> None: ...
    # No implementation signature in stubs
    def __enter__(self) -> "context": ...
    def __exit__(
        self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[TracebackType]
    ) -> None: ...
    @property
    def precision(self) -> int: ...
    @precision.setter
    def precision(self, value: int) -> None: ...
    @property
    def real_prec(self) -> int: ...
    @real_prec.setter
    def real_prec(self, value: int) -> None: ...
    @property
    def imag_prec(self) -> int: ...
    @imag_prec.setter
    def imag_prec(self, value: int) -> None: ...
    @property
    def round(self) -> int: ...
    @round.setter
    def round(self, value: int) -> None: ...
    @property
    def real_round(self) -> int: ...
    @real_round.setter
    def real_round(self, value: int) -> None: ...
    @property
    def imag_round(self) -> int: ...
    @imag_round.setter
    def imag_round(self, value: int) -> None: ...
    @property
    def subnormalize(self) -> bool: ...
    @subnormalize.setter
    def subnormalize(self, value: bool) -> None: ...
    @property
    def trap_underflow(self) -> bool: ...
    @trap_underflow.setter
    def trap_underflow(self, value: bool) -> None: ...
    @property
    def trap_overflow(self) -> bool: ...
    @trap_overflow.setter
    def trap_overflow(self, value: bool) -> None: ...
    @property
    def trap_inexact(self) -> bool: ...
    @trap_inexact.setter
    def trap_inexact(self, value: bool) -> None: ...
    @property
    def trap_invalid(self) -> bool: ...
    @trap_invalid.setter
    def trap_invalid(self, value: bool) -> None: ...
    @property
    def trap_erange(self) -> bool: ...
    @trap_erange.setter
    def trap_erange(self, value: bool) -> None: ...
    @property
    def trap_divzero(self) -> bool: ...
    @trap_divzero.setter
    def trap_divzero(self, value: bool) -> None: ...
    @property
    def allow_complex(self) -> bool: ...
    @allow_complex.setter
    def allow_complex(self, value: bool) -> None: ...
    @property
    def allow_release_gil(self) -> bool: ...
    @allow_release_gil.setter
    def allow_release_gil(self, value: bool) -> None: ...
    @property
    def rational_division(self) -> bool: ...
    @rational_division.setter
    def rational_division(self, value: bool) -> None: ...
    @property
    def underflow(self) -> bool: ...
    @property
    def overflow(self) -> bool: ...
    @property
    def divzero(self) -> bool: ...
    @property
    def inexact(self) -> bool: ...
    @property
    def invalid(self) -> bool: ...
    @property
    def erange(self) -> bool: ...
    @property
    def emax(self) -> int: ...
    @property
    def emin(self) -> int: ...
    def abs(self, x: _ComplexLike, /) -> Union[mpz, mpfr, mpq]: ...
    def acos(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def acosh(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def add(self, x: _ComplexLike, y: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
    def agm(self, x: _RealLike, y: _RealLike, /) -> mpfr: ...
    def ai(self, x: _RealLike, /) -> mpfr: ...
    def asin(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def asinh(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def atan(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def atan2(self, y: _RealLike, x: _RealLike, /) -> mpfr: ...
    def atanh(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def cbrt(self, x: _RealLike, /) -> mpfr: ...
    def ceil(self, x: _RealLike, /) -> mpfr: ...
    def const_catalan(self) -> "mpfr": ...
    def const_euler(self) -> "mpfr": ...
    def const_log2(self) -> "mpfr": ...
    def const_pi(self) -> "mpfr": ...
    def cos(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def cosh(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def cot(self, x: _RealLike, /) -> mpfr: ...
    def coth(self, x: _RealLike, /) -> mpfr: ...
    def csc(self, x: _RealLike, /) -> mpfr: ...
    def csch(self, x: _RealLike, /) -> mpfr: ...
    def degrees(self, x: _RealLike, /) -> mpfr: ...
    def digamma(self, x: _RealLike, /) -> mpfr: ...
    def div(self, x: _ComplexLike, y: _ComplexLike, /) -> Union[mpq, mpfr, mpc]: ...
    def div_2exp(self, x: Union[mpfr, mpc], n: int, /) -> Union[mpfr, mpc]: ...
    def divmod(self, x: _IntLike, y: _IntLike, /) -> Tuple["mpz", "mpz"]: ...
    def eint(self, x: _RealLike, /) -> mpfr: ...
    def erf(self, x: _RealLike, /) -> mpfr: ...
    def erfc(self, x: _RealLike, /) -> mpfr: ...
    def exp(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def exp10(self, x: _RealLike, /) -> mpfr: ...
    def exp2(self, x: _RealLike, /) -> mpfr: ...
    def expm1(self, x: _RealLike, /) -> mpfr: ...
    def factorial(self, n: _IntLike, /) -> mpfr: ...
    def floor(self, x: _RealLike, /) -> mpfr: ...
    def floor_div(self, x: _RealLike, y: _RealLike, /) -> Union[mpz, mpfr]: ...
    def fma(self, x: _ComplexLike, y: _ComplexLike, z: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
    def fmma(self, x: _RealLike, y: _RealLike, z: _RealLike, t: _RealLike, /) -> mpfr: ...
    def fmms(self, x: _RealLike, y: _RealLike, z: _RealLike, t: _RealLike, /) -> mpfr: ...
    def fmod(self, x: _RealLike, y: _RealLike, /) -> mpfr: ...
    def fms(self, x: _ComplexLike, y: _ComplexLike, z: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
    def frac(self, x: _RealLike, /) -> mpfr: ...
    def frexp(self, x: _RealLike, /) -> Tuple[int, mpfr]: ...
    def fsum(self, iterable: Iterable[_RealLike], /) -> mpfr: ...
    def gamma(self, x: _RealLike, /) -> mpfr: ...
    def gamma_inc(self, a: _RealLike, x: _RealLike, /) -> mpfr: ...
    def hypot(self, x: _RealLike, y: _RealLike, /) -> mpfr: ...
    def j0(self, x: _RealLike, /) -> mpfr: ...
    def j1(self, x: _RealLike, /) -> mpfr: ...
    def jn(self, n: int, x: _RealLike, /) -> mpfr: ...
    def lgamma(self, x: _RealLike, /) -> Tuple[mpfr, int]: ...
    def li2(self, x: _RealLike, /) -> mpfr: ...
    def lngamma(self, x: _RealLike, /) -> mpfr: ...
    def log(self, x: _ComplexLike, /) -> Union["mpfr", "mpc"]: ...
    def log10(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def log1p(self, x: _RealLike, /) -> mpfr: ...
    def log2(self, x: _RealLike, /) -> mpfr: ...
    def maxnum(self, x: _RealLike, y: _RealLike, /) -> mpfr: ...
    def minnum(self, x: _RealLike, y: _RealLike, /) -> mpfr: ...
    def mod(self, x: _RealLike, y: _RealLike, /) -> mpfr: ...
    def modf(self, x: _RealLike, /) -> Tuple[mpfr, mpfr]: ...
    def mul(self, x: _ComplexLike, y: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
    def mul_2exp(self, x: Union[mpfr, mpc], n: int, /) -> Union[mpfr, mpc]: ...
    def next_above(self, x: "mpfr", /) -> "mpfr": ...
    def next_below(self, x: "mpfr", /) -> "mpfr": ...
    def next_toward(self, x: "mpfr", y: "mpfr", /) -> "mpfr": ...
    def norm(self, x: "mpc", /) -> "mpfr": ...
    def phase(self, x: "mpc", /) -> "mpfr": ...
    def polar(self, x: "mpc", /) -> Tuple["mpfr", "mpfr"]: ...
    def pow(self, x: _ComplexLike, y: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
    def proj(self, x: "mpc", /) -> "mpc": ...
    def radians(self, x: _RealLike, /) -> mpfr: ...
    def rec_sqrt(self, x: _RealLike, /) -> mpfr: ...
    def reldiff(self, x: _RealLike, y: _RealLike, /) -> mpfr: ...
    def remainder(self, x: _RealLike, y: _RealLike, /) -> mpfr: ...
    def remquo(self, x: _RealLike, y: _RealLike, /) -> Tuple[mpfr, int]: ...
    def rint(self, x: _RealLike, /) -> mpfr: ...
    def rint_ceil(self, x: _RealLike, /) -> mpfr: ...
    def rint_floor(self, x: _RealLike, /) -> mpfr: ...
    def rint_round(self, x: _RealLike, /) -> mpfr: ...
    def rint_trunc(self, x: _RealLike, /) -> mpfr: ...
    def root(self, x: _RealLike, n: int, /) -> mpfr: ...
    def root_of_unity(self, n: int, k: int, /) -> mpc: ...
    def rootn(self, x: _RealLike, n: int, /) -> mpfr: ...
    def round2(self, x: _RealLike, n: int = 0, /) -> mpfr: ...
    def round_away(self, x: _RealLike, /) -> mpfr: ...
    def sec(self, x: _RealLike, /) -> mpfr: ...
    def sech(self, x: _RealLike, /) -> mpfr: ...
    def sin(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    @overload
    def sin_cos(self, x: _RealLike, /) -> Tuple["mpfr", "mpfr"]: ...
    @overload
    def sin_cos(self, x: "mpc", /) -> Tuple["mpc", "mpc"]: ...
    # No implementation signature in stubs
    def sinh(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def sinh_cosh(self, x: _RealLike, /) -> Tuple[mpfr, mpfr]: ...
    def sqrt(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def square(self, x: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
    def sub(self, x: _ComplexLike, y: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
    def tan(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def tanh(self, x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
    def trunc(self, x: _RealLike, /) -> mpfr: ...
    def y0(self, x: _RealLike, /) -> mpfr: ...
    def y1(self, x: _RealLike, /) -> mpfr: ...
    def yn(self, n: int, x: _RealLike, /) -> mpfr: ...
    def zeta(self, x: _RealLike, /) -> mpfr: ...
    def clear_flags(self) -> None: ...
    def copy(self) -> "context": ...
    def check_range(self, x: _RealLike, /) -> "mpfr": ...
    def is_finite(self, x: _ComplexLike, /) -> bool: ...
    def is_infinite(self, x: _ComplexLike, /) -> bool: ...
    def is_integer(self, x: _RealLike, /) -> bool: ...
    def is_nan(self, x: _ComplexLike, /) -> bool: ...
    def is_regular(self, x: _RealLike, /) -> bool: ...
    def is_signed(self, x: _RealLike, /) -> bool: ...
    def is_zero(self, x: _ComplexLike, /) -> bool: ...
    def minus(self, x: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
    def plus(self, x: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
    def rect(self, r: _RealLike, phi: _RealLike, /) -> "mpc": ...

# --- Number theoretic functions (module level) ---
def powmod(x: _IntLike, y: _IntLike, m: _IntLike, /) -> "mpz": ...
def invert(x: _IntLike, m: _IntLike, /) -> "mpz": ...
def is_prime(x: _IntLike, n: int = 25, /) -> bool: ...
def is_probab_prime(x: _IntLike, n: int = 25, /) -> int: ...
def gcd(*integers: _IntLike) -> "mpz": ...
def lcm(*integers: _IntLike) -> "mpz": ...
def gcdext(a: _IntLike, b: _IntLike, /) -> Tuple["mpz", "mpz", "mpz"]: ...
def divm(a: _IntLike, b: _IntLike, m: _IntLike, /) -> "mpz": ...
def fac(n: _IntLike, /) -> "mpz": ...
def fib(n: _IntLike, /) -> "mpz": ...
def fib2(n: _IntLike, /) -> Tuple["mpz", "mpz"]: ...
def lucas(n: _IntLike, /) -> "mpz": ...
def lucas2(n: _IntLike, /) -> Tuple["mpz", "mpz"]: ...
def jacobi(a: _IntLike, b: _IntLike, /) -> int: ...
def legendre(a: _IntLike, p: _IntLike, /) -> int: ...
def kronecker(a: _IntLike, b: _IntLike, /) -> int: ...
def next_prime(x: _IntLike, /) -> "mpz": ...
def prev_prime(x: _IntLike, /) -> "mpz": ...
def bincoef(n: _IntLike, k: _IntLike, /) -> "mpz": ...
def comb(n: _IntLike, k: _IntLike, /) -> "mpz": ...
def divexact(x: _IntLike, y: _IntLike, /) -> "mpz": ...
def double_fac(n: _IntLike, /) -> "mpz": ...
def f2q(x: "mpfr", err: int = 0, /) -> Union["mpz", "mpq"]: ...
def is_bpsw_prp(n: _IntLike, /) -> bool: ...
def is_euler_prp(n: _IntLike, a: _IntLike, /) -> bool: ...
def is_extra_strong_lucas_prp(n: _IntLike, p: _IntLike, /) -> bool: ...
def is_fermat_prp(n: _IntLike, a: _IntLike, /) -> bool: ...
def is_fibonacci_prp(n: _IntLike, p: _IntLike, q: _IntLike, /) -> bool: ...
def is_lucas_prp(n: _IntLike, p: _IntLike, q: _IntLike, /) -> bool: ...
def is_selfridge_prp(n: _IntLike, /) -> bool: ...
def is_strong_bpsw_prp(n: _IntLike, /) -> bool: ...
def is_strong_lucas_prp(n: _IntLike, p: _IntLike, q: _IntLike, /) -> bool: ...
def is_strong_prp(n: _IntLike, a: _IntLike, /) -> bool: ...
def is_strong_selfridge_prp(n: _IntLike, /) -> bool: ...
def lucasu(p: _IntLike, q: _IntLike, k: _IntLike, /) -> "mpz": ...
def lucasu_mod(p: _IntLike, q: _IntLike, k: _IntLike, n: _IntLike, /) -> "mpz": ...
def lucasv(p: _IntLike, q: _IntLike, k: _IntLike, /) -> "mpz": ...
def lucasv_mod(p: _IntLike, q: _IntLike, k: _IntLike, n: _IntLike, /) -> "mpz": ...
def multi_fac(n: _IntLike, m: _IntLike, /) -> "mpz": ...
def pack(lst: List[int], n: int, /) -> "mpz": ...
def powmod_base_list(base_lst: List[_IntLike], exp: _IntLike, mod: _IntLike, /) -> List["mpz"]: ...
def powmod_exp_list(base: _IntLike, exp_lst: List[_IntLike], mod: _IntLike, /) -> List["mpz"]: ...
def powmod_sec(x: _IntLike, y: _IntLike, m: _IntLike, /) -> "mpz": ...
def primorial(n: _IntLike, /) -> "mpz": ...
def remove(x: _IntLike, f: _IntLike, /) -> Tuple["mpz", int]: ...
def unpack(x: _IntLike, n: int, /) -> List[int]: ...

# --- Core arithmetic functions (module level) ---
def add(x: _ComplexLike, y: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
def sub(x: _ComplexLike, y: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
def mul(x: _ComplexLike, y: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
def div(x: _ComplexLike, y: _ComplexLike, /) -> Union[mpq, mpfr, mpc]: ...
def mod(x: _IntLike, y: _IntLike, /) -> "mpz": ...
def sqrt(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def isqrt(x: _IntLike, /) -> "mpz": ...
def isqrt_rem(x: _IntLike, /) -> Tuple["mpz", "mpz"]: ...
def square(x: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
def iroot(x: _IntLike, n: _IntLike, /) -> Tuple["mpz", bool]: ...
def iroot_rem(x: _IntLike, n: _IntLike, /) -> Tuple["mpz", "mpz"]: ...

# --- Random number generators ---
def random_state(seed: Optional[Union[int, str, bytes, Any]] = None, /) -> Any: ...
def mpz_random(state: Any, n: _IntLike, /) -> "mpz": ...
def mpz_rrandomb(state: Any, b: int, /) -> "mpz": ...
def mpz_urandomb(state: Any, b: int, /) -> "mpz": ...
def mpfr_grandom(state: Any, /) -> Tuple["mpfr", "mpfr"]: ...
def mpfr_nrandom(state: Any, /) -> "mpfr": ...
def mpfr_random(state: Any, /) -> "mpfr": ...
def mpc_random(state: Any, /) -> "mpc": ...

# --- Other utility functions ---
def hamdist(x: _IntLike, y: _IntLike, /) -> int: ...
def popcount(x: _IntLike, /) -> int: ...
def bit_mask(n: int, /) -> "mpz": ...
def bit_clear(x: _IntLike, n: int, /) -> "mpz": ...
def bit_count(x: _IntLike, /) -> int: ...
def bit_flip(x: _IntLike, n: int, /) -> "mpz": ...
def bit_length(x: _IntLike, /) -> int: ...
def bit_scan0(x: _IntLike, n: int = 0, /) -> Optional[int]: ...
def bit_scan1(x: _IntLike, n: int = 0, /) -> Optional[int]: ...
def bit_set(x: _IntLike, n: int, /) -> "mpz": ...
def bit_test(x: _IntLike, n: int, /) -> bool: ...
def num_digits(x: _IntLike, base: int = 10, /) -> int: ...
def is_divisible(x: _IntLike, d: _IntLike, /) -> bool: ...
def is_even(x: _IntLike, /) -> bool: ...
def is_odd(x: _IntLike, /) -> bool: ...
def is_power(x: _IntLike, /) -> bool: ...
def is_square(x: _IntLike, /) -> bool: ...
def is_congruent(x: _IntLike, y: _IntLike, m: _IntLike, /) -> bool: ...

# --- MPFR specific functions (module level) ---
def const_log2(precision: int = 0, /) -> "mpfr": ...
def const_pi(precision: int = 0, /) -> "mpfr": ...
def const_euler(precision: int = 0, /) -> "mpfr": ...
def const_catalan(precision: int = 0, /) -> "mpfr": ...
def log(x: _ComplexLike, /) -> Union["mpfr", "mpc"]: ...
def log10(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def exp(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def sin(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def cos(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def tan(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def atan(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def atan2(y: _RealLike, x: _RealLike, /) -> "mpfr": ...
def sinh(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def cosh(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def tanh(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def atanh(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def asin(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def acos(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def asinh(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def acosh(x: _ComplexLike, /) -> Union[mpfr, mpc]: ...
def floor(x: _RealLike, /) -> "mpfr": ...
def ceil(x: _RealLike, /) -> "mpfr": ...
def trunc(x: _RealLike, /) -> "mpfr": ...
def round2(x: _RealLike, n: int = 0, /) -> "mpfr": ...
def round_away(x: _RealLike, /) -> "mpfr": ...
def fmod(x: _RealLike, y: _RealLike, /) -> "mpfr": ...
def remainder(x: _RealLike, y: _RealLike, /) -> "mpfr": ...
def remquo(x: _RealLike, y: _RealLike, /) -> Tuple["mpfr", int]: ...
def rint(x: _RealLike, /) -> "mpfr": ...
def rint_ceil(x: _RealLike, /) -> "mpfr": ...
def rint_floor(x: _RealLike, /) -> "mpfr": ...
def rint_round(x: _RealLike, /) -> "mpfr": ...
def rint_trunc(x: _RealLike, /) -> "mpfr": ...
def root_of_unity(n: int, k: int, /) -> "mpc": ...
def next_toward(x: "mpfr", y: "mpfr", /) -> "mpfr": ...

# --- Division Variants (module level) ---
def c_div(x: _IntLike, y: _IntLike, /) -> "mpz": ...
def c_div_2exp(x: _IntLike, n: int, /) -> "mpz": ...
def c_divmod(x: _IntLike, y: _IntLike, /) -> Tuple["mpz", "mpz"]: ...
def c_divmod_2exp(x: _IntLike, n: int, /) -> Tuple["mpz", "mpz"]: ...
def c_mod(x: _IntLike, y: _IntLike, /) -> "mpz": ...
def c_mod_2exp(x: _IntLike, n: int, /) -> "mpz": ...
def f_div(x: _IntLike, y: _IntLike, /) -> "mpz": ...
def f_div_2exp(x: _IntLike, n: int, /) -> "mpz": ...
def f_divmod(x: _IntLike, y: _IntLike, /) -> Tuple["mpz", "mpz"]: ...
def f_divmod_2exp(x: _IntLike, n: int, /) -> Tuple["mpz", "mpz"]: ...
def f_mod(x: _IntLike, y: _IntLike, /) -> "mpz": ...
def f_mod_2exp(x: _IntLike, n: int, /) -> "mpz": ...
def t_div(x: _IntLike, y: _IntLike, /) -> "mpz": ...
def t_div_2exp(x: _IntLike, n: int, /) -> "mpz": ...
def t_divmod(x: _IntLike, y: _IntLike, /) -> Tuple["mpz", "mpz"]: ...
def t_divmod_2exp(x: _IntLike, n: int, /) -> Tuple["mpz", "mpz"]: ...
def t_mod(x: _IntLike, y: _IntLike, /) -> "mpz": ...
def t_mod_2exp(x: _IntLike, n: int, /) -> "mpz": ...

# --- Additional Float/Complex Functions (module level) ---
def agm(x: _RealLike, y: _RealLike, /) -> mpfr: ...
def ai(x: _RealLike, /) -> mpfr: ...
def cbrt(x: _RealLike, /) -> "mpfr": ...
def cot(x: _RealLike, /) -> mpfr: ...
def coth(x: _RealLike, /) -> mpfr: ...
def csc(x: _RealLike, /) -> mpfr: ...
def csch(x: _RealLike, /) -> mpfr: ...
def digamma(x: _RealLike, /) -> "mpfr": ...
def eint(x: _RealLike, /) -> "mpfr": ...
def erf(x: _RealLike, /) -> "mpfr": ...
def erfc(x: _RealLike, /) -> "mpfr": ...
def exp10(x: _RealLike, /) -> "mpfr": ...
def exp2(x: _RealLike, /) -> "mpfr": ...
def expm1(x: _RealLike, /) -> "mpfr": ...
def factorial(n: _IntLike, /) -> mpfr: ...
def floor_div(x: _RealLike, y: _RealLike, /) -> Union[mpz, mpfr]: ...
def fma(x: _ComplexLike, y: _ComplexLike, z: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
def fms(x: _ComplexLike, y: _ComplexLike, z: _ComplexLike, /) -> Union[mpz, mpq, mpfr, mpc]: ...
def fmma(x: _RealLike, y: _RealLike, z: _RealLike, t: _RealLike, /) -> "mpfr": ...
def fmms(x: _RealLike, y: _RealLike, z: _RealLike, t: _RealLike, /) -> "mpfr": ...
def frac(x: _RealLike, /) -> mpfr: ...
def frexp(x: _RealLike, /) -> Tuple[int, "mpfr"]: ...
def fsum(iterable: Iterable[_RealLike], /) -> "mpfr": ...
def gamma(x: _RealLike, /) -> "mpfr": ...
def gamma_inc(a: _RealLike, x: _RealLike, /) -> "mpfr": ...
def hypot(x: _RealLike, y: _RealLike, /) -> "mpfr": ...
def j0(x: _RealLike, /) -> "mpfr": ...
def j1(x: _RealLike, /) -> "mpfr": ...
def jn(n: int, x: _RealLike, /) -> "mpfr": ...
def lgamma(x: _RealLike, /) -> Tuple["mpfr", int]: ...
def li2(x: _RealLike, /) -> "mpfr": ...
def lngamma(x: _RealLike, /) -> "mpfr": ...
def log1p(x: _RealLike, /) -> "mpfr": ...
def log2(x: _RealLike, /) -> "mpfr": ...
def maxnum(x: _RealLike, y: _RealLike, /) -> "mpfr": ...
def minnum(x: _RealLike, y: _RealLike, /) -> "mpfr": ...
def modf(x: _RealLike, /) -> Tuple["mpfr", "mpfr"]: ...
def reldiff(x: _RealLike, y: _RealLike, /) -> "mpfr": ...
def root(x: _RealLike, n: int, /) -> "mpfr": ...
def rootn(x: _RealLike, n: int, /) -> "mpfr": ...
def sec(x: _RealLike, /) -> "mpfr": ...
def sech(x: _RealLike, /) -> "mpfr": ...
@overload
def sin_cos(x: _RealLike, /) -> Tuple["mpfr", "mpfr"]: ...
@overload
def sin_cos(x: "mpc", /) -> Tuple["mpc", "mpc"]: ...
# No implementation signature in stubs
def sinh_cosh(x: _RealLike, /) -> Tuple["mpfr", "mpfr"]: ...
def y0(x: _RealLike, /) -> "mpfr": ...
def y1(x: _RealLike, /) -> "mpfr": ...
def yn(n: int, x: _RealLike, /) -> "mpfr": ...
def zeta(x: _RealLike, /) -> "mpfr": ...
def qdiv(x: Union[_IntLike, "mpq"], y: Union[_IntLike, "mpq"] = 1, /) -> Union["mpz", "mpq"]: ...

# --- Context related functions (module level) ---
def ieee(size: int, subnormalize: bool = True, /) -> context: ...
@overload
def local_context(**kwargs: Any) -> context: ...
@overload
def local_context(ctx: context, /, **kwargs: Any) -> context: ...
# No implementation signature in stubs
def set_context(ctx: context, /) -> None: ...
def get_context() -> context: ...

# --- Misc Functions (module level) ---
def digits(x: _ComplexLike, base: int = 10, prec: int = 0, /) -> str: ...
def to_binary(x: Union[mpz, xmpz, mpq, mpfr, mpc], /) -> bytes: ...
def from_binary(data: bytes, /) -> Union[mpz, xmpz, mpq, mpfr, mpc]: ...
def license() -> str: ...
def mp_limbsize() -> int: ...
def cmp(x: _RealLike, y: _RealLike, /) -> int: ...
def cmp_abs(x: _ComplexLike, y: _ComplexLike, /) -> int: ...
def get_exp(x: _RealLike, /) -> int: ...
def inf(n: Optional[_RealLike] = None, /) -> "mpfr": ...
def is_finite(x: _ComplexLike, /) -> bool: ...
def is_infinite(x: _ComplexLike, /) -> bool: ...
def is_integer(x: _RealLike, /) -> bool: ...
def is_nan(x: _ComplexLike, /) -> bool: ...
def is_regular(x: _RealLike, /) -> bool: ...
def is_signed(x: _RealLike, /) -> bool: ...
def is_unordered(x: _RealLike, y: _RealLike, /) -> bool: ...
def is_zero(x: _ComplexLike, /) -> bool: ...
def mpfr_from_old_binary(data: bytes, /) -> "mpfr": ...
def nan() -> "mpfr": ...
def next_above(x: "mpfr", /) -> "mpfr": ...
def next_below(x: "mpfr", /) -> "mpfr": ...
def radians(x: _RealLike, /) -> "mpfr": ...
def degrees(x: _RealLike, /) -> "mpfr": ...
def rec_sqrt(x: _RealLike, /) -> "mpfr": ...
def set_exp(x: "mpfr", n: int, /) -> "mpfr": ...
def set_sign(x: "mpfr", s: bool, /) -> "mpfr": ...
def sign(x: _RealLike, /) -> int: ...
def zero(n: Optional[_RealLike] = None, /) -> "mpfr": ...
def copy_sign(x: "mpfr", y: _RealLike, /) -> "mpfr": ...
def can_round(b: "mpfr", err: int, rnd1: int, rnd2: int, prec: int, /) -> bool: ...
def free_cache() -> None: ...
def check_range(x: _RealLike, /) -> "mpfr": ...
def polar(x: "mpc", /) -> Tuple["mpfr", "mpfr"]: ...
def proj(x: "mpc", /) -> "mpc": ...
def rect(r: _RealLike, phi: _RealLike, /) -> "mpc": ...
def norm(x: "mpc", /) -> "mpfr": ...
def phase(x: "mpc", /) -> "mpfr": ...
def div_2exp(x: Union[mpfr, mpc], n: int, /) -> Union[mpfr, mpc]: ...
def mul_2exp(x: Union[mpfr, mpc], n: int, /) -> Union[mpfr, mpc]: ...

# --- Version Info ---
__version__: str = "2.2.1"