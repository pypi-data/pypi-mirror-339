# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'CatalogAccessControlSharedWithArgs',
    'CatalogAccessControlSharedWithArgsDict',
    'CatalogItemMetadataEntryArgs',
    'CatalogItemMetadataEntryArgsDict',
    'CatalogMediaMetadataEntryArgs',
    'CatalogMediaMetadataEntryArgsDict',
    'CatalogMetadataEntryArgs',
    'CatalogMetadataEntryArgsDict',
    'CatalogVappTemplateCaptureVappArgs',
    'CatalogVappTemplateCaptureVappArgsDict',
    'CatalogVappTemplateLeaseArgs',
    'CatalogVappTemplateLeaseArgsDict',
    'CatalogVappTemplateMetadataEntryArgs',
    'CatalogVappTemplateMetadataEntryArgsDict',
    'CseKubernetesClusterControlPlaneArgs',
    'CseKubernetesClusterControlPlaneArgsDict',
    'CseKubernetesClusterDefaultStorageClassArgs',
    'CseKubernetesClusterDefaultStorageClassArgsDict',
    'CseKubernetesClusterEventArgs',
    'CseKubernetesClusterEventArgsDict',
    'CseKubernetesClusterWorkerPoolArgs',
    'CseKubernetesClusterWorkerPoolArgsDict',
    'DseRegistryConfigurationContainerRegistryArgs',
    'DseRegistryConfigurationContainerRegistryArgsDict',
    'EdgegatewayExternalNetworkArgs',
    'EdgegatewayExternalNetworkArgsDict',
    'EdgegatewayExternalNetworkSubnetArgs',
    'EdgegatewayExternalNetworkSubnetArgsDict',
    'EdgegatewayExternalNetworkSubnetSuballocatePoolArgs',
    'EdgegatewayExternalNetworkSubnetSuballocatePoolArgsDict',
    'EdgegatewayVpnLocalSubnetArgs',
    'EdgegatewayVpnLocalSubnetArgsDict',
    'EdgegatewayVpnPeerSubnetArgs',
    'EdgegatewayVpnPeerSubnetArgsDict',
    'ExternalNetworkIpScopeArgs',
    'ExternalNetworkIpScopeArgsDict',
    'ExternalNetworkIpScopeStaticIpPoolArgs',
    'ExternalNetworkIpScopeStaticIpPoolArgsDict',
    'ExternalNetworkV2IpScopeArgs',
    'ExternalNetworkV2IpScopeArgsDict',
    'ExternalNetworkV2IpScopeStaticIpPoolArgs',
    'ExternalNetworkV2IpScopeStaticIpPoolArgsDict',
    'ExternalNetworkV2NsxtNetworkArgs',
    'ExternalNetworkV2NsxtNetworkArgsDict',
    'ExternalNetworkV2VsphereNetworkArgs',
    'ExternalNetworkV2VsphereNetworkArgsDict',
    'ExternalNetworkVsphereNetworkArgs',
    'ExternalNetworkVsphereNetworkArgsDict',
    'IndependentDiskMetadataEntryArgs',
    'IndependentDiskMetadataEntryArgsDict',
    'IpSpaceCustomQuotaIpPrefixQuotaArgs',
    'IpSpaceCustomQuotaIpPrefixQuotaArgsDict',
    'IpSpaceIpPrefixArgs',
    'IpSpaceIpPrefixArgsDict',
    'IpSpaceIpPrefixPrefixArgs',
    'IpSpaceIpPrefixPrefixArgsDict',
    'IpSpaceIpRangeArgs',
    'IpSpaceIpRangeArgsDict',
    'LbServerPoolMemberArgs',
    'LbServerPoolMemberArgsDict',
    'NetworkDirectMetadataEntryArgs',
    'NetworkDirectMetadataEntryArgsDict',
    'NetworkIsolatedDhcpPoolArgs',
    'NetworkIsolatedDhcpPoolArgsDict',
    'NetworkIsolatedMetadataEntryArgs',
    'NetworkIsolatedMetadataEntryArgsDict',
    'NetworkIsolatedStaticIpPoolArgs',
    'NetworkIsolatedStaticIpPoolArgsDict',
    'NetworkIsolatedV2MetadataEntryArgs',
    'NetworkIsolatedV2MetadataEntryArgsDict',
    'NetworkIsolatedV2SecondaryStaticIpPoolArgs',
    'NetworkIsolatedV2SecondaryStaticIpPoolArgsDict',
    'NetworkIsolatedV2StaticIpPoolArgs',
    'NetworkIsolatedV2StaticIpPoolArgsDict',
    'NetworkPoolBackingArgs',
    'NetworkPoolBackingArgsDict',
    'NetworkPoolBackingDistributedSwitchArgs',
    'NetworkPoolBackingDistributedSwitchArgsDict',
    'NetworkPoolBackingPortGroupArgs',
    'NetworkPoolBackingPortGroupArgsDict',
    'NetworkPoolBackingRangeIdArgs',
    'NetworkPoolBackingRangeIdArgsDict',
    'NetworkPoolBackingTransportZoneArgs',
    'NetworkPoolBackingTransportZoneArgsDict',
    'NetworkRoutedDhcpPoolArgs',
    'NetworkRoutedDhcpPoolArgsDict',
    'NetworkRoutedMetadataEntryArgs',
    'NetworkRoutedMetadataEntryArgsDict',
    'NetworkRoutedStaticIpPoolArgs',
    'NetworkRoutedStaticIpPoolArgsDict',
    'NetworkRoutedV2MetadataEntryArgs',
    'NetworkRoutedV2MetadataEntryArgsDict',
    'NetworkRoutedV2SecondaryStaticIpPoolArgs',
    'NetworkRoutedV2SecondaryStaticIpPoolArgsDict',
    'NetworkRoutedV2StaticIpPoolArgs',
    'NetworkRoutedV2StaticIpPoolArgsDict',
    'NsxtAlbPoolHealthMonitorArgs',
    'NsxtAlbPoolHealthMonitorArgsDict',
    'NsxtAlbPoolMemberArgs',
    'NsxtAlbPoolMemberArgsDict',
    'NsxtAlbPoolPersistenceProfileArgs',
    'NsxtAlbPoolPersistenceProfileArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgsDict',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgs',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgsDict',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgs',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgsDict',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgs',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgsDict',
    'NsxtAlbVirtualServiceServicePortArgs',
    'NsxtAlbVirtualServiceServicePortArgsDict',
    'NsxtAppPortProfileAppPortArgs',
    'NsxtAppPortProfileAppPortArgsDict',
    'NsxtDistributedFirewallRuleArgs',
    'NsxtDistributedFirewallRuleArgsDict',
    'NsxtDynamicSecurityGroupCriteriaArgs',
    'NsxtDynamicSecurityGroupCriteriaArgsDict',
    'NsxtDynamicSecurityGroupCriteriaRuleArgs',
    'NsxtDynamicSecurityGroupCriteriaRuleArgsDict',
    'NsxtDynamicSecurityGroupMemberVmArgs',
    'NsxtDynamicSecurityGroupMemberVmArgsDict',
    'NsxtEdgegatewayBgpIpPrefixListIpPrefixArgs',
    'NsxtEdgegatewayBgpIpPrefixListIpPrefixArgsDict',
    'NsxtEdgegatewayDnsConditionalForwarderZoneArgs',
    'NsxtEdgegatewayDnsConditionalForwarderZoneArgsDict',
    'NsxtEdgegatewayDnsDefaultForwarderZoneArgs',
    'NsxtEdgegatewayDnsDefaultForwarderZoneArgsDict',
    'NsxtEdgegatewayExternalNetworkArgs',
    'NsxtEdgegatewayExternalNetworkArgsDict',
    'NsxtEdgegatewayL2VpnTunnelStretchedNetworkArgs',
    'NsxtEdgegatewayL2VpnTunnelStretchedNetworkArgsDict',
    'NsxtEdgegatewayStaticRouteNextHopArgs',
    'NsxtEdgegatewayStaticRouteNextHopArgsDict',
    'NsxtEdgegatewayStaticRouteNextHopScopeArgs',
    'NsxtEdgegatewayStaticRouteNextHopScopeArgsDict',
    'NsxtEdgegatewaySubnetArgs',
    'NsxtEdgegatewaySubnetArgsDict',
    'NsxtEdgegatewaySubnetAllocatedIpArgs',
    'NsxtEdgegatewaySubnetAllocatedIpArgsDict',
    'NsxtEdgegatewaySubnetWithIpCountArgs',
    'NsxtEdgegatewaySubnetWithIpCountArgsDict',
    'NsxtEdgegatewaySubnetWithTotalIpCountArgs',
    'NsxtEdgegatewaySubnetWithTotalIpCountArgsDict',
    'NsxtFirewallRuleArgs',
    'NsxtFirewallRuleArgsDict',
    'NsxtIpsecVpnTunnelSecurityProfileCustomizationArgs',
    'NsxtIpsecVpnTunnelSecurityProfileCustomizationArgsDict',
    'NsxtNetworkDhcpBindingDhcpV4ConfigArgs',
    'NsxtNetworkDhcpBindingDhcpV4ConfigArgsDict',
    'NsxtNetworkDhcpBindingDhcpV6ConfigArgs',
    'NsxtNetworkDhcpBindingDhcpV6ConfigArgsDict',
    'NsxtNetworkDhcpPoolArgs',
    'NsxtNetworkDhcpPoolArgsDict',
    'NsxtNetworkImportedSecondaryStaticIpPoolArgs',
    'NsxtNetworkImportedSecondaryStaticIpPoolArgsDict',
    'NsxtNetworkImportedStaticIpPoolArgs',
    'NsxtNetworkImportedStaticIpPoolArgsDict',
    'NsxtSecurityGroupMemberVmArgs',
    'NsxtSecurityGroupMemberVmArgsDict',
    'NsxvDhcpRelayRelayAgentArgs',
    'NsxvDhcpRelayRelayAgentArgsDict',
    'NsxvDistributedFirewallRuleArgs',
    'NsxvDistributedFirewallRuleArgsDict',
    'NsxvDistributedFirewallRuleApplicationArgs',
    'NsxvDistributedFirewallRuleApplicationArgsDict',
    'NsxvDistributedFirewallRuleAppliedToArgs',
    'NsxvDistributedFirewallRuleAppliedToArgsDict',
    'NsxvDistributedFirewallRuleDestinationArgs',
    'NsxvDistributedFirewallRuleDestinationArgsDict',
    'NsxvDistributedFirewallRuleSourceArgs',
    'NsxvDistributedFirewallRuleSourceArgsDict',
    'NsxvFirewallRuleDestinationArgs',
    'NsxvFirewallRuleDestinationArgsDict',
    'NsxvFirewallRuleServiceArgs',
    'NsxvFirewallRuleServiceArgsDict',
    'NsxvFirewallRuleSourceArgs',
    'NsxvFirewallRuleSourceArgsDict',
    'OrgAccountLockoutArgs',
    'OrgAccountLockoutArgsDict',
    'OrgLdapCustomSettingsArgs',
    'OrgLdapCustomSettingsArgsDict',
    'OrgLdapCustomSettingsGroupAttributesArgs',
    'OrgLdapCustomSettingsGroupAttributesArgsDict',
    'OrgLdapCustomSettingsUserAttributesArgs',
    'OrgLdapCustomSettingsUserAttributesArgsDict',
    'OrgMetadataEntryArgs',
    'OrgMetadataEntryArgsDict',
    'OrgOidcClaimsMappingArgs',
    'OrgOidcClaimsMappingArgsDict',
    'OrgOidcKeyArgs',
    'OrgOidcKeyArgsDict',
    'OrgVappLeaseArgs',
    'OrgVappLeaseArgsDict',
    'OrgVappTemplateLeaseArgs',
    'OrgVappTemplateLeaseArgsDict',
    'OrgVdcAccessControlSharedWithArgs',
    'OrgVdcAccessControlSharedWithArgsDict',
    'OrgVdcComputeCapacityArgs',
    'OrgVdcComputeCapacityArgsDict',
    'OrgVdcComputeCapacityCpuArgs',
    'OrgVdcComputeCapacityCpuArgsDict',
    'OrgVdcComputeCapacityMemoryArgs',
    'OrgVdcComputeCapacityMemoryArgsDict',
    'OrgVdcMetadataEntryArgs',
    'OrgVdcMetadataEntryArgsDict',
    'OrgVdcStorageProfileArgs',
    'OrgVdcStorageProfileArgsDict',
    'OrgVdcTemplateComputeConfigurationArgs',
    'OrgVdcTemplateComputeConfigurationArgsDict',
    'OrgVdcTemplateEdgeGatewayArgs',
    'OrgVdcTemplateEdgeGatewayArgsDict',
    'OrgVdcTemplateEdgeGatewayStaticIpPoolArgs',
    'OrgVdcTemplateEdgeGatewayStaticIpPoolArgsDict',
    'OrgVdcTemplateProviderVdcArgs',
    'OrgVdcTemplateProviderVdcArgsDict',
    'OrgVdcTemplateStorageProfileArgs',
    'OrgVdcTemplateStorageProfileArgsDict',
    'ProviderIgnoreMetadataChangeArgs',
    'ProviderIgnoreMetadataChangeArgsDict',
    'ProviderVdcComputeCapacityArgs',
    'ProviderVdcComputeCapacityArgsDict',
    'ProviderVdcComputeCapacityCpusArgs',
    'ProviderVdcComputeCapacityCpusArgsDict',
    'ProviderVdcComputeCapacityMemoryArgs',
    'ProviderVdcComputeCapacityMemoryArgsDict',
    'ProviderVdcMetadataEntryArgs',
    'ProviderVdcMetadataEntryArgsDict',
    'RdeMetadataEntryArgs',
    'RdeMetadataEntryArgsDict',
    'RdeTypeHookArgs',
    'RdeTypeHookArgsDict',
    'SolutionLandingZoneCatalogArgs',
    'SolutionLandingZoneCatalogArgsDict',
    'SolutionLandingZoneVdcArgs',
    'SolutionLandingZoneVdcArgsDict',
    'SolutionLandingZoneVdcComputePolicyArgs',
    'SolutionLandingZoneVdcComputePolicyArgsDict',
    'SolutionLandingZoneVdcOrgVdcNetworkArgs',
    'SolutionLandingZoneVdcOrgVdcNetworkArgsDict',
    'SolutionLandingZoneVdcStoragePolicyArgs',
    'SolutionLandingZoneVdcStoragePolicyArgsDict',
    'VappAccessControlSharedWithArgs',
    'VappAccessControlSharedWithArgsDict',
    'VappFirewallRulesRuleArgs',
    'VappFirewallRulesRuleArgsDict',
    'VappLeaseArgs',
    'VappLeaseArgsDict',
    'VappMetadataEntryArgs',
    'VappMetadataEntryArgsDict',
    'VappNatRulesRuleArgs',
    'VappNatRulesRuleArgsDict',
    'VappNetworkDhcpPoolArgs',
    'VappNetworkDhcpPoolArgsDict',
    'VappNetworkStaticIpPoolArgs',
    'VappNetworkStaticIpPoolArgsDict',
    'VappStaticRoutingRuleArgs',
    'VappStaticRoutingRuleArgsDict',
    'VappVmBootOptionsArgs',
    'VappVmBootOptionsArgsDict',
    'VappVmCustomizationArgs',
    'VappVmCustomizationArgsDict',
    'VappVmDiskArgs',
    'VappVmDiskArgsDict',
    'VappVmExtraConfigArgs',
    'VappVmExtraConfigArgsDict',
    'VappVmInternalDiskArgs',
    'VappVmInternalDiskArgsDict',
    'VappVmMetadataEntryArgs',
    'VappVmMetadataEntryArgsDict',
    'VappVmNetworkArgs',
    'VappVmNetworkArgsDict',
    'VappVmOverrideTemplateDiskArgs',
    'VappVmOverrideTemplateDiskArgsDict',
    'VappVmSetExtraConfigArgs',
    'VappVmSetExtraConfigArgsDict',
    'VdcGroupParticipatingOrgVdcArgs',
    'VdcGroupParticipatingOrgVdcArgsDict',
    'VmBootOptionsArgs',
    'VmBootOptionsArgsDict',
    'VmCustomizationArgs',
    'VmCustomizationArgsDict',
    'VmDiskArgs',
    'VmDiskArgsDict',
    'VmExtraConfigArgs',
    'VmExtraConfigArgsDict',
    'VmInternalDiskArgs',
    'VmInternalDiskArgsDict',
    'VmMetadataEntryArgs',
    'VmMetadataEntryArgsDict',
    'VmNetworkArgs',
    'VmNetworkArgsDict',
    'VmOverrideTemplateDiskArgs',
    'VmOverrideTemplateDiskArgsDict',
    'VmSetExtraConfigArgs',
    'VmSetExtraConfigArgsDict',
    'VmSizingPolicyCpuArgs',
    'VmSizingPolicyCpuArgsDict',
    'VmSizingPolicyMemoryArgs',
    'VmSizingPolicyMemoryArgsDict',
    'VmVgpuPolicyCpuArgs',
    'VmVgpuPolicyCpuArgsDict',
    'VmVgpuPolicyMemoryArgs',
    'VmVgpuPolicyMemoryArgsDict',
    'VmVgpuPolicyProviderVdcScopeArgs',
    'VmVgpuPolicyProviderVdcScopeArgsDict',
    'VmVgpuPolicyVgpuProfileArgs',
    'VmVgpuPolicyVgpuProfileArgsDict',
    'GetCatalogFilterArgs',
    'GetCatalogFilterArgsDict',
    'GetCatalogFilterMetadataArgs',
    'GetCatalogFilterMetadataArgsDict',
    'GetCatalogItemFilterArgs',
    'GetCatalogItemFilterArgsDict',
    'GetCatalogItemFilterMetadataArgs',
    'GetCatalogItemFilterMetadataArgsDict',
    'GetCatalogMediaFilterArgs',
    'GetCatalogMediaFilterArgsDict',
    'GetCatalogMediaFilterMetadataArgs',
    'GetCatalogMediaFilterMetadataArgsDict',
    'GetCatalogVappTemplateFilterArgs',
    'GetCatalogVappTemplateFilterArgsDict',
    'GetCatalogVappTemplateFilterMetadataArgs',
    'GetCatalogVappTemplateFilterMetadataArgsDict',
    'GetEdgegatewayFilterArgs',
    'GetEdgegatewayFilterArgsDict',
    'GetNetworkDirectFilterArgs',
    'GetNetworkDirectFilterArgsDict',
    'GetNetworkDirectFilterMetadataArgs',
    'GetNetworkDirectFilterMetadataArgsDict',
    'GetNetworkIsolatedFilterArgs',
    'GetNetworkIsolatedFilterArgsDict',
    'GetNetworkIsolatedFilterMetadataArgs',
    'GetNetworkIsolatedFilterMetadataArgsDict',
    'GetNetworkIsolatedV2FilterArgs',
    'GetNetworkIsolatedV2FilterArgsDict',
    'GetNetworkRoutedFilterArgs',
    'GetNetworkRoutedFilterArgsDict',
    'GetNetworkRoutedFilterMetadataArgs',
    'GetNetworkRoutedFilterMetadataArgsDict',
    'GetNetworkRoutedV2FilterArgs',
    'GetNetworkRoutedV2FilterArgsDict',
    'GetNsxtNetworkImportedFilterArgs',
    'GetNsxtNetworkImportedFilterArgsDict',
    'GetSubscribedCatalogFilterArgs',
    'GetSubscribedCatalogFilterArgsDict',
    'GetSubscribedCatalogFilterMetadataArgs',
    'GetSubscribedCatalogFilterMetadataArgsDict',
]

MYPY = False

if not MYPY:
    class CatalogAccessControlSharedWithArgsDict(TypedDict):
        access_level: pulumi.Input[str]
        """
        The access level for the user or group to which we are sharing. (One of `ReadOnly`, 
        `Change`, `FullControl`, but it can only be `ReadOnly` when we share to an Organization)
        """
        group_id: NotRequired[pulumi.Input[str]]
        """
        The ID of a group with which we are sharing. Required if `user_id` or `org_id` is not set.
        """
        org_id: NotRequired[pulumi.Input[str]]
        """
        The ID of a group with which we are sharing. Required if `user_id` or `group_id` is not set.
        """
        subject_name: NotRequired[pulumi.Input[str]]
        """
        the name of the subject (Org, group, or user) with which we are sharing.
        """
        user_id: NotRequired[pulumi.Input[str]]
        """
        The ID of a user with which we are sharing. Required if `group_id` or `org_id` is not set.
        """
elif False:
    CatalogAccessControlSharedWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogAccessControlSharedWithArgs:
    def __init__(__self__, *,
                 access_level: pulumi.Input[str],
                 group_id: Optional[pulumi.Input[str]] = None,
                 org_id: Optional[pulumi.Input[str]] = None,
                 subject_name: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_level: The access level for the user or group to which we are sharing. (One of `ReadOnly`, 
               `Change`, `FullControl`, but it can only be `ReadOnly` when we share to an Organization)
        :param pulumi.Input[str] group_id: The ID of a group with which we are sharing. Required if `user_id` or `org_id` is not set.
        :param pulumi.Input[str] org_id: The ID of a group with which we are sharing. Required if `user_id` or `group_id` is not set.
        :param pulumi.Input[str] subject_name: the name of the subject (Org, group, or user) with which we are sharing.
        :param pulumi.Input[str] user_id: The ID of a user with which we are sharing. Required if `group_id` or `org_id` is not set.
        """
        pulumi.set(__self__, "access_level", access_level)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> pulumi.Input[str]:
        """
        The access level for the user or group to which we are sharing. (One of `ReadOnly`, 
        `Change`, `FullControl`, but it can only be `ReadOnly` when we share to an Organization)
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a group with which we are sharing. Required if `user_id` or `org_id` is not set.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a group with which we are sharing. Required if `user_id` or `group_id` is not set.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[pulumi.Input[str]]:
        """
        the name of the subject (Org, group, or user) with which we are sharing.
        """
        return pulumi.get(self, "subject_name")

    @subject_name.setter
    def subject_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_name", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a user with which we are sharing. Required if `group_id` or `org_id` is not set.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class CatalogItemMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    CatalogItemMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogItemMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CatalogMediaMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    CatalogMediaMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogMediaMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CatalogMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    CatalogMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CatalogVappTemplateCaptureVappArgsDict(TypedDict):
        copy_tpm_on_instantiate: NotRequired[pulumi.Input[bool]]
        """
        Defines if Trusted Platform Module should be copied (false) or created (true). Default 'false'. VCD 10.4.2+
        """
        customize_on_instantiate: NotRequired[pulumi.Input[bool]]
        """
        Marks if instantiating applies customization settings ('true'). Default is 'false` - create an identical copy.
        """
        overwrite_catalog_item_id: NotRequired[pulumi.Input[str]]
        """
        An existing catalog item ID to overwrite
        """
        source_id: NotRequired[pulumi.Input[str]]
        """
        Source vApp ID (can be a vApp ID or 'vapp_id' field of standalone VM 'vcd_vm')
        """
elif False:
    CatalogVappTemplateCaptureVappArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogVappTemplateCaptureVappArgs:
    def __init__(__self__, *,
                 copy_tpm_on_instantiate: Optional[pulumi.Input[bool]] = None,
                 customize_on_instantiate: Optional[pulumi.Input[bool]] = None,
                 overwrite_catalog_item_id: Optional[pulumi.Input[str]] = None,
                 source_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] copy_tpm_on_instantiate: Defines if Trusted Platform Module should be copied (false) or created (true). Default 'false'. VCD 10.4.2+
        :param pulumi.Input[bool] customize_on_instantiate: Marks if instantiating applies customization settings ('true'). Default is 'false` - create an identical copy.
        :param pulumi.Input[str] overwrite_catalog_item_id: An existing catalog item ID to overwrite
        :param pulumi.Input[str] source_id: Source vApp ID (can be a vApp ID or 'vapp_id' field of standalone VM 'vcd_vm')
        """
        if copy_tpm_on_instantiate is not None:
            pulumi.set(__self__, "copy_tpm_on_instantiate", copy_tpm_on_instantiate)
        if customize_on_instantiate is not None:
            pulumi.set(__self__, "customize_on_instantiate", customize_on_instantiate)
        if overwrite_catalog_item_id is not None:
            pulumi.set(__self__, "overwrite_catalog_item_id", overwrite_catalog_item_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)

    @property
    @pulumi.getter(name="copyTpmOnInstantiate")
    def copy_tpm_on_instantiate(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if Trusted Platform Module should be copied (false) or created (true). Default 'false'. VCD 10.4.2+
        """
        return pulumi.get(self, "copy_tpm_on_instantiate")

    @copy_tpm_on_instantiate.setter
    def copy_tpm_on_instantiate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "copy_tpm_on_instantiate", value)

    @property
    @pulumi.getter(name="customizeOnInstantiate")
    def customize_on_instantiate(self) -> Optional[pulumi.Input[bool]]:
        """
        Marks if instantiating applies customization settings ('true'). Default is 'false` - create an identical copy.
        """
        return pulumi.get(self, "customize_on_instantiate")

    @customize_on_instantiate.setter
    def customize_on_instantiate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "customize_on_instantiate", value)

    @property
    @pulumi.getter(name="overwriteCatalogItemId")
    def overwrite_catalog_item_id(self) -> Optional[pulumi.Input[str]]:
        """
        An existing catalog item ID to overwrite
        """
        return pulumi.get(self, "overwrite_catalog_item_id")

    @overwrite_catalog_item_id.setter
    def overwrite_catalog_item_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "overwrite_catalog_item_id", value)

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[pulumi.Input[str]]:
        """
        Source vApp ID (can be a vApp ID or 'vapp_id' field of standalone VM 'vcd_vm')
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_id", value)


if not MYPY:
    class CatalogVappTemplateLeaseArgsDict(TypedDict):
        storage_lease_in_sec: pulumi.Input[int]
        """
        How long the vApp Template is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by parent Org). Regular values accepted from 3600+.
        """
elif False:
    CatalogVappTemplateLeaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogVappTemplateLeaseArgs:
    def __init__(__self__, *,
                 storage_lease_in_sec: pulumi.Input[int]):
        """
        :param pulumi.Input[int] storage_lease_in_sec: How long the vApp Template is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by parent Org). Regular values accepted from 3600+.
        """
        pulumi.set(__self__, "storage_lease_in_sec", storage_lease_in_sec)

    @property
    @pulumi.getter(name="storageLeaseInSec")
    def storage_lease_in_sec(self) -> pulumi.Input[int]:
        """
        How long the vApp Template is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by parent Org). Regular values accepted from 3600+.
        """
        return pulumi.get(self, "storage_lease_in_sec")

    @storage_lease_in_sec.setter
    def storage_lease_in_sec(self, value: pulumi.Input[int]):
        pulumi.set(self, "storage_lease_in_sec", value)


if not MYPY:
    class CatalogVappTemplateMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    CatalogVappTemplateMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogVappTemplateMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CseKubernetesClusterControlPlaneArgsDict(TypedDict):
        disk_size_gi: NotRequired[pulumi.Input[int]]
        """
        Disk size, in **Gibibytes (Gi)**, for the control plane VMs. Must be at least `20`. Defaults to `20`
        """
        ip: NotRequired[pulumi.Input[str]]
        """
        IP for the control plane. It will be automatically assigned during cluster creation if left empty
        """
        machine_count: NotRequired[pulumi.Input[int]]
        """
        The number of nodes that the control plane has. Must be an odd number and higher than `0`. Defaults to `3`
        """
        placement_policy_id: NotRequired[pulumi.Input[str]]
        """
        VM Placement policy for the control plane VMs
        """
        sizing_policy_id: NotRequired[pulumi.Input[str]]
        """
        VM Sizing policy for the control plane VMs. Must be one of the ones made available during CSE installation
        """
        storage_profile_id: NotRequired[pulumi.Input[str]]
        """
        Storage profile for the control plane VMs
        """
elif False:
    CseKubernetesClusterControlPlaneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseKubernetesClusterControlPlaneArgs:
    def __init__(__self__, *,
                 disk_size_gi: Optional[pulumi.Input[int]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 machine_count: Optional[pulumi.Input[int]] = None,
                 placement_policy_id: Optional[pulumi.Input[str]] = None,
                 sizing_policy_id: Optional[pulumi.Input[str]] = None,
                 storage_profile_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] disk_size_gi: Disk size, in **Gibibytes (Gi)**, for the control plane VMs. Must be at least `20`. Defaults to `20`
        :param pulumi.Input[str] ip: IP for the control plane. It will be automatically assigned during cluster creation if left empty
        :param pulumi.Input[int] machine_count: The number of nodes that the control plane has. Must be an odd number and higher than `0`. Defaults to `3`
        :param pulumi.Input[str] placement_policy_id: VM Placement policy for the control plane VMs
        :param pulumi.Input[str] sizing_policy_id: VM Sizing policy for the control plane VMs. Must be one of the ones made available during CSE installation
        :param pulumi.Input[str] storage_profile_id: Storage profile for the control plane VMs
        """
        if disk_size_gi is not None:
            pulumi.set(__self__, "disk_size_gi", disk_size_gi)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if machine_count is not None:
            pulumi.set(__self__, "machine_count", machine_count)
        if placement_policy_id is not None:
            pulumi.set(__self__, "placement_policy_id", placement_policy_id)
        if sizing_policy_id is not None:
            pulumi.set(__self__, "sizing_policy_id", sizing_policy_id)
        if storage_profile_id is not None:
            pulumi.set(__self__, "storage_profile_id", storage_profile_id)

    @property
    @pulumi.getter(name="diskSizeGi")
    def disk_size_gi(self) -> Optional[pulumi.Input[int]]:
        """
        Disk size, in **Gibibytes (Gi)**, for the control plane VMs. Must be at least `20`. Defaults to `20`
        """
        return pulumi.get(self, "disk_size_gi")

    @disk_size_gi.setter
    def disk_size_gi(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gi", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP for the control plane. It will be automatically assigned during cluster creation if left empty
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="machineCount")
    def machine_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of nodes that the control plane has. Must be an odd number and higher than `0`. Defaults to `3`
        """
        return pulumi.get(self, "machine_count")

    @machine_count.setter
    def machine_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "machine_count", value)

    @property
    @pulumi.getter(name="placementPolicyId")
    def placement_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        VM Placement policy for the control plane VMs
        """
        return pulumi.get(self, "placement_policy_id")

    @placement_policy_id.setter
    def placement_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_policy_id", value)

    @property
    @pulumi.getter(name="sizingPolicyId")
    def sizing_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        VM Sizing policy for the control plane VMs. Must be one of the ones made available during CSE installation
        """
        return pulumi.get(self, "sizing_policy_id")

    @sizing_policy_id.setter
    def sizing_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sizing_policy_id", value)

    @property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> Optional[pulumi.Input[str]]:
        """
        Storage profile for the control plane VMs
        """
        return pulumi.get(self, "storage_profile_id")

    @storage_profile_id.setter
    def storage_profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_profile_id", value)


if not MYPY:
    class CseKubernetesClusterDefaultStorageClassArgsDict(TypedDict):
        filesystem: pulumi.Input[str]
        """
        Filesystem of the storage class, can be either `ext4` or `xfs`
        """
        name: pulumi.Input[str]
        """
        The name of the default storage class. It must contain only lowercase alphanumeric characters or "-",
        start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        """
        reclaim_policy: pulumi.Input[str]
        """
        A value of `delete` deletes the volume when the PersistentVolumeClaim is deleted. `retain` does not,
        and the volume can be manually reclaimed
        """
        storage_profile_id: pulumi.Input[str]
        """
        Storage profile for the default storage class
        """
elif False:
    CseKubernetesClusterDefaultStorageClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseKubernetesClusterDefaultStorageClassArgs:
    def __init__(__self__, *,
                 filesystem: pulumi.Input[str],
                 name: pulumi.Input[str],
                 reclaim_policy: pulumi.Input[str],
                 storage_profile_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] filesystem: Filesystem of the storage class, can be either `ext4` or `xfs`
        :param pulumi.Input[str] name: The name of the default storage class. It must contain only lowercase alphanumeric characters or "-",
               start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        :param pulumi.Input[str] reclaim_policy: A value of `delete` deletes the volume when the PersistentVolumeClaim is deleted. `retain` does not,
               and the volume can be manually reclaimed
        :param pulumi.Input[str] storage_profile_id: Storage profile for the default storage class
        """
        pulumi.set(__self__, "filesystem", filesystem)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "reclaim_policy", reclaim_policy)
        pulumi.set(__self__, "storage_profile_id", storage_profile_id)

    @property
    @pulumi.getter
    def filesystem(self) -> pulumi.Input[str]:
        """
        Filesystem of the storage class, can be either `ext4` or `xfs`
        """
        return pulumi.get(self, "filesystem")

    @filesystem.setter
    def filesystem(self, value: pulumi.Input[str]):
        pulumi.set(self, "filesystem", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the default storage class. It must contain only lowercase alphanumeric characters or "-",
        start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="reclaimPolicy")
    def reclaim_policy(self) -> pulumi.Input[str]:
        """
        A value of `delete` deletes the volume when the PersistentVolumeClaim is deleted. `retain` does not,
        and the volume can be manually reclaimed
        """
        return pulumi.get(self, "reclaim_policy")

    @reclaim_policy.setter
    def reclaim_policy(self, value: pulumi.Input[str]):
        pulumi.set(self, "reclaim_policy", value)

    @property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> pulumi.Input[str]:
        """
        Storage profile for the default storage class
        """
        return pulumi.get(self, "storage_profile_id")

    @storage_profile_id.setter
    def storage_profile_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_profile_id", value)


if not MYPY:
    class CseKubernetesClusterEventArgsDict(TypedDict):
        details: NotRequired[pulumi.Input[str]]
        """
        Details of the event
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
        start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        """
        occurred_at: NotRequired[pulumi.Input[str]]
        """
        When the event happened
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        ID of the resource that caused the event
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the event, either `event` or `error`
        """
elif False:
    CseKubernetesClusterEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseKubernetesClusterEventArgs:
    def __init__(__self__, *,
                 details: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 occurred_at: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] details: Details of the event
        :param pulumi.Input[str] name: The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
               start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        :param pulumi.Input[str] occurred_at: When the event happened
        :param pulumi.Input[str] resource_id: ID of the resource that caused the event
        :param pulumi.Input[str] type: Type of the event, either `event` or `error`
        """
        if details is not None:
            pulumi.set(__self__, "details", details)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if occurred_at is not None:
            pulumi.set(__self__, "occurred_at", occurred_at)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[str]]:
        """
        Details of the event
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
        start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="occurredAt")
    def occurred_at(self) -> Optional[pulumi.Input[str]]:
        """
        When the event happened
        """
        return pulumi.get(self, "occurred_at")

    @occurred_at.setter
    def occurred_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "occurred_at", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the resource that caused the event
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the event, either `event` or `error`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CseKubernetesClusterWorkerPoolArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
        start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        """
        autoscaler_max_replicas: NotRequired[pulumi.Input[int]]
        """
        Maximum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_min_replicas'
        """
        autoscaler_min_replicas: NotRequired[pulumi.Input[int]]
        """
        Minimum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_max_replicas'
        """
        disk_size_gi: NotRequired[pulumi.Input[int]]
        """
        Disk size, in Gibibytes (Gi), for this worker pool
        """
        machine_count: NotRequired[pulumi.Input[int]]
        """
        The number of nodes that this worker pool has. Must be higher than or equal to 0. Ignored if 'autoscaler_max_replicas' and 'autoscaler_min_replicas' are set
        """
        placement_policy_id: NotRequired[pulumi.Input[str]]
        """
        VM Placement policy for this worker pool
        """
        sizing_policy_id: NotRequired[pulumi.Input[str]]
        """
        VM Sizing policy for this worker pool
        """
        storage_profile_id: NotRequired[pulumi.Input[str]]
        """
        Storage profile for this worker pool
        """
        vgpu_policy_id: NotRequired[pulumi.Input[str]]
        """
        vGPU policy for this worker pool
        """
elif False:
    CseKubernetesClusterWorkerPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseKubernetesClusterWorkerPoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 autoscaler_max_replicas: Optional[pulumi.Input[int]] = None,
                 autoscaler_min_replicas: Optional[pulumi.Input[int]] = None,
                 disk_size_gi: Optional[pulumi.Input[int]] = None,
                 machine_count: Optional[pulumi.Input[int]] = None,
                 placement_policy_id: Optional[pulumi.Input[str]] = None,
                 sizing_policy_id: Optional[pulumi.Input[str]] = None,
                 storage_profile_id: Optional[pulumi.Input[str]] = None,
                 vgpu_policy_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
               start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        :param pulumi.Input[int] autoscaler_max_replicas: Maximum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_min_replicas'
        :param pulumi.Input[int] autoscaler_min_replicas: Minimum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_max_replicas'
        :param pulumi.Input[int] disk_size_gi: Disk size, in Gibibytes (Gi), for this worker pool
        :param pulumi.Input[int] machine_count: The number of nodes that this worker pool has. Must be higher than or equal to 0. Ignored if 'autoscaler_max_replicas' and 'autoscaler_min_replicas' are set
        :param pulumi.Input[str] placement_policy_id: VM Placement policy for this worker pool
        :param pulumi.Input[str] sizing_policy_id: VM Sizing policy for this worker pool
        :param pulumi.Input[str] storage_profile_id: Storage profile for this worker pool
        :param pulumi.Input[str] vgpu_policy_id: vGPU policy for this worker pool
        """
        pulumi.set(__self__, "name", name)
        if autoscaler_max_replicas is not None:
            pulumi.set(__self__, "autoscaler_max_replicas", autoscaler_max_replicas)
        if autoscaler_min_replicas is not None:
            pulumi.set(__self__, "autoscaler_min_replicas", autoscaler_min_replicas)
        if disk_size_gi is not None:
            pulumi.set(__self__, "disk_size_gi", disk_size_gi)
        if machine_count is not None:
            pulumi.set(__self__, "machine_count", machine_count)
        if placement_policy_id is not None:
            pulumi.set(__self__, "placement_policy_id", placement_policy_id)
        if sizing_policy_id is not None:
            pulumi.set(__self__, "sizing_policy_id", sizing_policy_id)
        if storage_profile_id is not None:
            pulumi.set(__self__, "storage_profile_id", storage_profile_id)
        if vgpu_policy_id is not None:
            pulumi.set(__self__, "vgpu_policy_id", vgpu_policy_id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
        start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="autoscalerMaxReplicas")
    def autoscaler_max_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_min_replicas'
        """
        return pulumi.get(self, "autoscaler_max_replicas")

    @autoscaler_max_replicas.setter
    def autoscaler_max_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autoscaler_max_replicas", value)

    @property
    @pulumi.getter(name="autoscalerMinReplicas")
    def autoscaler_min_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_max_replicas'
        """
        return pulumi.get(self, "autoscaler_min_replicas")

    @autoscaler_min_replicas.setter
    def autoscaler_min_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autoscaler_min_replicas", value)

    @property
    @pulumi.getter(name="diskSizeGi")
    def disk_size_gi(self) -> Optional[pulumi.Input[int]]:
        """
        Disk size, in Gibibytes (Gi), for this worker pool
        """
        return pulumi.get(self, "disk_size_gi")

    @disk_size_gi.setter
    def disk_size_gi(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gi", value)

    @property
    @pulumi.getter(name="machineCount")
    def machine_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of nodes that this worker pool has. Must be higher than or equal to 0. Ignored if 'autoscaler_max_replicas' and 'autoscaler_min_replicas' are set
        """
        return pulumi.get(self, "machine_count")

    @machine_count.setter
    def machine_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "machine_count", value)

    @property
    @pulumi.getter(name="placementPolicyId")
    def placement_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        VM Placement policy for this worker pool
        """
        return pulumi.get(self, "placement_policy_id")

    @placement_policy_id.setter
    def placement_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_policy_id", value)

    @property
    @pulumi.getter(name="sizingPolicyId")
    def sizing_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        VM Sizing policy for this worker pool
        """
        return pulumi.get(self, "sizing_policy_id")

    @sizing_policy_id.setter
    def sizing_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sizing_policy_id", value)

    @property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> Optional[pulumi.Input[str]]:
        """
        Storage profile for this worker pool
        """
        return pulumi.get(self, "storage_profile_id")

    @storage_profile_id.setter
    def storage_profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_profile_id", value)

    @property
    @pulumi.getter(name="vgpuPolicyId")
    def vgpu_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        vGPU policy for this worker pool
        """
        return pulumi.get(self, "vgpu_policy_id")

    @vgpu_policy_id.setter
    def vgpu_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vgpu_policy_id", value)


if not MYPY:
    class DseRegistryConfigurationContainerRegistryArgsDict(TypedDict):
        description: pulumi.Input[str]
        """
        Registry description
        """
        host: pulumi.Input[str]
        """
        Registry host
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password for registry user
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Username for registry access
        """
elif False:
    DseRegistryConfigurationContainerRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DseRegistryConfigurationContainerRegistryArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[str],
                 host: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Registry description
        :param pulumi.Input[str] host: Registry host
        :param pulumi.Input[str] password: Password for registry user
        :param pulumi.Input[str] username: Username for registry access
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        """
        Registry description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Registry host
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for registry user
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username for registry access
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class EdgegatewayExternalNetworkArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A unique name for the edge gateway.
        """
        enable_rate_limit: NotRequired[pulumi.Input[bool]]
        """
        Enable rate limiting
        """
        incoming_rate_limit: NotRequired[pulumi.Input[float]]
        """
        Incoming rate limit (Mbps)
        """
        outgoing_rate_limit: NotRequired[pulumi.Input[float]]
        """
        Outgoing rate limit (Mbps)
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['EdgegatewayExternalNetworkSubnetArgsDict']]]]
elif False:
    EdgegatewayExternalNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgegatewayExternalNetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 enable_rate_limit: Optional[pulumi.Input[bool]] = None,
                 incoming_rate_limit: Optional[pulumi.Input[float]] = None,
                 outgoing_rate_limit: Optional[pulumi.Input[float]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input['EdgegatewayExternalNetworkSubnetArgs']]]] = None):
        """
        :param pulumi.Input[str] name: A unique name for the edge gateway.
        :param pulumi.Input[bool] enable_rate_limit: Enable rate limiting
        :param pulumi.Input[float] incoming_rate_limit: Incoming rate limit (Mbps)
        :param pulumi.Input[float] outgoing_rate_limit: Outgoing rate limit (Mbps)
        """
        pulumi.set(__self__, "name", name)
        if enable_rate_limit is not None:
            pulumi.set(__self__, "enable_rate_limit", enable_rate_limit)
        if incoming_rate_limit is not None:
            pulumi.set(__self__, "incoming_rate_limit", incoming_rate_limit)
        if outgoing_rate_limit is not None:
            pulumi.set(__self__, "outgoing_rate_limit", outgoing_rate_limit)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A unique name for the edge gateway.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="enableRateLimit")
    def enable_rate_limit(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable rate limiting
        """
        return pulumi.get(self, "enable_rate_limit")

    @enable_rate_limit.setter
    def enable_rate_limit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_rate_limit", value)

    @property
    @pulumi.getter(name="incomingRateLimit")
    def incoming_rate_limit(self) -> Optional[pulumi.Input[float]]:
        """
        Incoming rate limit (Mbps)
        """
        return pulumi.get(self, "incoming_rate_limit")

    @incoming_rate_limit.setter
    def incoming_rate_limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "incoming_rate_limit", value)

    @property
    @pulumi.getter(name="outgoingRateLimit")
    def outgoing_rate_limit(self) -> Optional[pulumi.Input[float]]:
        """
        Outgoing rate limit (Mbps)
        """
        return pulumi.get(self, "outgoing_rate_limit")

    @outgoing_rate_limit.setter
    def outgoing_rate_limit(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "outgoing_rate_limit", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EdgegatewayExternalNetworkSubnetArgs']]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EdgegatewayExternalNetworkSubnetArgs']]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class EdgegatewayExternalNetworkSubnetArgsDict(TypedDict):
        gateway: pulumi.Input[str]
        """
        Gateway address for a subnet
        """
        netmask: pulumi.Input[str]
        """
        Netmask address for a subnet
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        IP address on the edge gateway - will be auto-assigned if not defined
        """
        suballocate_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['EdgegatewayExternalNetworkSubnetSuballocatePoolArgsDict']]]]
        """
        Define zero or more blocks to sub-allocate pools on the edge gateway
        """
        use_for_default_route: NotRequired[pulumi.Input[bool]]
        """
        Defines if this subnet should be used as default gateway for edge
        """
elif False:
    EdgegatewayExternalNetworkSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgegatewayExternalNetworkSubnetArgs:
    def __init__(__self__, *,
                 gateway: pulumi.Input[str],
                 netmask: pulumi.Input[str],
                 ip_address: Optional[pulumi.Input[str]] = None,
                 suballocate_pools: Optional[pulumi.Input[Sequence[pulumi.Input['EdgegatewayExternalNetworkSubnetSuballocatePoolArgs']]]] = None,
                 use_for_default_route: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] gateway: Gateway address for a subnet
        :param pulumi.Input[str] netmask: Netmask address for a subnet
        :param pulumi.Input[str] ip_address: IP address on the edge gateway - will be auto-assigned if not defined
        :param pulumi.Input[Sequence[pulumi.Input['EdgegatewayExternalNetworkSubnetSuballocatePoolArgs']]] suballocate_pools: Define zero or more blocks to sub-allocate pools on the edge gateway
        :param pulumi.Input[bool] use_for_default_route: Defines if this subnet should be used as default gateway for edge
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if suballocate_pools is not None:
            pulumi.set(__self__, "suballocate_pools", suballocate_pools)
        if use_for_default_route is not None:
            pulumi.set(__self__, "use_for_default_route", use_for_default_route)

    @property
    @pulumi.getter
    def gateway(self) -> pulumi.Input[str]:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def netmask(self) -> pulumi.Input[str]:
        """
        Netmask address for a subnet
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: pulumi.Input[str]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        IP address on the edge gateway - will be auto-assigned if not defined
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="suballocatePools")
    def suballocate_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EdgegatewayExternalNetworkSubnetSuballocatePoolArgs']]]]:
        """
        Define zero or more blocks to sub-allocate pools on the edge gateway
        """
        return pulumi.get(self, "suballocate_pools")

    @suballocate_pools.setter
    def suballocate_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EdgegatewayExternalNetworkSubnetSuballocatePoolArgs']]]]):
        pulumi.set(self, "suballocate_pools", value)

    @property
    @pulumi.getter(name="useForDefaultRoute")
    def use_for_default_route(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if this subnet should be used as default gateway for edge
        """
        return pulumi.get(self, "use_for_default_route")

    @use_for_default_route.setter
    def use_for_default_route(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_for_default_route", value)


if not MYPY:
    class EdgegatewayExternalNetworkSubnetSuballocatePoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        start_address: pulumi.Input[str]
elif False:
    EdgegatewayExternalNetworkSubnetSuballocatePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgegatewayExternalNetworkSubnetSuballocatePoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class EdgegatewayVpnLocalSubnetArgsDict(TypedDict):
        local_subnet_gateway: pulumi.Input[str]
        local_subnet_mask: pulumi.Input[str]
        local_subnet_name: pulumi.Input[str]
elif False:
    EdgegatewayVpnLocalSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgegatewayVpnLocalSubnetArgs:
    def __init__(__self__, *,
                 local_subnet_gateway: pulumi.Input[str],
                 local_subnet_mask: pulumi.Input[str],
                 local_subnet_name: pulumi.Input[str]):
        pulumi.set(__self__, "local_subnet_gateway", local_subnet_gateway)
        pulumi.set(__self__, "local_subnet_mask", local_subnet_mask)
        pulumi.set(__self__, "local_subnet_name", local_subnet_name)

    @property
    @pulumi.getter(name="localSubnetGateway")
    def local_subnet_gateway(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_subnet_gateway")

    @local_subnet_gateway.setter
    def local_subnet_gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_subnet_gateway", value)

    @property
    @pulumi.getter(name="localSubnetMask")
    def local_subnet_mask(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_subnet_mask")

    @local_subnet_mask.setter
    def local_subnet_mask(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_subnet_mask", value)

    @property
    @pulumi.getter(name="localSubnetName")
    def local_subnet_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "local_subnet_name")

    @local_subnet_name.setter
    def local_subnet_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_subnet_name", value)


if not MYPY:
    class EdgegatewayVpnPeerSubnetArgsDict(TypedDict):
        peer_subnet_gateway: pulumi.Input[str]
        peer_subnet_mask: pulumi.Input[str]
        peer_subnet_name: pulumi.Input[str]
elif False:
    EdgegatewayVpnPeerSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EdgegatewayVpnPeerSubnetArgs:
    def __init__(__self__, *,
                 peer_subnet_gateway: pulumi.Input[str],
                 peer_subnet_mask: pulumi.Input[str],
                 peer_subnet_name: pulumi.Input[str]):
        pulumi.set(__self__, "peer_subnet_gateway", peer_subnet_gateway)
        pulumi.set(__self__, "peer_subnet_mask", peer_subnet_mask)
        pulumi.set(__self__, "peer_subnet_name", peer_subnet_name)

    @property
    @pulumi.getter(name="peerSubnetGateway")
    def peer_subnet_gateway(self) -> pulumi.Input[str]:
        return pulumi.get(self, "peer_subnet_gateway")

    @peer_subnet_gateway.setter
    def peer_subnet_gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "peer_subnet_gateway", value)

    @property
    @pulumi.getter(name="peerSubnetMask")
    def peer_subnet_mask(self) -> pulumi.Input[str]:
        return pulumi.get(self, "peer_subnet_mask")

    @peer_subnet_mask.setter
    def peer_subnet_mask(self, value: pulumi.Input[str]):
        pulumi.set(self, "peer_subnet_mask", value)

    @property
    @pulumi.getter(name="peerSubnetName")
    def peer_subnet_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "peer_subnet_name")

    @peer_subnet_name.setter
    def peer_subnet_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "peer_subnet_name", value)


if not MYPY:
    class ExternalNetworkIpScopeArgsDict(TypedDict):
        gateway: pulumi.Input[str]
        """
        Gateway of the network
        """
        netmask: pulumi.Input[str]
        """
        Network mask
        """
        dns1: NotRequired[pulumi.Input[str]]
        """
        Primary DNS server
        """
        dns2: NotRequired[pulumi.Input[str]]
        """
        Secondary DNS server
        """
        dns_suffix: NotRequired[pulumi.Input[str]]
        """
        DNS suffix
        """
        static_ip_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExternalNetworkIpScopeStaticIpPoolArgsDict']]]]
        """
        IP ranges used for static pool allocation in the network
        """
elif False:
    ExternalNetworkIpScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNetworkIpScopeArgs:
    def __init__(__self__, *,
                 gateway: pulumi.Input[str],
                 netmask: pulumi.Input[str],
                 dns1: Optional[pulumi.Input[str]] = None,
                 dns2: Optional[pulumi.Input[str]] = None,
                 dns_suffix: Optional[pulumi.Input[str]] = None,
                 static_ip_pools: Optional[pulumi.Input[Sequence[pulumi.Input['ExternalNetworkIpScopeStaticIpPoolArgs']]]] = None):
        """
        :param pulumi.Input[str] gateway: Gateway of the network
        :param pulumi.Input[str] netmask: Network mask
        :param pulumi.Input[str] dns1: Primary DNS server
        :param pulumi.Input[str] dns2: Secondary DNS server
        :param pulumi.Input[str] dns_suffix: DNS suffix
        :param pulumi.Input[Sequence[pulumi.Input['ExternalNetworkIpScopeStaticIpPoolArgs']]] static_ip_pools: IP ranges used for static pool allocation in the network
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        if dns1 is not None:
            pulumi.set(__self__, "dns1", dns1)
        if dns2 is not None:
            pulumi.set(__self__, "dns2", dns2)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)
        if static_ip_pools is not None:
            pulumi.set(__self__, "static_ip_pools", static_ip_pools)

    @property
    @pulumi.getter
    def gateway(self) -> pulumi.Input[str]:
        """
        Gateway of the network
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def netmask(self) -> pulumi.Input[str]:
        """
        Network mask
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: pulumi.Input[str]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def dns1(self) -> Optional[pulumi.Input[str]]:
        """
        Primary DNS server
        """
        return pulumi.get(self, "dns1")

    @dns1.setter
    def dns1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns1", value)

    @property
    @pulumi.getter
    def dns2(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary DNS server
        """
        return pulumi.get(self, "dns2")

    @dns2.setter
    def dns2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns2", value)

    @property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        DNS suffix
        """
        return pulumi.get(self, "dns_suffix")

    @dns_suffix.setter
    def dns_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_suffix", value)

    @property
    @pulumi.getter(name="staticIpPools")
    def static_ip_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExternalNetworkIpScopeStaticIpPoolArgs']]]]:
        """
        IP ranges used for static pool allocation in the network
        """
        return pulumi.get(self, "static_ip_pools")

    @static_ip_pools.setter
    def static_ip_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExternalNetworkIpScopeStaticIpPoolArgs']]]]):
        pulumi.set(self, "static_ip_pools", value)


if not MYPY:
    class ExternalNetworkIpScopeStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
elif False:
    ExternalNetworkIpScopeStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNetworkIpScopeStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class ExternalNetworkV2IpScopeArgsDict(TypedDict):
        gateway: pulumi.Input[str]
        """
        Gateway of the network
        """
        prefix_length: pulumi.Input[int]
        """
        Network mask
        """
        dns1: NotRequired[pulumi.Input[str]]
        """
        Primary DNS server
        """
        dns2: NotRequired[pulumi.Input[str]]
        """
        Secondary DNS server
        """
        dns_suffix: NotRequired[pulumi.Input[str]]
        """
        DNS suffix
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        If subnet is enabled
        """
        static_ip_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExternalNetworkV2IpScopeStaticIpPoolArgsDict']]]]
        """
        IP ranges used for static pool allocation in the network
        """
elif False:
    ExternalNetworkV2IpScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNetworkV2IpScopeArgs:
    def __init__(__self__, *,
                 gateway: pulumi.Input[str],
                 prefix_length: pulumi.Input[int],
                 dns1: Optional[pulumi.Input[str]] = None,
                 dns2: Optional[pulumi.Input[str]] = None,
                 dns_suffix: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 static_ip_pools: Optional[pulumi.Input[Sequence[pulumi.Input['ExternalNetworkV2IpScopeStaticIpPoolArgs']]]] = None):
        """
        :param pulumi.Input[str] gateway: Gateway of the network
        :param pulumi.Input[int] prefix_length: Network mask
        :param pulumi.Input[str] dns1: Primary DNS server
        :param pulumi.Input[str] dns2: Secondary DNS server
        :param pulumi.Input[str] dns_suffix: DNS suffix
        :param pulumi.Input[bool] enabled: If subnet is enabled
        :param pulumi.Input[Sequence[pulumi.Input['ExternalNetworkV2IpScopeStaticIpPoolArgs']]] static_ip_pools: IP ranges used for static pool allocation in the network
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if dns1 is not None:
            pulumi.set(__self__, "dns1", dns1)
        if dns2 is not None:
            pulumi.set(__self__, "dns2", dns2)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if static_ip_pools is not None:
            pulumi.set(__self__, "static_ip_pools", static_ip_pools)

    @property
    @pulumi.getter
    def gateway(self) -> pulumi.Input[str]:
        """
        Gateway of the network
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        """
        Network mask
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def dns1(self) -> Optional[pulumi.Input[str]]:
        """
        Primary DNS server
        """
        return pulumi.get(self, "dns1")

    @dns1.setter
    def dns1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns1", value)

    @property
    @pulumi.getter
    def dns2(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary DNS server
        """
        return pulumi.get(self, "dns2")

    @dns2.setter
    def dns2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns2", value)

    @property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        DNS suffix
        """
        return pulumi.get(self, "dns_suffix")

    @dns_suffix.setter
    def dns_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_suffix", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If subnet is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="staticIpPools")
    def static_ip_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExternalNetworkV2IpScopeStaticIpPoolArgs']]]]:
        """
        IP ranges used for static pool allocation in the network
        """
        return pulumi.get(self, "static_ip_pools")

    @static_ip_pools.setter
    def static_ip_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExternalNetworkV2IpScopeStaticIpPoolArgs']]]]):
        pulumi.set(self, "static_ip_pools", value)


if not MYPY:
    class ExternalNetworkV2IpScopeStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
elif False:
    ExternalNetworkV2IpScopeStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNetworkV2IpScopeStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class ExternalNetworkV2NsxtNetworkArgsDict(TypedDict):
        nsxt_manager_id: pulumi.Input[str]
        """
        ID of NSX-T manager
        """
        nsxt_segment_name: NotRequired[pulumi.Input[str]]
        """
        Name of NSX-T segment (for NSX-T segment backed external network)
        """
        nsxt_tier0_router_id: NotRequired[pulumi.Input[str]]
        """
        ID of NSX-T Tier-0 router (for T0 gateway backed external network)
        """
elif False:
    ExternalNetworkV2NsxtNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNetworkV2NsxtNetworkArgs:
    def __init__(__self__, *,
                 nsxt_manager_id: pulumi.Input[str],
                 nsxt_segment_name: Optional[pulumi.Input[str]] = None,
                 nsxt_tier0_router_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] nsxt_manager_id: ID of NSX-T manager
        :param pulumi.Input[str] nsxt_segment_name: Name of NSX-T segment (for NSX-T segment backed external network)
        :param pulumi.Input[str] nsxt_tier0_router_id: ID of NSX-T Tier-0 router (for T0 gateway backed external network)
        """
        pulumi.set(__self__, "nsxt_manager_id", nsxt_manager_id)
        if nsxt_segment_name is not None:
            pulumi.set(__self__, "nsxt_segment_name", nsxt_segment_name)
        if nsxt_tier0_router_id is not None:
            pulumi.set(__self__, "nsxt_tier0_router_id", nsxt_tier0_router_id)

    @property
    @pulumi.getter(name="nsxtManagerId")
    def nsxt_manager_id(self) -> pulumi.Input[str]:
        """
        ID of NSX-T manager
        """
        return pulumi.get(self, "nsxt_manager_id")

    @nsxt_manager_id.setter
    def nsxt_manager_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "nsxt_manager_id", value)

    @property
    @pulumi.getter(name="nsxtSegmentName")
    def nsxt_segment_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of NSX-T segment (for NSX-T segment backed external network)
        """
        return pulumi.get(self, "nsxt_segment_name")

    @nsxt_segment_name.setter
    def nsxt_segment_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nsxt_segment_name", value)

    @property
    @pulumi.getter(name="nsxtTier0RouterId")
    def nsxt_tier0_router_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of NSX-T Tier-0 router (for T0 gateway backed external network)
        """
        return pulumi.get(self, "nsxt_tier0_router_id")

    @nsxt_tier0_router_id.setter
    def nsxt_tier0_router_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nsxt_tier0_router_id", value)


if not MYPY:
    class ExternalNetworkV2VsphereNetworkArgsDict(TypedDict):
        portgroup_id: pulumi.Input[str]
        """
        The name of the port group
        """
        vcenter_id: pulumi.Input[str]
        """
        The vCenter server name
        """
elif False:
    ExternalNetworkV2VsphereNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNetworkV2VsphereNetworkArgs:
    def __init__(__self__, *,
                 portgroup_id: pulumi.Input[str],
                 vcenter_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] portgroup_id: The name of the port group
        :param pulumi.Input[str] vcenter_id: The vCenter server name
        """
        pulumi.set(__self__, "portgroup_id", portgroup_id)
        pulumi.set(__self__, "vcenter_id", vcenter_id)

    @property
    @pulumi.getter(name="portgroupId")
    def portgroup_id(self) -> pulumi.Input[str]:
        """
        The name of the port group
        """
        return pulumi.get(self, "portgroup_id")

    @portgroup_id.setter
    def portgroup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "portgroup_id", value)

    @property
    @pulumi.getter(name="vcenterId")
    def vcenter_id(self) -> pulumi.Input[str]:
        """
        The vCenter server name
        """
        return pulumi.get(self, "vcenter_id")

    @vcenter_id.setter
    def vcenter_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vcenter_id", value)


if not MYPY:
    class ExternalNetworkVsphereNetworkArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A unique name for the network
        """
        type: pulumi.Input[str]
        """
        The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK
        """
        vcenter: pulumi.Input[str]
        """
        The vCenter server name
        """
elif False:
    ExternalNetworkVsphereNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalNetworkVsphereNetworkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 vcenter: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: A unique name for the network
        :param pulumi.Input[str] type: The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK
        :param pulumi.Input[str] vcenter: The vCenter server name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vcenter", vcenter)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A unique name for the network
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def vcenter(self) -> pulumi.Input[str]:
        """
        The vCenter server name
        """
        return pulumi.get(self, "vcenter")

    @vcenter.setter
    def vcenter(self, value: pulumi.Input[str]):
        pulumi.set(self, "vcenter", value)


if not MYPY:
    class IndependentDiskMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    IndependentDiskMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndependentDiskMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IpSpaceCustomQuotaIpPrefixQuotaArgsDict(TypedDict):
        prefix_length: pulumi.Input[str]
        """
        Prefix length
        """
        quota: pulumi.Input[str]
        """
        IP Prefix Quota
        """
elif False:
    IpSpaceCustomQuotaIpPrefixQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpSpaceCustomQuotaIpPrefixQuotaArgs:
    def __init__(__self__, *,
                 prefix_length: pulumi.Input[str],
                 quota: pulumi.Input[str]):
        """
        :param pulumi.Input[str] prefix_length: Prefix length
        :param pulumi.Input[str] quota: IP Prefix Quota
        """
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "quota", quota)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[str]:
        """
        Prefix length
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def quota(self) -> pulumi.Input[str]:
        """
        IP Prefix Quota
        """
        return pulumi.get(self, "quota")

    @quota.setter
    def quota(self, value: pulumi.Input[str]):
        pulumi.set(self, "quota", value)


if not MYPY:
    class IpSpaceIpPrefixArgsDict(TypedDict):
        prefixes: pulumi.Input[Sequence[pulumi.Input['IpSpaceIpPrefixPrefixArgsDict']]]
        """
        One or more prefixes
        """
        default_quota: NotRequired[pulumi.Input[str]]
        """
        Floating IP quota
        """
elif False:
    IpSpaceIpPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpSpaceIpPrefixArgs:
    def __init__(__self__, *,
                 prefixes: pulumi.Input[Sequence[pulumi.Input['IpSpaceIpPrefixPrefixArgs']]],
                 default_quota: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['IpSpaceIpPrefixPrefixArgs']]] prefixes: One or more prefixes
        :param pulumi.Input[str] default_quota: Floating IP quota
        """
        pulumi.set(__self__, "prefixes", prefixes)
        if default_quota is not None:
            pulumi.set(__self__, "default_quota", default_quota)

    @property
    @pulumi.getter
    def prefixes(self) -> pulumi.Input[Sequence[pulumi.Input['IpSpaceIpPrefixPrefixArgs']]]:
        """
        One or more prefixes
        """
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: pulumi.Input[Sequence[pulumi.Input['IpSpaceIpPrefixPrefixArgs']]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="defaultQuota")
    def default_quota(self) -> Optional[pulumi.Input[str]]:
        """
        Floating IP quota
        """
        return pulumi.get(self, "default_quota")

    @default_quota.setter
    def default_quota(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_quota", value)


if not MYPY:
    class IpSpaceIpPrefixPrefixArgsDict(TypedDict):
        first_ip: pulumi.Input[str]
        """
        First IP
        """
        prefix_count: pulumi.Input[str]
        """
        Number of prefixes to define
        """
        prefix_length: pulumi.Input[str]
        """
        Prefix length
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID of IP Prefix
        """
elif False:
    IpSpaceIpPrefixPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpSpaceIpPrefixPrefixArgs:
    def __init__(__self__, *,
                 first_ip: pulumi.Input[str],
                 prefix_count: pulumi.Input[str],
                 prefix_length: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] first_ip: First IP
        :param pulumi.Input[str] prefix_count: Number of prefixes to define
        :param pulumi.Input[str] prefix_length: Prefix length
        :param pulumi.Input[str] id: ID of IP Prefix
        """
        pulumi.set(__self__, "first_ip", first_ip)
        pulumi.set(__self__, "prefix_count", prefix_count)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="firstIp")
    def first_ip(self) -> pulumi.Input[str]:
        """
        First IP
        """
        return pulumi.get(self, "first_ip")

    @first_ip.setter
    def first_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "first_ip", value)

    @property
    @pulumi.getter(name="prefixCount")
    def prefix_count(self) -> pulumi.Input[str]:
        """
        Number of prefixes to define
        """
        return pulumi.get(self, "prefix_count")

    @prefix_count.setter
    def prefix_count(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix_count", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[str]:
        """
        Prefix length
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[str]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of IP Prefix
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class IpSpaceIpRangeArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID of IP Range
        """
elif False:
    IpSpaceIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpSpaceIpRangeArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        :param pulumi.Input[str] id: ID of IP Range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of IP Range
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class LbServerPoolMemberArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Defines member state. One of enabled, drain, disabled.
        """
        ip_address: pulumi.Input[str]
        """
        IP address of member in server pool
        """
        monitor_port: pulumi.Input[int]
        """
        Port at which the member is to receive health monitor requests. Can be the same as port
        """
        name: pulumi.Input[str]
        """
        Server Pool name
        """
        port: pulumi.Input[int]
        """
        Port at which the member is to receive traffic from the load balancer
        """
        weight: pulumi.Input[int]
        """
        Proportion of traffic this member is to handle. Must be an integer in the range 1-256
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The NSX ID of the load balancer server pool
        """
        max_connections: NotRequired[pulumi.Input[int]]
        """
        The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released
        """
        min_connections: NotRequired[pulumi.Input[int]]
        """
        Minimum number of concurrent connections a member must always accept
        """
elif False:
    LbServerPoolMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LbServerPoolMemberArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 ip_address: pulumi.Input[str],
                 monitor_port: pulumi.Input[int],
                 name: pulumi.Input[str],
                 port: pulumi.Input[int],
                 weight: pulumi.Input[int],
                 id: Optional[pulumi.Input[str]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 min_connections: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] condition: Defines member state. One of enabled, drain, disabled.
        :param pulumi.Input[str] ip_address: IP address of member in server pool
        :param pulumi.Input[int] monitor_port: Port at which the member is to receive health monitor requests. Can be the same as port
        :param pulumi.Input[str] name: Server Pool name
        :param pulumi.Input[int] port: Port at which the member is to receive traffic from the load balancer
        :param pulumi.Input[int] weight: Proportion of traffic this member is to handle. Must be an integer in the range 1-256
        :param pulumi.Input[str] id: The NSX ID of the load balancer server pool
        :param pulumi.Input[int] max_connections: The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released
        :param pulumi.Input[int] min_connections: Minimum number of concurrent connections a member must always accept
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "monitor_port", monitor_port)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if min_connections is not None:
            pulumi.set(__self__, "min_connections", min_connections)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Defines member state. One of enabled, drain, disabled.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[str]:
        """
        IP address of member in server pool
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="monitorPort")
    def monitor_port(self) -> pulumi.Input[int]:
        """
        Port at which the member is to receive health monitor requests. Can be the same as port
        """
        return pulumi.get(self, "monitor_port")

    @monitor_port.setter
    def monitor_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "monitor_port", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Server Pool name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port at which the member is to receive traffic from the load balancer
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        Proportion of traffic this member is to handle. Must be an integer in the range 1-256
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The NSX ID of the load balancer server pool
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="minConnections")
    def min_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of concurrent connections a member must always accept
        """
        return pulumi.get(self, "min_connections")

    @min_connections.setter
    def min_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_connections", value)


if not MYPY:
    class NetworkDirectMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    NetworkDirectMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkDirectMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkIsolatedDhcpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        The final address in the IP Range
        """
        start_address: pulumi.Input[str]
        """
        The first address in the IP Range
        """
        default_lease_time: NotRequired[pulumi.Input[int]]
        """
        The default DHCP lease time to use
        """
        max_lease_time: NotRequired[pulumi.Input[int]]
        """
        The maximum DHCP lease time to use
        """
elif False:
    NetworkIsolatedDhcpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkIsolatedDhcpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str],
                 default_lease_time: Optional[pulumi.Input[int]] = None,
                 max_lease_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] end_address: The final address in the IP Range
        :param pulumi.Input[str] start_address: The first address in the IP Range
        :param pulumi.Input[int] default_lease_time: The default DHCP lease time to use
        :param pulumi.Input[int] max_lease_time: The maximum DHCP lease time to use
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)
        if default_lease_time is not None:
            pulumi.set(__self__, "default_lease_time", default_lease_time)
        if max_lease_time is not None:
            pulumi.set(__self__, "max_lease_time", max_lease_time)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)

    @property
    @pulumi.getter(name="defaultLeaseTime")
    def default_lease_time(self) -> Optional[pulumi.Input[int]]:
        """
        The default DHCP lease time to use
        """
        return pulumi.get(self, "default_lease_time")

    @default_lease_time.setter
    def default_lease_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_lease_time", value)

    @property
    @pulumi.getter(name="maxLeaseTime")
    def max_lease_time(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum DHCP lease time to use
        """
        return pulumi.get(self, "max_lease_time")

    @max_lease_time.setter
    def max_lease_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_lease_time", value)


if not MYPY:
    class NetworkIsolatedMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    NetworkIsolatedMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkIsolatedMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkIsolatedStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        The final address in the IP Range
        """
        start_address: pulumi.Input[str]
        """
        The first address in the IP Range
        """
elif False:
    NetworkIsolatedStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkIsolatedStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: The final address in the IP Range
        :param pulumi.Input[str] start_address: The first address in the IP Range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NetworkIsolatedV2MetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    NetworkIsolatedV2MetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkIsolatedV2MetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkIsolatedV2SecondaryStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
elif False:
    NetworkIsolatedV2SecondaryStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkIsolatedV2SecondaryStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NetworkIsolatedV2StaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
elif False:
    NetworkIsolatedV2StaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkIsolatedV2StaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NetworkPoolBackingArgsDict(TypedDict):
        distributed_switch: NotRequired[pulumi.Input['NetworkPoolBackingDistributedSwitchArgsDict']]
        """
        (Optional) A backing structure used for `VLAN` network pool
        """
        port_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingPortGroupArgsDict']]]]
        """
        (Optional) A list of backing structure used for `PORTGROUP_BACKED` network pool
        """
        range_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingRangeIdArgsDict']]]]
        """
        (Optional) A list of range IDs, required with `VLAN` network pools
        """
        transport_zone: NotRequired[pulumi.Input['NetworkPoolBackingTransportZoneArgsDict']]
        """
        (Optional) A backing structure used for `GENEVE` network pool
        """
elif False:
    NetworkPoolBackingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPoolBackingArgs:
    def __init__(__self__, *,
                 distributed_switch: Optional[pulumi.Input['NetworkPoolBackingDistributedSwitchArgs']] = None,
                 port_groups: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingPortGroupArgs']]]] = None,
                 range_ids: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingRangeIdArgs']]]] = None,
                 transport_zone: Optional[pulumi.Input['NetworkPoolBackingTransportZoneArgs']] = None):
        """
        :param pulumi.Input['NetworkPoolBackingDistributedSwitchArgs'] distributed_switch: (Optional) A backing structure used for `VLAN` network pool
        :param pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingPortGroupArgs']]] port_groups: (Optional) A list of backing structure used for `PORTGROUP_BACKED` network pool
        :param pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingRangeIdArgs']]] range_ids: (Optional) A list of range IDs, required with `VLAN` network pools
        :param pulumi.Input['NetworkPoolBackingTransportZoneArgs'] transport_zone: (Optional) A backing structure used for `GENEVE` network pool
        """
        if distributed_switch is not None:
            pulumi.set(__self__, "distributed_switch", distributed_switch)
        if port_groups is not None:
            pulumi.set(__self__, "port_groups", port_groups)
        if range_ids is not None:
            pulumi.set(__self__, "range_ids", range_ids)
        if transport_zone is not None:
            pulumi.set(__self__, "transport_zone", transport_zone)

    @property
    @pulumi.getter(name="distributedSwitch")
    def distributed_switch(self) -> Optional[pulumi.Input['NetworkPoolBackingDistributedSwitchArgs']]:
        """
        (Optional) A backing structure used for `VLAN` network pool
        """
        return pulumi.get(self, "distributed_switch")

    @distributed_switch.setter
    def distributed_switch(self, value: Optional[pulumi.Input['NetworkPoolBackingDistributedSwitchArgs']]):
        pulumi.set(self, "distributed_switch", value)

    @property
    @pulumi.getter(name="portGroups")
    def port_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingPortGroupArgs']]]]:
        """
        (Optional) A list of backing structure used for `PORTGROUP_BACKED` network pool
        """
        return pulumi.get(self, "port_groups")

    @port_groups.setter
    def port_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingPortGroupArgs']]]]):
        pulumi.set(self, "port_groups", value)

    @property
    @pulumi.getter(name="rangeIds")
    def range_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingRangeIdArgs']]]]:
        """
        (Optional) A list of range IDs, required with `VLAN` network pools
        """
        return pulumi.get(self, "range_ids")

    @range_ids.setter
    def range_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkPoolBackingRangeIdArgs']]]]):
        pulumi.set(self, "range_ids", value)

    @property
    @pulumi.getter(name="transportZone")
    def transport_zone(self) -> Optional[pulumi.Input['NetworkPoolBackingTransportZoneArgs']]:
        """
        (Optional) A backing structure used for `GENEVE` network pool
        """
        return pulumi.get(self, "transport_zone")

    @transport_zone.setter
    def transport_zone(self, value: Optional[pulumi.Input['NetworkPoolBackingTransportZoneArgs']]):
        pulumi.set(self, "transport_zone", value)


if not MYPY:
    class NetworkPoolBackingDistributedSwitchArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        (Computed) The ID of the backing element
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Unique name of network pool
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
elif False:
    NetworkPoolBackingDistributedSwitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPoolBackingDistributedSwitchArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: (Computed) The ID of the backing element
        :param pulumi.Input[str] name: Unique name of network pool
        :param pulumi.Input[str] type: Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The ID of the backing element
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of network pool
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkPoolBackingPortGroupArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        (Computed) The ID of the backing element
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Unique name of network pool
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
elif False:
    NetworkPoolBackingPortGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPoolBackingPortGroupArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: (Computed) The ID of the backing element
        :param pulumi.Input[str] name: Unique name of network pool
        :param pulumi.Input[str] type: Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The ID of the backing element
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of network pool
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkPoolBackingRangeIdArgsDict(TypedDict):
        end_id: pulumi.Input[int]
        """
        (Required) The last ID of the range
        """
        start_id: pulumi.Input[int]
        """
        (Required) The first ID of the range
        """
elif False:
    NetworkPoolBackingRangeIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPoolBackingRangeIdArgs:
    def __init__(__self__, *,
                 end_id: pulumi.Input[int],
                 start_id: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end_id: (Required) The last ID of the range
        :param pulumi.Input[int] start_id: (Required) The first ID of the range
        """
        pulumi.set(__self__, "end_id", end_id)
        pulumi.set(__self__, "start_id", start_id)

    @property
    @pulumi.getter(name="endId")
    def end_id(self) -> pulumi.Input[int]:
        """
        (Required) The last ID of the range
        """
        return pulumi.get(self, "end_id")

    @end_id.setter
    def end_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_id", value)

    @property
    @pulumi.getter(name="startId")
    def start_id(self) -> pulumi.Input[int]:
        """
        (Required) The first ID of the range
        """
        return pulumi.get(self, "start_id")

    @start_id.setter
    def start_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_id", value)


if not MYPY:
    class NetworkPoolBackingTransportZoneArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        (Computed) The ID of the backing element
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Unique name of network pool
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
elif False:
    NetworkPoolBackingTransportZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPoolBackingTransportZoneArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: (Computed) The ID of the backing element
        :param pulumi.Input[str] name: Unique name of network pool
        :param pulumi.Input[str] type: Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The ID of the backing element
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of network pool
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkRoutedDhcpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        The final address in the IP Range
        """
        start_address: pulumi.Input[str]
        """
        The first address in the IP Range
        """
        default_lease_time: NotRequired[pulumi.Input[int]]
        """
        The default DHCP lease time to use
        """
        max_lease_time: NotRequired[pulumi.Input[int]]
        """
        The maximum DHCP lease time to use
        """
elif False:
    NetworkRoutedDhcpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkRoutedDhcpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str],
                 default_lease_time: Optional[pulumi.Input[int]] = None,
                 max_lease_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] end_address: The final address in the IP Range
        :param pulumi.Input[str] start_address: The first address in the IP Range
        :param pulumi.Input[int] default_lease_time: The default DHCP lease time to use
        :param pulumi.Input[int] max_lease_time: The maximum DHCP lease time to use
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)
        if default_lease_time is not None:
            pulumi.set(__self__, "default_lease_time", default_lease_time)
        if max_lease_time is not None:
            pulumi.set(__self__, "max_lease_time", max_lease_time)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)

    @property
    @pulumi.getter(name="defaultLeaseTime")
    def default_lease_time(self) -> Optional[pulumi.Input[int]]:
        """
        The default DHCP lease time to use
        """
        return pulumi.get(self, "default_lease_time")

    @default_lease_time.setter
    def default_lease_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_lease_time", value)

    @property
    @pulumi.getter(name="maxLeaseTime")
    def max_lease_time(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum DHCP lease time to use
        """
        return pulumi.get(self, "max_lease_time")

    @max_lease_time.setter
    def max_lease_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_lease_time", value)


if not MYPY:
    class NetworkRoutedMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    NetworkRoutedMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkRoutedMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkRoutedStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        The final address in the IP Range
        """
        start_address: pulumi.Input[str]
        """
        The first address in the IP Range
        """
elif False:
    NetworkRoutedStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkRoutedStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: The final address in the IP Range
        :param pulumi.Input[str] start_address: The first address in the IP Range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NetworkRoutedV2MetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    NetworkRoutedV2MetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkRoutedV2MetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkRoutedV2SecondaryStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
elif False:
    NetworkRoutedV2SecondaryStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkRoutedV2SecondaryStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NetworkRoutedV2StaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
elif False:
    NetworkRoutedV2StaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkRoutedV2StaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NsxtAlbPoolHealthMonitorArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of health monitor. One of `HTTP`, `HTTPS`, `TCP`, `UDP`, `PING`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A name for ALB Pool
        """
        system_defined: NotRequired[pulumi.Input[bool]]
elif False:
    NsxtAlbPoolHealthMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbPoolHealthMonitorArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 system_defined: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: Type of health monitor. One of `HTTP`, `HTTPS`, `TCP`, `UDP`, `PING`
        :param pulumi.Input[str] name: A name for ALB Pool
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if system_defined is not None:
            pulumi.set(__self__, "system_defined", system_defined)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of health monitor. One of `HTTP`, `HTTPS`, `TCP`, `UDP`, `PING`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for ALB Pool
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="systemDefined")
    def system_defined(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_defined")

    @system_defined.setter
    def system_defined(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_defined", value)


if not MYPY:
    class NsxtAlbPoolMemberArgsDict(TypedDict):
        ip_address: pulumi.Input[str]
        """
        IP address of pool member
        """
        detailed_health_message: NotRequired[pulumi.Input[str]]
        """
        Detailed health message
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Boolean value if ALB Pool should be enabled (default `true`)
        """
        health_status: NotRequired[pulumi.Input[str]]
        """
        Health status
        """
        marked_down_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Marked down by provides a set of health monitors that marked the service down
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Member port
        """
        ratio: NotRequired[pulumi.Input[int]]
        """
        Ratio of selecting eligible servers in the pool
        """
elif False:
    NsxtAlbPoolMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbPoolMemberArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[str],
                 detailed_health_message: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 health_status: Optional[pulumi.Input[str]] = None,
                 marked_down_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 ratio: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ip_address: IP address of pool member
        :param pulumi.Input[str] detailed_health_message: Detailed health message
        :param pulumi.Input[bool] enabled: Boolean value if ALB Pool should be enabled (default `true`)
        :param pulumi.Input[str] health_status: Health status
        :param pulumi.Input[Sequence[pulumi.Input[str]]] marked_down_bies: Marked down by provides a set of health monitors that marked the service down
        :param pulumi.Input[int] port: Member port
        :param pulumi.Input[int] ratio: Ratio of selecting eligible servers in the pool
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if detailed_health_message is not None:
            pulumi.set(__self__, "detailed_health_message", detailed_health_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if health_status is not None:
            pulumi.set(__self__, "health_status", health_status)
        if marked_down_bies is not None:
            pulumi.set(__self__, "marked_down_bies", marked_down_bies)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[str]:
        """
        IP address of pool member
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="detailedHealthMessage")
    def detailed_health_message(self) -> Optional[pulumi.Input[str]]:
        """
        Detailed health message
        """
        return pulumi.get(self, "detailed_health_message")

    @detailed_health_message.setter
    def detailed_health_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detailed_health_message", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value if ALB Pool should be enabled (default `true`)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="healthStatus")
    def health_status(self) -> Optional[pulumi.Input[str]]:
        """
        Health status
        """
        return pulumi.get(self, "health_status")

    @health_status.setter
    def health_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_status", value)

    @property
    @pulumi.getter(name="markedDownBies")
    def marked_down_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Marked down by provides a set of health monitors that marked the service down
        """
        return pulumi.get(self, "marked_down_bies")

    @marked_down_bies.setter
    def marked_down_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "marked_down_bies", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Member port
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def ratio(self) -> Optional[pulumi.Input[int]]:
        """
        Ratio of selecting eligible servers in the pool
        """
        return pulumi.get(self, "ratio")

    @ratio.setter
    def ratio(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ratio", value)


if not MYPY:
    class NsxtAlbPoolPersistenceProfileArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of persistence strategy. One of `CLIENT_IP`, `HTTP_COOKIE`, `CUSTOM_HTTP_HEADER`, `APP_COOKIE`, `TLS`
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A name for ALB Pool
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of attribute based on persistence type
        """
elif False:
    NsxtAlbPoolPersistenceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbPoolPersistenceProfileArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of persistence strategy. One of `CLIENT_IP`, `HTTP_COOKIE`, `CUSTOM_HTTP_HEADER`, `APP_COOKIE`, `TLS`
        :param pulumi.Input[str] name: A name for ALB Pool
        :param pulumi.Input[str] value: Value of attribute based on persistence type
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of persistence strategy. One of `CLIENT_IP`, `HTTP_COOKIE`, `CUSTOM_HTTP_HEADER`, `APP_COOKIE`, `TLS`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for ALB Pool
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of attribute based on persistence type
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleArgsDict(TypedDict):
        actions: pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgsDict']
        """
        Actions to perform with the rule that matches
        """
        match_criteria: pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgsDict']
        """
        Rule matching Criteria
        """
        name: pulumi.Input[str]
        """
        Name of the rule
        """
        active: NotRequired[pulumi.Input[bool]]
        """
        Defines if the rule is active or not
        """
        logging: NotRequired[pulumi.Input[bool]]
        """
        Defines whether to enable logging with headers on rule match or not
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgs'],
                 match_criteria: pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgs'],
                 name: pulumi.Input[str],
                 active: Optional[pulumi.Input[bool]] = None,
                 logging: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgs'] actions: Actions to perform with the rule that matches
        :param pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgs'] match_criteria: Rule matching Criteria
        :param pulumi.Input[str] name: Name of the rule
        :param pulumi.Input[bool] active: Defines if the rule is active or not
        :param pulumi.Input[bool] logging: Defines whether to enable logging with headers on rule match or not
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_criteria", match_criteria)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgs']:
        """
        Actions to perform with the rule that matches
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgs']:
        """
        Rule matching Criteria
        """
        return pulumi.get(self, "match_criteria")

    @match_criteria.setter
    def match_criteria(self, value: pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgs']):
        pulumi.set(self, "match_criteria", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the rule is active or not
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether to enable logging with headers on rule match or not
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "logging", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgsDict(TypedDict):
        modify_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgsDict']]]]
        """
        A set of header modification rules
        """
        redirect: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgsDict']]
        """
        Redirect request
        """
        rewrite_url: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgsDict']]
        """
        URL rewrite rules
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgs:
    def __init__(__self__, *,
                 modify_headers: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgs']]]] = None,
                 redirect: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgs']] = None,
                 rewrite_url: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgs']]] modify_headers: A set of header modification rules
        :param pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgs'] redirect: Redirect request
        :param pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgs'] rewrite_url: URL rewrite rules
        """
        if modify_headers is not None:
            pulumi.set(__self__, "modify_headers", modify_headers)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if rewrite_url is not None:
            pulumi.set(__self__, "rewrite_url", rewrite_url)

    @property
    @pulumi.getter(name="modifyHeaders")
    def modify_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgs']]]]:
        """
        A set of header modification rules
        """
        return pulumi.get(self, "modify_headers")

    @modify_headers.setter
    def modify_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgs']]]]):
        pulumi.set(self, "modify_headers", value)

    @property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgs']]:
        """
        Redirect request
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgs']]):
        pulumi.set(self, "redirect", value)

    @property
    @pulumi.getter(name="rewriteUrl")
    def rewrite_url(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgs']]:
        """
        URL rewrite rules
        """
        return pulumi.get(self, "rewrite_url")

    @rewrite_url.setter
    def rewrite_url(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgs']]):
        pulumi.set(self, "rewrite_url", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        """
        name: pulumi.Input[str]
        """
        HTTP header name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        HTTP header value
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        :param pulumi.Input[str] name: HTTP header name
        :param pulumi.Input[str] value: HTTP header value
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        HTTP header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        """
        HTTP or HTTPS protocol
        """
        status_code: pulumi.Input[int]
        """
        One of the redirect status codes - 301, 302, 307
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Host to which redirect the request
        """
        keep_query: NotRequired[pulumi.Input[bool]]
        """
        Should the query part be preserved
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to which redirect the request
        """
        port: NotRequired[pulumi.Input[str]]
        """
        Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 status_code: pulumi.Input[int],
                 host: Optional[pulumi.Input[str]] = None,
                 keep_query: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: HTTP or HTTPS protocol
        :param pulumi.Input[int] status_code: One of the redirect status codes - 301, 302, 307
        :param pulumi.Input[str] host: Host to which redirect the request
        :param pulumi.Input[bool] keep_query: Should the query part be preserved
        :param pulumi.Input[str] path: Path to which redirect the request
        :param pulumi.Input[str] port: Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol
        """
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "status_code", status_code)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_query is not None:
            pulumi.set(__self__, "keep_query", keep_query)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        HTTP or HTTPS protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[int]:
        """
        One of the redirect status codes - 301, 302, 307
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host to which redirect the request
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the query part be preserved
        """
        return pulumi.get(self, "keep_query")

    @keep_query.setter
    def keep_query(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_query", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to which redirect the request
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgsDict(TypedDict):
        existing_path: pulumi.Input[str]
        """
        Path to use for the rewritten URL
        """
        host_header: pulumi.Input[str]
        """
        Host to use for the rewritten URL
        """
        keep_query: NotRequired[pulumi.Input[bool]]
        """
        Whether or not to keep the existing query string when rewriting the URL
        """
        query: NotRequired[pulumi.Input[str]]
        """
        Query string to use or append to the existing query string in the rewritten URL
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgs:
    def __init__(__self__, *,
                 existing_path: pulumi.Input[str],
                 host_header: pulumi.Input[str],
                 keep_query: Optional[pulumi.Input[bool]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] existing_path: Path to use for the rewritten URL
        :param pulumi.Input[str] host_header: Host to use for the rewritten URL
        :param pulumi.Input[bool] keep_query: Whether or not to keep the existing query string when rewriting the URL
        :param pulumi.Input[str] query: Query string to use or append to the existing query string in the rewritten URL
        """
        pulumi.set(__self__, "existing_path", existing_path)
        pulumi.set(__self__, "host_header", host_header)
        if keep_query is not None:
            pulumi.set(__self__, "keep_query", keep_query)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="existingPath")
    def existing_path(self) -> pulumi.Input[str]:
        """
        Path to use for the rewritten URL
        """
        return pulumi.get(self, "existing_path")

    @existing_path.setter
    def existing_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "existing_path", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> pulumi.Input[str]:
        """
        Host to use for the rewritten URL
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to keep the existing query string when rewriting the URL
        """
        return pulumi.get(self, "keep_query")

    @keep_query.setter
    def keep_query(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_query", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        Query string to use or append to the existing query string in the rewritten URL
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgsDict(TypedDict):
        client_ip_address: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgsDict']]
        """
        Client IP Address criteria
        """
        cookie: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgsDict']]
        """
        Criteria for matching cookie
        """
        http_methods: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgsDict']]
        """
        HTTP methods that should be matched
        """
        path: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgsDict']]
        """
        Request path criteria
        """
        protocol_type: NotRequired[pulumi.Input[str]]
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        HTTP request query strings to match
        """
        request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgsDict']]]]
        """
        A set of rules for matching request headers
        """
        service_ports: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgsDict']]
        """
        Service Port criteria
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgs:
    def __init__(__self__, *,
                 client_ip_address: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgs']] = None,
                 cookie: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgs']] = None,
                 http_methods: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgs']] = None,
                 path: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgs']] = None,
                 protocol_type: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgs']]]] = None,
                 service_ports: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgs']] = None):
        """
        :param pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgs'] client_ip_address: Client IP Address criteria
        :param pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgs'] cookie: Criteria for matching cookie
        :param pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgs'] http_methods: HTTP methods that should be matched
        :param pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgs'] path: Request path criteria
        :param pulumi.Input[str] protocol_type: Protocol to match - 'HTTP' or 'HTTPS'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] queries: HTTP request query strings to match
        :param pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgs']]] request_headers: A set of rules for matching request headers
        :param pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgs'] service_ports: Service Port criteria
        """
        if client_ip_address is not None:
            pulumi.set(__self__, "client_ip_address", client_ip_address)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if service_ports is not None:
            pulumi.set(__self__, "service_ports", service_ports)

    @property
    @pulumi.getter(name="clientIpAddress")
    def client_ip_address(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgs']]:
        """
        Client IP Address criteria
        """
        return pulumi.get(self, "client_ip_address")

    @client_ip_address.setter
    def client_ip_address(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgs']]):
        pulumi.set(self, "client_ip_address", value)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgs']]:
        """
        Criteria for matching cookie
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgs']]:
        """
        HTTP methods that should be matched
        """
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgs']]):
        pulumi.set(self, "http_methods", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgs']]:
        """
        Request path criteria
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        return pulumi.get(self, "protocol_type")

    @protocol_type.setter
    def protocol_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_type", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        HTTP request query strings to match
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgs']]]]:
        """
        A set of rules for matching request headers
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgs']]]]):
        pulumi.set(self, "request_headers", value)

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgs']]:
        """
        Service Port criteria
        """
        return pulumi.get(self, "service_ports")

    @service_ports.setter
    def service_ports(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgs']]):
        pulumi.set(self, "service_ports", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        ip_addresses: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A set of IP addresses
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 ip_addresses: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_addresses: A set of IP addresses
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A set of IP addresses
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        name: pulumi.Input[str]
        """
        Name of the HTTP cookie whose value is to be matched
        """
        value: pulumi.Input[str]
        """
        String values to match for an HTTP cookie
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param pulumi.Input[str] name: Name of the HTTP cookie whose value is to be matched
        :param pulumi.Input[str] value: String values to match for an HTTP cookie
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP cookie whose value is to be matched
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        String values to match for an HTTP cookie
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        methods: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 methods: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "methods", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        paths: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        String values to match the path
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 paths: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: String values to match the path
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def paths(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        String values to match the path
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        name: pulumi.Input[str]
        """
        Name of the HTTP header whose value is to be matched
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        String values to match for an HTTP header
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param pulumi.Input[str] name: Name of the HTTP header whose value is to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: String values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        String values to match for an HTTP header
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        ports: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        A set of TCP ports. Allowed values are 1-65535
        """
elif False:
    NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 ports: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: A set of TCP ports. Allowed values are 1-65535
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        A set of TCP ports. Allowed values are 1-65535
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleArgsDict(TypedDict):
        actions: pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgsDict']
        """
        Actions to perform with the rule that matches
        """
        match_criteria: pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgsDict']
        """
        Rule matching Criteria
        """
        name: pulumi.Input[str]
        """
        Name of the rule
        """
        active: NotRequired[pulumi.Input[bool]]
        """
        Defines if the rule is active or not
        """
        logging: NotRequired[pulumi.Input[bool]]
        """
        Defines whether to enable logging with headers on rule match or not
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgs'],
                 match_criteria: pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgs'],
                 name: pulumi.Input[str],
                 active: Optional[pulumi.Input[bool]] = None,
                 logging: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgs'] actions: Actions to perform with the rule that matches
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgs'] match_criteria: Rule matching Criteria
        :param pulumi.Input[str] name: Name of the rule
        :param pulumi.Input[bool] active: Defines if the rule is active or not
        :param pulumi.Input[bool] logging: Defines whether to enable logging with headers on rule match or not
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_criteria", match_criteria)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgs']:
        """
        Actions to perform with the rule that matches
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgs']:
        """
        Rule matching Criteria
        """
        return pulumi.get(self, "match_criteria")

    @match_criteria.setter
    def match_criteria(self, value: pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgs']):
        pulumi.set(self, "match_criteria", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if the rule is active or not
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether to enable logging with headers on rule match or not
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "logging", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgsDict(TypedDict):
        modify_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgsDict']]]]
        """
        Modify header
        """
        rewrite_location_header: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgsDict']]
        """
        Rewrite location header
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgs:
    def __init__(__self__, *,
                 modify_headers: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgs']]]] = None,
                 rewrite_location_header: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgs']]] modify_headers: Modify header
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgs'] rewrite_location_header: Rewrite location header
        """
        if modify_headers is not None:
            pulumi.set(__self__, "modify_headers", modify_headers)
        if rewrite_location_header is not None:
            pulumi.set(__self__, "rewrite_location_header", rewrite_location_header)

    @property
    @pulumi.getter(name="modifyHeaders")
    def modify_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgs']]]]:
        """
        Modify header
        """
        return pulumi.get(self, "modify_headers")

    @modify_headers.setter
    def modify_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgs']]]]):
        pulumi.set(self, "modify_headers", value)

    @property
    @pulumi.getter(name="rewriteLocationHeader")
    def rewrite_location_header(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgs']]:
        """
        Rewrite location header
        """
        return pulumi.get(self, "rewrite_location_header")

    @rewrite_location_header.setter
    def rewrite_location_header(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgs']]):
        pulumi.set(self, "rewrite_location_header", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        """
        name: pulumi.Input[str]
        """
        HTTP header name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        HTTP header value
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        :param pulumi.Input[str] name: HTTP header name
        :param pulumi.Input[str] value: HTTP header value
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        HTTP header name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        HTTP header value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgsDict(TypedDict):
        port: pulumi.Input[str]
        """
        Port to which redirect the request
        """
        protocol: pulumi.Input[str]
        """
        HTTP or HTTPS protocol
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Host to which redirect the request
        """
        keep_query: NotRequired[pulumi.Input[bool]]
        """
        Should the query part be preserved
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to which redirect the request
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 host: Optional[pulumi.Input[str]] = None,
                 keep_query: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] port: Port to which redirect the request
        :param pulumi.Input[str] protocol: HTTP or HTTPS protocol
        :param pulumi.Input[str] host: Host to which redirect the request
        :param pulumi.Input[bool] keep_query: Should the query part be preserved
        :param pulumi.Input[str] path: Path to which redirect the request
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_query is not None:
            pulumi.set(__self__, "keep_query", keep_query)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[str]:
        """
        Port to which redirect the request
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[str]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        HTTP or HTTPS protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host to which redirect the request
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the query part be preserved
        """
        return pulumi.get(self, "keep_query")

    @keep_query.setter
    def keep_query(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_query", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to which redirect the request
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgsDict(TypedDict):
        client_ip_address: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgsDict']]
        """
        Client IP Address criteria
        """
        cookie: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgsDict']]
        """
        Criteria for matching cookie
        """
        http_methods: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgsDict']]
        """
        HTTP methods that should be matched
        """
        location_header: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgsDict']]
        """
        A matching criteria for Location header
        """
        path: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgsDict']]
        """
        Request path criteria
        """
        protocol_type: NotRequired[pulumi.Input[str]]
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        HTTP request query strings to match
        """
        request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgsDict']]]]
        """
        A set of rules for matching request headers
        """
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgsDict']]]]
        """
        A set of criteria to match response headers
        """
        service_ports: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgsDict']]
        """
        Service Port criteria
        """
        status_code: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgsDict']]
        """
        HTTP Status code to match
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgs:
    def __init__(__self__, *,
                 client_ip_address: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgs']] = None,
                 cookie: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgs']] = None,
                 http_methods: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgs']] = None,
                 location_header: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgs']] = None,
                 path: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgs']] = None,
                 protocol_type: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgs']]]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgs']]]] = None,
                 service_ports: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgs']] = None,
                 status_code: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgs']] = None):
        """
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgs'] client_ip_address: Client IP Address criteria
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgs'] cookie: Criteria for matching cookie
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgs'] http_methods: HTTP methods that should be matched
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgs'] location_header: A matching criteria for Location header
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgs'] path: Request path criteria
        :param pulumi.Input[str] protocol_type: Protocol to match - 'HTTP' or 'HTTPS'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] queries: HTTP request query strings to match
        :param pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgs']]] request_headers: A set of rules for matching request headers
        :param pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgs']]] response_headers: A set of criteria to match response headers
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgs'] service_ports: Service Port criteria
        :param pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgs'] status_code: HTTP Status code to match
        """
        if client_ip_address is not None:
            pulumi.set(__self__, "client_ip_address", client_ip_address)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if location_header is not None:
            pulumi.set(__self__, "location_header", location_header)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)
        if service_ports is not None:
            pulumi.set(__self__, "service_ports", service_ports)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="clientIpAddress")
    def client_ip_address(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgs']]:
        """
        Client IP Address criteria
        """
        return pulumi.get(self, "client_ip_address")

    @client_ip_address.setter
    def client_ip_address(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgs']]):
        pulumi.set(self, "client_ip_address", value)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgs']]:
        """
        Criteria for matching cookie
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgs']]:
        """
        HTTP methods that should be matched
        """
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgs']]):
        pulumi.set(self, "http_methods", value)

    @property
    @pulumi.getter(name="locationHeader")
    def location_header(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgs']]:
        """
        A matching criteria for Location header
        """
        return pulumi.get(self, "location_header")

    @location_header.setter
    def location_header(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgs']]):
        pulumi.set(self, "location_header", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgs']]:
        """
        Request path criteria
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        return pulumi.get(self, "protocol_type")

    @protocol_type.setter
    def protocol_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_type", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        HTTP request query strings to match
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgs']]]]:
        """
        A set of rules for matching request headers
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgs']]]]):
        pulumi.set(self, "request_headers", value)

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgs']]]]:
        """
        A set of criteria to match response headers
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgs']]]]):
        pulumi.set(self, "response_headers", value)

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgs']]:
        """
        Service Port criteria
        """
        return pulumi.get(self, "service_ports")

    @service_ports.setter
    def service_ports(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgs']]):
        pulumi.set(self, "service_ports", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgs']]:
        """
        HTTP Status code to match
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgs']]):
        pulumi.set(self, "status_code", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        ip_addresses: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A set of IP addresses
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 ip_addresses: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_addresses: A set of IP addresses
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A set of IP addresses
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        name: pulumi.Input[str]
        """
        Name of the HTTP cookie whose value is to be matched
        """
        value: pulumi.Input[str]
        """
        String values to match for an HTTP cookie
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param pulumi.Input[str] name: Name of the HTTP cookie whose value is to be matched
        :param pulumi.Input[str] value: String values to match for an HTTP cookie
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP cookie whose value is to be matched
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        String values to match for an HTTP cookie
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        methods: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 methods: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "methods", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching location header. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A set of values to match for criteria
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching location header. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A set of values to match for criteria
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching location header. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A set of values to match for criteria
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        paths: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        String values to match the path
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 paths: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: String values to match the path
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def paths(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        String values to match the path
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        name: pulumi.Input[str]
        """
        Name of the HTTP header whose value is to be matched
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        String values to match for an HTTP header
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param pulumi.Input[str] name: Name of the HTTP header whose value is to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: String values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        String values to match for an HTTP header
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the HTTP header whose value is to be matched
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of values to match for an HTTP header
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param pulumi.Input[str] name: Name of the HTTP header whose value is to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A set of values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of values to match for an HTTP header
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        ports: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        A set of TCP ports. Allowed values are 1-65535
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 ports: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: A set of TCP ports. Allowed values are 1-65535
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        A set of TCP ports. Allowed values are 1-65535
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        http_status_code: pulumi.Input[str]
        """
        Enter a http status code or range
        """
elif False:
    NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 http_status_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        :param pulumi.Input[str] http_status_code: Enter a http status code or range
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "http_status_code", http_status_code)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter(name="httpStatusCode")
    def http_status_code(self) -> pulumi.Input[str]:
        """
        Enter a http status code or range
        """
        return pulumi.get(self, "http_status_code")

    @http_status_code.setter
    def http_status_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "http_status_code", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleArgsDict(TypedDict):
        actions: pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgsDict']
        """
        Actions to perform with the rule that matches
        """
        match_criteria: pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgsDict']
        """
        Rule matching Criteria
        """
        name: pulumi.Input[str]
        """
        Name of the rule
        """
        active: NotRequired[pulumi.Input[bool]]
        """
        Defines is the rule is active or not
        """
        logging: NotRequired[pulumi.Input[bool]]
        """
        Defines whether to enable logging with headers on rule match or not
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgs'],
                 match_criteria: pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgs'],
                 name: pulumi.Input[str],
                 active: Optional[pulumi.Input[bool]] = None,
                 logging: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgs'] actions: Actions to perform with the rule that matches
        :param pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgs'] match_criteria: Rule matching Criteria
        :param pulumi.Input[str] name: Name of the rule
        :param pulumi.Input[bool] active: Defines is the rule is active or not
        :param pulumi.Input[bool] logging: Defines whether to enable logging with headers on rule match or not
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_criteria", match_criteria)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgs']:
        """
        Actions to perform with the rule that matches
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgs']:
        """
        Rule matching Criteria
        """
        return pulumi.get(self, "match_criteria")

    @match_criteria.setter
    def match_criteria(self, value: pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgs']):
        pulumi.set(self, "match_criteria", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines is the rule is active or not
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether to enable logging with headers on rule match or not
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "logging", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgsDict(TypedDict):
        connections: NotRequired[pulumi.Input[str]]
        """
        ALLOW or CLOSE connections
        """
        rate_limit: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgsDict']]
        """
        Apply actions based on rate limits
        """
        redirect_to_https: NotRequired[pulumi.Input[str]]
        """
        Port number that should be redirected to HTTPS
        """
        send_response: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgsDict']]
        """
        Send custom response
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgs:
    def __init__(__self__, *,
                 connections: Optional[pulumi.Input[str]] = None,
                 rate_limit: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgs']] = None,
                 redirect_to_https: Optional[pulumi.Input[str]] = None,
                 send_response: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgs']] = None):
        """
        :param pulumi.Input[str] connections: ALLOW or CLOSE connections
        :param pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgs'] rate_limit: Apply actions based on rate limits
        :param pulumi.Input[str] redirect_to_https: Port number that should be redirected to HTTPS
        :param pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgs'] send_response: Send custom response
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if redirect_to_https is not None:
            pulumi.set(__self__, "redirect_to_https", redirect_to_https)
        if send_response is not None:
            pulumi.set(__self__, "send_response", send_response)

    @property
    @pulumi.getter
    def connections(self) -> Optional[pulumi.Input[str]]:
        """
        ALLOW or CLOSE connections
        """
        return pulumi.get(self, "connections")

    @connections.setter
    def connections(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connections", value)

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgs']]:
        """
        Apply actions based on rate limits
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgs']]):
        pulumi.set(self, "rate_limit", value)

    @property
    @pulumi.getter(name="redirectToHttps")
    def redirect_to_https(self) -> Optional[pulumi.Input[str]]:
        """
        Port number that should be redirected to HTTPS
        """
        return pulumi.get(self, "redirect_to_https")

    @redirect_to_https.setter
    def redirect_to_https(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_to_https", value)

    @property
    @pulumi.getter(name="sendResponse")
    def send_response(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgs']]:
        """
        Send custom response
        """
        return pulumi.get(self, "send_response")

    @send_response.setter
    def send_response(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgs']]):
        pulumi.set(self, "send_response", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgsDict(TypedDict):
        count: pulumi.Input[str]
        """
        Maximum number of connections, requests or packets permitted each period. The count must be between 1 and 1000000000
        """
        period: pulumi.Input[str]
        """
        Time value in seconds to enforce rate count. The period must be between 1 and 1000000000
        """
        action_close_connection: NotRequired[pulumi.Input[bool]]
        """
        Set to true if the connection should be closed
        """
        action_local_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgsDict']]]]
        """
        Send custom response
        """
        action_redirects: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgsDict']]]]
        """
        Redirect based on rate limits
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[str],
                 period: pulumi.Input[str],
                 action_close_connection: Optional[pulumi.Input[bool]] = None,
                 action_local_responses: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgs']]]] = None,
                 action_redirects: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgs']]]] = None):
        """
        :param pulumi.Input[str] count: Maximum number of connections, requests or packets permitted each period. The count must be between 1 and 1000000000
        :param pulumi.Input[str] period: Time value in seconds to enforce rate count. The period must be between 1 and 1000000000
        :param pulumi.Input[bool] action_close_connection: Set to true if the connection should be closed
        :param pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgs']]] action_local_responses: Send custom response
        :param pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgs']]] action_redirects: Redirect based on rate limits
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "period", period)
        if action_close_connection is not None:
            pulumi.set(__self__, "action_close_connection", action_close_connection)
        if action_local_responses is not None:
            pulumi.set(__self__, "action_local_responses", action_local_responses)
        if action_redirects is not None:
            pulumi.set(__self__, "action_redirects", action_redirects)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[str]:
        """
        Maximum number of connections, requests or packets permitted each period. The count must be between 1 and 1000000000
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[str]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[str]:
        """
        Time value in seconds to enforce rate count. The period must be between 1 and 1000000000
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[str]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="actionCloseConnection")
    def action_close_connection(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true if the connection should be closed
        """
        return pulumi.get(self, "action_close_connection")

    @action_close_connection.setter
    def action_close_connection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action_close_connection", value)

    @property
    @pulumi.getter(name="actionLocalResponses")
    def action_local_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgs']]]]:
        """
        Send custom response
        """
        return pulumi.get(self, "action_local_responses")

    @action_local_responses.setter
    def action_local_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgs']]]]):
        pulumi.set(self, "action_local_responses", value)

    @property
    @pulumi.getter(name="actionRedirects")
    def action_redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgs']]]]:
        """
        Redirect based on rate limits
        """
        return pulumi.get(self, "action_redirects")

    @action_redirects.setter
    def action_redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgs']]]]):
        pulumi.set(self, "action_redirects", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgsDict(TypedDict):
        status_code: pulumi.Input[str]
        """
        HTTP Status code to send
        """
        content: NotRequired[pulumi.Input[str]]
        """
        Base64 encoded content
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        MIME type for the content
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[str],
                 content: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status_code: HTTP Status code to send
        :param pulumi.Input[str] content: Base64 encoded content
        :param pulumi.Input[str] content_type: MIME type for the content
        """
        pulumi.set(__self__, "status_code", status_code)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[str]:
        """
        HTTP Status code to send
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded content
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        MIME type for the content
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgsDict(TypedDict):
        port: pulumi.Input[str]
        """
        Port to which redirect the request
        """
        protocol: pulumi.Input[str]
        """
        HTTP or HTTPS protocol
        """
        status_code: pulumi.Input[int]
        """
        One of the redirect status codes - 301, 302, 307
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Host to which redirect the request
        """
        keep_query: NotRequired[pulumi.Input[bool]]
        """
        Should the query part be preserved
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path to which redirect the request
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 status_code: pulumi.Input[int],
                 host: Optional[pulumi.Input[str]] = None,
                 keep_query: Optional[pulumi.Input[bool]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] port: Port to which redirect the request
        :param pulumi.Input[str] protocol: HTTP or HTTPS protocol
        :param pulumi.Input[int] status_code: One of the redirect status codes - 301, 302, 307
        :param pulumi.Input[str] host: Host to which redirect the request
        :param pulumi.Input[bool] keep_query: Should the query part be preserved
        :param pulumi.Input[str] path: Path to which redirect the request
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "status_code", status_code)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_query is not None:
            pulumi.set(__self__, "keep_query", keep_query)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[str]:
        """
        Port to which redirect the request
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[str]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        HTTP or HTTPS protocol
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[int]:
        """
        One of the redirect status codes - 301, 302, 307
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host to which redirect the request
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the query part be preserved
        """
        return pulumi.get(self, "keep_query")

    @keep_query.setter
    def keep_query(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_query", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to which redirect the request
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgsDict(TypedDict):
        status_code: pulumi.Input[str]
        """
        HTTP Status code to send
        """
        content: NotRequired[pulumi.Input[str]]
        """
        Base64 encoded content
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        MIME type for the content
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgs:
    def __init__(__self__, *,
                 status_code: pulumi.Input[str],
                 content: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status_code: HTTP Status code to send
        :param pulumi.Input[str] content: Base64 encoded content
        :param pulumi.Input[str] content_type: MIME type for the content
        """
        pulumi.set(__self__, "status_code", status_code)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> pulumi.Input[str]:
        """
        HTTP Status code to send
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded content
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        MIME type for the content
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgsDict(TypedDict):
        client_ip_address: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgsDict']]
        """
        Client IP Address criteria
        """
        cookie: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgsDict']]
        """
        Criteria for matching cookie
        """
        http_methods: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgsDict']]
        """
        HTTP methods that should be matched
        """
        path: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgsDict']]
        """
        Request path criteria
        """
        protocol_type: NotRequired[pulumi.Input[str]]
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        HTTP request query strings to match
        """
        request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgsDict']]]]
        """
        A set of rules for matching request headers
        """
        service_ports: NotRequired[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgsDict']]
        """
        Service Port criteria
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgs:
    def __init__(__self__, *,
                 client_ip_address: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgs']] = None,
                 cookie: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgs']] = None,
                 http_methods: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgs']] = None,
                 path: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgs']] = None,
                 protocol_type: Optional[pulumi.Input[str]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgs']]]] = None,
                 service_ports: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgs']] = None):
        """
        :param pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgs'] client_ip_address: Client IP Address criteria
        :param pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgs'] cookie: Criteria for matching cookie
        :param pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgs'] http_methods: HTTP methods that should be matched
        :param pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgs'] path: Request path criteria
        :param pulumi.Input[str] protocol_type: Protocol to match - 'HTTP' or 'HTTPS'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] queries: HTTP request query strings to match
        :param pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgs']]] request_headers: A set of rules for matching request headers
        :param pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgs'] service_ports: Service Port criteria
        """
        if client_ip_address is not None:
            pulumi.set(__self__, "client_ip_address", client_ip_address)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if service_ports is not None:
            pulumi.set(__self__, "service_ports", service_ports)

    @property
    @pulumi.getter(name="clientIpAddress")
    def client_ip_address(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgs']]:
        """
        Client IP Address criteria
        """
        return pulumi.get(self, "client_ip_address")

    @client_ip_address.setter
    def client_ip_address(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgs']]):
        pulumi.set(self, "client_ip_address", value)

    @property
    @pulumi.getter
    def cookie(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgs']]:
        """
        Criteria for matching cookie
        """
        return pulumi.get(self, "cookie")

    @cookie.setter
    def cookie(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgs']]):
        pulumi.set(self, "cookie", value)

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgs']]:
        """
        HTTP methods that should be matched
        """
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgs']]):
        pulumi.set(self, "http_methods", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgs']]:
        """
        Request path criteria
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgs']]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        return pulumi.get(self, "protocol_type")

    @protocol_type.setter
    def protocol_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_type", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        HTTP request query strings to match
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgs']]]]:
        """
        A set of rules for matching request headers
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgs']]]]):
        pulumi.set(self, "request_headers", value)

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgs']]:
        """
        Service Port criteria
        """
        return pulumi.get(self, "service_ports")

    @service_ports.setter
    def service_ports(self, value: Optional[pulumi.Input['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgs']]):
        pulumi.set(self, "service_ports", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        ip_addresses: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A set of IP addresses
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 ip_addresses: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_addresses: A set of IP addresses
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A set of IP addresses
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ip_addresses", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        name: pulumi.Input[str]
        """
        Name of the HTTP cookie whose value is to be matched
        """
        value: pulumi.Input[str]
        """
        String values to match for an HTTP cookie
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param pulumi.Input[str] name: Name of the HTTP cookie whose value is to be matched
        :param pulumi.Input[str] value: String values to match for an HTTP cookie
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP cookie whose value is to be matched
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        String values to match for an HTTP cookie
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        methods: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 methods: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "methods", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        paths: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        String values to match the path
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 paths: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: String values to match the path
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def paths(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        String values to match the path
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        name: pulumi.Input[str]
        """
        Name of the HTTP header whose value is to be matched
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        String values to match for an HTTP header
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param pulumi.Input[str] name: Name of the HTTP header whose value is to be matched
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: String values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        String values to match for an HTTP header
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgsDict(TypedDict):
        criteria: pulumi.Input[str]
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        ports: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        A set of TCP ports. Allowed values are 1-65535
        """
elif False:
    NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgs:
    def __init__(__self__, *,
                 criteria: pulumi.Input[str],
                 ports: pulumi.Input[Sequence[pulumi.Input[int]]]):
        """
        :param pulumi.Input[str] criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: A set of TCP ports. Allowed values are 1-65535
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input[str]:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input[str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        A set of TCP ports. Allowed values are 1-65535
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class NsxtAlbVirtualServiceServicePortArgsDict(TypedDict):
        start_port: pulumi.Input[int]
        """
        Starting port in the range
        """
        type: pulumi.Input[str]
        """
        One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'
        """
        end_port: NotRequired[pulumi.Input[int]]
        """
        Last port in the range
        """
        ssl_enabled: NotRequired[pulumi.Input[bool]]
        """
        Defines if certificate should be used
        """
elif False:
    NsxtAlbVirtualServiceServicePortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAlbVirtualServiceServicePortArgs:
    def __init__(__self__, *,
                 start_port: pulumi.Input[int],
                 type: pulumi.Input[str],
                 end_port: Optional[pulumi.Input[int]] = None,
                 ssl_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] start_port: Starting port in the range
        :param pulumi.Input[str] type: One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'
        :param pulumi.Input[int] end_port: Last port in the range
        :param pulumi.Input[bool] ssl_enabled: Defines if certificate should be used
        """
        pulumi.set(__self__, "start_port", start_port)
        pulumi.set(__self__, "type", type)
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if ssl_enabled is not None:
            pulumi.set(__self__, "ssl_enabled", ssl_enabled)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[int]:
        """
        Starting port in the range
        """
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_port", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        """
        Last port in the range
        """
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="sslEnabled")
    def ssl_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if certificate should be used
        """
        return pulumi.get(self, "ssl_enabled")

    @ssl_enabled.setter
    def ssl_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl_enabled", value)


if not MYPY:
    class NsxtAppPortProfileAppPortArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of ports or ranges
        """
elif False:
    NsxtAppPortProfileAppPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtAppPortProfileAppPortArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ports: Set of ports or ranges
        """
        pulumi.set(__self__, "protocol", protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of ports or ranges
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class NsxtDistributedFirewallRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic
        """
        name: pulumi.Input[str]
        """
        Firewall Rule name
        """
        app_port_profile_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of Application Port Profile IDs. Leaving it empty means 'Any'
        """
        comment: NotRequired[pulumi.Input[str]]
        """
        Comment that is shown next to rule in UI (VCD 10.3.2+)
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description is not shown in UI
        """
        destination_groups_excluded: NotRequired[pulumi.Input[bool]]
        """
        Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)
        """
        destination_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        direction: NotRequired[pulumi.Input[str]]
        """
        Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Defined if Firewall Rule is active
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Firewall Rule ID
        """
        ip_protocol: NotRequired[pulumi.Input[str]]
        """
        Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        """
        logging: NotRequired[pulumi.Input[bool]]
        """
        Defines if matching traffic should be logged
        """
        network_context_profile_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of Network Context Profile IDs. Leaving it empty means 'Any'
        """
        source_groups_excluded: NotRequired[pulumi.Input[bool]]
        """
        Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)
        """
        source_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
elif False:
    NsxtDistributedFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtDistributedFirewallRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 app_port_profile_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 destination_groups_excluded: Optional[pulumi.Input[bool]] = None,
                 destination_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 direction: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 ip_protocol: Optional[pulumi.Input[str]] = None,
                 logging: Optional[pulumi.Input[bool]] = None,
                 network_context_profile_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_groups_excluded: Optional[pulumi.Input[bool]] = None,
                 source_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] action: Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic
        :param pulumi.Input[str] name: Firewall Rule name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_port_profile_ids: A set of Application Port Profile IDs. Leaving it empty means 'Any'
        :param pulumi.Input[str] comment: Comment that is shown next to rule in UI (VCD 10.3.2+)
        :param pulumi.Input[str] description: Description is not shown in UI
        :param pulumi.Input[bool] destination_groups_excluded: Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_ids: A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        :param pulumi.Input[str] direction: Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        :param pulumi.Input[bool] enabled: Defined if Firewall Rule is active
        :param pulumi.Input[str] id: Firewall Rule ID
        :param pulumi.Input[str] ip_protocol: Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        :param pulumi.Input[bool] logging: Defines if matching traffic should be logged
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_context_profile_ids: A set of Network Context Profile IDs. Leaving it empty means 'Any'
        :param pulumi.Input[bool] source_groups_excluded: Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ids: A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if app_port_profile_ids is not None:
            pulumi.set(__self__, "app_port_profile_ids", app_port_profile_ids)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_groups_excluded is not None:
            pulumi.set(__self__, "destination_groups_excluded", destination_groups_excluded)
        if destination_ids is not None:
            pulumi.set(__self__, "destination_ids", destination_ids)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if network_context_profile_ids is not None:
            pulumi.set(__self__, "network_context_profile_ids", network_context_profile_ids)
        if source_groups_excluded is not None:
            pulumi.set(__self__, "source_groups_excluded", source_groups_excluded)
        if source_ids is not None:
            pulumi.set(__self__, "source_ids", source_ids)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="appPortProfileIds")
    def app_port_profile_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of Application Port Profile IDs. Leaving it empty means 'Any'
        """
        return pulumi.get(self, "app_port_profile_ids")

    @app_port_profile_ids.setter
    def app_port_profile_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_port_profile_ids", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        Comment that is shown next to rule in UI (VCD 10.3.2+)
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description is not shown in UI
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationGroupsExcluded")
    def destination_groups_excluded(self) -> Optional[pulumi.Input[bool]]:
        """
        Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)
        """
        return pulumi.get(self, "destination_groups_excluded")

    @destination_groups_excluded.setter
    def destination_groups_excluded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "destination_groups_excluded", value)

    @property
    @pulumi.getter(name="destinationIds")
    def destination_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "destination_ids")

    @destination_ids.setter
    def destination_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_ids", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        """
        Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defined if Firewall Rule is active
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall Rule ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        """
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_protocol", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if matching traffic should be logged
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter(name="networkContextProfileIds")
    def network_context_profile_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of Network Context Profile IDs. Leaving it empty means 'Any'
        """
        return pulumi.get(self, "network_context_profile_ids")

    @network_context_profile_ids.setter
    def network_context_profile_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_context_profile_ids", value)

    @property
    @pulumi.getter(name="sourceGroupsExcluded")
    def source_groups_excluded(self) -> Optional[pulumi.Input[bool]]:
        """
        Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)
        """
        return pulumi.get(self, "source_groups_excluded")

    @source_groups_excluded.setter
    def source_groups_excluded(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "source_groups_excluded", value)

    @property
    @pulumi.getter(name="sourceIds")
    def source_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "source_ids")

    @source_ids.setter
    def source_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_ids", value)


if not MYPY:
    class NsxtDynamicSecurityGroupCriteriaArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtDynamicSecurityGroupCriteriaRuleArgsDict']]]]
        """
        Up to 4 rules for matching VMs. List of rules are matched with boolean `AND`
        operation and all defines rules must match to include object. See Rule for rule
        definition structure.


        <a id="rule"></a>
        """
elif False:
    NsxtDynamicSecurityGroupCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtDynamicSecurityGroupCriteriaArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtDynamicSecurityGroupCriteriaRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NsxtDynamicSecurityGroupCriteriaRuleArgs']]] rules: Up to 4 rules for matching VMs. List of rules are matched with boolean `AND`
               operation and all defines rules must match to include object. See Rule for rule
               definition structure.
               
               
               <a id="rule"></a>
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtDynamicSecurityGroupCriteriaRuleArgs']]]]:
        """
        Up to 4 rules for matching VMs. List of rules are matched with boolean `AND`
        operation and all defines rules must match to include object. See Rule for rule
        definition structure.


        <a id="rule"></a>
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtDynamicSecurityGroupCriteriaRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class NsxtDynamicSecurityGroupCriteriaRuleArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'
        """
        type: pulumi.Input[str]
        """
        Type of object matching 'VM_TAG' or 'VM_NAME'
        """
        value: pulumi.Input[str]
        """
        Filter value
        """
elif False:
    NsxtDynamicSecurityGroupCriteriaRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtDynamicSecurityGroupCriteriaRuleArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] operator: Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'
        :param pulumi.Input[str] type: Type of object matching 'VM_TAG' or 'VM_NAME'
        :param pulumi.Input[str] value: Filter value
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of object matching 'VM_TAG' or 'VM_NAME'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Filter value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxtDynamicSecurityGroupMemberVmArgsDict(TypedDict):
        vapp_id: NotRequired[pulumi.Input[str]]
        """
        Parent vApp name (if exists) for member VM
        """
        vapp_name: NotRequired[pulumi.Input[str]]
        """
        Parent vApp ID (if exists) for member VM
        """
        vm_id: NotRequired[pulumi.Input[str]]
        """
        Member VM ID
        """
        vm_name: NotRequired[pulumi.Input[str]]
        """
        Member VM Name
        """
elif False:
    NsxtDynamicSecurityGroupMemberVmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtDynamicSecurityGroupMemberVmArgs:
    def __init__(__self__, *,
                 vapp_id: Optional[pulumi.Input[str]] = None,
                 vapp_name: Optional[pulumi.Input[str]] = None,
                 vm_id: Optional[pulumi.Input[str]] = None,
                 vm_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] vapp_id: Parent vApp name (if exists) for member VM
        :param pulumi.Input[str] vapp_name: Parent vApp ID (if exists) for member VM
        :param pulumi.Input[str] vm_id: Member VM ID
        :param pulumi.Input[str] vm_name: Member VM Name
        """
        if vapp_id is not None:
            pulumi.set(__self__, "vapp_id", vapp_id)
        if vapp_name is not None:
            pulumi.set(__self__, "vapp_name", vapp_name)
        if vm_id is not None:
            pulumi.set(__self__, "vm_id", vm_id)
        if vm_name is not None:
            pulumi.set(__self__, "vm_name", vm_name)

    @property
    @pulumi.getter(name="vappId")
    def vapp_id(self) -> Optional[pulumi.Input[str]]:
        """
        Parent vApp name (if exists) for member VM
        """
        return pulumi.get(self, "vapp_id")

    @vapp_id.setter
    def vapp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_id", value)

    @property
    @pulumi.getter(name="vappName")
    def vapp_name(self) -> Optional[pulumi.Input[str]]:
        """
        Parent vApp ID (if exists) for member VM
        """
        return pulumi.get(self, "vapp_name")

    @vapp_name.setter
    def vapp_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_name", value)

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> Optional[pulumi.Input[str]]:
        """
        Member VM ID
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_id", value)

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> Optional[pulumi.Input[str]]:
        """
        Member VM Name
        """
        return pulumi.get(self, "vm_name")

    @vm_name.setter
    def vm_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_name", value)


if not MYPY:
    class NsxtEdgegatewayBgpIpPrefixListIpPrefixArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action 'PERMIT' or 'DENY'
        """
        network: pulumi.Input[str]
        """
        Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')
        """
        greater_than_or_equal_to: NotRequired[pulumi.Input[int]]
        """
        Greater than or equal to subnet mask
        """
        less_than_or_equal_to: NotRequired[pulumi.Input[int]]
        """
        Less than or equal to subnet mask
        """
elif False:
    NsxtEdgegatewayBgpIpPrefixListIpPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewayBgpIpPrefixListIpPrefixArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 network: pulumi.Input[str],
                 greater_than_or_equal_to: Optional[pulumi.Input[int]] = None,
                 less_than_or_equal_to: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] action: Action 'PERMIT' or 'DENY'
        :param pulumi.Input[str] network: Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')
        :param pulumi.Input[int] greater_than_or_equal_to: Greater than or equal to subnet mask
        :param pulumi.Input[int] less_than_or_equal_to: Less than or equal to subnet mask
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "network", network)
        if greater_than_or_equal_to is not None:
            pulumi.set(__self__, "greater_than_or_equal_to", greater_than_or_equal_to)
        if less_than_or_equal_to is not None:
            pulumi.set(__self__, "less_than_or_equal_to", less_than_or_equal_to)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action 'PERMIT' or 'DENY'
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="greaterThanOrEqualTo")
    def greater_than_or_equal_to(self) -> Optional[pulumi.Input[int]]:
        """
        Greater than or equal to subnet mask
        """
        return pulumi.get(self, "greater_than_or_equal_to")

    @greater_than_or_equal_to.setter
    def greater_than_or_equal_to(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "greater_than_or_equal_to", value)

    @property
    @pulumi.getter(name="lessThanOrEqualTo")
    def less_than_or_equal_to(self) -> Optional[pulumi.Input[int]]:
        """
        Less than or equal to subnet mask
        """
        return pulumi.get(self, "less_than_or_equal_to")

    @less_than_or_equal_to.setter
    def less_than_or_equal_to(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "less_than_or_equal_to", value)


if not MYPY:
    class NsxtEdgegatewayDnsConditionalForwarderZoneArgsDict(TypedDict):
        domain_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of domain names on which conditional forwarding is based.
        """
        name: pulumi.Input[str]
        """
        Name of the forwarder zone.
        """
        upstream_servers: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Servers to which DNS requests should be forwarded to.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique ID of the forwarder zone.
        """
elif False:
    NsxtEdgegatewayDnsConditionalForwarderZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewayDnsConditionalForwarderZoneArgs:
    def __init__(__self__, *,
                 domain_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 upstream_servers: pulumi.Input[Sequence[pulumi.Input[str]]],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domain_names: Set of domain names on which conditional forwarding is based.
        :param pulumi.Input[str] name: Name of the forwarder zone.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] upstream_servers: Servers to which DNS requests should be forwarded to.
        :param pulumi.Input[str] id: Unique ID of the forwarder zone.
        """
        pulumi.set(__self__, "domain_names", domain_names)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "upstream_servers", upstream_servers)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of domain names on which conditional forwarding is based.
        """
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "domain_names", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the forwarder zone.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="upstreamServers")
    def upstream_servers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Servers to which DNS requests should be forwarded to.
        """
        return pulumi.get(self, "upstream_servers")

    @upstream_servers.setter
    def upstream_servers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "upstream_servers", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique ID of the forwarder zone.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NsxtEdgegatewayDnsDefaultForwarderZoneArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the forwarder zone.
        """
        upstream_servers: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Servers to which DNS requests should be forwarded to.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique ID of the forwarder zone.
        """
elif False:
    NsxtEdgegatewayDnsDefaultForwarderZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewayDnsDefaultForwarderZoneArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 upstream_servers: pulumi.Input[Sequence[pulumi.Input[str]]],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the forwarder zone.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] upstream_servers: Servers to which DNS requests should be forwarded to.
        :param pulumi.Input[str] id: Unique ID of the forwarder zone.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "upstream_servers", upstream_servers)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the forwarder zone.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="upstreamServers")
    def upstream_servers(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Servers to which DNS requests should be forwarded to.
        """
        return pulumi.get(self, "upstream_servers")

    @upstream_servers.setter
    def upstream_servers(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "upstream_servers", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique ID of the forwarder zone.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class NsxtEdgegatewayExternalNetworkArgsDict(TypedDict):
        allocated_ip_count: pulumi.Input[int]
        """
        Number of allocated IPs
        """
        external_network_id: pulumi.Input[str]
        """
        An external network ID. **Note:** Data source [ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
        can be used to lookup ID by name.
        """
        gateway: pulumi.Input[str]
        """
        Gateway IP Address
        """
        prefix_length: pulumi.Input[int]
        """
        Prefix length for a subnet (e.g. 24)
        """
        primary_ip: NotRequired[pulumi.Input[str]]
        """
        Primary IP address exposed for an easy access without nesting.
        """
elif False:
    NsxtEdgegatewayExternalNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewayExternalNetworkArgs:
    def __init__(__self__, *,
                 allocated_ip_count: pulumi.Input[int],
                 external_network_id: pulumi.Input[str],
                 gateway: pulumi.Input[str],
                 prefix_length: pulumi.Input[int],
                 primary_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] allocated_ip_count: Number of allocated IPs
        :param pulumi.Input[str] external_network_id: An external network ID. **Note:** Data source [ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
               can be used to lookup ID by name.
        :param pulumi.Input[str] gateway: Gateway IP Address
        :param pulumi.Input[int] prefix_length: Prefix length for a subnet (e.g. 24)
        :param pulumi.Input[str] primary_ip: Primary IP address exposed for an easy access without nesting.
        """
        pulumi.set(__self__, "allocated_ip_count", allocated_ip_count)
        pulumi.set(__self__, "external_network_id", external_network_id)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if primary_ip is not None:
            pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter(name="allocatedIpCount")
    def allocated_ip_count(self) -> pulumi.Input[int]:
        """
        Number of allocated IPs
        """
        return pulumi.get(self, "allocated_ip_count")

    @allocated_ip_count.setter
    def allocated_ip_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "allocated_ip_count", value)

    @property
    @pulumi.getter(name="externalNetworkId")
    def external_network_id(self) -> pulumi.Input[str]:
        """
        An external network ID. **Note:** Data source [ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
        can be used to lookup ID by name.
        """
        return pulumi.get(self, "external_network_id")

    @external_network_id.setter
    def external_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "external_network_id", value)

    @property
    @pulumi.getter
    def gateway(self) -> pulumi.Input[str]:
        """
        Gateway IP Address
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Primary IP address exposed for an easy access without nesting.
        """
        return pulumi.get(self, "primary_ip")

    @primary_ip.setter
    def primary_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ip", value)


if not MYPY:
    class NsxtEdgegatewayL2VpnTunnelStretchedNetworkArgsDict(TypedDict):
        network_id: pulumi.Input[str]
        """
        ID of the Org VDC network
        """
        tunnel_id: NotRequired[pulumi.Input[int]]
        """
        Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.
        """
elif False:
    NsxtEdgegatewayL2VpnTunnelStretchedNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewayL2VpnTunnelStretchedNetworkArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[str],
                 tunnel_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] network_id: ID of the Org VDC network
        :param pulumi.Input[int] tunnel_id: Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.
        """
        pulumi.set(__self__, "network_id", network_id)
        if tunnel_id is not None:
            pulumi.set(__self__, "tunnel_id", tunnel_id)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[str]:
        """
        ID of the Org VDC network
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter(name="tunnelId")
    def tunnel_id(self) -> Optional[pulumi.Input[int]]:
        """
        Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.
        """
        return pulumi.get(self, "tunnel_id")

    @tunnel_id.setter
    def tunnel_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_id", value)


if not MYPY:
    class NsxtEdgegatewayStaticRouteNextHopArgsDict(TypedDict):
        admin_distance: pulumi.Input[int]
        """
        Admin distance of next hop
        """
        ip_address: pulumi.Input[str]
        """
        IP Address of next hop
        """
        scope: NotRequired[pulumi.Input['NsxtEdgegatewayStaticRouteNextHopScopeArgsDict']]
elif False:
    NsxtEdgegatewayStaticRouteNextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewayStaticRouteNextHopArgs:
    def __init__(__self__, *,
                 admin_distance: pulumi.Input[int],
                 ip_address: pulumi.Input[str],
                 scope: Optional[pulumi.Input['NsxtEdgegatewayStaticRouteNextHopScopeArgs']] = None):
        """
        :param pulumi.Input[int] admin_distance: Admin distance of next hop
        :param pulumi.Input[str] ip_address: IP Address of next hop
        """
        pulumi.set(__self__, "admin_distance", admin_distance)
        pulumi.set(__self__, "ip_address", ip_address)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="adminDistance")
    def admin_distance(self) -> pulumi.Input[int]:
        """
        Admin distance of next hop
        """
        return pulumi.get(self, "admin_distance")

    @admin_distance.setter
    def admin_distance(self, value: pulumi.Input[int]):
        pulumi.set(self, "admin_distance", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[str]:
        """
        IP Address of next hop
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['NsxtEdgegatewayStaticRouteNextHopScopeArgs']]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['NsxtEdgegatewayStaticRouteNextHopScopeArgs']]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class NsxtEdgegatewayStaticRouteNextHopScopeArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of Scope element
        """
        type: pulumi.Input[str]
        """
        Scope type - One of 'NETWORK', 'SYSTEM_OWNED'
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name for NSX-T Edge Gateway Static Route
        """
elif False:
    NsxtEdgegatewayStaticRouteNextHopScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewayStaticRouteNextHopScopeArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of Scope element
        :param pulumi.Input[str] type: Scope type - One of 'NETWORK', 'SYSTEM_OWNED'
        :param pulumi.Input[str] name: Name for NSX-T Edge Gateway Static Route
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of Scope element
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Scope type - One of 'NETWORK', 'SYSTEM_OWNED'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for NSX-T Edge Gateway Static Route
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class NsxtEdgegatewaySubnetArgsDict(TypedDict):
        gateway: pulumi.Input[str]
        """
        Gateway address for a subnet
        """
        prefix_length: pulumi.Input[int]
        """
        Prefix length for a subnet (e.g. 24)
        """
        allocated_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxtEdgegatewaySubnetAllocatedIpArgsDict']]]]
        """
        Define one or more blocks to sub-allocate pools on the edge gateway
        """
        primary_ip: NotRequired[pulumi.Input[str]]
        """
        Primary IP address exposed for an easy access without nesting.
        """
elif False:
    NsxtEdgegatewaySubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewaySubnetArgs:
    def __init__(__self__, *,
                 gateway: pulumi.Input[str],
                 prefix_length: pulumi.Input[int],
                 allocated_ips: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtEdgegatewaySubnetAllocatedIpArgs']]]] = None,
                 primary_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gateway: Gateway address for a subnet
        :param pulumi.Input[int] prefix_length: Prefix length for a subnet (e.g. 24)
        :param pulumi.Input[Sequence[pulumi.Input['NsxtEdgegatewaySubnetAllocatedIpArgs']]] allocated_ips: Define one or more blocks to sub-allocate pools on the edge gateway
        :param pulumi.Input[str] primary_ip: Primary IP address exposed for an easy access without nesting.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if allocated_ips is not None:
            pulumi.set(__self__, "allocated_ips", allocated_ips)
        if primary_ip is not None:
            pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter
    def gateway(self) -> pulumi.Input[str]:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter(name="allocatedIps")
    def allocated_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxtEdgegatewaySubnetAllocatedIpArgs']]]]:
        """
        Define one or more blocks to sub-allocate pools on the edge gateway
        """
        return pulumi.get(self, "allocated_ips")

    @allocated_ips.setter
    def allocated_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxtEdgegatewaySubnetAllocatedIpArgs']]]]):
        pulumi.set(self, "allocated_ips", value)

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Primary IP address exposed for an easy access without nesting.
        """
        return pulumi.get(self, "primary_ip")

    @primary_ip.setter
    def primary_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ip", value)


if not MYPY:
    class NsxtEdgegatewaySubnetAllocatedIpArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        start_address: pulumi.Input[str]
elif False:
    NsxtEdgegatewaySubnetAllocatedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewaySubnetAllocatedIpArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NsxtEdgegatewaySubnetWithIpCountArgsDict(TypedDict):
        allocated_ip_count: pulumi.Input[int]
        """
        Number of IP addresses to allocate
        """
        gateway: pulumi.Input[str]
        """
        Gateway address for a subnet
        """
        prefix_length: pulumi.Input[int]
        """
        Prefix length for a subnet (e.g. 24)
        """
        primary_ip: NotRequired[pulumi.Input[str]]
        """
        Primary IP address exposed for an easy access without nesting.
        """
elif False:
    NsxtEdgegatewaySubnetWithIpCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewaySubnetWithIpCountArgs:
    def __init__(__self__, *,
                 allocated_ip_count: pulumi.Input[int],
                 gateway: pulumi.Input[str],
                 prefix_length: pulumi.Input[int],
                 primary_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] allocated_ip_count: Number of IP addresses to allocate
        :param pulumi.Input[str] gateway: Gateway address for a subnet
        :param pulumi.Input[int] prefix_length: Prefix length for a subnet (e.g. 24)
        :param pulumi.Input[str] primary_ip: Primary IP address exposed for an easy access without nesting.
        """
        pulumi.set(__self__, "allocated_ip_count", allocated_ip_count)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if primary_ip is not None:
            pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter(name="allocatedIpCount")
    def allocated_ip_count(self) -> pulumi.Input[int]:
        """
        Number of IP addresses to allocate
        """
        return pulumi.get(self, "allocated_ip_count")

    @allocated_ip_count.setter
    def allocated_ip_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "allocated_ip_count", value)

    @property
    @pulumi.getter
    def gateway(self) -> pulumi.Input[str]:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Primary IP address exposed for an easy access without nesting.
        """
        return pulumi.get(self, "primary_ip")

    @primary_ip.setter
    def primary_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ip", value)


if not MYPY:
    class NsxtEdgegatewaySubnetWithTotalIpCountArgsDict(TypedDict):
        gateway: pulumi.Input[str]
        """
        Gateway address for a subnet
        """
        prefix_length: pulumi.Input[int]
        """
        Prefix length for a subnet (e.g. 24)
        """
        primary_ip: NotRequired[pulumi.Input[str]]
        """
        Primary IP address exposed for an easy access without nesting.
        """
elif False:
    NsxtEdgegatewaySubnetWithTotalIpCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtEdgegatewaySubnetWithTotalIpCountArgs:
    def __init__(__self__, *,
                 gateway: pulumi.Input[str],
                 prefix_length: pulumi.Input[int],
                 primary_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gateway: Gateway address for a subnet
        :param pulumi.Input[int] prefix_length: Prefix length for a subnet (e.g. 24)
        :param pulumi.Input[str] primary_ip: Primary IP address exposed for an easy access without nesting.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if primary_ip is not None:
            pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter
    def gateway(self) -> pulumi.Input[str]:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Primary IP address exposed for an easy access without nesting.
        """
        return pulumi.get(self, "primary_ip")

    @primary_ip.setter
    def primary_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_ip", value)


if not MYPY:
    class NsxtFirewallRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Defines if the rule should 'ALLOW', 'DROP' or 'REJECT' matching traffic
        """
        direction: pulumi.Input[str]
        """
        Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        """
        ip_protocol: pulumi.Input[str]
        """
        Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        """
        name: pulumi.Input[str]
        """
        Firewall Rule name
        """
        app_port_profile_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of Application Port Profile IDs. Leaving it empty means 'Any'
        """
        destination_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Defined if Firewall Rule is active
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Firewall Rule ID
        """
        logging: NotRequired[pulumi.Input[bool]]
        """
        Defines if matching traffic should be logged
        """
        source_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
elif False:
    NsxtFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtFirewallRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 direction: pulumi.Input[str],
                 ip_protocol: pulumi.Input[str],
                 name: pulumi.Input[str],
                 app_port_profile_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 logging: Optional[pulumi.Input[bool]] = None,
                 source_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] action: Defines if the rule should 'ALLOW', 'DROP' or 'REJECT' matching traffic
        :param pulumi.Input[str] direction: Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        :param pulumi.Input[str] ip_protocol: Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        :param pulumi.Input[str] name: Firewall Rule name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] app_port_profile_ids: A set of Application Port Profile IDs. Leaving it empty means 'Any'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_ids: A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        :param pulumi.Input[bool] enabled: Defined if Firewall Rule is active
        :param pulumi.Input[str] id: Firewall Rule ID
        :param pulumi.Input[bool] logging: Defines if matching traffic should be logged
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_ids: A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        pulumi.set(__self__, "name", name)
        if app_port_profile_ids is not None:
            pulumi.set(__self__, "app_port_profile_ids", app_port_profile_ids)
        if destination_ids is not None:
            pulumi.set(__self__, "destination_ids", destination_ids)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if source_ids is not None:
            pulumi.set(__self__, "source_ids", source_ids)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Defines if the rule should 'ALLOW', 'DROP' or 'REJECT' matching traffic
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> pulumi.Input[str]:
        """
        Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        """
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_protocol", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="appPortProfileIds")
    def app_port_profile_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of Application Port Profile IDs. Leaving it empty means 'Any'
        """
        return pulumi.get(self, "app_port_profile_ids")

    @app_port_profile_ids.setter
    def app_port_profile_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "app_port_profile_ids", value)

    @property
    @pulumi.getter(name="destinationIds")
    def destination_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "destination_ids")

    @destination_ids.setter
    def destination_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_ids", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Defined if Firewall Rule is active
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall Rule ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines if matching traffic should be logged
        """
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "logging", value)

    @property
    @pulumi.getter(name="sourceIds")
    def source_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "source_ids")

    @source_ids.setter
    def source_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_ids", value)


if not MYPY:
    class NsxtIpsecVpnTunnelSecurityProfileCustomizationArgsDict(TypedDict):
        ike_dh_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        """
        ike_encryption_algorithms: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        ike_version: pulumi.Input[str]
        """
        IKE version one of IKE_V1, IKE_V2, IKE_FLEX
        """
        tunnel_dh_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        """
        tunnel_encryption_algorithms: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
        """
        dpd_probe_internal: NotRequired[pulumi.Input[int]]
        """
        Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
        """
        ike_digest_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        ike_sa_lifetime: NotRequired[pulumi.Input[int]]
        """
        Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
        """
        tunnel_df_policy: NotRequired[pulumi.Input[str]]
        """
        Policy for handling defragmentation bit. One of COPY, CLEAR
        """
        tunnel_digest_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        tunnel_pfs_enabled: NotRequired[pulumi.Input[bool]]
        """
        Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
        """
        tunnel_sa_lifetime: NotRequired[pulumi.Input[int]]
        """
        Security Association life time (in seconds)
        """
elif False:
    NsxtIpsecVpnTunnelSecurityProfileCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtIpsecVpnTunnelSecurityProfileCustomizationArgs:
    def __init__(__self__, *,
                 ike_dh_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 ike_encryption_algorithms: pulumi.Input[Sequence[pulumi.Input[str]]],
                 ike_version: pulumi.Input[str],
                 tunnel_dh_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 tunnel_encryption_algorithms: pulumi.Input[Sequence[pulumi.Input[str]]],
                 dpd_probe_internal: Optional[pulumi.Input[int]] = None,
                 ike_digest_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ike_sa_lifetime: Optional[pulumi.Input[int]] = None,
                 tunnel_df_policy: Optional[pulumi.Input[str]] = None,
                 tunnel_digest_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tunnel_pfs_enabled: Optional[pulumi.Input[bool]] = None,
                 tunnel_sa_lifetime: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ike_dh_groups: Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ike_encryption_algorithms: Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        :param pulumi.Input[str] ike_version: IKE version one of IKE_V1, IKE_V2, IKE_FLEX
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tunnel_dh_groups: Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tunnel_encryption_algorithms: Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
        :param pulumi.Input[int] dpd_probe_internal: Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ike_digest_algorithms: Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        :param pulumi.Input[int] ike_sa_lifetime: Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
        :param pulumi.Input[str] tunnel_df_policy: Policy for handling defragmentation bit. One of COPY, CLEAR
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tunnel_digest_algorithms: Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        :param pulumi.Input[bool] tunnel_pfs_enabled: Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
        :param pulumi.Input[int] tunnel_sa_lifetime: Security Association life time (in seconds)
        """
        pulumi.set(__self__, "ike_dh_groups", ike_dh_groups)
        pulumi.set(__self__, "ike_encryption_algorithms", ike_encryption_algorithms)
        pulumi.set(__self__, "ike_version", ike_version)
        pulumi.set(__self__, "tunnel_dh_groups", tunnel_dh_groups)
        pulumi.set(__self__, "tunnel_encryption_algorithms", tunnel_encryption_algorithms)
        if dpd_probe_internal is not None:
            pulumi.set(__self__, "dpd_probe_internal", dpd_probe_internal)
        if ike_digest_algorithms is not None:
            pulumi.set(__self__, "ike_digest_algorithms", ike_digest_algorithms)
        if ike_sa_lifetime is not None:
            pulumi.set(__self__, "ike_sa_lifetime", ike_sa_lifetime)
        if tunnel_df_policy is not None:
            pulumi.set(__self__, "tunnel_df_policy", tunnel_df_policy)
        if tunnel_digest_algorithms is not None:
            pulumi.set(__self__, "tunnel_digest_algorithms", tunnel_digest_algorithms)
        if tunnel_pfs_enabled is not None:
            pulumi.set(__self__, "tunnel_pfs_enabled", tunnel_pfs_enabled)
        if tunnel_sa_lifetime is not None:
            pulumi.set(__self__, "tunnel_sa_lifetime", tunnel_sa_lifetime)

    @property
    @pulumi.getter(name="ikeDhGroups")
    def ike_dh_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        """
        return pulumi.get(self, "ike_dh_groups")

    @ike_dh_groups.setter
    def ike_dh_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ike_dh_groups", value)

    @property
    @pulumi.getter(name="ikeEncryptionAlgorithms")
    def ike_encryption_algorithms(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        return pulumi.get(self, "ike_encryption_algorithms")

    @ike_encryption_algorithms.setter
    def ike_encryption_algorithms(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ike_encryption_algorithms", value)

    @property
    @pulumi.getter(name="ikeVersion")
    def ike_version(self) -> pulumi.Input[str]:
        """
        IKE version one of IKE_V1, IKE_V2, IKE_FLEX
        """
        return pulumi.get(self, "ike_version")

    @ike_version.setter
    def ike_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "ike_version", value)

    @property
    @pulumi.getter(name="tunnelDhGroups")
    def tunnel_dh_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        """
        return pulumi.get(self, "tunnel_dh_groups")

    @tunnel_dh_groups.setter
    def tunnel_dh_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "tunnel_dh_groups", value)

    @property
    @pulumi.getter(name="tunnelEncryptionAlgorithms")
    def tunnel_encryption_algorithms(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
        """
        return pulumi.get(self, "tunnel_encryption_algorithms")

    @tunnel_encryption_algorithms.setter
    def tunnel_encryption_algorithms(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "tunnel_encryption_algorithms", value)

    @property
    @pulumi.getter(name="dpdProbeInternal")
    def dpd_probe_internal(self) -> Optional[pulumi.Input[int]]:
        """
        Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
        """
        return pulumi.get(self, "dpd_probe_internal")

    @dpd_probe_internal.setter
    def dpd_probe_internal(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dpd_probe_internal", value)

    @property
    @pulumi.getter(name="ikeDigestAlgorithms")
    def ike_digest_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        return pulumi.get(self, "ike_digest_algorithms")

    @ike_digest_algorithms.setter
    def ike_digest_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ike_digest_algorithms", value)

    @property
    @pulumi.getter(name="ikeSaLifetime")
    def ike_sa_lifetime(self) -> Optional[pulumi.Input[int]]:
        """
        Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
        """
        return pulumi.get(self, "ike_sa_lifetime")

    @ike_sa_lifetime.setter
    def ike_sa_lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ike_sa_lifetime", value)

    @property
    @pulumi.getter(name="tunnelDfPolicy")
    def tunnel_df_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Policy for handling defragmentation bit. One of COPY, CLEAR
        """
        return pulumi.get(self, "tunnel_df_policy")

    @tunnel_df_policy.setter
    def tunnel_df_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tunnel_df_policy", value)

    @property
    @pulumi.getter(name="tunnelDigestAlgorithms")
    def tunnel_digest_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        return pulumi.get(self, "tunnel_digest_algorithms")

    @tunnel_digest_algorithms.setter
    def tunnel_digest_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tunnel_digest_algorithms", value)

    @property
    @pulumi.getter(name="tunnelPfsEnabled")
    def tunnel_pfs_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
        """
        return pulumi.get(self, "tunnel_pfs_enabled")

    @tunnel_pfs_enabled.setter
    def tunnel_pfs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tunnel_pfs_enabled", value)

    @property
    @pulumi.getter(name="tunnelSaLifetime")
    def tunnel_sa_lifetime(self) -> Optional[pulumi.Input[int]]:
        """
        Security Association life time (in seconds)
        """
        return pulumi.get(self, "tunnel_sa_lifetime")

    @tunnel_sa_lifetime.setter
    def tunnel_sa_lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_sa_lifetime", value)


if not MYPY:
    class NsxtNetworkDhcpBindingDhcpV4ConfigArgsDict(TypedDict):
        gateway_ip_address: NotRequired[pulumi.Input[str]]
        """
        IPv4 gateway address
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname for the DHCP client
        """
elif False:
    NsxtNetworkDhcpBindingDhcpV4ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtNetworkDhcpBindingDhcpV4ConfigArgs:
    def __init__(__self__, *,
                 gateway_ip_address: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gateway_ip_address: IPv4 gateway address
        :param pulumi.Input[str] hostname: Hostname for the DHCP client
        """
        if gateway_ip_address is not None:
            pulumi.set(__self__, "gateway_ip_address", gateway_ip_address)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter(name="gatewayIpAddress")
    def gateway_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 gateway address
        """
        return pulumi.get(self, "gateway_ip_address")

    @gateway_ip_address.setter
    def gateway_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_ip_address", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname for the DHCP client
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class NsxtNetworkDhcpBindingDhcpV6ConfigArgsDict(TypedDict):
        domain_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of domain names
        """
        sntp_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of SNTP servers
        """
elif False:
    NsxtNetworkDhcpBindingDhcpV6ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtNetworkDhcpBindingDhcpV6ConfigArgs:
    def __init__(__self__, *,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sntp_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] domain_names: Set of domain names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sntp_servers: Set of SNTP servers
        """
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if sntp_servers is not None:
            pulumi.set(__self__, "sntp_servers", sntp_servers)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of domain names
        """
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domain_names", value)

    @property
    @pulumi.getter(name="sntpServers")
    def sntp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of SNTP servers
        """
        return pulumi.get(self, "sntp_servers")

    @sntp_servers.setter
    def sntp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sntp_servers", value)


if not MYPY:
    class NsxtNetworkDhcpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of DHCP pool IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of DHCP pool IP range
        """
elif False:
    NsxtNetworkDhcpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtNetworkDhcpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of DHCP pool IP range
        :param pulumi.Input[str] start_address: Start address of DHCP pool IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of DHCP pool IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of DHCP pool IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NsxtNetworkImportedSecondaryStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
elif False:
    NsxtNetworkImportedSecondaryStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtNetworkImportedSecondaryStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NsxtNetworkImportedStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
elif False:
    NsxtNetworkImportedStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtNetworkImportedStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class NsxtSecurityGroupMemberVmArgsDict(TypedDict):
        vapp_id: NotRequired[pulumi.Input[str]]
        """
        Parent vApp name (if exists) for member VM
        """
        vapp_name: NotRequired[pulumi.Input[str]]
        """
        Parent vApp ID (if exists) for member VM
        """
        vm_id: NotRequired[pulumi.Input[str]]
        """
        Member VM ID
        """
        vm_name: NotRequired[pulumi.Input[str]]
        """
        Member VM Name
        """
elif False:
    NsxtSecurityGroupMemberVmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxtSecurityGroupMemberVmArgs:
    def __init__(__self__, *,
                 vapp_id: Optional[pulumi.Input[str]] = None,
                 vapp_name: Optional[pulumi.Input[str]] = None,
                 vm_id: Optional[pulumi.Input[str]] = None,
                 vm_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] vapp_id: Parent vApp name (if exists) for member VM
        :param pulumi.Input[str] vapp_name: Parent vApp ID (if exists) for member VM
        :param pulumi.Input[str] vm_id: Member VM ID
        :param pulumi.Input[str] vm_name: Member VM Name
        """
        if vapp_id is not None:
            pulumi.set(__self__, "vapp_id", vapp_id)
        if vapp_name is not None:
            pulumi.set(__self__, "vapp_name", vapp_name)
        if vm_id is not None:
            pulumi.set(__self__, "vm_id", vm_id)
        if vm_name is not None:
            pulumi.set(__self__, "vm_name", vm_name)

    @property
    @pulumi.getter(name="vappId")
    def vapp_id(self) -> Optional[pulumi.Input[str]]:
        """
        Parent vApp name (if exists) for member VM
        """
        return pulumi.get(self, "vapp_id")

    @vapp_id.setter
    def vapp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_id", value)

    @property
    @pulumi.getter(name="vappName")
    def vapp_name(self) -> Optional[pulumi.Input[str]]:
        """
        Parent vApp ID (if exists) for member VM
        """
        return pulumi.get(self, "vapp_name")

    @vapp_name.setter
    def vapp_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_name", value)

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> Optional[pulumi.Input[str]]:
        """
        Member VM ID
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_id", value)

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> Optional[pulumi.Input[str]]:
        """
        Member VM Name
        """
        return pulumi.get(self, "vm_name")

    @vm_name.setter
    def vm_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_name", value)


if not MYPY:
    class NsxvDhcpRelayRelayAgentArgsDict(TypedDict):
        network_name: pulumi.Input[str]
        """
        Org network which is to be used for relaying DHCP message to specified servers
        """
        gateway_ip_address: NotRequired[pulumi.Input[str]]
        """
        Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers
        """
elif False:
    NsxvDhcpRelayRelayAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxvDhcpRelayRelayAgentArgs:
    def __init__(__self__, *,
                 network_name: pulumi.Input[str],
                 gateway_ip_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network_name: Org network which is to be used for relaying DHCP message to specified servers
        :param pulumi.Input[str] gateway_ip_address: Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers
        """
        pulumi.set(__self__, "network_name", network_name)
        if gateway_ip_address is not None:
            pulumi.set(__self__, "gateway_ip_address", gateway_ip_address)

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> pulumi.Input[str]:
        """
        Org network which is to be used for relaying DHCP message to specified servers
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_name", value)

    @property
    @pulumi.getter(name="gatewayIpAddress")
    def gateway_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers
        """
        return pulumi.get(self, "gateway_ip_address")

    @gateway_ip_address.setter
    def gateway_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_ip_address", value)


if not MYPY:
    class NsxvDistributedFirewallRuleArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Action of the rule (allow, deny)
        """
        applied_tos: pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleAppliedToArgsDict']]]
        """
        List of elements to which this rule applies
        """
        direction: pulumi.Input[str]
        """
        Direction of the rule (in, out, inout)
        """
        applications: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleApplicationArgsDict']]]]
        """
        Application definitions for this rule. An empty value means 'any'
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleDestinationArgsDict']]]]
        """
        List of destination traffic for this rule. An empty value means 'any'
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Shows whether the NSX-V Distributed Firewall is enabled.
        """
        exclude_destination: NotRequired[pulumi.Input[bool]]
        """
        If true, the content of the destination elements is reversed
        """
        exclude_source: NotRequired[pulumi.Input[bool]]
        """
        If true, the content of the source elements is reversed
        """
        id: NotRequired[pulumi.Input[int]]
        """
        Firewall Rule ID
        """
        logged: NotRequired[pulumi.Input[bool]]
        """
        Whether the rule traffic is logged
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Firewall Rule name
        """
        packet_type: NotRequired[pulumi.Input[str]]
        """
        Packet type of the rule (any, ipv4, ipv6)
        """
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleSourceArgsDict']]]]
        """
        List of source traffic for this rule. An empty value means 'any'
        """
elif False:
    NsxvDistributedFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxvDistributedFirewallRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 applied_tos: pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleAppliedToArgs']]],
                 direction: pulumi.Input[str],
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleApplicationArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleDestinationArgs']]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 exclude_destination: Optional[pulumi.Input[bool]] = None,
                 exclude_source: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[int]] = None,
                 logged: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 packet_type: Optional[pulumi.Input[str]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleSourceArgs']]]] = None):
        """
        :param pulumi.Input[str] action: Action of the rule (allow, deny)
        :param pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleAppliedToArgs']]] applied_tos: List of elements to which this rule applies
        :param pulumi.Input[str] direction: Direction of the rule (in, out, inout)
        :param pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleApplicationArgs']]] applications: Application definitions for this rule. An empty value means 'any'
        :param pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleDestinationArgs']]] destinations: List of destination traffic for this rule. An empty value means 'any'
        :param pulumi.Input[bool] enabled: Shows whether the NSX-V Distributed Firewall is enabled.
        :param pulumi.Input[bool] exclude_destination: If true, the content of the destination elements is reversed
        :param pulumi.Input[bool] exclude_source: If true, the content of the source elements is reversed
        :param pulumi.Input[int] id: Firewall Rule ID
        :param pulumi.Input[bool] logged: Whether the rule traffic is logged
        :param pulumi.Input[str] name: Firewall Rule name
        :param pulumi.Input[str] packet_type: Packet type of the rule (any, ipv4, ipv6)
        :param pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleSourceArgs']]] sources: List of source traffic for this rule. An empty value means 'any'
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "applied_tos", applied_tos)
        pulumi.set(__self__, "direction", direction)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclude_destination is not None:
            pulumi.set(__self__, "exclude_destination", exclude_destination)
        if exclude_source is not None:
            pulumi.set(__self__, "exclude_source", exclude_source)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logged is not None:
            pulumi.set(__self__, "logged", logged)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packet_type is not None:
            pulumi.set(__self__, "packet_type", packet_type)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action of the rule (allow, deny)
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="appliedTos")
    def applied_tos(self) -> pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleAppliedToArgs']]]:
        """
        List of elements to which this rule applies
        """
        return pulumi.get(self, "applied_tos")

    @applied_tos.setter
    def applied_tos(self, value: pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleAppliedToArgs']]]):
        pulumi.set(self, "applied_tos", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input[str]:
        """
        Direction of the rule (in, out, inout)
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[str]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleApplicationArgs']]]]:
        """
        Application definitions for this rule. An empty value means 'any'
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleApplicationArgs']]]]):
        pulumi.set(self, "applications", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleDestinationArgs']]]]:
        """
        List of destination traffic for this rule. An empty value means 'any'
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Shows whether the NSX-V Distributed Firewall is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="excludeDestination")
    def exclude_destination(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the content of the destination elements is reversed
        """
        return pulumi.get(self, "exclude_destination")

    @exclude_destination.setter
    def exclude_destination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_destination", value)

    @property
    @pulumi.getter(name="excludeSource")
    def exclude_source(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the content of the source elements is reversed
        """
        return pulumi.get(self, "exclude_source")

    @exclude_source.setter
    def exclude_source(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_source", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        Firewall Rule ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def logged(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the rule traffic is logged
        """
        return pulumi.get(self, "logged")

    @logged.setter
    def logged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "logged", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="packetType")
    def packet_type(self) -> Optional[pulumi.Input[str]]:
        """
        Packet type of the rule (any, ipv4, ipv6)
        """
        return pulumi.get(self, "packet_type")

    @packet_type.setter
    def packet_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "packet_type", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleSourceArgs']]]]:
        """
        List of source traffic for this rule. An empty value means 'any'
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NsxvDistributedFirewallRuleSourceArgs']]]]):
        pulumi.set(self, "sources", value)


if not MYPY:
    class NsxvDistributedFirewallRuleApplicationArgsDict(TypedDict):
        destination_port: NotRequired[pulumi.Input[str]]
        """
        Destination port for this application. Leaving it empty means 'any' port
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of application (Application, ApplicationGroup)
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)
        """
        source_port: NotRequired[pulumi.Input[str]]
        """
        Source port for this application. Leaving it empty means 'any' port
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of application
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of the application
        """
elif False:
    NsxvDistributedFirewallRuleApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxvDistributedFirewallRuleApplicationArgs:
    def __init__(__self__, *,
                 destination_port: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 source_port: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination_port: Destination port for this application. Leaving it empty means 'any' port
        :param pulumi.Input[str] name: Name of application (Application, ApplicationGroup)
        :param pulumi.Input[str] protocol: Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)
        :param pulumi.Input[str] source_port: Source port for this application. Leaving it empty means 'any' port
        :param pulumi.Input[str] type: Type of application
        :param pulumi.Input[str] value: Value of the application
        """
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[pulumi.Input[str]]:
        """
        Destination port for this application. Leaving it empty means 'any' port
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_port", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of application (Application, ApplicationGroup)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[str]]:
        """
        Source port for this application. Leaving it empty means 'any' port
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_port", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of application
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of the application
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxvDistributedFirewallRuleAppliedToArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the applied-to entity
        """
        type: pulumi.Input[str]
        """
        Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)
        """
        value: pulumi.Input[str]
        """
        Value of the applied-to entity
        """
elif False:
    NsxvDistributedFirewallRuleAppliedToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxvDistributedFirewallRuleAppliedToArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the applied-to entity
        :param pulumi.Input[str] type: Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)
        :param pulumi.Input[str] value: Value of the applied-to entity
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the applied-to entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the applied-to entity
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxvDistributedFirewallRuleDestinationArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the destination entity
        """
        type: pulumi.Input[str]
        """
        Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        """
        value: pulumi.Input[str]
        """
        Value of the destination entity
        """
elif False:
    NsxvDistributedFirewallRuleDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxvDistributedFirewallRuleDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the destination entity
        :param pulumi.Input[str] type: Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        :param pulumi.Input[str] value: Value of the destination entity
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the destination entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the destination entity
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxvDistributedFirewallRuleSourceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the source entity
        """
        type: pulumi.Input[str]
        """
        Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        """
        value: pulumi.Input[str]
        """
        Value of the source entity
        """
elif False:
    NsxvDistributedFirewallRuleSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxvDistributedFirewallRuleSourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the source entity
        :param pulumi.Input[str] type: Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        :param pulumi.Input[str] value: Value of the source entity
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the source entity
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of the source entity
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NsxvFirewallRuleDestinationArgsDict(TypedDict):
        exclude: NotRequired[pulumi.Input[bool]]
        """
        Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'
        """
        gateway_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        'vse', 'internal', 'external' or network name
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IP address, CIDR, an IP range, or the keyword 'any'
        """
        ip_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of IP set names
        """
        org_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of org network names
        """
        vm_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of VM IDs
        """
elif False:
    NsxvFirewallRuleDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxvFirewallRuleDestinationArgs:
    def __init__(__self__, *,
                 exclude: Optional[pulumi.Input[bool]] = None,
                 gateway_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 org_networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vm_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] exclude: Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gateway_interfaces: 'vse', 'internal', 'external' or network name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_addresses: IP address, CIDR, an IP range, or the keyword 'any'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_sets: Set of IP set names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] org_networks: Set of org network names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vm_ids: Set of VM IDs
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if gateway_interfaces is not None:
            pulumi.set(__self__, "gateway_interfaces", gateway_interfaces)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ip_sets is not None:
            pulumi.set(__self__, "ip_sets", ip_sets)
        if org_networks is not None:
            pulumi.set(__self__, "org_networks", org_networks)
        if vm_ids is not None:
            pulumi.set(__self__, "vm_ids", vm_ids)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[pulumi.Input[bool]]:
        """
        Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'
        """
        return pulumi.get(self, "exclude")

    @exclude.setter
    def exclude(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude", value)

    @property
    @pulumi.getter(name="gatewayInterfaces")
    def gateway_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        'vse', 'internal', 'external' or network name
        """
        return pulumi.get(self, "gateway_interfaces")

    @gateway_interfaces.setter
    def gateway_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateway_interfaces", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP address, CIDR, an IP range, or the keyword 'any'
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of IP set names
        """
        return pulumi.get(self, "ip_sets")

    @ip_sets.setter
    def ip_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_sets", value)

    @property
    @pulumi.getter(name="orgNetworks")
    def org_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of org network names
        """
        return pulumi.get(self, "org_networks")

    @org_networks.setter
    def org_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "org_networks", value)

    @property
    @pulumi.getter(name="vmIds")
    def vm_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of VM IDs
        """
        return pulumi.get(self, "vm_ids")

    @vm_ids.setter
    def vm_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vm_ids", value)


if not MYPY:
    class NsxvFirewallRuleServiceArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        port: NotRequired[pulumi.Input[str]]
        source_port: NotRequired[pulumi.Input[str]]
elif False:
    NsxvFirewallRuleServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxvFirewallRuleServiceArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 port: Optional[pulumi.Input[str]] = None,
                 source_port: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "protocol", protocol)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_port", value)


if not MYPY:
    class NsxvFirewallRuleSourceArgsDict(TypedDict):
        exclude: NotRequired[pulumi.Input[bool]]
        """
        Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'
        """
        gateway_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        'vse', 'internal', 'external' or network name
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        IP address, CIDR, an IP range, or the keyword 'any'
        """
        ip_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of IP set names
        """
        org_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of org network names
        """
        vm_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of VM IDs
        """
elif False:
    NsxvFirewallRuleSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NsxvFirewallRuleSourceArgs:
    def __init__(__self__, *,
                 exclude: Optional[pulumi.Input[bool]] = None,
                 gateway_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_sets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 org_networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vm_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] exclude: Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gateway_interfaces: 'vse', 'internal', 'external' or network name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_addresses: IP address, CIDR, an IP range, or the keyword 'any'
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_sets: Set of IP set names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] org_networks: Set of org network names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vm_ids: Set of VM IDs
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if gateway_interfaces is not None:
            pulumi.set(__self__, "gateway_interfaces", gateway_interfaces)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ip_sets is not None:
            pulumi.set(__self__, "ip_sets", ip_sets)
        if org_networks is not None:
            pulumi.set(__self__, "org_networks", org_networks)
        if vm_ids is not None:
            pulumi.set(__self__, "vm_ids", vm_ids)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[pulumi.Input[bool]]:
        """
        Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'
        """
        return pulumi.get(self, "exclude")

    @exclude.setter
    def exclude(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude", value)

    @property
    @pulumi.getter(name="gatewayInterfaces")
    def gateway_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        'vse', 'internal', 'external' or network name
        """
        return pulumi.get(self, "gateway_interfaces")

    @gateway_interfaces.setter
    def gateway_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateway_interfaces", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP address, CIDR, an IP range, or the keyword 'any'
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of IP set names
        """
        return pulumi.get(self, "ip_sets")

    @ip_sets.setter
    def ip_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_sets", value)

    @property
    @pulumi.getter(name="orgNetworks")
    def org_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of org network names
        """
        return pulumi.get(self, "org_networks")

    @org_networks.setter
    def org_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "org_networks", value)

    @property
    @pulumi.getter(name="vmIds")
    def vm_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of VM IDs
        """
        return pulumi.get(self, "vm_ids")

    @vm_ids.setter
    def vm_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vm_ids", value)


if not MYPY:
    class OrgAccountLockoutArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether account lockout is enabled or not
        """
        invalid_logins_before_lockout: pulumi.Input[int]
        """
        Number of login attempts that will trigger an account lockout for the given user
        """
        lockout_interval_minutes: pulumi.Input[int]
        """
        Once a user is locked out, they will not be able to log back in for this time period
        """
elif False:
    OrgAccountLockoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgAccountLockoutArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 invalid_logins_before_lockout: pulumi.Input[int],
                 lockout_interval_minutes: pulumi.Input[int]):
        """
        :param pulumi.Input[bool] enabled: Whether account lockout is enabled or not
        :param pulumi.Input[int] invalid_logins_before_lockout: Number of login attempts that will trigger an account lockout for the given user
        :param pulumi.Input[int] lockout_interval_minutes: Once a user is locked out, they will not be able to log back in for this time period
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "invalid_logins_before_lockout", invalid_logins_before_lockout)
        pulumi.set(__self__, "lockout_interval_minutes", lockout_interval_minutes)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether account lockout is enabled or not
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="invalidLoginsBeforeLockout")
    def invalid_logins_before_lockout(self) -> pulumi.Input[int]:
        """
        Number of login attempts that will trigger an account lockout for the given user
        """
        return pulumi.get(self, "invalid_logins_before_lockout")

    @invalid_logins_before_lockout.setter
    def invalid_logins_before_lockout(self, value: pulumi.Input[int]):
        pulumi.set(self, "invalid_logins_before_lockout", value)

    @property
    @pulumi.getter(name="lockoutIntervalMinutes")
    def lockout_interval_minutes(self) -> pulumi.Input[int]:
        """
        Once a user is locked out, they will not be able to log back in for this time period
        """
        return pulumi.get(self, "lockout_interval_minutes")

    @lockout_interval_minutes.setter
    def lockout_interval_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "lockout_interval_minutes", value)


if not MYPY:
    class OrgLdapCustomSettingsArgsDict(TypedDict):
        authentication_method: pulumi.Input[str]
        """
        authentication method: one of SIMPLE, MD5DIGEST, NTLM
        """
        connector_type: pulumi.Input[str]
        """
        type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY
        """
        group_attributes: pulumi.Input['OrgLdapCustomSettingsGroupAttributesArgsDict']
        """
        Group settings when `ldap_mode` is CUSTOM
        """
        port: pulumi.Input[int]
        """
        Port number for LDAP service
        """
        server: pulumi.Input[str]
        """
        host name or IP of the LDAP server
        """
        user_attributes: pulumi.Input['OrgLdapCustomSettingsUserAttributesArgsDict']
        """
        User settings when `ldap_mode` is CUSTOM
        """
        base_distinguished_name: NotRequired[pulumi.Input[str]]
        """
        LDAP search base
        """
        is_ssl: NotRequired[pulumi.Input[bool]]
        """
        True if the LDAP service requires an SSL connection
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn="ldap-admin", c="example", dc="com")
        """
elif False:
    OrgLdapCustomSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLdapCustomSettingsArgs:
    def __init__(__self__, *,
                 authentication_method: pulumi.Input[str],
                 connector_type: pulumi.Input[str],
                 group_attributes: pulumi.Input['OrgLdapCustomSettingsGroupAttributesArgs'],
                 port: pulumi.Input[int],
                 server: pulumi.Input[str],
                 user_attributes: pulumi.Input['OrgLdapCustomSettingsUserAttributesArgs'],
                 base_distinguished_name: Optional[pulumi.Input[str]] = None,
                 is_ssl: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authentication_method: authentication method: one of SIMPLE, MD5DIGEST, NTLM
        :param pulumi.Input[str] connector_type: type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY
        :param pulumi.Input['OrgLdapCustomSettingsGroupAttributesArgs'] group_attributes: Group settings when `ldap_mode` is CUSTOM
        :param pulumi.Input[int] port: Port number for LDAP service
        :param pulumi.Input[str] server: host name or IP of the LDAP server
        :param pulumi.Input['OrgLdapCustomSettingsUserAttributesArgs'] user_attributes: User settings when `ldap_mode` is CUSTOM
        :param pulumi.Input[str] base_distinguished_name: LDAP search base
        :param pulumi.Input[bool] is_ssl: True if the LDAP service requires an SSL connection
        :param pulumi.Input[str] password: Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed
        :param pulumi.Input[str] username: Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn="ldap-admin", c="example", dc="com")
        """
        pulumi.set(__self__, "authentication_method", authentication_method)
        pulumi.set(__self__, "connector_type", connector_type)
        pulumi.set(__self__, "group_attributes", group_attributes)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "user_attributes", user_attributes)
        if base_distinguished_name is not None:
            pulumi.set(__self__, "base_distinguished_name", base_distinguished_name)
        if is_ssl is not None:
            pulumi.set(__self__, "is_ssl", is_ssl)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> pulumi.Input[str]:
        """
        authentication method: one of SIMPLE, MD5DIGEST, NTLM
        """
        return pulumi.get(self, "authentication_method")

    @authentication_method.setter
    def authentication_method(self, value: pulumi.Input[str]):
        pulumi.set(self, "authentication_method", value)

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> pulumi.Input[str]:
        """
        type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY
        """
        return pulumi.get(self, "connector_type")

    @connector_type.setter
    def connector_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "connector_type", value)

    @property
    @pulumi.getter(name="groupAttributes")
    def group_attributes(self) -> pulumi.Input['OrgLdapCustomSettingsGroupAttributesArgs']:
        """
        Group settings when `ldap_mode` is CUSTOM
        """
        return pulumi.get(self, "group_attributes")

    @group_attributes.setter
    def group_attributes(self, value: pulumi.Input['OrgLdapCustomSettingsGroupAttributesArgs']):
        pulumi.set(self, "group_attributes", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Port number for LDAP service
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[str]:
        """
        host name or IP of the LDAP server
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="userAttributes")
    def user_attributes(self) -> pulumi.Input['OrgLdapCustomSettingsUserAttributesArgs']:
        """
        User settings when `ldap_mode` is CUSTOM
        """
        return pulumi.get(self, "user_attributes")

    @user_attributes.setter
    def user_attributes(self, value: pulumi.Input['OrgLdapCustomSettingsUserAttributesArgs']):
        pulumi.set(self, "user_attributes", value)

    @property
    @pulumi.getter(name="baseDistinguishedName")
    def base_distinguished_name(self) -> Optional[pulumi.Input[str]]:
        """
        LDAP search base
        """
        return pulumi.get(self, "base_distinguished_name")

    @base_distinguished_name.setter
    def base_distinguished_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_distinguished_name", value)

    @property
    @pulumi.getter(name="isSsl")
    def is_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the LDAP service requires an SSL connection
        """
        return pulumi.get(self, "is_ssl")

    @is_ssl.setter
    def is_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ssl", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn="ldap-admin", c="example", dc="com")
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class OrgLdapCustomSettingsGroupAttributesArgsDict(TypedDict):
        group_membership_identifier: pulumi.Input[str]
        """
        LDAP attribute that identifies a group as a member of another group. For example, dn
        """
        membership: pulumi.Input[str]
        """
        LDAP attribute to use when getting the members of a group. For example, member
        """
        name: pulumi.Input[str]
        """
        LDAP attribute to use for the group name. For example, cn
        """
        object_class: pulumi.Input[str]
        """
        LDAP objectClass of which imported groups are members. For example, group
        """
        unique_identifier: pulumi.Input[str]
        """
        LDAP attribute to use as the unique identifier for a group. For example, objectGuid
        """
        group_back_link_identifier: NotRequired[pulumi.Input[str]]
        """
        LDAP group attribute used to identify a group member
        """
elif False:
    OrgLdapCustomSettingsGroupAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLdapCustomSettingsGroupAttributesArgs:
    def __init__(__self__, *,
                 group_membership_identifier: pulumi.Input[str],
                 membership: pulumi.Input[str],
                 name: pulumi.Input[str],
                 object_class: pulumi.Input[str],
                 unique_identifier: pulumi.Input[str],
                 group_back_link_identifier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] group_membership_identifier: LDAP attribute that identifies a group as a member of another group. For example, dn
        :param pulumi.Input[str] membership: LDAP attribute to use when getting the members of a group. For example, member
        :param pulumi.Input[str] name: LDAP attribute to use for the group name. For example, cn
        :param pulumi.Input[str] object_class: LDAP objectClass of which imported groups are members. For example, group
        :param pulumi.Input[str] unique_identifier: LDAP attribute to use as the unique identifier for a group. For example, objectGuid
        :param pulumi.Input[str] group_back_link_identifier: LDAP group attribute used to identify a group member
        """
        pulumi.set(__self__, "group_membership_identifier", group_membership_identifier)
        pulumi.set(__self__, "membership", membership)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "object_class", object_class)
        pulumi.set(__self__, "unique_identifier", unique_identifier)
        if group_back_link_identifier is not None:
            pulumi.set(__self__, "group_back_link_identifier", group_back_link_identifier)

    @property
    @pulumi.getter(name="groupMembershipIdentifier")
    def group_membership_identifier(self) -> pulumi.Input[str]:
        """
        LDAP attribute that identifies a group as a member of another group. For example, dn
        """
        return pulumi.get(self, "group_membership_identifier")

    @group_membership_identifier.setter
    def group_membership_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_membership_identifier", value)

    @property
    @pulumi.getter
    def membership(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use when getting the members of a group. For example, member
        """
        return pulumi.get(self, "membership")

    @membership.setter
    def membership(self, value: pulumi.Input[str]):
        pulumi.set(self, "membership", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use for the group name. For example, cn
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="objectClass")
    def object_class(self) -> pulumi.Input[str]:
        """
        LDAP objectClass of which imported groups are members. For example, group
        """
        return pulumi.get(self, "object_class")

    @object_class.setter
    def object_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_class", value)

    @property
    @pulumi.getter(name="uniqueIdentifier")
    def unique_identifier(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use as the unique identifier for a group. For example, objectGuid
        """
        return pulumi.get(self, "unique_identifier")

    @unique_identifier.setter
    def unique_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "unique_identifier", value)

    @property
    @pulumi.getter(name="groupBackLinkIdentifier")
    def group_back_link_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        LDAP group attribute used to identify a group member
        """
        return pulumi.get(self, "group_back_link_identifier")

    @group_back_link_identifier.setter
    def group_back_link_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_back_link_identifier", value)


if not MYPY:
    class OrgLdapCustomSettingsUserAttributesArgsDict(TypedDict):
        display_name: pulumi.Input[str]
        """
        LDAP attribute to use for the user's full name. For example, displayName
        """
        email: pulumi.Input[str]
        """
        LDAP attribute to use for the user's email address. For example, mail
        """
        given_name: pulumi.Input[str]
        """
        LDAP attribute to use for the user's given name. For example, givenName
        """
        group_membership_identifier: pulumi.Input[str]
        """
        LDAP attribute that identifies a user as a member of a group. For example, dn
        """
        object_class: pulumi.Input[str]
        """
        LDAP objectClass of which imported users are members. For example, user or person
        """
        surname: pulumi.Input[str]
        """
        LDAP attribute to use for the user's surname. For example, sn
        """
        telephone: pulumi.Input[str]
        """
        LDAP attribute to use for the user's telephone number. For example, telephoneNumber
        """
        unique_identifier: pulumi.Input[str]
        """
        LDAP attribute to use as the unique identifier for a user. For example, objectGuid
        """
        username: pulumi.Input[str]
        """
        LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName
        """
        group_back_link_identifier: NotRequired[pulumi.Input[str]]
        """
        LDAP attribute that returns the identifiers of all the groups of which the user is a member
        """
elif False:
    OrgLdapCustomSettingsUserAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLdapCustomSettingsUserAttributesArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[str],
                 email: pulumi.Input[str],
                 given_name: pulumi.Input[str],
                 group_membership_identifier: pulumi.Input[str],
                 object_class: pulumi.Input[str],
                 surname: pulumi.Input[str],
                 telephone: pulumi.Input[str],
                 unique_identifier: pulumi.Input[str],
                 username: pulumi.Input[str],
                 group_back_link_identifier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: LDAP attribute to use for the user's full name. For example, displayName
        :param pulumi.Input[str] email: LDAP attribute to use for the user's email address. For example, mail
        :param pulumi.Input[str] given_name: LDAP attribute to use for the user's given name. For example, givenName
        :param pulumi.Input[str] group_membership_identifier: LDAP attribute that identifies a user as a member of a group. For example, dn
        :param pulumi.Input[str] object_class: LDAP objectClass of which imported users are members. For example, user or person
        :param pulumi.Input[str] surname: LDAP attribute to use for the user's surname. For example, sn
        :param pulumi.Input[str] telephone: LDAP attribute to use for the user's telephone number. For example, telephoneNumber
        :param pulumi.Input[str] unique_identifier: LDAP attribute to use as the unique identifier for a user. For example, objectGuid
        :param pulumi.Input[str] username: LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName
        :param pulumi.Input[str] group_back_link_identifier: LDAP attribute that returns the identifiers of all the groups of which the user is a member
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "given_name", given_name)
        pulumi.set(__self__, "group_membership_identifier", group_membership_identifier)
        pulumi.set(__self__, "object_class", object_class)
        pulumi.set(__self__, "surname", surname)
        pulumi.set(__self__, "telephone", telephone)
        pulumi.set(__self__, "unique_identifier", unique_identifier)
        pulumi.set(__self__, "username", username)
        if group_back_link_identifier is not None:
            pulumi.set(__self__, "group_back_link_identifier", group_back_link_identifier)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use for the user's full name. For example, displayName
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use for the user's email address. For example, mail
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="givenName")
    def given_name(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use for the user's given name. For example, givenName
        """
        return pulumi.get(self, "given_name")

    @given_name.setter
    def given_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "given_name", value)

    @property
    @pulumi.getter(name="groupMembershipIdentifier")
    def group_membership_identifier(self) -> pulumi.Input[str]:
        """
        LDAP attribute that identifies a user as a member of a group. For example, dn
        """
        return pulumi.get(self, "group_membership_identifier")

    @group_membership_identifier.setter
    def group_membership_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_membership_identifier", value)

    @property
    @pulumi.getter(name="objectClass")
    def object_class(self) -> pulumi.Input[str]:
        """
        LDAP objectClass of which imported users are members. For example, user or person
        """
        return pulumi.get(self, "object_class")

    @object_class.setter
    def object_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_class", value)

    @property
    @pulumi.getter
    def surname(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use for the user's surname. For example, sn
        """
        return pulumi.get(self, "surname")

    @surname.setter
    def surname(self, value: pulumi.Input[str]):
        pulumi.set(self, "surname", value)

    @property
    @pulumi.getter
    def telephone(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use for the user's telephone number. For example, telephoneNumber
        """
        return pulumi.get(self, "telephone")

    @telephone.setter
    def telephone(self, value: pulumi.Input[str]):
        pulumi.set(self, "telephone", value)

    @property
    @pulumi.getter(name="uniqueIdentifier")
    def unique_identifier(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use as the unique identifier for a user. For example, objectGuid
        """
        return pulumi.get(self, "unique_identifier")

    @unique_identifier.setter
    def unique_identifier(self, value: pulumi.Input[str]):
        pulumi.set(self, "unique_identifier", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="groupBackLinkIdentifier")
    def group_back_link_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        LDAP attribute that returns the identifiers of all the groups of which the user is a member
        """
        return pulumi.get(self, "group_back_link_identifier")

    @group_back_link_identifier.setter
    def group_back_link_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_back_link_identifier", value)


if not MYPY:
    class OrgMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    OrgMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OrgOidcClaimsMappingArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[str]]
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        first_name: NotRequired[pulumi.Input[str]]
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        full_name: NotRequired[pulumi.Input[str]]
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        groups: NotRequired[pulumi.Input[str]]
        """
        Optional
        """
        last_name: NotRequired[pulumi.Input[str]]
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        roles: NotRequired[pulumi.Input[str]]
        """
        Optional
        """
        subject: NotRequired[pulumi.Input[str]]
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
elif False:
    OrgOidcClaimsMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgOidcClaimsMappingArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 first_name: Optional[pulumi.Input[str]] = None,
                 full_name: Optional[pulumi.Input[str]] = None,
                 groups: Optional[pulumi.Input[str]] = None,
                 last_name: Optional[pulumi.Input[str]] = None,
                 roles: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: Required if `wellknown_endpoint` doesn't give info about it
        :param pulumi.Input[str] first_name: Required if `wellknown_endpoint` doesn't give info about it
        :param pulumi.Input[str] full_name: Required if `wellknown_endpoint` doesn't give info about it
        :param pulumi.Input[str] groups: Optional
        :param pulumi.Input[str] last_name: Required if `wellknown_endpoint` doesn't give info about it
        :param pulumi.Input[str] roles: Optional
        :param pulumi.Input[str] subject: Required if `wellknown_endpoint` doesn't give info about it
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "full_name")

    @full_name.setter
    def full_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "full_name", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[str]]:
        """
        Optional
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[str]]:
        """
        Optional
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class OrgOidcKeyArgsDict(TypedDict):
        algorithm: pulumi.Input[str]
        """
        Algorithm used by the key. Can be `RSA` or `EC`
        """
        certificate: pulumi.Input[str]
        """
        The contents of a PEM file to create/update the key
        """
        id: pulumi.Input[str]
        """
        Identifier of the key
        """
        expiration_date: NotRequired[pulumi.Input[str]]
        """
        Expiration date for the key. The accepted format is `YYYY-MM-DD`, like `2077-12-31`
        """
elif False:
    OrgOidcKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgOidcKeyArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[str],
                 certificate: pulumi.Input[str],
                 id: pulumi.Input[str],
                 expiration_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm: Algorithm used by the key. Can be `RSA` or `EC`
        :param pulumi.Input[str] certificate: The contents of a PEM file to create/update the key
        :param pulumi.Input[str] id: Identifier of the key
        :param pulumi.Input[str] expiration_date: Expiration date for the key. The accepted format is `YYYY-MM-DD`, like `2077-12-31`
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "id", id)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)

    @property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[str]:
        """
        Algorithm used by the key. Can be `RSA` or `EC`
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        """
        The contents of a PEM file to create/update the key
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Identifier of the key
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[pulumi.Input[str]]:
        """
        Expiration date for the key. The accepted format is `YYYY-MM-DD`, like `2077-12-31`
        """
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_date", value)


if not MYPY:
    class OrgVappLeaseArgsDict(TypedDict):
        delete_on_storage_lease_expiration: pulumi.Input[bool]
        """
        If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.
        """
        maximum_runtime_lease_in_sec: pulumi.Input[int]
        """
        How long vApps can run before they are automatically stopped (in seconds). 0 means never expires
        """
        maximum_storage_lease_in_sec: pulumi.Input[int]
        """
        How long stopped vApps are available before being automatically cleaned up (in seconds). 0 means never expires
        """
        power_off_on_runtime_lease_expiration: pulumi.Input[bool]
        """
        When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires
        """
elif False:
    OrgVappLeaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVappLeaseArgs:
    def __init__(__self__, *,
                 delete_on_storage_lease_expiration: pulumi.Input[bool],
                 maximum_runtime_lease_in_sec: pulumi.Input[int],
                 maximum_storage_lease_in_sec: pulumi.Input[int],
                 power_off_on_runtime_lease_expiration: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] delete_on_storage_lease_expiration: If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.
        :param pulumi.Input[int] maximum_runtime_lease_in_sec: How long vApps can run before they are automatically stopped (in seconds). 0 means never expires
        :param pulumi.Input[int] maximum_storage_lease_in_sec: How long stopped vApps are available before being automatically cleaned up (in seconds). 0 means never expires
        :param pulumi.Input[bool] power_off_on_runtime_lease_expiration: When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires
        """
        pulumi.set(__self__, "delete_on_storage_lease_expiration", delete_on_storage_lease_expiration)
        pulumi.set(__self__, "maximum_runtime_lease_in_sec", maximum_runtime_lease_in_sec)
        pulumi.set(__self__, "maximum_storage_lease_in_sec", maximum_storage_lease_in_sec)
        pulumi.set(__self__, "power_off_on_runtime_lease_expiration", power_off_on_runtime_lease_expiration)

    @property
    @pulumi.getter(name="deleteOnStorageLeaseExpiration")
    def delete_on_storage_lease_expiration(self) -> pulumi.Input[bool]:
        """
        If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.
        """
        return pulumi.get(self, "delete_on_storage_lease_expiration")

    @delete_on_storage_lease_expiration.setter
    def delete_on_storage_lease_expiration(self, value: pulumi.Input[bool]):
        pulumi.set(self, "delete_on_storage_lease_expiration", value)

    @property
    @pulumi.getter(name="maximumRuntimeLeaseInSec")
    def maximum_runtime_lease_in_sec(self) -> pulumi.Input[int]:
        """
        How long vApps can run before they are automatically stopped (in seconds). 0 means never expires
        """
        return pulumi.get(self, "maximum_runtime_lease_in_sec")

    @maximum_runtime_lease_in_sec.setter
    def maximum_runtime_lease_in_sec(self, value: pulumi.Input[int]):
        pulumi.set(self, "maximum_runtime_lease_in_sec", value)

    @property
    @pulumi.getter(name="maximumStorageLeaseInSec")
    def maximum_storage_lease_in_sec(self) -> pulumi.Input[int]:
        """
        How long stopped vApps are available before being automatically cleaned up (in seconds). 0 means never expires
        """
        return pulumi.get(self, "maximum_storage_lease_in_sec")

    @maximum_storage_lease_in_sec.setter
    def maximum_storage_lease_in_sec(self, value: pulumi.Input[int]):
        pulumi.set(self, "maximum_storage_lease_in_sec", value)

    @property
    @pulumi.getter(name="powerOffOnRuntimeLeaseExpiration")
    def power_off_on_runtime_lease_expiration(self) -> pulumi.Input[bool]:
        """
        When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires
        """
        return pulumi.get(self, "power_off_on_runtime_lease_expiration")

    @power_off_on_runtime_lease_expiration.setter
    def power_off_on_runtime_lease_expiration(self, value: pulumi.Input[bool]):
        pulumi.set(self, "power_off_on_runtime_lease_expiration", value)


if not MYPY:
    class OrgVappTemplateLeaseArgsDict(TypedDict):
        delete_on_storage_lease_expiration: pulumi.Input[bool]
        """
        If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted
        """
        maximum_storage_lease_in_sec: pulumi.Input[int]
        """
        How long vApp templates are available before being automatically cleaned up (in seconds). 0 means never expires
        """
elif False:
    OrgVappTemplateLeaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVappTemplateLeaseArgs:
    def __init__(__self__, *,
                 delete_on_storage_lease_expiration: pulumi.Input[bool],
                 maximum_storage_lease_in_sec: pulumi.Input[int]):
        """
        :param pulumi.Input[bool] delete_on_storage_lease_expiration: If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted
        :param pulumi.Input[int] maximum_storage_lease_in_sec: How long vApp templates are available before being automatically cleaned up (in seconds). 0 means never expires
        """
        pulumi.set(__self__, "delete_on_storage_lease_expiration", delete_on_storage_lease_expiration)
        pulumi.set(__self__, "maximum_storage_lease_in_sec", maximum_storage_lease_in_sec)

    @property
    @pulumi.getter(name="deleteOnStorageLeaseExpiration")
    def delete_on_storage_lease_expiration(self) -> pulumi.Input[bool]:
        """
        If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted
        """
        return pulumi.get(self, "delete_on_storage_lease_expiration")

    @delete_on_storage_lease_expiration.setter
    def delete_on_storage_lease_expiration(self, value: pulumi.Input[bool]):
        pulumi.set(self, "delete_on_storage_lease_expiration", value)

    @property
    @pulumi.getter(name="maximumStorageLeaseInSec")
    def maximum_storage_lease_in_sec(self) -> pulumi.Input[int]:
        """
        How long vApp templates are available before being automatically cleaned up (in seconds). 0 means never expires
        """
        return pulumi.get(self, "maximum_storage_lease_in_sec")

    @maximum_storage_lease_in_sec.setter
    def maximum_storage_lease_in_sec(self, value: pulumi.Input[int]):
        pulumi.set(self, "maximum_storage_lease_in_sec", value)


if not MYPY:
    class OrgVdcAccessControlSharedWithArgsDict(TypedDict):
        access_level: pulumi.Input[str]
        """
        The access level for the user or group to which we are sharing. (Only `ReadOnly` is available)
        """
        group_id: NotRequired[pulumi.Input[str]]
        """
        The ID of a group which we are sharing with. Required if `user_id` is not set.
        """
        subject_name: NotRequired[pulumi.Input[str]]
        """
        The name of the subject (group or user) which we are sharing with.
        """
        user_id: NotRequired[pulumi.Input[str]]
        """
        The ID of a user which we are sharing with. Required if `group_id` is not set.
        """
elif False:
    OrgVdcAccessControlSharedWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcAccessControlSharedWithArgs:
    def __init__(__self__, *,
                 access_level: pulumi.Input[str],
                 group_id: Optional[pulumi.Input[str]] = None,
                 subject_name: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_level: The access level for the user or group to which we are sharing. (Only `ReadOnly` is available)
        :param pulumi.Input[str] group_id: The ID of a group which we are sharing with. Required if `user_id` is not set.
        :param pulumi.Input[str] subject_name: The name of the subject (group or user) which we are sharing with.
        :param pulumi.Input[str] user_id: The ID of a user which we are sharing with. Required if `group_id` is not set.
        """
        pulumi.set(__self__, "access_level", access_level)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> pulumi.Input[str]:
        """
        The access level for the user or group to which we are sharing. (Only `ReadOnly` is available)
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a group which we are sharing with. Required if `user_id` is not set.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the subject (group or user) which we are sharing with.
        """
        return pulumi.get(self, "subject_name")

    @subject_name.setter
    def subject_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_name", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a user which we are sharing with. Required if `group_id` is not set.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class OrgVdcComputeCapacityArgsDict(TypedDict):
        cpu: pulumi.Input['OrgVdcComputeCapacityCpuArgsDict']
        memory: pulumi.Input['OrgVdcComputeCapacityMemoryArgsDict']
elif False:
    OrgVdcComputeCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcComputeCapacityArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input['OrgVdcComputeCapacityCpuArgs'],
                 memory: pulumi.Input['OrgVdcComputeCapacityMemoryArgs']):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input['OrgVdcComputeCapacityCpuArgs']:
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input['OrgVdcComputeCapacityCpuArgs']):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input['OrgVdcComputeCapacityMemoryArgs']:
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input['OrgVdcComputeCapacityMemoryArgs']):
        pulumi.set(self, "memory", value)


if not MYPY:
    class OrgVdcComputeCapacityCpuArgsDict(TypedDict):
        allocated: NotRequired[pulumi.Input[int]]
        """
        Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        """
        limit: NotRequired[pulumi.Input[int]]
        """
        Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        reserved: NotRequired[pulumi.Input[int]]
        used: NotRequired[pulumi.Input[int]]
elif False:
    OrgVdcComputeCapacityCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcComputeCapacityCpuArgs:
    def __init__(__self__, *,
                 allocated: Optional[pulumi.Input[int]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 reserved: Optional[pulumi.Input[int]] = None,
                 used: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] allocated: Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        :param pulumi.Input[int] limit: Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        if allocated is not None:
            pulumi.set(__self__, "allocated", allocated)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)
        if used is not None:
            pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocated(self) -> Optional[pulumi.Input[int]]:
        """
        Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        """
        return pulumi.get(self, "allocated")

    @allocated.setter
    def allocated(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "allocated", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def reserved(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reserved")

    @reserved.setter
    def reserved(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reserved", value)

    @property
    @pulumi.getter
    def used(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "used")

    @used.setter
    def used(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "used", value)


if not MYPY:
    class OrgVdcComputeCapacityMemoryArgsDict(TypedDict):
        allocated: NotRequired[pulumi.Input[int]]
        """
        Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        """
        limit: NotRequired[pulumi.Input[int]]
        """
        Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        reserved: NotRequired[pulumi.Input[int]]
        used: NotRequired[pulumi.Input[int]]
elif False:
    OrgVdcComputeCapacityMemoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcComputeCapacityMemoryArgs:
    def __init__(__self__, *,
                 allocated: Optional[pulumi.Input[int]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 reserved: Optional[pulumi.Input[int]] = None,
                 used: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] allocated: Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        :param pulumi.Input[int] limit: Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        if allocated is not None:
            pulumi.set(__self__, "allocated", allocated)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)
        if used is not None:
            pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocated(self) -> Optional[pulumi.Input[int]]:
        """
        Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        """
        return pulumi.get(self, "allocated")

    @allocated.setter
    def allocated(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "allocated", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def reserved(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reserved")

    @reserved.setter
    def reserved(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reserved", value)

    @property
    @pulumi.getter
    def used(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "used")

    @used.setter
    def used(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "used", value)


if not MYPY:
    class OrgVdcMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    OrgVdcMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OrgVdcStorageProfileArgsDict(TypedDict):
        default: pulumi.Input[bool]
        """
        True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.
        """
        limit: pulumi.Input[int]
        """
        Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.
        """
        name: pulumi.Input[str]
        """
        VDC name
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True if this VDC is enabled for use by the organization VDCs. Default is true.
        """
        storage_used_in_mb: NotRequired[pulumi.Input[int]]
        """
        Storage used in MB
        """
elif False:
    OrgVdcStorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcStorageProfileArgs:
    def __init__(__self__, *,
                 default: pulumi.Input[bool],
                 limit: pulumi.Input[int],
                 name: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 storage_used_in_mb: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] default: True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.
        :param pulumi.Input[int] limit: Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.
        :param pulumi.Input[str] name: VDC name
        :param pulumi.Input[bool] enabled: True if this VDC is enabled for use by the organization VDCs. Default is true.
        :param pulumi.Input[int] storage_used_in_mb: Storage used in MB
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if storage_used_in_mb is not None:
            pulumi.set(__self__, "storage_used_in_mb", storage_used_in_mb)

    @property
    @pulumi.getter
    def default(self) -> pulumi.Input[bool]:
        """
        True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: pulumi.Input[bool]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        """
        Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        VDC name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if this VDC is enabled for use by the organization VDCs. Default is true.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="storageUsedInMb")
    def storage_used_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Storage used in MB
        """
        return pulumi.get(self, "storage_used_in_mb")

    @storage_used_in_mb.setter
    def storage_used_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage_used_in_mb", value)


if not MYPY:
    class OrgVdcTemplateComputeConfigurationArgsDict(TypedDict):
        cpu_allocated: NotRequired[pulumi.Input[int]]
        """
        The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template. Minimum is 256MHz
        """
        cpu_guaranteed: NotRequired[pulumi.Input[int]]
        """
        The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template
        """
        cpu_limit: NotRequired[pulumi.Input[int]]
        """
        The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. Minimum is 256MHz. 0 means unlimited
        """
        cpu_speed: NotRequired[pulumi.Input[int]]
        """
        Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM. Minimum is 256MHz
        """
        elasticity: NotRequired[pulumi.Input[bool]]
        """
        True if compute capacity can grow or shrink based on demand
        """
        include_vm_memory_overhead: NotRequired[pulumi.Input[bool]]
        """
        True if the instantiated VDC includes memory overhead into its accounting for admission control
        """
        memory_allocated: NotRequired[pulumi.Input[int]]
        """
        The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template
        """
        memory_guaranteed: NotRequired[pulumi.Input[int]]
        """
        The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template
        """
        memory_limit: NotRequired[pulumi.Input[int]]
        """
        The limit amount of Memory, in MB, of the VDC that is instantiated from this template. Minimum is 1024MB. 0 means unlimited
        """
elif False:
    OrgVdcTemplateComputeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcTemplateComputeConfigurationArgs:
    def __init__(__self__, *,
                 cpu_allocated: Optional[pulumi.Input[int]] = None,
                 cpu_guaranteed: Optional[pulumi.Input[int]] = None,
                 cpu_limit: Optional[pulumi.Input[int]] = None,
                 cpu_speed: Optional[pulumi.Input[int]] = None,
                 elasticity: Optional[pulumi.Input[bool]] = None,
                 include_vm_memory_overhead: Optional[pulumi.Input[bool]] = None,
                 memory_allocated: Optional[pulumi.Input[int]] = None,
                 memory_guaranteed: Optional[pulumi.Input[int]] = None,
                 memory_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cpu_allocated: The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template. Minimum is 256MHz
        :param pulumi.Input[int] cpu_guaranteed: The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template
        :param pulumi.Input[int] cpu_limit: The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. Minimum is 256MHz. 0 means unlimited
        :param pulumi.Input[int] cpu_speed: Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM. Minimum is 256MHz
        :param pulumi.Input[bool] elasticity: True if compute capacity can grow or shrink based on demand
        :param pulumi.Input[bool] include_vm_memory_overhead: True if the instantiated VDC includes memory overhead into its accounting for admission control
        :param pulumi.Input[int] memory_allocated: The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template
        :param pulumi.Input[int] memory_guaranteed: The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template
        :param pulumi.Input[int] memory_limit: The limit amount of Memory, in MB, of the VDC that is instantiated from this template. Minimum is 1024MB. 0 means unlimited
        """
        if cpu_allocated is not None:
            pulumi.set(__self__, "cpu_allocated", cpu_allocated)
        if cpu_guaranteed is not None:
            pulumi.set(__self__, "cpu_guaranteed", cpu_guaranteed)
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_speed is not None:
            pulumi.set(__self__, "cpu_speed", cpu_speed)
        if elasticity is not None:
            pulumi.set(__self__, "elasticity", elasticity)
        if include_vm_memory_overhead is not None:
            pulumi.set(__self__, "include_vm_memory_overhead", include_vm_memory_overhead)
        if memory_allocated is not None:
            pulumi.set(__self__, "memory_allocated", memory_allocated)
        if memory_guaranteed is not None:
            pulumi.set(__self__, "memory_guaranteed", memory_guaranteed)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)

    @property
    @pulumi.getter(name="cpuAllocated")
    def cpu_allocated(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template. Minimum is 256MHz
        """
        return pulumi.get(self, "cpu_allocated")

    @cpu_allocated.setter
    def cpu_allocated(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_allocated", value)

    @property
    @pulumi.getter(name="cpuGuaranteed")
    def cpu_guaranteed(self) -> Optional[pulumi.Input[int]]:
        """
        The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template
        """
        return pulumi.get(self, "cpu_guaranteed")

    @cpu_guaranteed.setter
    def cpu_guaranteed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_guaranteed", value)

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. Minimum is 256MHz. 0 means unlimited
        """
        return pulumi.get(self, "cpu_limit")

    @cpu_limit.setter
    def cpu_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_limit", value)

    @property
    @pulumi.getter(name="cpuSpeed")
    def cpu_speed(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM. Minimum is 256MHz
        """
        return pulumi.get(self, "cpu_speed")

    @cpu_speed.setter
    def cpu_speed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_speed", value)

    @property
    @pulumi.getter
    def elasticity(self) -> Optional[pulumi.Input[bool]]:
        """
        True if compute capacity can grow or shrink based on demand
        """
        return pulumi.get(self, "elasticity")

    @elasticity.setter
    def elasticity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "elasticity", value)

    @property
    @pulumi.getter(name="includeVmMemoryOverhead")
    def include_vm_memory_overhead(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the instantiated VDC includes memory overhead into its accounting for admission control
        """
        return pulumi.get(self, "include_vm_memory_overhead")

    @include_vm_memory_overhead.setter
    def include_vm_memory_overhead(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_vm_memory_overhead", value)

    @property
    @pulumi.getter(name="memoryAllocated")
    def memory_allocated(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template
        """
        return pulumi.get(self, "memory_allocated")

    @memory_allocated.setter
    def memory_allocated(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_allocated", value)

    @property
    @pulumi.getter(name="memoryGuaranteed")
    def memory_guaranteed(self) -> Optional[pulumi.Input[int]]:
        """
        The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template
        """
        return pulumi.get(self, "memory_guaranteed")

    @memory_guaranteed.setter
    def memory_guaranteed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_guaranteed", value)

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The limit amount of Memory, in MB, of the VDC that is instantiated from this template. Minimum is 1024MB. 0 means unlimited
        """
        return pulumi.get(self, "memory_limit")

    @memory_limit.setter
    def memory_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_limit", value)


if not MYPY:
    class OrgVdcTemplateEdgeGatewayArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the Edge Gateway
        """
        routed_network_gateway_cidr: pulumi.Input[str]
        """
        CIDR of the Edge Gateway for the created routed network
        """
        routed_network_name: pulumi.Input[str]
        """
        Name of the routed network to create with the Edge Gateway
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the Edge Gateway
        """
        ip_allocation_count: NotRequired[pulumi.Input[int]]
        """
        Allocated IPs for the Edge Gateway. Defaults to 0
        """
        routed_network_description: NotRequired[pulumi.Input[str]]
        """
        Description of the routed network to create with the Edge Gateway
        """
        static_ip_pool: NotRequired[pulumi.Input['OrgVdcTemplateEdgeGatewayStaticIpPoolArgsDict']]
        """
        **One block** with a single IP range (this is a constraint due to a bug in VCD 10.5+) that has two properties: `start_address`, the start address of the IP range;
        `end_address`, the end address of the IP range
        """
elif False:
    OrgVdcTemplateEdgeGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcTemplateEdgeGatewayArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 routed_network_gateway_cidr: pulumi.Input[str],
                 routed_network_name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 ip_allocation_count: Optional[pulumi.Input[int]] = None,
                 routed_network_description: Optional[pulumi.Input[str]] = None,
                 static_ip_pool: Optional[pulumi.Input['OrgVdcTemplateEdgeGatewayStaticIpPoolArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the Edge Gateway
        :param pulumi.Input[str] routed_network_gateway_cidr: CIDR of the Edge Gateway for the created routed network
        :param pulumi.Input[str] routed_network_name: Name of the routed network to create with the Edge Gateway
        :param pulumi.Input[str] description: Description of the Edge Gateway
        :param pulumi.Input[int] ip_allocation_count: Allocated IPs for the Edge Gateway. Defaults to 0
        :param pulumi.Input[str] routed_network_description: Description of the routed network to create with the Edge Gateway
        :param pulumi.Input['OrgVdcTemplateEdgeGatewayStaticIpPoolArgs'] static_ip_pool: **One block** with a single IP range (this is a constraint due to a bug in VCD 10.5+) that has two properties: `start_address`, the start address of the IP range;
               `end_address`, the end address of the IP range
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routed_network_gateway_cidr", routed_network_gateway_cidr)
        pulumi.set(__self__, "routed_network_name", routed_network_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip_allocation_count is not None:
            pulumi.set(__self__, "ip_allocation_count", ip_allocation_count)
        if routed_network_description is not None:
            pulumi.set(__self__, "routed_network_description", routed_network_description)
        if static_ip_pool is not None:
            pulumi.set(__self__, "static_ip_pool", static_ip_pool)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Edge Gateway
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="routedNetworkGatewayCidr")
    def routed_network_gateway_cidr(self) -> pulumi.Input[str]:
        """
        CIDR of the Edge Gateway for the created routed network
        """
        return pulumi.get(self, "routed_network_gateway_cidr")

    @routed_network_gateway_cidr.setter
    def routed_network_gateway_cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "routed_network_gateway_cidr", value)

    @property
    @pulumi.getter(name="routedNetworkName")
    def routed_network_name(self) -> pulumi.Input[str]:
        """
        Name of the routed network to create with the Edge Gateway
        """
        return pulumi.get(self, "routed_network_name")

    @routed_network_name.setter
    def routed_network_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "routed_network_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the Edge Gateway
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="ipAllocationCount")
    def ip_allocation_count(self) -> Optional[pulumi.Input[int]]:
        """
        Allocated IPs for the Edge Gateway. Defaults to 0
        """
        return pulumi.get(self, "ip_allocation_count")

    @ip_allocation_count.setter
    def ip_allocation_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ip_allocation_count", value)

    @property
    @pulumi.getter(name="routedNetworkDescription")
    def routed_network_description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the routed network to create with the Edge Gateway
        """
        return pulumi.get(self, "routed_network_description")

    @routed_network_description.setter
    def routed_network_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routed_network_description", value)

    @property
    @pulumi.getter(name="staticIpPool")
    def static_ip_pool(self) -> Optional[pulumi.Input['OrgVdcTemplateEdgeGatewayStaticIpPoolArgs']]:
        """
        **One block** with a single IP range (this is a constraint due to a bug in VCD 10.5+) that has two properties: `start_address`, the start address of the IP range;
        `end_address`, the end address of the IP range
        """
        return pulumi.get(self, "static_ip_pool")

    @static_ip_pool.setter
    def static_ip_pool(self, value: Optional[pulumi.Input['OrgVdcTemplateEdgeGatewayStaticIpPoolArgs']]):
        pulumi.set(self, "static_ip_pool", value)


if not MYPY:
    class OrgVdcTemplateEdgeGatewayStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        """
        End address of the IP range
        """
        start_address: pulumi.Input[str]
        """
        Start address of the IP range
        """
elif False:
    OrgVdcTemplateEdgeGatewayStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcTemplateEdgeGatewayStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] end_address: End address of the IP range
        :param pulumi.Input[str] start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class OrgVdcTemplateProviderVdcArgsDict(TypedDict):
        external_network_id: pulumi.Input[str]
        """
        ID of the Provider Gateway to use, can be obtained with
        [`ExternalNetworkV2` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
        """
        id: pulumi.Input[str]
        """
        ID of the Provider VDC, can be obtained with
        [`ProviderVdc` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/provider_vdc)
        """
        gateway_edge_cluster_id: NotRequired[pulumi.Input[str]]
        """
        ID of the Edge Cluster that the VDCs instantiated from this template will use with the Edge Gateway.
        Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster).
        If set, a `edge_gateway` block **must** be present in the VDC Template configuration (see below).
        """
        services_edge_cluster_id: NotRequired[pulumi.Input[str]]
        """
        ID of the Edge Cluster that the VDCs instantiated from this template will use for services.
        Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster)
        """
elif False:
    OrgVdcTemplateProviderVdcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcTemplateProviderVdcArgs:
    def __init__(__self__, *,
                 external_network_id: pulumi.Input[str],
                 id: pulumi.Input[str],
                 gateway_edge_cluster_id: Optional[pulumi.Input[str]] = None,
                 services_edge_cluster_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] external_network_id: ID of the Provider Gateway to use, can be obtained with
               [`ExternalNetworkV2` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
        :param pulumi.Input[str] id: ID of the Provider VDC, can be obtained with
               [`ProviderVdc` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/provider_vdc)
        :param pulumi.Input[str] gateway_edge_cluster_id: ID of the Edge Cluster that the VDCs instantiated from this template will use with the Edge Gateway.
               Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster).
               If set, a `edge_gateway` block **must** be present in the VDC Template configuration (see below).
        :param pulumi.Input[str] services_edge_cluster_id: ID of the Edge Cluster that the VDCs instantiated from this template will use for services.
               Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster)
        """
        pulumi.set(__self__, "external_network_id", external_network_id)
        pulumi.set(__self__, "id", id)
        if gateway_edge_cluster_id is not None:
            pulumi.set(__self__, "gateway_edge_cluster_id", gateway_edge_cluster_id)
        if services_edge_cluster_id is not None:
            pulumi.set(__self__, "services_edge_cluster_id", services_edge_cluster_id)

    @property
    @pulumi.getter(name="externalNetworkId")
    def external_network_id(self) -> pulumi.Input[str]:
        """
        ID of the Provider Gateway to use, can be obtained with
        [`ExternalNetworkV2` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
        """
        return pulumi.get(self, "external_network_id")

    @external_network_id.setter
    def external_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "external_network_id", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the Provider VDC, can be obtained with
        [`ProviderVdc` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/provider_vdc)
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="gatewayEdgeClusterId")
    def gateway_edge_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Edge Cluster that the VDCs instantiated from this template will use with the Edge Gateway.
        Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster).
        If set, a `edge_gateway` block **must** be present in the VDC Template configuration (see below).
        """
        return pulumi.get(self, "gateway_edge_cluster_id")

    @gateway_edge_cluster_id.setter
    def gateway_edge_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway_edge_cluster_id", value)

    @property
    @pulumi.getter(name="servicesEdgeClusterId")
    def services_edge_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the Edge Cluster that the VDCs instantiated from this template will use for services.
        Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster)
        """
        return pulumi.get(self, "services_edge_cluster_id")

    @services_edge_cluster_id.setter
    def services_edge_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_edge_cluster_id", value)


if not MYPY:
    class OrgVdcTemplateStorageProfileArgsDict(TypedDict):
        default: pulumi.Input[bool]
        """
        True if this is default storage profile for the VDCs instantiated from this template. Only **one** block should have this set to `true`
        """
        limit: pulumi.Input[int]
        """
        Storage limit for the VDCs instantiated from this template, in MB. 0 means unlimited
        """
        name: pulumi.Input[str]
        """
        Name of Provider VDC storage profile to use for the VDCs instantiated from this template
        """
elif False:
    OrgVdcTemplateStorageProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgVdcTemplateStorageProfileArgs:
    def __init__(__self__, *,
                 default: pulumi.Input[bool],
                 limit: pulumi.Input[int],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] default: True if this is default storage profile for the VDCs instantiated from this template. Only **one** block should have this set to `true`
        :param pulumi.Input[int] limit: Storage limit for the VDCs instantiated from this template, in MB. 0 means unlimited
        :param pulumi.Input[str] name: Name of Provider VDC storage profile to use for the VDCs instantiated from this template
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> pulumi.Input[bool]:
        """
        True if this is default storage profile for the VDCs instantiated from this template. Only **one** block should have this set to `true`
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: pulumi.Input[bool]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        """
        Storage limit for the VDCs instantiated from this template, in MB. 0 means unlimited
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of Provider VDC storage profile to use for the VDCs instantiated from this template
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProviderIgnoreMetadataChangeArgsDict(TypedDict):
        conflict_action: NotRequired[pulumi.Input[str]]
        key_regex: NotRequired[pulumi.Input[str]]
        """
        Regular expression of the metadata entry keys to ignore. Either `key_regex` or `value_regex` is required
        """
        resource_name: NotRequired[pulumi.Input[str]]
        """
        Ignores metadata from the specific entity in VCD named like this argument
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        Ignores metadata from the specific resource type
        """
        value_regex: NotRequired[pulumi.Input[str]]
        """
        Regular expression of the metadata entry values to ignore. Either `key_regex` or `value_regex` is required
        """
elif False:
    ProviderIgnoreMetadataChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderIgnoreMetadataChangeArgs:
    def __init__(__self__, *,
                 conflict_action: Optional[pulumi.Input[str]] = None,
                 key_regex: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 value_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_regex: Regular expression of the metadata entry keys to ignore. Either `key_regex` or `value_regex` is required
        :param pulumi.Input[str] resource_name: Ignores metadata from the specific entity in VCD named like this argument
        :param pulumi.Input[str] resource_type: Ignores metadata from the specific resource type
        :param pulumi.Input[str] value_regex: Regular expression of the metadata entry values to ignore. Either `key_regex` or `value_regex` is required
        """
        if conflict_action is not None:
            pulumi.set(__self__, "conflict_action", conflict_action)
        if key_regex is not None:
            pulumi.set(__self__, "key_regex", key_regex)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter(name="conflictAction")
    def conflict_action(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "conflict_action")

    @conflict_action.setter
    def conflict_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conflict_action", value)

    @property
    @pulumi.getter(name="keyRegex")
    def key_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression of the metadata entry keys to ignore. Either `key_regex` or `value_regex` is required
        """
        return pulumi.get(self, "key_regex")

    @key_regex.setter
    def key_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_regex", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        Ignores metadata from the specific entity in VCD named like this argument
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        Ignores metadata from the specific resource type
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression of the metadata entry values to ignore. Either `key_regex` or `value_regex` is required
        """
        return pulumi.get(self, "value_regex")

    @value_regex.setter
    def value_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_regex", value)


if not MYPY:
    class ProviderVdcComputeCapacityArgsDict(TypedDict):
        cpus: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityCpusArgsDict']]]]
        """
        Single-element list with an indicator of CPU capacity available in the Provider VDC
        """
        is_elastic: NotRequired[pulumi.Input[bool]]
        """
        True if compute capacity can grow or shrink based on demand
        """
        is_ha: NotRequired[pulumi.Input[bool]]
        """
        True if compute capacity is highly available
        """
        memories: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityMemoryArgsDict']]]]
        """
        Single-element list with an indicator of Memory capacity available in the Provider VDC
        """
elif False:
    ProviderVdcComputeCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderVdcComputeCapacityArgs:
    def __init__(__self__, *,
                 cpus: Optional[pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityCpusArgs']]]] = None,
                 is_elastic: Optional[pulumi.Input[bool]] = None,
                 is_ha: Optional[pulumi.Input[bool]] = None,
                 memories: Optional[pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityMemoryArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityCpusArgs']]] cpus: Single-element list with an indicator of CPU capacity available in the Provider VDC
        :param pulumi.Input[bool] is_elastic: True if compute capacity can grow or shrink based on demand
        :param pulumi.Input[bool] is_ha: True if compute capacity is highly available
        :param pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityMemoryArgs']]] memories: Single-element list with an indicator of Memory capacity available in the Provider VDC
        """
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if is_elastic is not None:
            pulumi.set(__self__, "is_elastic", is_elastic)
        if is_ha is not None:
            pulumi.set(__self__, "is_ha", is_ha)
        if memories is not None:
            pulumi.set(__self__, "memories", memories)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityCpusArgs']]]]:
        """
        Single-element list with an indicator of CPU capacity available in the Provider VDC
        """
        return pulumi.get(self, "cpus")

    @cpus.setter
    def cpus(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityCpusArgs']]]]):
        pulumi.set(self, "cpus", value)

    @property
    @pulumi.getter(name="isElastic")
    def is_elastic(self) -> Optional[pulumi.Input[bool]]:
        """
        True if compute capacity can grow or shrink based on demand
        """
        return pulumi.get(self, "is_elastic")

    @is_elastic.setter
    def is_elastic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_elastic", value)

    @property
    @pulumi.getter(name="isHa")
    def is_ha(self) -> Optional[pulumi.Input[bool]]:
        """
        True if compute capacity is highly available
        """
        return pulumi.get(self, "is_ha")

    @is_ha.setter
    def is_ha(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ha", value)

    @property
    @pulumi.getter
    def memories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityMemoryArgs']]]]:
        """
        Single-element list with an indicator of Memory capacity available in the Provider VDC
        """
        return pulumi.get(self, "memories")

    @memories.setter
    def memories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProviderVdcComputeCapacityMemoryArgs']]]]):
        pulumi.set(self, "memories", value)


if not MYPY:
    class ProviderVdcComputeCapacityCpusArgsDict(TypedDict):
        allocation: NotRequired[pulumi.Input[int]]
        """
        Allocated CPU for this Provider VDC
        """
        overhead: NotRequired[pulumi.Input[int]]
        """
        CPU overhead for this Provider VDC
        """
        reserved: NotRequired[pulumi.Input[int]]
        """
        Reserved CPU for this Provider VDC
        """
        total: NotRequired[pulumi.Input[int]]
        """
        Total CPU for this Provider VDC
        """
        units: NotRequired[pulumi.Input[str]]
        """
        Units for the CPU of this Provider VDC
        """
        used: NotRequired[pulumi.Input[int]]
        """
        Used CPU in this Provider VDC
        """
elif False:
    ProviderVdcComputeCapacityCpusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderVdcComputeCapacityCpusArgs:
    def __init__(__self__, *,
                 allocation: Optional[pulumi.Input[int]] = None,
                 overhead: Optional[pulumi.Input[int]] = None,
                 reserved: Optional[pulumi.Input[int]] = None,
                 total: Optional[pulumi.Input[int]] = None,
                 units: Optional[pulumi.Input[str]] = None,
                 used: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] allocation: Allocated CPU for this Provider VDC
        :param pulumi.Input[int] overhead: CPU overhead for this Provider VDC
        :param pulumi.Input[int] reserved: Reserved CPU for this Provider VDC
        :param pulumi.Input[int] total: Total CPU for this Provider VDC
        :param pulumi.Input[str] units: Units for the CPU of this Provider VDC
        :param pulumi.Input[int] used: Used CPU in this Provider VDC
        """
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if overhead is not None:
            pulumi.set(__self__, "overhead", overhead)
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)
        if total is not None:
            pulumi.set(__self__, "total", total)
        if units is not None:
            pulumi.set(__self__, "units", units)
        if used is not None:
            pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocation(self) -> Optional[pulumi.Input[int]]:
        """
        Allocated CPU for this Provider VDC
        """
        return pulumi.get(self, "allocation")

    @allocation.setter
    def allocation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "allocation", value)

    @property
    @pulumi.getter
    def overhead(self) -> Optional[pulumi.Input[int]]:
        """
        CPU overhead for this Provider VDC
        """
        return pulumi.get(self, "overhead")

    @overhead.setter
    def overhead(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "overhead", value)

    @property
    @pulumi.getter
    def reserved(self) -> Optional[pulumi.Input[int]]:
        """
        Reserved CPU for this Provider VDC
        """
        return pulumi.get(self, "reserved")

    @reserved.setter
    def reserved(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reserved", value)

    @property
    @pulumi.getter
    def total(self) -> Optional[pulumi.Input[int]]:
        """
        Total CPU for this Provider VDC
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[str]]:
        """
        Units for the CPU of this Provider VDC
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "units", value)

    @property
    @pulumi.getter
    def used(self) -> Optional[pulumi.Input[int]]:
        """
        Used CPU in this Provider VDC
        """
        return pulumi.get(self, "used")

    @used.setter
    def used(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "used", value)


if not MYPY:
    class ProviderVdcComputeCapacityMemoryArgsDict(TypedDict):
        allocation: NotRequired[pulumi.Input[int]]
        """
        Allocated Memory for this Provider VDC
        """
        overhead: NotRequired[pulumi.Input[int]]
        """
        Memory overhead for this Provider VDC
        """
        reserved: NotRequired[pulumi.Input[int]]
        """
        Reserved Memory for this Provider VDC
        """
        total: NotRequired[pulumi.Input[int]]
        """
        Total Memory for this Provider VDC
        """
        units: NotRequired[pulumi.Input[str]]
        """
        Units for the Memory of this Provider VDC
        """
        used: NotRequired[pulumi.Input[int]]
        """
        Used Memory in this Provider VDC
        """
elif False:
    ProviderVdcComputeCapacityMemoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderVdcComputeCapacityMemoryArgs:
    def __init__(__self__, *,
                 allocation: Optional[pulumi.Input[int]] = None,
                 overhead: Optional[pulumi.Input[int]] = None,
                 reserved: Optional[pulumi.Input[int]] = None,
                 total: Optional[pulumi.Input[int]] = None,
                 units: Optional[pulumi.Input[str]] = None,
                 used: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] allocation: Allocated Memory for this Provider VDC
        :param pulumi.Input[int] overhead: Memory overhead for this Provider VDC
        :param pulumi.Input[int] reserved: Reserved Memory for this Provider VDC
        :param pulumi.Input[int] total: Total Memory for this Provider VDC
        :param pulumi.Input[str] units: Units for the Memory of this Provider VDC
        :param pulumi.Input[int] used: Used Memory in this Provider VDC
        """
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if overhead is not None:
            pulumi.set(__self__, "overhead", overhead)
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)
        if total is not None:
            pulumi.set(__self__, "total", total)
        if units is not None:
            pulumi.set(__self__, "units", units)
        if used is not None:
            pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocation(self) -> Optional[pulumi.Input[int]]:
        """
        Allocated Memory for this Provider VDC
        """
        return pulumi.get(self, "allocation")

    @allocation.setter
    def allocation(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "allocation", value)

    @property
    @pulumi.getter
    def overhead(self) -> Optional[pulumi.Input[int]]:
        """
        Memory overhead for this Provider VDC
        """
        return pulumi.get(self, "overhead")

    @overhead.setter
    def overhead(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "overhead", value)

    @property
    @pulumi.getter
    def reserved(self) -> Optional[pulumi.Input[int]]:
        """
        Reserved Memory for this Provider VDC
        """
        return pulumi.get(self, "reserved")

    @reserved.setter
    def reserved(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reserved", value)

    @property
    @pulumi.getter
    def total(self) -> Optional[pulumi.Input[int]]:
        """
        Total Memory for this Provider VDC
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[str]]:
        """
        Units for the Memory of this Provider VDC
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "units", value)

    @property
    @pulumi.getter
    def used(self) -> Optional[pulumi.Input[int]]:
        """
        Used Memory in this Provider VDC
        """
        return pulumi.get(self, "used")

    @used.setter
    def used(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "used", value)


if not MYPY:
    class ProviderVdcMetadataEntryArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key of this metadata entry
        """
        value: pulumi.Input[str]
        """
        Value of this metadata entry
        """
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL. Defaults to false
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'. Defaults to 'MetadataStringValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'. Defaults to 'READWRITE'
        """
elif False:
    ProviderVdcMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderVdcMetadataEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 is_system: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Key of this metadata entry
        :param pulumi.Input[str] value: Value of this metadata entry
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL. Defaults to false
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'. Defaults to 'MetadataStringValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'. Defaults to 'READWRITE'
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL. Defaults to false
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'. Defaults to 'MetadataStringValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'. Defaults to 'READWRITE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)


if not MYPY:
    class RdeMetadataEntryArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        value: pulumi.Input[str]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        Only meaningful for providers. Allows them to share entries with their tenants. Currently, accepted values are: `TENANT`, `PROVIDER`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID of the metadata entry
        """
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace of the metadata entry
        """
        persistent: NotRequired[pulumi.Input[bool]]
        """
        Persistent metadata entries can be copied over on some entity operation
        """
        readonly: NotRequired[pulumi.Input[bool]]
        """
        True if the metadata entry is read only
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'
        """
elif False:
    RdeMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdeMetadataEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 domain: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 persistent: Optional[pulumi.Input[bool]] = None,
                 readonly: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] domain: Only meaningful for providers. Allows them to share entries with their tenants. Currently, accepted values are: `TENANT`, `PROVIDER`
        :param pulumi.Input[str] id: ID of the metadata entry
        :param pulumi.Input[str] namespace: Namespace of the metadata entry
        :param pulumi.Input[bool] persistent: Persistent metadata entries can be copied over on some entity operation
        :param pulumi.Input[bool] readonly: True if the metadata entry is read only
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if persistent is not None:
            pulumi.set(__self__, "persistent", persistent)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Only meaningful for providers. Allows them to share entries with their tenants. Currently, accepted values are: `TENANT`, `PROVIDER`
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the metadata entry
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace of the metadata entry
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def persistent(self) -> Optional[pulumi.Input[bool]]:
        """
        Persistent metadata entries can be copied over on some entity operation
        """
        return pulumi.get(self, "persistent")

    @persistent.setter
    def persistent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "persistent", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the metadata entry is read only
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "readonly", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RdeTypeHookArgsDict(TypedDict):
        behavior_id: pulumi.Input[str]
        """
        Existing Behavior that will be automatically invoked when any RDE of this RDE Type triggers the event.
        """
        event: pulumi.Input[str]
        """
        Event that will invoke the Behavior, one of `PostCreate`, `PostUpdate`, `PreDelete`, `PostDelete`.
        """
elif False:
    RdeTypeHookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RdeTypeHookArgs:
    def __init__(__self__, *,
                 behavior_id: pulumi.Input[str],
                 event: pulumi.Input[str]):
        """
        :param pulumi.Input[str] behavior_id: Existing Behavior that will be automatically invoked when any RDE of this RDE Type triggers the event.
        :param pulumi.Input[str] event: Event that will invoke the Behavior, one of `PostCreate`, `PostUpdate`, `PreDelete`, `PostDelete`.
        """
        pulumi.set(__self__, "behavior_id", behavior_id)
        pulumi.set(__self__, "event", event)

    @property
    @pulumi.getter(name="behaviorId")
    def behavior_id(self) -> pulumi.Input[str]:
        """
        Existing Behavior that will be automatically invoked when any RDE of this RDE Type triggers the event.
        """
        return pulumi.get(self, "behavior_id")

    @behavior_id.setter
    def behavior_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "behavior_id", value)

    @property
    @pulumi.getter
    def event(self) -> pulumi.Input[str]:
        """
        Event that will invoke the Behavior, one of `PostCreate`, `PostUpdate`, `PreDelete`, `PostDelete`.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: pulumi.Input[str]):
        pulumi.set(self, "event", value)


if not MYPY:
    class SolutionLandingZoneCatalogArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of catalog
        """
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Capability set for catalog
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Catalog Name
        """
elif False:
    SolutionLandingZoneCatalogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SolutionLandingZoneCatalogArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of catalog
        :param pulumi.Input[Sequence[pulumi.Input[str]]] capabilities: Capability set for catalog
        :param pulumi.Input[str] name: Catalog Name
        """
        pulumi.set(__self__, "id", id)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of catalog
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Capability set for catalog
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Catalog Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SolutionLandingZoneVdcArgsDict(TypedDict):
        compute_policies: pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcComputePolicyArgsDict']]]
        """
        Structure for Compute Policy
        """
        id: pulumi.Input[str]
        """
        ID of VDC
        """
        is_default: pulumi.Input[bool]
        """
        Defines if the entity should be considered as default
        """
        org_vdc_networks: pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcOrgVdcNetworkArgsDict']]]
        """
        Structure for Org VDC Network
        """
        storage_policies: pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcStoragePolicyArgsDict']]]
        """
        Structure for Storage Policy
        """
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Capability set for VDC
        """
        name: NotRequired[pulumi.Input[str]]
        """
        VDC Name
        """
elif False:
    SolutionLandingZoneVdcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SolutionLandingZoneVdcArgs:
    def __init__(__self__, *,
                 compute_policies: pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcComputePolicyArgs']]],
                 id: pulumi.Input[str],
                 is_default: pulumi.Input[bool],
                 org_vdc_networks: pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcOrgVdcNetworkArgs']]],
                 storage_policies: pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcStoragePolicyArgs']]],
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcComputePolicyArgs']]] compute_policies: Structure for Compute Policy
        :param pulumi.Input[str] id: ID of VDC
        :param pulumi.Input[bool] is_default: Defines if the entity should be considered as default
        :param pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcOrgVdcNetworkArgs']]] org_vdc_networks: Structure for Org VDC Network
        :param pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcStoragePolicyArgs']]] storage_policies: Structure for Storage Policy
        :param pulumi.Input[Sequence[pulumi.Input[str]]] capabilities: Capability set for VDC
        :param pulumi.Input[str] name: VDC Name
        """
        pulumi.set(__self__, "compute_policies", compute_policies)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "org_vdc_networks", org_vdc_networks)
        pulumi.set(__self__, "storage_policies", storage_policies)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="computePolicies")
    def compute_policies(self) -> pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcComputePolicyArgs']]]:
        """
        Structure for Compute Policy
        """
        return pulumi.get(self, "compute_policies")

    @compute_policies.setter
    def compute_policies(self, value: pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcComputePolicyArgs']]]):
        pulumi.set(self, "compute_policies", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of VDC
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> pulumi.Input[bool]:
        """
        Defines if the entity should be considered as default
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter(name="orgVdcNetworks")
    def org_vdc_networks(self) -> pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcOrgVdcNetworkArgs']]]:
        """
        Structure for Org VDC Network
        """
        return pulumi.get(self, "org_vdc_networks")

    @org_vdc_networks.setter
    def org_vdc_networks(self, value: pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcOrgVdcNetworkArgs']]]):
        pulumi.set(self, "org_vdc_networks", value)

    @property
    @pulumi.getter(name="storagePolicies")
    def storage_policies(self) -> pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcStoragePolicyArgs']]]:
        """
        Structure for Storage Policy
        """
        return pulumi.get(self, "storage_policies")

    @storage_policies.setter
    def storage_policies(self, value: pulumi.Input[Sequence[pulumi.Input['SolutionLandingZoneVdcStoragePolicyArgs']]]):
        pulumi.set(self, "storage_policies", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Capability set for VDC
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        VDC Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SolutionLandingZoneVdcComputePolicyArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of Compute Policy
        """
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of capabilities for Compute Policy
        """
        is_default: NotRequired[pulumi.Input[bool]]
        """
        Boolean value that marks if this Compute Policy should be default
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of Compute Policy
        """
elif False:
    SolutionLandingZoneVdcComputePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SolutionLandingZoneVdcComputePolicyArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_default: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of Compute Policy
        :param pulumi.Input[Sequence[pulumi.Input[str]]] capabilities: Set of capabilities for Compute Policy
        :param pulumi.Input[bool] is_default: Boolean value that marks if this Compute Policy should be default
        :param pulumi.Input[str] name: Name of Compute Policy
        """
        pulumi.set(__self__, "id", id)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of Compute Policy
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of capabilities for Compute Policy
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that marks if this Compute Policy should be default
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Compute Policy
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SolutionLandingZoneVdcOrgVdcNetworkArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of Org VDC Network
        """
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of capabilities for Org VDC Network
        """
        is_default: NotRequired[pulumi.Input[bool]]
        """
        Boolean value that marks if this Org VDC Network should be default
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of Org VDC Network
        """
elif False:
    SolutionLandingZoneVdcOrgVdcNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SolutionLandingZoneVdcOrgVdcNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_default: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of Org VDC Network
        :param pulumi.Input[Sequence[pulumi.Input[str]]] capabilities: Set of capabilities for Org VDC Network
        :param pulumi.Input[bool] is_default: Boolean value that marks if this Org VDC Network should be default
        :param pulumi.Input[str] name: Name of Org VDC Network
        """
        pulumi.set(__self__, "id", id)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of Org VDC Network
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of capabilities for Org VDC Network
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that marks if this Org VDC Network should be default
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Org VDC Network
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SolutionLandingZoneVdcStoragePolicyArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of Storage Policy
        """
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of capabilities for Storage Policy
        """
        is_default: NotRequired[pulumi.Input[bool]]
        """
        Boolean value that marks if this Storage Policy should be default
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of Storage Policy
        """
elif False:
    SolutionLandingZoneVdcStoragePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SolutionLandingZoneVdcStoragePolicyArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_default: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of Storage Policy
        :param pulumi.Input[Sequence[pulumi.Input[str]]] capabilities: Set of capabilities for Storage Policy
        :param pulumi.Input[bool] is_default: Boolean value that marks if this Storage Policy should be default
        :param pulumi.Input[str] name: Name of Storage Policy
        """
        pulumi.set(__self__, "id", id)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of Storage Policy
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of capabilities for Storage Policy
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that marks if this Storage Policy should be default
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of Storage Policy
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VappAccessControlSharedWithArgsDict(TypedDict):
        access_level: pulumi.Input[str]
        """
        The access level for the user or group to which we are sharing. (One of `ReadOnly`, `Change`, `FullControl`)
        """
        group_id: NotRequired[pulumi.Input[str]]
        """
        The ID of a group with which we are sharing. Required if `user_id` is not set.
        """
        subject_name: NotRequired[pulumi.Input[str]]
        """
        the name of the subject (group or user) with which we are sharing.
        """
        user_id: NotRequired[pulumi.Input[str]]
        """
        The ID of a user with which we are sharing. Required if `group_id` is not set.
        """
elif False:
    VappAccessControlSharedWithArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappAccessControlSharedWithArgs:
    def __init__(__self__, *,
                 access_level: pulumi.Input[str],
                 group_id: Optional[pulumi.Input[str]] = None,
                 subject_name: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_level: The access level for the user or group to which we are sharing. (One of `ReadOnly`, `Change`, `FullControl`)
        :param pulumi.Input[str] group_id: The ID of a group with which we are sharing. Required if `user_id` is not set.
        :param pulumi.Input[str] subject_name: the name of the subject (group or user) with which we are sharing.
        :param pulumi.Input[str] user_id: The ID of a user with which we are sharing. Required if `group_id` is not set.
        """
        pulumi.set(__self__, "access_level", access_level)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> pulumi.Input[str]:
        """
        The access level for the user or group to which we are sharing. (One of `ReadOnly`, `Change`, `FullControl`)
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a group with which we are sharing. Required if `user_id` is not set.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[pulumi.Input[str]]:
        """
        the name of the subject (group or user) with which we are sharing.
        """
        return pulumi.get(self, "subject_name")

    @subject_name.setter
    def subject_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_name", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a user with which we are sharing. Required if `group_id` is not set.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class VappFirewallRulesRuleArgsDict(TypedDict):
        destination_ip: NotRequired[pulumi.Input[str]]
        """
        Destination IP address to which the rule applies. A value of `Any` matches any IP address.
        """
        destination_port: NotRequired[pulumi.Input[str]]
        """
        Destination port to which this rule applies.
        """
        destination_vm_id: NotRequired[pulumi.Input[str]]
        """
        Destination VM identifier
        """
        destination_vm_ip_type: NotRequired[pulumi.Input[str]]
        """
        The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        """
        destination_vm_nic_id: NotRequired[pulumi.Input[int]]
        """
        Destination VM NIC ID to which this rule applies.
        """
        enable_logging: NotRequired[pulumi.Input[bool]]
        """
        'true' value will enable rule logging. Default is false
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable firewall. Default is `true`.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Rule name
        """
        policy: NotRequired[pulumi.Input[str]]
        """
        One of: `drop` (drop packets that match the rule), `allow` (allow packets that match the rule to pass through the firewall)
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Specify the protocols to which the rule should be applied. One of: `any`, `icmp`, `tcp`, `udp`, `tcp&udp`
        """
        source_ip: NotRequired[pulumi.Input[str]]
        """
        Source IP address to which the rule applies. A value of `Any` matches any IP address.
        """
        source_port: NotRequired[pulumi.Input[str]]
        """
        Source port to which this rule applies.
        """
        source_vm_id: NotRequired[pulumi.Input[str]]
        """
        Source VM identifier
        """
        source_vm_ip_type: NotRequired[pulumi.Input[str]]
        """
        The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        """
        source_vm_nic_id: NotRequired[pulumi.Input[int]]
        """
        Source VM NIC ID to which this rule applies.
        """
elif False:
    VappFirewallRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappFirewallRulesRuleArgs:
    def __init__(__self__, *,
                 destination_ip: Optional[pulumi.Input[str]] = None,
                 destination_port: Optional[pulumi.Input[str]] = None,
                 destination_vm_id: Optional[pulumi.Input[str]] = None,
                 destination_vm_ip_type: Optional[pulumi.Input[str]] = None,
                 destination_vm_nic_id: Optional[pulumi.Input[int]] = None,
                 enable_logging: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 policy: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 source_ip: Optional[pulumi.Input[str]] = None,
                 source_port: Optional[pulumi.Input[str]] = None,
                 source_vm_id: Optional[pulumi.Input[str]] = None,
                 source_vm_ip_type: Optional[pulumi.Input[str]] = None,
                 source_vm_nic_id: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] destination_ip: Destination IP address to which the rule applies. A value of `Any` matches any IP address.
        :param pulumi.Input[str] destination_port: Destination port to which this rule applies.
        :param pulumi.Input[str] destination_vm_id: Destination VM identifier
        :param pulumi.Input[str] destination_vm_ip_type: The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        :param pulumi.Input[int] destination_vm_nic_id: Destination VM NIC ID to which this rule applies.
        :param pulumi.Input[bool] enable_logging: 'true' value will enable rule logging. Default is false
        :param pulumi.Input[bool] enabled: Enable or disable firewall. Default is `true`.
        :param pulumi.Input[str] name: Rule name
        :param pulumi.Input[str] policy: One of: `drop` (drop packets that match the rule), `allow` (allow packets that match the rule to pass through the firewall)
        :param pulumi.Input[str] protocol: Specify the protocols to which the rule should be applied. One of: `any`, `icmp`, `tcp`, `udp`, `tcp&udp`
        :param pulumi.Input[str] source_ip: Source IP address to which the rule applies. A value of `Any` matches any IP address.
        :param pulumi.Input[str] source_port: Source port to which this rule applies.
        :param pulumi.Input[str] source_vm_id: Source VM identifier
        :param pulumi.Input[str] source_vm_ip_type: The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        :param pulumi.Input[int] source_vm_nic_id: Source VM NIC ID to which this rule applies.
        """
        if destination_ip is not None:
            pulumi.set(__self__, "destination_ip", destination_ip)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if destination_vm_id is not None:
            pulumi.set(__self__, "destination_vm_id", destination_vm_id)
        if destination_vm_ip_type is not None:
            pulumi.set(__self__, "destination_vm_ip_type", destination_vm_ip_type)
        if destination_vm_nic_id is not None:
            pulumi.set(__self__, "destination_vm_nic_id", destination_vm_nic_id)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)
        if source_vm_id is not None:
            pulumi.set(__self__, "source_vm_id", source_vm_id)
        if source_vm_ip_type is not None:
            pulumi.set(__self__, "source_vm_ip_type", source_vm_ip_type)
        if source_vm_nic_id is not None:
            pulumi.set(__self__, "source_vm_nic_id", source_vm_nic_id)

    @property
    @pulumi.getter(name="destinationIp")
    def destination_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Destination IP address to which the rule applies. A value of `Any` matches any IP address.
        """
        return pulumi.get(self, "destination_ip")

    @destination_ip.setter
    def destination_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_ip", value)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[pulumi.Input[str]]:
        """
        Destination port to which this rule applies.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_port", value)

    @property
    @pulumi.getter(name="destinationVmId")
    def destination_vm_id(self) -> Optional[pulumi.Input[str]]:
        """
        Destination VM identifier
        """
        return pulumi.get(self, "destination_vm_id")

    @destination_vm_id.setter
    def destination_vm_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_vm_id", value)

    @property
    @pulumi.getter(name="destinationVmIpType")
    def destination_vm_ip_type(self) -> Optional[pulumi.Input[str]]:
        """
        The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        """
        return pulumi.get(self, "destination_vm_ip_type")

    @destination_vm_ip_type.setter
    def destination_vm_ip_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_vm_ip_type", value)

    @property
    @pulumi.getter(name="destinationVmNicId")
    def destination_vm_nic_id(self) -> Optional[pulumi.Input[int]]:
        """
        Destination VM NIC ID to which this rule applies.
        """
        return pulumi.get(self, "destination_vm_nic_id")

    @destination_vm_nic_id.setter
    def destination_vm_nic_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "destination_vm_nic_id", value)

    @property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[pulumi.Input[bool]]:
        """
        'true' value will enable rule logging. Default is false
        """
        return pulumi.get(self, "enable_logging")

    @enable_logging.setter
    def enable_logging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_logging", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable firewall. Default is `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Rule name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        One of: `drop` (drop packets that match the rule), `allow` (allow packets that match the rule to pass through the firewall)
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the protocols to which the rule should be applied. One of: `any`, `icmp`, `tcp`, `udp`, `tcp&udp`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Source IP address to which the rule applies. A value of `Any` matches any IP address.
        """
        return pulumi.get(self, "source_ip")

    @source_ip.setter
    def source_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_ip", value)

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[str]]:
        """
        Source port to which this rule applies.
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_port", value)

    @property
    @pulumi.getter(name="sourceVmId")
    def source_vm_id(self) -> Optional[pulumi.Input[str]]:
        """
        Source VM identifier
        """
        return pulumi.get(self, "source_vm_id")

    @source_vm_id.setter
    def source_vm_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_vm_id", value)

    @property
    @pulumi.getter(name="sourceVmIpType")
    def source_vm_ip_type(self) -> Optional[pulumi.Input[str]]:
        """
        The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        """
        return pulumi.get(self, "source_vm_ip_type")

    @source_vm_ip_type.setter
    def source_vm_ip_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_vm_ip_type", value)

    @property
    @pulumi.getter(name="sourceVmNicId")
    def source_vm_nic_id(self) -> Optional[pulumi.Input[int]]:
        """
        Source VM NIC ID to which this rule applies.
        """
        return pulumi.get(self, "source_vm_nic_id")

    @source_vm_nic_id.setter
    def source_vm_nic_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "source_vm_nic_id", value)


if not MYPY:
    class VappLeaseArgsDict(TypedDict):
        runtime_lease_in_sec: pulumi.Input[int]
        """
        How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        """
        storage_lease_in_sec: pulumi.Input[int]
        """
        How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        """
elif False:
    VappLeaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappLeaseArgs:
    def __init__(__self__, *,
                 runtime_lease_in_sec: pulumi.Input[int],
                 storage_lease_in_sec: pulumi.Input[int]):
        """
        :param pulumi.Input[int] runtime_lease_in_sec: How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        :param pulumi.Input[int] storage_lease_in_sec: How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        """
        pulumi.set(__self__, "runtime_lease_in_sec", runtime_lease_in_sec)
        pulumi.set(__self__, "storage_lease_in_sec", storage_lease_in_sec)

    @property
    @pulumi.getter(name="runtimeLeaseInSec")
    def runtime_lease_in_sec(self) -> pulumi.Input[int]:
        """
        How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        """
        return pulumi.get(self, "runtime_lease_in_sec")

    @runtime_lease_in_sec.setter
    def runtime_lease_in_sec(self, value: pulumi.Input[int]):
        pulumi.set(self, "runtime_lease_in_sec", value)

    @property
    @pulumi.getter(name="storageLeaseInSec")
    def storage_lease_in_sec(self) -> pulumi.Input[int]:
        """
        How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        """
        return pulumi.get(self, "storage_lease_in_sec")

    @storage_lease_in_sec.setter
    def storage_lease_in_sec(self, value: pulumi.Input[int]):
        pulumi.set(self, "storage_lease_in_sec", value)


if not MYPY:
    class VappMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    VappMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VappNatRulesRuleArgsDict(TypedDict):
        vm_id: pulumi.Input[str]
        """
        VM to which this rule applies.
        """
        vm_nic_id: pulumi.Input[int]
        """
        VM NIC ID to which this rule applies.
        """
        external_ip: NotRequired[pulumi.Input[str]]
        """
        External IP address to forward to or External IP address to map to VM
        """
        external_port: NotRequired[pulumi.Input[int]]
        """
        External port to forward.
        """
        forward_to_port: NotRequired[pulumi.Input[int]]
        """
        Internal port to forward.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID of the rule. Can be used to track syslog messages.
        """
        mapping_mode: NotRequired[pulumi.Input[str]]
        """
        Mapping mode. One of: `automatic`, `manual`
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Protocol to forward. One of: `TCP` (forward TCP packets), `UDP` (forward UDP packets), `TCP_UDP` (forward TCP and UDP packets).
        """
elif False:
    VappNatRulesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappNatRulesRuleArgs:
    def __init__(__self__, *,
                 vm_id: pulumi.Input[str],
                 vm_nic_id: pulumi.Input[int],
                 external_ip: Optional[pulumi.Input[str]] = None,
                 external_port: Optional[pulumi.Input[int]] = None,
                 forward_to_port: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 mapping_mode: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] vm_id: VM to which this rule applies.
        :param pulumi.Input[int] vm_nic_id: VM NIC ID to which this rule applies.
        :param pulumi.Input[str] external_ip: External IP address to forward to or External IP address to map to VM
        :param pulumi.Input[int] external_port: External port to forward.
        :param pulumi.Input[int] forward_to_port: Internal port to forward.
        :param pulumi.Input[str] id: ID of the rule. Can be used to track syslog messages.
        :param pulumi.Input[str] mapping_mode: Mapping mode. One of: `automatic`, `manual`
        :param pulumi.Input[str] protocol: Protocol to forward. One of: `TCP` (forward TCP packets), `UDP` (forward UDP packets), `TCP_UDP` (forward TCP and UDP packets).
        """
        pulumi.set(__self__, "vm_id", vm_id)
        pulumi.set(__self__, "vm_nic_id", vm_nic_id)
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)
        if external_port is not None:
            pulumi.set(__self__, "external_port", external_port)
        if forward_to_port is not None:
            pulumi.set(__self__, "forward_to_port", forward_to_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mapping_mode is not None:
            pulumi.set(__self__, "mapping_mode", mapping_mode)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> pulumi.Input[str]:
        """
        VM to which this rule applies.
        """
        return pulumi.get(self, "vm_id")

    @vm_id.setter
    def vm_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_id", value)

    @property
    @pulumi.getter(name="vmNicId")
    def vm_nic_id(self) -> pulumi.Input[int]:
        """
        VM NIC ID to which this rule applies.
        """
        return pulumi.get(self, "vm_nic_id")

    @vm_nic_id.setter
    def vm_nic_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "vm_nic_id", value)

    @property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[pulumi.Input[str]]:
        """
        External IP address to forward to or External IP address to map to VM
        """
        return pulumi.get(self, "external_ip")

    @external_ip.setter
    def external_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_ip", value)

    @property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> Optional[pulumi.Input[int]]:
        """
        External port to forward.
        """
        return pulumi.get(self, "external_port")

    @external_port.setter
    def external_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "external_port", value)

    @property
    @pulumi.getter(name="forwardToPort")
    def forward_to_port(self) -> Optional[pulumi.Input[int]]:
        """
        Internal port to forward.
        """
        return pulumi.get(self, "forward_to_port")

    @forward_to_port.setter
    def forward_to_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "forward_to_port", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the rule. Can be used to track syslog messages.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="mappingMode")
    def mapping_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mapping mode. One of: `automatic`, `manual`
        """
        return pulumi.get(self, "mapping_mode")

    @mapping_mode.setter
    def mapping_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mapping_mode", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol to forward. One of: `TCP` (forward TCP packets), `UDP` (forward UDP packets), `TCP_UDP` (forward TCP and UDP packets).
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class VappNetworkDhcpPoolArgsDict(TypedDict):
        start_address: pulumi.Input[str]
        default_lease_time: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        end_address: NotRequired[pulumi.Input[str]]
        max_lease_time: NotRequired[pulumi.Input[int]]
elif False:
    VappNetworkDhcpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappNetworkDhcpPoolArgs:
    def __init__(__self__, *,
                 start_address: pulumi.Input[str],
                 default_lease_time: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 end_address: Optional[pulumi.Input[str]] = None,
                 max_lease_time: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "start_address", start_address)
        if default_lease_time is not None:
            pulumi.set(__self__, "default_lease_time", default_lease_time)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if end_address is not None:
            pulumi.set(__self__, "end_address", end_address)
        if max_lease_time is not None:
            pulumi.set(__self__, "max_lease_time", max_lease_time)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)

    @property
    @pulumi.getter(name="defaultLeaseTime")
    def default_lease_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "default_lease_time")

    @default_lease_time.setter
    def default_lease_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_lease_time", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="maxLeaseTime")
    def max_lease_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_lease_time")

    @max_lease_time.setter
    def max_lease_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_lease_time", value)


if not MYPY:
    class VappNetworkStaticIpPoolArgsDict(TypedDict):
        end_address: pulumi.Input[str]
        start_address: pulumi.Input[str]
elif False:
    VappNetworkStaticIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappNetworkStaticIpPoolArgs:
    def __init__(__self__, *,
                 end_address: pulumi.Input[str],
                 start_address: pulumi.Input[str]):
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end_address")

    @end_address.setter
    def end_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_address", value)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_address")

    @start_address.setter
    def start_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_address", value)


if not MYPY:
    class VappStaticRoutingRuleArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name for the static route.
        """
        network_cidr: pulumi.Input[str]
        """
        network specification in CIDR.
        """
        next_hop_ip: pulumi.Input[str]
        """
        IP Address of Next Hop router/gateway.
        """
elif False:
    VappStaticRoutingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappStaticRoutingRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 network_cidr: pulumi.Input[str],
                 next_hop_ip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name for the static route.
        :param pulumi.Input[str] network_cidr: network specification in CIDR.
        :param pulumi.Input[str] next_hop_ip: IP Address of Next Hop router/gateway.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_cidr", network_cidr)
        pulumi.set(__self__, "next_hop_ip", next_hop_ip)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for the static route.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkCidr")
    def network_cidr(self) -> pulumi.Input[str]:
        """
        network specification in CIDR.
        """
        return pulumi.get(self, "network_cidr")

    @network_cidr.setter
    def network_cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_cidr", value)

    @property
    @pulumi.getter(name="nextHopIp")
    def next_hop_ip(self) -> pulumi.Input[str]:
        """
        IP Address of Next Hop router/gateway.
        """
        return pulumi.get(self, "next_hop_ip")

    @next_hop_ip.setter
    def next_hop_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "next_hop_ip", value)


if not MYPY:
    class VappVmBootOptionsArgsDict(TypedDict):
        boot_delay: NotRequired[pulumi.Input[int]]
        """
        Number of milliseconds to wait between powering-on and booting the VM
        """
        boot_retry_delay: NotRequired[pulumi.Input[int]]
        """
        Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        """
        boot_retry_enabled: NotRequired[pulumi.Input[bool]]
        """
        If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        """
        efi_secure_boot: NotRequired[pulumi.Input[bool]]
        """
        If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        enter_bios_setup_on_next_boot: NotRequired[pulumi.Input[bool]]
elif False:
    VappVmBootOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappVmBootOptionsArgs:
    def __init__(__self__, *,
                 boot_delay: Optional[pulumi.Input[int]] = None,
                 boot_retry_delay: Optional[pulumi.Input[int]] = None,
                 boot_retry_enabled: Optional[pulumi.Input[bool]] = None,
                 efi_secure_boot: Optional[pulumi.Input[bool]] = None,
                 enter_bios_setup_on_next_boot: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] boot_delay: Number of milliseconds to wait between powering-on and booting the VM
        :param pulumi.Input[int] boot_retry_delay: Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        :param pulumi.Input[bool] boot_retry_enabled: If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        :param pulumi.Input[bool] efi_secure_boot: If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        if boot_delay is not None:
            pulumi.set(__self__, "boot_delay", boot_delay)
        if boot_retry_delay is not None:
            pulumi.set(__self__, "boot_retry_delay", boot_retry_delay)
        if boot_retry_enabled is not None:
            pulumi.set(__self__, "boot_retry_enabled", boot_retry_enabled)
        if efi_secure_boot is not None:
            pulumi.set(__self__, "efi_secure_boot", efi_secure_boot)
        if enter_bios_setup_on_next_boot is not None:
            pulumi.set(__self__, "enter_bios_setup_on_next_boot", enter_bios_setup_on_next_boot)

    @property
    @pulumi.getter(name="bootDelay")
    def boot_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of milliseconds to wait between powering-on and booting the VM
        """
        return pulumi.get(self, "boot_delay")

    @boot_delay.setter
    def boot_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_delay", value)

    @property
    @pulumi.getter(name="bootRetryDelay")
    def boot_retry_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        """
        return pulumi.get(self, "boot_retry_delay")

    @boot_retry_delay.setter
    def boot_retry_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_retry_delay", value)

    @property
    @pulumi.getter(name="bootRetryEnabled")
    def boot_retry_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        """
        return pulumi.get(self, "boot_retry_enabled")

    @boot_retry_enabled.setter
    def boot_retry_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boot_retry_enabled", value)

    @property
    @pulumi.getter(name="efiSecureBoot")
    def efi_secure_boot(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        return pulumi.get(self, "efi_secure_boot")

    @efi_secure_boot.setter
    def efi_secure_boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "efi_secure_boot", value)

    @property
    @pulumi.getter(name="enterBiosSetupOnNextBoot")
    def enter_bios_setup_on_next_boot(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enter_bios_setup_on_next_boot")

    @enter_bios_setup_on_next_boot.setter
    def enter_bios_setup_on_next_boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enter_bios_setup_on_next_boot", value)


if not MYPY:
    class VappVmCustomizationArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[str]]
        """
        Manually specify admin password
        """
        allow_local_admin_password: NotRequired[pulumi.Input[bool]]
        """
        Allow local administrator password
        """
        auto_generate_password: NotRequired[pulumi.Input[bool]]
        """
        Auto generate password
        """
        change_sid: NotRequired[pulumi.Input[bool]]
        """
        'true' value will change SID. Applicable only for Windows VMs
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        """
        force: NotRequired[pulumi.Input[bool]]
        """
        'true' value will cause the VM to reboot on every 'apply' operation
        """
        initscript: NotRequired[pulumi.Input[str]]
        """
        Script to run on initial boot or with customization.force=true set
        """
        join_domain: NotRequired[pulumi.Input[bool]]
        """
        Enable this VM to join a domain
        """
        join_domain_account_ou: NotRequired[pulumi.Input[str]]
        """
        Account organizational unit for domain name join
        """
        join_domain_name: NotRequired[pulumi.Input[str]]
        """
        Custom domain name for join
        """
        join_domain_password: NotRequired[pulumi.Input[str]]
        """
        Password for custom domain name join
        """
        join_domain_user: NotRequired[pulumi.Input[str]]
        """
        Username for custom domain name join
        """
        join_org_domain: NotRequired[pulumi.Input[bool]]
        """
        Use organization's domain for joining
        """
        must_change_password_on_first_login: NotRequired[pulumi.Input[bool]]
        """
        Require Administrator to change password on first login
        """
        number_of_auto_logons: NotRequired[pulumi.Input[int]]
        """
        Number of times to log on automatically. '0' - disabled.
        """
elif False:
    VappVmCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappVmCustomizationArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 allow_local_admin_password: Optional[pulumi.Input[bool]] = None,
                 auto_generate_password: Optional[pulumi.Input[bool]] = None,
                 change_sid: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 force: Optional[pulumi.Input[bool]] = None,
                 initscript: Optional[pulumi.Input[str]] = None,
                 join_domain: Optional[pulumi.Input[bool]] = None,
                 join_domain_account_ou: Optional[pulumi.Input[str]] = None,
                 join_domain_name: Optional[pulumi.Input[str]] = None,
                 join_domain_password: Optional[pulumi.Input[str]] = None,
                 join_domain_user: Optional[pulumi.Input[str]] = None,
                 join_org_domain: Optional[pulumi.Input[bool]] = None,
                 must_change_password_on_first_login: Optional[pulumi.Input[bool]] = None,
                 number_of_auto_logons: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] admin_password: Manually specify admin password
        :param pulumi.Input[bool] allow_local_admin_password: Allow local administrator password
        :param pulumi.Input[bool] auto_generate_password: Auto generate password
        :param pulumi.Input[bool] change_sid: 'true' value will change SID. Applicable only for Windows VMs
        :param pulumi.Input[bool] enabled: 'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        :param pulumi.Input[bool] force: 'true' value will cause the VM to reboot on every 'apply' operation
        :param pulumi.Input[str] initscript: Script to run on initial boot or with customization.force=true set
        :param pulumi.Input[bool] join_domain: Enable this VM to join a domain
        :param pulumi.Input[str] join_domain_account_ou: Account organizational unit for domain name join
        :param pulumi.Input[str] join_domain_name: Custom domain name for join
        :param pulumi.Input[str] join_domain_password: Password for custom domain name join
        :param pulumi.Input[str] join_domain_user: Username for custom domain name join
        :param pulumi.Input[bool] join_org_domain: Use organization's domain for joining
        :param pulumi.Input[bool] must_change_password_on_first_login: Require Administrator to change password on first login
        :param pulumi.Input[int] number_of_auto_logons: Number of times to log on automatically. '0' - disabled.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if allow_local_admin_password is not None:
            pulumi.set(__self__, "allow_local_admin_password", allow_local_admin_password)
        if auto_generate_password is not None:
            pulumi.set(__self__, "auto_generate_password", auto_generate_password)
        if change_sid is not None:
            pulumi.set(__self__, "change_sid", change_sid)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if initscript is not None:
            pulumi.set(__self__, "initscript", initscript)
        if join_domain is not None:
            pulumi.set(__self__, "join_domain", join_domain)
        if join_domain_account_ou is not None:
            pulumi.set(__self__, "join_domain_account_ou", join_domain_account_ou)
        if join_domain_name is not None:
            pulumi.set(__self__, "join_domain_name", join_domain_name)
        if join_domain_password is not None:
            pulumi.set(__self__, "join_domain_password", join_domain_password)
        if join_domain_user is not None:
            pulumi.set(__self__, "join_domain_user", join_domain_user)
        if join_org_domain is not None:
            pulumi.set(__self__, "join_org_domain", join_org_domain)
        if must_change_password_on_first_login is not None:
            pulumi.set(__self__, "must_change_password_on_first_login", must_change_password_on_first_login)
        if number_of_auto_logons is not None:
            pulumi.set(__self__, "number_of_auto_logons", number_of_auto_logons)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        Manually specify admin password
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="allowLocalAdminPassword")
    def allow_local_admin_password(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow local administrator password
        """
        return pulumi.get(self, "allow_local_admin_password")

    @allow_local_admin_password.setter
    def allow_local_admin_password(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_local_admin_password", value)

    @property
    @pulumi.getter(name="autoGeneratePassword")
    def auto_generate_password(self) -> Optional[pulumi.Input[bool]]:
        """
        Auto generate password
        """
        return pulumi.get(self, "auto_generate_password")

    @auto_generate_password.setter
    def auto_generate_password(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_generate_password", value)

    @property
    @pulumi.getter(name="changeSid")
    def change_sid(self) -> Optional[pulumi.Input[bool]]:
        """
        'true' value will change SID. Applicable only for Windows VMs
        """
        return pulumi.get(self, "change_sid")

    @change_sid.setter
    def change_sid(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "change_sid", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[bool]]:
        """
        'true' value will cause the VM to reboot on every 'apply' operation
        """
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force", value)

    @property
    @pulumi.getter
    def initscript(self) -> Optional[pulumi.Input[str]]:
        """
        Script to run on initial boot or with customization.force=true set
        """
        return pulumi.get(self, "initscript")

    @initscript.setter
    def initscript(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initscript", value)

    @property
    @pulumi.getter(name="joinDomain")
    def join_domain(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable this VM to join a domain
        """
        return pulumi.get(self, "join_domain")

    @join_domain.setter
    def join_domain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "join_domain", value)

    @property
    @pulumi.getter(name="joinDomainAccountOu")
    def join_domain_account_ou(self) -> Optional[pulumi.Input[str]]:
        """
        Account organizational unit for domain name join
        """
        return pulumi.get(self, "join_domain_account_ou")

    @join_domain_account_ou.setter
    def join_domain_account_ou(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_domain_account_ou", value)

    @property
    @pulumi.getter(name="joinDomainName")
    def join_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Custom domain name for join
        """
        return pulumi.get(self, "join_domain_name")

    @join_domain_name.setter
    def join_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_domain_name", value)

    @property
    @pulumi.getter(name="joinDomainPassword")
    def join_domain_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for custom domain name join
        """
        return pulumi.get(self, "join_domain_password")

    @join_domain_password.setter
    def join_domain_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_domain_password", value)

    @property
    @pulumi.getter(name="joinDomainUser")
    def join_domain_user(self) -> Optional[pulumi.Input[str]]:
        """
        Username for custom domain name join
        """
        return pulumi.get(self, "join_domain_user")

    @join_domain_user.setter
    def join_domain_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_domain_user", value)

    @property
    @pulumi.getter(name="joinOrgDomain")
    def join_org_domain(self) -> Optional[pulumi.Input[bool]]:
        """
        Use organization's domain for joining
        """
        return pulumi.get(self, "join_org_domain")

    @join_org_domain.setter
    def join_org_domain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "join_org_domain", value)

    @property
    @pulumi.getter(name="mustChangePasswordOnFirstLogin")
    def must_change_password_on_first_login(self) -> Optional[pulumi.Input[bool]]:
        """
        Require Administrator to change password on first login
        """
        return pulumi.get(self, "must_change_password_on_first_login")

    @must_change_password_on_first_login.setter
    def must_change_password_on_first_login(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "must_change_password_on_first_login", value)

    @property
    @pulumi.getter(name="numberOfAutoLogons")
    def number_of_auto_logons(self) -> Optional[pulumi.Input[int]]:
        """
        Number of times to log on automatically. '0' - disabled.
        """
        return pulumi.get(self, "number_of_auto_logons")

    @number_of_auto_logons.setter
    def number_of_auto_logons(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_auto_logons", value)


if not MYPY:
    class VappVmDiskArgsDict(TypedDict):
        bus_number: pulumi.Input[str]
        """
        Bus number on which to place the disk controller
        """
        name: pulumi.Input[str]
        """
        A name for the VM, unique within the vApp
        """
        unit_number: pulumi.Input[str]
        """
        Unit number (slot) on the bus specified by BusNumber
        """
        size_in_mb: NotRequired[pulumi.Input[int]]
        """
        (*v2.7+*) Independent disk size in MB.
        """
elif False:
    VappVmDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappVmDiskArgs:
    def __init__(__self__, *,
                 bus_number: pulumi.Input[str],
                 name: pulumi.Input[str],
                 unit_number: pulumi.Input[str],
                 size_in_mb: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] bus_number: Bus number on which to place the disk controller
        :param pulumi.Input[str] name: A name for the VM, unique within the vApp
        :param pulumi.Input[str] unit_number: Unit number (slot) on the bus specified by BusNumber
        :param pulumi.Input[int] size_in_mb: (*v2.7+*) Independent disk size in MB.
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "unit_number", unit_number)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> pulumi.Input[str]:
        """
        Bus number on which to place the disk controller
        """
        return pulumi.get(self, "bus_number")

    @bus_number.setter
    def bus_number(self, value: pulumi.Input[str]):
        pulumi.set(self, "bus_number", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A name for the VM, unique within the vApp
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> pulumi.Input[str]:
        """
        Unit number (slot) on the bus specified by BusNumber
        """
        return pulumi.get(self, "unit_number")

    @unit_number.setter
    def unit_number(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit_number", value)

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        (*v2.7+*) Independent disk size in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @size_in_mb.setter
    def size_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_in_mb", value)


if not MYPY:
    class VappVmExtraConfigArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The key of the extra configuration item
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Whether the extra configuration item is required
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the extra configuration item
        """
elif False:
    VappVmExtraConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappVmExtraConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of the extra configuration item
        :param pulumi.Input[bool] required: Whether the extra configuration item is required
        :param pulumi.Input[str] value: The value of the extra configuration item
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the extra configuration item is required
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the extra configuration item
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VappVmInternalDiskArgsDict(TypedDict):
        bus_number: NotRequired[pulumi.Input[int]]
        """
        The number of the SCSI or IDE controller itself.
        """
        bus_type: NotRequired[pulumi.Input[str]]
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        disk_id: NotRequired[pulumi.Input[str]]
        """
        The disk ID.
        """
        iops: NotRequired[pulumi.Input[int]]
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        size_in_mb: NotRequired[pulumi.Input[int]]
        """
        The size of the disk in MB.
        """
        storage_profile: NotRequired[pulumi.Input[str]]
        """
        Storage profile to override the default one
        """
        thin_provisioned: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the disk storage is pre-allocated or allocated on demand.
        """
        unit_number: NotRequired[pulumi.Input[int]]
        """
        The device number on the SCSI or IDE controller of the disk.
        """
elif False:
    VappVmInternalDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappVmInternalDiskArgs:
    def __init__(__self__, *,
                 bus_number: Optional[pulumi.Input[int]] = None,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 disk_id: Optional[pulumi.Input[str]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 size_in_mb: Optional[pulumi.Input[int]] = None,
                 storage_profile: Optional[pulumi.Input[str]] = None,
                 thin_provisioned: Optional[pulumi.Input[bool]] = None,
                 unit_number: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bus_number: The number of the SCSI or IDE controller itself.
        :param pulumi.Input[str] bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param pulumi.Input[str] disk_id: The disk ID.
        :param pulumi.Input[int] iops: Specifies the IOPS for the disk. Default is 0.
        :param pulumi.Input[int] size_in_mb: The size of the disk in MB.
        :param pulumi.Input[str] storage_profile: Storage profile to override the default one
        :param pulumi.Input[bool] thin_provisioned: Specifies whether the disk storage is pre-allocated or allocated on demand.
        :param pulumi.Input[int] unit_number: The device number on the SCSI or IDE controller of the disk.
        """
        if bus_number is not None:
            pulumi.set(__self__, "bus_number", bus_number)
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if thin_provisioned is not None:
            pulumi.set(__self__, "thin_provisioned", thin_provisioned)
        if unit_number is not None:
            pulumi.set(__self__, "unit_number", unit_number)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> Optional[pulumi.Input[int]]:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @bus_number.setter
    def bus_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bus_number", value)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        The disk ID.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_id", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @size_in_mb.setter
    def size_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_in_mb", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input[str]]:
        """
        Storage profile to override the default one
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the disk storage is pre-allocated or allocated on demand.
        """
        return pulumi.get(self, "thin_provisioned")

    @thin_provisioned.setter
    def thin_provisioned(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "thin_provisioned", value)

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> Optional[pulumi.Input[int]]:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")

    @unit_number.setter
    def unit_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit_number", value)


if not MYPY:
    class VappVmMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    VappVmMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappVmMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VappVmNetworkArgsDict(TypedDict):
        ip_allocation_mode: pulumi.Input[str]
        """
        IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        type: pulumi.Input[str]
        """
        Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        """
        adapter_type: NotRequired[pulumi.Input[str]]
        """
        Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        """
        connected: NotRequired[pulumi.Input[bool]]
        """
        It defines if NIC is connected or not.
        """
        ip: NotRequired[pulumi.Input[str]]
        """
        IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        is_primary: NotRequired[pulumi.Input[bool]]
        """
        Set to true if network interface should be primary. First network card in the list will be primary by default
        """
        mac: NotRequired[pulumi.Input[str]]
        """
        Mac address of network interface
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A name for the VM, unique within the vApp
        """
        secondary_ip: NotRequired[pulumi.Input[str]]
        """
        Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        secondary_ip_allocation_mode: NotRequired[pulumi.Input[str]]
        """
        Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
elif False:
    VappVmNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappVmNetworkArgs:
    def __init__(__self__, *,
                 ip_allocation_mode: pulumi.Input[str],
                 type: pulumi.Input[str],
                 adapter_type: Optional[pulumi.Input[str]] = None,
                 connected: Optional[pulumi.Input[bool]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 is_primary: Optional[pulumi.Input[bool]] = None,
                 mac: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 secondary_ip: Optional[pulumi.Input[str]] = None,
                 secondary_ip_allocation_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_allocation_mode: IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        :param pulumi.Input[str] type: Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        :param pulumi.Input[str] adapter_type: Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        :param pulumi.Input[bool] connected: It defines if NIC is connected or not.
        :param pulumi.Input[str] ip: IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param pulumi.Input[bool] is_primary: Set to true if network interface should be primary. First network card in the list will be primary by default
        :param pulumi.Input[str] mac: Mac address of network interface
        :param pulumi.Input[str] name: A name for the VM, unique within the vApp
        :param pulumi.Input[str] secondary_ip: Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param pulumi.Input[str] secondary_ip_allocation_mode: Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        pulumi.set(__self__, "ip_allocation_mode", ip_allocation_mode)
        pulumi.set(__self__, "type", type)
        if adapter_type is not None:
            pulumi.set(__self__, "adapter_type", adapter_type)
        if connected is not None:
            pulumi.set(__self__, "connected", connected)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secondary_ip is not None:
            pulumi.set(__self__, "secondary_ip", secondary_ip)
        if secondary_ip_allocation_mode is not None:
            pulumi.set(__self__, "secondary_ip_allocation_mode", secondary_ip_allocation_mode)

    @property
    @pulumi.getter(name="ipAllocationMode")
    def ip_allocation_mode(self) -> pulumi.Input[str]:
        """
        IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "ip_allocation_mode")

    @ip_allocation_mode.setter
    def ip_allocation_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_allocation_mode", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> Optional[pulumi.Input[str]]:
        """
        Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        """
        return pulumi.get(self, "adapter_type")

    @adapter_type.setter
    def adapter_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adapter_type", value)

    @property
    @pulumi.getter
    def connected(self) -> Optional[pulumi.Input[bool]]:
        """
        It defines if NIC is connected or not.
        """
        return pulumi.get(self, "connected")

    @connected.setter
    def connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "connected", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true if network interface should be primary. First network card in the list will be primary by default
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        """
        Mac address of network interface
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for the VM, unique within the vApp
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secondaryIp")
    def secondary_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "secondary_ip")

    @secondary_ip.setter
    def secondary_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ip", value)

    @property
    @pulumi.getter(name="secondaryIpAllocationMode")
    def secondary_ip_allocation_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "secondary_ip_allocation_mode")

    @secondary_ip_allocation_mode.setter
    def secondary_ip_allocation_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ip_allocation_mode", value)


if not MYPY:
    class VappVmOverrideTemplateDiskArgsDict(TypedDict):
        bus_number: pulumi.Input[int]
        """
        The number of the SCSI or IDE controller itself.
        """
        bus_type: pulumi.Input[str]
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        size_in_mb: pulumi.Input[int]
        """
        The size of the disk in MB.
        """
        unit_number: pulumi.Input[int]
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        iops: NotRequired[pulumi.Input[int]]
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        storage_profile: NotRequired[pulumi.Input[str]]
        """
        Storage profile to override the default one
        """
elif False:
    VappVmOverrideTemplateDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappVmOverrideTemplateDiskArgs:
    def __init__(__self__, *,
                 bus_number: pulumi.Input[int],
                 bus_type: pulumi.Input[str],
                 size_in_mb: pulumi.Input[int],
                 unit_number: pulumi.Input[int],
                 iops: Optional[pulumi.Input[int]] = None,
                 storage_profile: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] bus_number: The number of the SCSI or IDE controller itself.
        :param pulumi.Input[str] bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param pulumi.Input[int] size_in_mb: The size of the disk in MB.
        :param pulumi.Input[int] unit_number: The device number on the SCSI or IDE controller of the disk.
        :param pulumi.Input[int] iops: Specifies the IOPS for the disk. Default is 0.
        :param pulumi.Input[str] storage_profile: Storage profile to override the default one
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "bus_type", bus_type)
        pulumi.set(__self__, "size_in_mb", size_in_mb)
        pulumi.set(__self__, "unit_number", unit_number)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> pulumi.Input[int]:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @bus_number.setter
    def bus_number(self, value: pulumi.Input[int]):
        pulumi.set(self, "bus_number", value)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> pulumi.Input[str]:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> pulumi.Input[int]:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @size_in_mb.setter
    def size_in_mb(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_in_mb", value)

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> pulumi.Input[int]:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")

    @unit_number.setter
    def unit_number(self, value: pulumi.Input[int]):
        pulumi.set(self, "unit_number", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input[str]]:
        """
        Storage profile to override the default one
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_profile", value)


if not MYPY:
    class VappVmSetExtraConfigArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key of the extra configuration item
        """
        value: pulumi.Input[str]
        """
        The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
elif False:
    VappVmSetExtraConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VappVmSetExtraConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key of the extra configuration item
        :param pulumi.Input[str] value: The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VdcGroupParticipatingOrgVdcArgsDict(TypedDict):
        fault_domain_tag: NotRequired[pulumi.Input[str]]
        """
        Represents the fault domain of a given organization VDC
        """
        is_remote_org: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the VDC is local to this VCD site
        """
        network_provider_scope: NotRequired[pulumi.Input[str]]
        """
        Specifies the network provider scope of the VDC
        """
        org_id: NotRequired[pulumi.Input[str]]
        """
        Organization VDC belongs
        """
        org_name: NotRequired[pulumi.Input[str]]
        """
        Organization VDC belongs
        """
        site_id: NotRequired[pulumi.Input[str]]
        """
        Site VDC belongs
        """
        site_name: NotRequired[pulumi.Input[str]]
        """
        Site VDC belongs
        """
        status: NotRequired[pulumi.Input[str]]
        """
        The status that the group can be in (e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED').
        """
        vdc_id: NotRequired[pulumi.Input[str]]
        """
        VDC ID
        """
        vdc_name: NotRequired[pulumi.Input[str]]
        """
        VDC name
        """
elif False:
    VdcGroupParticipatingOrgVdcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VdcGroupParticipatingOrgVdcArgs:
    def __init__(__self__, *,
                 fault_domain_tag: Optional[pulumi.Input[str]] = None,
                 is_remote_org: Optional[pulumi.Input[bool]] = None,
                 network_provider_scope: Optional[pulumi.Input[str]] = None,
                 org_id: Optional[pulumi.Input[str]] = None,
                 org_name: Optional[pulumi.Input[str]] = None,
                 site_id: Optional[pulumi.Input[str]] = None,
                 site_name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 vdc_id: Optional[pulumi.Input[str]] = None,
                 vdc_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] fault_domain_tag: Represents the fault domain of a given organization VDC
        :param pulumi.Input[bool] is_remote_org: Specifies whether the VDC is local to this VCD site
        :param pulumi.Input[str] network_provider_scope: Specifies the network provider scope of the VDC
        :param pulumi.Input[str] org_id: Organization VDC belongs
        :param pulumi.Input[str] org_name: Organization VDC belongs
        :param pulumi.Input[str] site_id: Site VDC belongs
        :param pulumi.Input[str] site_name: Site VDC belongs
        :param pulumi.Input[str] status: The status that the group can be in (e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED').
        :param pulumi.Input[str] vdc_id: VDC ID
        :param pulumi.Input[str] vdc_name: VDC name
        """
        if fault_domain_tag is not None:
            pulumi.set(__self__, "fault_domain_tag", fault_domain_tag)
        if is_remote_org is not None:
            pulumi.set(__self__, "is_remote_org", is_remote_org)
        if network_provider_scope is not None:
            pulumi.set(__self__, "network_provider_scope", network_provider_scope)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)
        if site_name is not None:
            pulumi.set(__self__, "site_name", site_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if vdc_id is not None:
            pulumi.set(__self__, "vdc_id", vdc_id)
        if vdc_name is not None:
            pulumi.set(__self__, "vdc_name", vdc_name)

    @property
    @pulumi.getter(name="faultDomainTag")
    def fault_domain_tag(self) -> Optional[pulumi.Input[str]]:
        """
        Represents the fault domain of a given organization VDC
        """
        return pulumi.get(self, "fault_domain_tag")

    @fault_domain_tag.setter
    def fault_domain_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain_tag", value)

    @property
    @pulumi.getter(name="isRemoteOrg")
    def is_remote_org(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the VDC is local to this VCD site
        """
        return pulumi.get(self, "is_remote_org")

    @is_remote_org.setter
    def is_remote_org(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_remote_org", value)

    @property
    @pulumi.getter(name="networkProviderScope")
    def network_provider_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the network provider scope of the VDC
        """
        return pulumi.get(self, "network_provider_scope")

    @network_provider_scope.setter
    def network_provider_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_provider_scope", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[str]]:
        """
        Organization VDC belongs
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[pulumi.Input[str]]:
        """
        Organization VDC belongs
        """
        return pulumi.get(self, "org_name")

    @org_name.setter
    def org_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_name", value)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[pulumi.Input[str]]:
        """
        Site VDC belongs
        """
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "site_id", value)

    @property
    @pulumi.getter(name="siteName")
    def site_name(self) -> Optional[pulumi.Input[str]]:
        """
        Site VDC belongs
        """
        return pulumi.get(self, "site_name")

    @site_name.setter
    def site_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "site_name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status that the group can be in (e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED').
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="vdcId")
    def vdc_id(self) -> Optional[pulumi.Input[str]]:
        """
        VDC ID
        """
        return pulumi.get(self, "vdc_id")

    @vdc_id.setter
    def vdc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vdc_id", value)

    @property
    @pulumi.getter(name="vdcName")
    def vdc_name(self) -> Optional[pulumi.Input[str]]:
        """
        VDC name
        """
        return pulumi.get(self, "vdc_name")

    @vdc_name.setter
    def vdc_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vdc_name", value)


if not MYPY:
    class VmBootOptionsArgsDict(TypedDict):
        boot_delay: NotRequired[pulumi.Input[int]]
        """
        Number of milliseconds to wait between powering-on and booting the VM
        """
        boot_retry_delay: NotRequired[pulumi.Input[int]]
        """
        Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        """
        boot_retry_enabled: NotRequired[pulumi.Input[bool]]
        """
        If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        """
        efi_secure_boot: NotRequired[pulumi.Input[bool]]
        """
        If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        enter_bios_setup_on_next_boot: NotRequired[pulumi.Input[bool]]
elif False:
    VmBootOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmBootOptionsArgs:
    def __init__(__self__, *,
                 boot_delay: Optional[pulumi.Input[int]] = None,
                 boot_retry_delay: Optional[pulumi.Input[int]] = None,
                 boot_retry_enabled: Optional[pulumi.Input[bool]] = None,
                 efi_secure_boot: Optional[pulumi.Input[bool]] = None,
                 enter_bios_setup_on_next_boot: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] boot_delay: Number of milliseconds to wait between powering-on and booting the VM
        :param pulumi.Input[int] boot_retry_delay: Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        :param pulumi.Input[bool] boot_retry_enabled: If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        :param pulumi.Input[bool] efi_secure_boot: If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        if boot_delay is not None:
            pulumi.set(__self__, "boot_delay", boot_delay)
        if boot_retry_delay is not None:
            pulumi.set(__self__, "boot_retry_delay", boot_retry_delay)
        if boot_retry_enabled is not None:
            pulumi.set(__self__, "boot_retry_enabled", boot_retry_enabled)
        if efi_secure_boot is not None:
            pulumi.set(__self__, "efi_secure_boot", efi_secure_boot)
        if enter_bios_setup_on_next_boot is not None:
            pulumi.set(__self__, "enter_bios_setup_on_next_boot", enter_bios_setup_on_next_boot)

    @property
    @pulumi.getter(name="bootDelay")
    def boot_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Number of milliseconds to wait between powering-on and booting the VM
        """
        return pulumi.get(self, "boot_delay")

    @boot_delay.setter
    def boot_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_delay", value)

    @property
    @pulumi.getter(name="bootRetryDelay")
    def boot_retry_delay(self) -> Optional[pulumi.Input[int]]:
        """
        Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        """
        return pulumi.get(self, "boot_retry_delay")

    @boot_retry_delay.setter
    def boot_retry_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_retry_delay", value)

    @property
    @pulumi.getter(name="bootRetryEnabled")
    def boot_retry_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        """
        return pulumi.get(self, "boot_retry_enabled")

    @boot_retry_enabled.setter
    def boot_retry_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boot_retry_enabled", value)

    @property
    @pulumi.getter(name="efiSecureBoot")
    def efi_secure_boot(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        return pulumi.get(self, "efi_secure_boot")

    @efi_secure_boot.setter
    def efi_secure_boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "efi_secure_boot", value)

    @property
    @pulumi.getter(name="enterBiosSetupOnNextBoot")
    def enter_bios_setup_on_next_boot(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enter_bios_setup_on_next_boot")

    @enter_bios_setup_on_next_boot.setter
    def enter_bios_setup_on_next_boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enter_bios_setup_on_next_boot", value)


if not MYPY:
    class VmCustomizationArgsDict(TypedDict):
        admin_password: NotRequired[pulumi.Input[str]]
        """
        Manually specify admin password
        """
        allow_local_admin_password: NotRequired[pulumi.Input[bool]]
        """
        Allow local administrator password
        """
        auto_generate_password: NotRequired[pulumi.Input[bool]]
        """
        Auto generate password
        """
        change_sid: NotRequired[pulumi.Input[bool]]
        """
        'true' value will change SID. Applicable only for Windows VMs
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        """
        force: NotRequired[pulumi.Input[bool]]
        """
        'true' value will cause the VM to reboot on every 'apply' operation
        """
        initscript: NotRequired[pulumi.Input[str]]
        """
        Script to run on initial boot or with customization.force=true set
        """
        join_domain: NotRequired[pulumi.Input[bool]]
        """
        Enable this VM to join a domain
        """
        join_domain_account_ou: NotRequired[pulumi.Input[str]]
        """
        Account organizational unit for domain name join
        """
        join_domain_name: NotRequired[pulumi.Input[str]]
        """
        Custom domain name for join
        """
        join_domain_password: NotRequired[pulumi.Input[str]]
        """
        Password for custom domain name join
        """
        join_domain_user: NotRequired[pulumi.Input[str]]
        """
        Username for custom domain name join
        """
        join_org_domain: NotRequired[pulumi.Input[bool]]
        """
        Use organization's domain for joining
        """
        must_change_password_on_first_login: NotRequired[pulumi.Input[bool]]
        """
        Require Administrator to change password on first login
        """
        number_of_auto_logons: NotRequired[pulumi.Input[int]]
        """
        Number of times to log on automatically. '0' - disabled.
        """
elif False:
    VmCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCustomizationArgs:
    def __init__(__self__, *,
                 admin_password: Optional[pulumi.Input[str]] = None,
                 allow_local_admin_password: Optional[pulumi.Input[bool]] = None,
                 auto_generate_password: Optional[pulumi.Input[bool]] = None,
                 change_sid: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 force: Optional[pulumi.Input[bool]] = None,
                 initscript: Optional[pulumi.Input[str]] = None,
                 join_domain: Optional[pulumi.Input[bool]] = None,
                 join_domain_account_ou: Optional[pulumi.Input[str]] = None,
                 join_domain_name: Optional[pulumi.Input[str]] = None,
                 join_domain_password: Optional[pulumi.Input[str]] = None,
                 join_domain_user: Optional[pulumi.Input[str]] = None,
                 join_org_domain: Optional[pulumi.Input[bool]] = None,
                 must_change_password_on_first_login: Optional[pulumi.Input[bool]] = None,
                 number_of_auto_logons: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] admin_password: Manually specify admin password
        :param pulumi.Input[bool] allow_local_admin_password: Allow local administrator password
        :param pulumi.Input[bool] auto_generate_password: Auto generate password
        :param pulumi.Input[bool] change_sid: 'true' value will change SID. Applicable only for Windows VMs
        :param pulumi.Input[bool] enabled: 'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        :param pulumi.Input[bool] force: 'true' value will cause the VM to reboot on every 'apply' operation
        :param pulumi.Input[str] initscript: Script to run on initial boot or with customization.force=true set
        :param pulumi.Input[bool] join_domain: Enable this VM to join a domain
        :param pulumi.Input[str] join_domain_account_ou: Account organizational unit for domain name join
        :param pulumi.Input[str] join_domain_name: Custom domain name for join
        :param pulumi.Input[str] join_domain_password: Password for custom domain name join
        :param pulumi.Input[str] join_domain_user: Username for custom domain name join
        :param pulumi.Input[bool] join_org_domain: Use organization's domain for joining
        :param pulumi.Input[bool] must_change_password_on_first_login: Require Administrator to change password on first login
        :param pulumi.Input[int] number_of_auto_logons: Number of times to log on automatically. '0' - disabled.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if allow_local_admin_password is not None:
            pulumi.set(__self__, "allow_local_admin_password", allow_local_admin_password)
        if auto_generate_password is not None:
            pulumi.set(__self__, "auto_generate_password", auto_generate_password)
        if change_sid is not None:
            pulumi.set(__self__, "change_sid", change_sid)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if initscript is not None:
            pulumi.set(__self__, "initscript", initscript)
        if join_domain is not None:
            pulumi.set(__self__, "join_domain", join_domain)
        if join_domain_account_ou is not None:
            pulumi.set(__self__, "join_domain_account_ou", join_domain_account_ou)
        if join_domain_name is not None:
            pulumi.set(__self__, "join_domain_name", join_domain_name)
        if join_domain_password is not None:
            pulumi.set(__self__, "join_domain_password", join_domain_password)
        if join_domain_user is not None:
            pulumi.set(__self__, "join_domain_user", join_domain_user)
        if join_org_domain is not None:
            pulumi.set(__self__, "join_org_domain", join_org_domain)
        if must_change_password_on_first_login is not None:
            pulumi.set(__self__, "must_change_password_on_first_login", must_change_password_on_first_login)
        if number_of_auto_logons is not None:
            pulumi.set(__self__, "number_of_auto_logons", number_of_auto_logons)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[pulumi.Input[str]]:
        """
        Manually specify admin password
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="allowLocalAdminPassword")
    def allow_local_admin_password(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow local administrator password
        """
        return pulumi.get(self, "allow_local_admin_password")

    @allow_local_admin_password.setter
    def allow_local_admin_password(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_local_admin_password", value)

    @property
    @pulumi.getter(name="autoGeneratePassword")
    def auto_generate_password(self) -> Optional[pulumi.Input[bool]]:
        """
        Auto generate password
        """
        return pulumi.get(self, "auto_generate_password")

    @auto_generate_password.setter
    def auto_generate_password(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_generate_password", value)

    @property
    @pulumi.getter(name="changeSid")
    def change_sid(self) -> Optional[pulumi.Input[bool]]:
        """
        'true' value will change SID. Applicable only for Windows VMs
        """
        return pulumi.get(self, "change_sid")

    @change_sid.setter
    def change_sid(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "change_sid", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[bool]]:
        """
        'true' value will cause the VM to reboot on every 'apply' operation
        """
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force", value)

    @property
    @pulumi.getter
    def initscript(self) -> Optional[pulumi.Input[str]]:
        """
        Script to run on initial boot or with customization.force=true set
        """
        return pulumi.get(self, "initscript")

    @initscript.setter
    def initscript(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "initscript", value)

    @property
    @pulumi.getter(name="joinDomain")
    def join_domain(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable this VM to join a domain
        """
        return pulumi.get(self, "join_domain")

    @join_domain.setter
    def join_domain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "join_domain", value)

    @property
    @pulumi.getter(name="joinDomainAccountOu")
    def join_domain_account_ou(self) -> Optional[pulumi.Input[str]]:
        """
        Account organizational unit for domain name join
        """
        return pulumi.get(self, "join_domain_account_ou")

    @join_domain_account_ou.setter
    def join_domain_account_ou(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_domain_account_ou", value)

    @property
    @pulumi.getter(name="joinDomainName")
    def join_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Custom domain name for join
        """
        return pulumi.get(self, "join_domain_name")

    @join_domain_name.setter
    def join_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_domain_name", value)

    @property
    @pulumi.getter(name="joinDomainPassword")
    def join_domain_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for custom domain name join
        """
        return pulumi.get(self, "join_domain_password")

    @join_domain_password.setter
    def join_domain_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_domain_password", value)

    @property
    @pulumi.getter(name="joinDomainUser")
    def join_domain_user(self) -> Optional[pulumi.Input[str]]:
        """
        Username for custom domain name join
        """
        return pulumi.get(self, "join_domain_user")

    @join_domain_user.setter
    def join_domain_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_domain_user", value)

    @property
    @pulumi.getter(name="joinOrgDomain")
    def join_org_domain(self) -> Optional[pulumi.Input[bool]]:
        """
        Use organization's domain for joining
        """
        return pulumi.get(self, "join_org_domain")

    @join_org_domain.setter
    def join_org_domain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "join_org_domain", value)

    @property
    @pulumi.getter(name="mustChangePasswordOnFirstLogin")
    def must_change_password_on_first_login(self) -> Optional[pulumi.Input[bool]]:
        """
        Require Administrator to change password on first login
        """
        return pulumi.get(self, "must_change_password_on_first_login")

    @must_change_password_on_first_login.setter
    def must_change_password_on_first_login(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "must_change_password_on_first_login", value)

    @property
    @pulumi.getter(name="numberOfAutoLogons")
    def number_of_auto_logons(self) -> Optional[pulumi.Input[int]]:
        """
        Number of times to log on automatically. '0' - disabled.
        """
        return pulumi.get(self, "number_of_auto_logons")

    @number_of_auto_logons.setter
    def number_of_auto_logons(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_auto_logons", value)


if not MYPY:
    class VmDiskArgsDict(TypedDict):
        bus_number: pulumi.Input[str]
        """
        Bus number on which to place the disk controller
        """
        name: pulumi.Input[str]
        """
        Independent disk name
        """
        unit_number: pulumi.Input[str]
        """
        Unit number (slot) on the bus specified by BusNumber
        """
        size_in_mb: NotRequired[pulumi.Input[int]]
        """
        The size of the disk in MB.
        """
elif False:
    VmDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmDiskArgs:
    def __init__(__self__, *,
                 bus_number: pulumi.Input[str],
                 name: pulumi.Input[str],
                 unit_number: pulumi.Input[str],
                 size_in_mb: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] bus_number: Bus number on which to place the disk controller
        :param pulumi.Input[str] name: Independent disk name
        :param pulumi.Input[str] unit_number: Unit number (slot) on the bus specified by BusNumber
        :param pulumi.Input[int] size_in_mb: The size of the disk in MB.
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "unit_number", unit_number)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> pulumi.Input[str]:
        """
        Bus number on which to place the disk controller
        """
        return pulumi.get(self, "bus_number")

    @bus_number.setter
    def bus_number(self, value: pulumi.Input[str]):
        pulumi.set(self, "bus_number", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Independent disk name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> pulumi.Input[str]:
        """
        Unit number (slot) on the bus specified by BusNumber
        """
        return pulumi.get(self, "unit_number")

    @unit_number.setter
    def unit_number(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit_number", value)

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @size_in_mb.setter
    def size_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_in_mb", value)


if not MYPY:
    class VmExtraConfigArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The key of the extra configuration item
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Whether the extra configuration item is required
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the extra configuration item
        """
elif False:
    VmExtraConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmExtraConfigArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of the extra configuration item
        :param pulumi.Input[bool] required: Whether the extra configuration item is required
        :param pulumi.Input[str] value: The value of the extra configuration item
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the extra configuration item is required
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the extra configuration item
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmInternalDiskArgsDict(TypedDict):
        bus_number: NotRequired[pulumi.Input[int]]
        """
        The number of the SCSI or IDE controller itself.
        """
        bus_type: NotRequired[pulumi.Input[str]]
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        disk_id: NotRequired[pulumi.Input[str]]
        """
        The disk ID.
        """
        iops: NotRequired[pulumi.Input[int]]
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        size_in_mb: NotRequired[pulumi.Input[int]]
        """
        The size of the disk in MB.
        """
        storage_profile: NotRequired[pulumi.Input[str]]
        """
        Storage profile to override the VM default one
        """
        thin_provisioned: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the disk storage is pre-allocated or allocated on demand.
        """
        unit_number: NotRequired[pulumi.Input[int]]
        """
        The device number on the SCSI or IDE controller of the disk.
        """
elif False:
    VmInternalDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmInternalDiskArgs:
    def __init__(__self__, *,
                 bus_number: Optional[pulumi.Input[int]] = None,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 disk_id: Optional[pulumi.Input[str]] = None,
                 iops: Optional[pulumi.Input[int]] = None,
                 size_in_mb: Optional[pulumi.Input[int]] = None,
                 storage_profile: Optional[pulumi.Input[str]] = None,
                 thin_provisioned: Optional[pulumi.Input[bool]] = None,
                 unit_number: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] bus_number: The number of the SCSI or IDE controller itself.
        :param pulumi.Input[str] bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param pulumi.Input[str] disk_id: The disk ID.
        :param pulumi.Input[int] iops: Specifies the IOPS for the disk. Default is 0.
        :param pulumi.Input[int] size_in_mb: The size of the disk in MB.
        :param pulumi.Input[str] storage_profile: Storage profile to override the VM default one
        :param pulumi.Input[bool] thin_provisioned: Specifies whether the disk storage is pre-allocated or allocated on demand.
        :param pulumi.Input[int] unit_number: The device number on the SCSI or IDE controller of the disk.
        """
        if bus_number is not None:
            pulumi.set(__self__, "bus_number", bus_number)
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if thin_provisioned is not None:
            pulumi.set(__self__, "thin_provisioned", thin_provisioned)
        if unit_number is not None:
            pulumi.set(__self__, "unit_number", unit_number)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> Optional[pulumi.Input[int]]:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @bus_number.setter
    def bus_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bus_number", value)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[pulumi.Input[str]]:
        """
        The disk ID.
        """
        return pulumi.get(self, "disk_id")

    @disk_id.setter
    def disk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_id", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @size_in_mb.setter
    def size_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_in_mb", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input[str]]:
        """
        Storage profile to override the VM default one
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_profile", value)

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the disk storage is pre-allocated or allocated on demand.
        """
        return pulumi.get(self, "thin_provisioned")

    @thin_provisioned.setter
    def thin_provisioned(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "thin_provisioned", value)

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> Optional[pulumi.Input[int]]:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")

    @unit_number.setter
    def unit_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unit_number", value)


if not MYPY:
    class VmMetadataEntryArgsDict(TypedDict):
        is_system: NotRequired[pulumi.Input[bool]]
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        key: NotRequired[pulumi.Input[str]]
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        user_access: NotRequired[pulumi.Input[str]]
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
elif False:
    VmMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmMetadataEntryArgs:
    def __init__(__self__, *,
                 is_system: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_access: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param pulumi.Input[str] key: Key of this metadata entry. Required if the metadata entry is not empty
        :param pulumi.Input[str] type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param pulumi.Input[str] user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param pulumi.Input[str] value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[pulumi.Input[bool]]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[pulumi.Input[str]]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @user_access.setter
    def user_access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_access", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmNetworkArgsDict(TypedDict):
        ip_allocation_mode: pulumi.Input[str]
        """
        IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        type: pulumi.Input[str]
        """
        Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        """
        adapter_type: NotRequired[pulumi.Input[str]]
        """
        Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        """
        connected: NotRequired[pulumi.Input[bool]]
        """
        It defines if NIC is connected or not.
        """
        ip: NotRequired[pulumi.Input[str]]
        """
        IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        is_primary: NotRequired[pulumi.Input[bool]]
        """
        Set to true if network interface should be primary. First network card in the list will be primary by default
        """
        mac: NotRequired[pulumi.Input[str]]
        """
        Mac address of network interface
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the network this VM should connect to. Always required except for `type` `NONE`
        """
        secondary_ip: NotRequired[pulumi.Input[str]]
        """
        Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        secondary_ip_allocation_mode: NotRequired[pulumi.Input[str]]
        """
        Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
elif False:
    VmNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNetworkArgs:
    def __init__(__self__, *,
                 ip_allocation_mode: pulumi.Input[str],
                 type: pulumi.Input[str],
                 adapter_type: Optional[pulumi.Input[str]] = None,
                 connected: Optional[pulumi.Input[bool]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 is_primary: Optional[pulumi.Input[bool]] = None,
                 mac: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 secondary_ip: Optional[pulumi.Input[str]] = None,
                 secondary_ip_allocation_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_allocation_mode: IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        :param pulumi.Input[str] type: Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        :param pulumi.Input[str] adapter_type: Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        :param pulumi.Input[bool] connected: It defines if NIC is connected or not.
        :param pulumi.Input[str] ip: IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param pulumi.Input[bool] is_primary: Set to true if network interface should be primary. First network card in the list will be primary by default
        :param pulumi.Input[str] mac: Mac address of network interface
        :param pulumi.Input[str] name: Name of the network this VM should connect to. Always required except for `type` `NONE`
        :param pulumi.Input[str] secondary_ip: Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param pulumi.Input[str] secondary_ip_allocation_mode: Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        pulumi.set(__self__, "ip_allocation_mode", ip_allocation_mode)
        pulumi.set(__self__, "type", type)
        if adapter_type is not None:
            pulumi.set(__self__, "adapter_type", adapter_type)
        if connected is not None:
            pulumi.set(__self__, "connected", connected)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secondary_ip is not None:
            pulumi.set(__self__, "secondary_ip", secondary_ip)
        if secondary_ip_allocation_mode is not None:
            pulumi.set(__self__, "secondary_ip_allocation_mode", secondary_ip_allocation_mode)

    @property
    @pulumi.getter(name="ipAllocationMode")
    def ip_allocation_mode(self) -> pulumi.Input[str]:
        """
        IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "ip_allocation_mode")

    @ip_allocation_mode.setter
    def ip_allocation_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_allocation_mode", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> Optional[pulumi.Input[str]]:
        """
        Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        """
        return pulumi.get(self, "adapter_type")

    @adapter_type.setter
    def adapter_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adapter_type", value)

    @property
    @pulumi.getter
    def connected(self) -> Optional[pulumi.Input[bool]]:
        """
        It defines if NIC is connected or not.
        """
        return pulumi.get(self, "connected")

    @connected.setter
    def connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "connected", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to true if network interface should be primary. First network card in the list will be primary by default
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        """
        Mac address of network interface
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the network this VM should connect to. Always required except for `type` `NONE`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="secondaryIp")
    def secondary_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "secondary_ip")

    @secondary_ip.setter
    def secondary_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ip", value)

    @property
    @pulumi.getter(name="secondaryIpAllocationMode")
    def secondary_ip_allocation_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "secondary_ip_allocation_mode")

    @secondary_ip_allocation_mode.setter
    def secondary_ip_allocation_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secondary_ip_allocation_mode", value)


if not MYPY:
    class VmOverrideTemplateDiskArgsDict(TypedDict):
        bus_number: pulumi.Input[int]
        """
        The number of the SCSI or IDE controller itself.
        """
        bus_type: pulumi.Input[str]
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        size_in_mb: pulumi.Input[int]
        """
        The size of the disk in MB.
        """
        unit_number: pulumi.Input[int]
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        iops: NotRequired[pulumi.Input[int]]
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        storage_profile: NotRequired[pulumi.Input[str]]
        """
        Storage profile to override the VM default one
        """
elif False:
    VmOverrideTemplateDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmOverrideTemplateDiskArgs:
    def __init__(__self__, *,
                 bus_number: pulumi.Input[int],
                 bus_type: pulumi.Input[str],
                 size_in_mb: pulumi.Input[int],
                 unit_number: pulumi.Input[int],
                 iops: Optional[pulumi.Input[int]] = None,
                 storage_profile: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] bus_number: The number of the SCSI or IDE controller itself.
        :param pulumi.Input[str] bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param pulumi.Input[int] size_in_mb: The size of the disk in MB.
        :param pulumi.Input[int] unit_number: The device number on the SCSI or IDE controller of the disk.
        :param pulumi.Input[int] iops: Specifies the IOPS for the disk. Default is 0.
        :param pulumi.Input[str] storage_profile: Storage profile to override the VM default one
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "bus_type", bus_type)
        pulumi.set(__self__, "size_in_mb", size_in_mb)
        pulumi.set(__self__, "unit_number", unit_number)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> pulumi.Input[int]:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @bus_number.setter
    def bus_number(self, value: pulumi.Input[int]):
        pulumi.set(self, "bus_number", value)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> pulumi.Input[str]:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> pulumi.Input[int]:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @size_in_mb.setter
    def size_in_mb(self, value: pulumi.Input[int]):
        pulumi.set(self, "size_in_mb", value)

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> pulumi.Input[int]:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")

    @unit_number.setter
    def unit_number(self, value: pulumi.Input[int]):
        pulumi.set(self, "unit_number", value)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[pulumi.Input[str]]:
        """
        Storage profile to override the VM default one
        """
        return pulumi.get(self, "storage_profile")

    @storage_profile.setter
    def storage_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_profile", value)


if not MYPY:
    class VmSetExtraConfigArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key of the extra configuration item
        """
        value: pulumi.Input[str]
        """
        The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
elif False:
    VmSetExtraConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmSetExtraConfigArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key of the extra configuration item
        :param pulumi.Input[str] value: The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmSizingPolicyCpuArgsDict(TypedDict):
        cores_per_socket: NotRequired[pulumi.Input[str]]
        """
        The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        """
        count: NotRequired[pulumi.Input[str]]
        """
        Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        """
        limit_in_mhz: NotRequired[pulumi.Input[str]]
        """
        Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        """
        reservation_guarantee: NotRequired[pulumi.Input[str]]
        """
        Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        """
        shares: NotRequired[pulumi.Input[str]]
        """
        Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        speed_in_mhz: NotRequired[pulumi.Input[str]]
        """
        Defines the vCPU speed of a core in MHz.
        """
elif False:
    VmSizingPolicyCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmSizingPolicyCpuArgs:
    def __init__(__self__, *,
                 cores_per_socket: Optional[pulumi.Input[str]] = None,
                 count: Optional[pulumi.Input[str]] = None,
                 limit_in_mhz: Optional[pulumi.Input[str]] = None,
                 reservation_guarantee: Optional[pulumi.Input[str]] = None,
                 shares: Optional[pulumi.Input[str]] = None,
                 speed_in_mhz: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cores_per_socket: The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        :param pulumi.Input[str] count: Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        :param pulumi.Input[str] limit_in_mhz: Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        :param pulumi.Input[str] reservation_guarantee: Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        :param pulumi.Input[str] shares: Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param pulumi.Input[str] speed_in_mhz: Defines the vCPU speed of a core in MHz.
        """
        if cores_per_socket is not None:
            pulumi.set(__self__, "cores_per_socket", cores_per_socket)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if limit_in_mhz is not None:
            pulumi.set(__self__, "limit_in_mhz", limit_in_mhz)
        if reservation_guarantee is not None:
            pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        if shares is not None:
            pulumi.set(__self__, "shares", shares)
        if speed_in_mhz is not None:
            pulumi.set(__self__, "speed_in_mhz", speed_in_mhz)

    @property
    @pulumi.getter(name="coresPerSocket")
    def cores_per_socket(self) -> Optional[pulumi.Input[str]]:
        """
        The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        """
        return pulumi.get(self, "cores_per_socket")

    @cores_per_socket.setter
    def cores_per_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cores_per_socket", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="limitInMhz")
    def limit_in_mhz(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        """
        return pulumi.get(self, "limit_in_mhz")

    @limit_in_mhz.setter
    def limit_in_mhz(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limit_in_mhz", value)

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> Optional[pulumi.Input[str]]:
        """
        Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @reservation_guarantee.setter
    def reservation_guarantee(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reservation_guarantee", value)

    @property
    @pulumi.getter
    def shares(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @shares.setter
    def shares(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shares", value)

    @property
    @pulumi.getter(name="speedInMhz")
    def speed_in_mhz(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the vCPU speed of a core in MHz.
        """
        return pulumi.get(self, "speed_in_mhz")

    @speed_in_mhz.setter
    def speed_in_mhz(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed_in_mhz", value)


if not MYPY:
    class VmSizingPolicyMemoryArgsDict(TypedDict):
        limit_in_mb: NotRequired[pulumi.Input[str]]
        """
        Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        """
        reservation_guarantee: NotRequired[pulumi.Input[str]]
        """
        Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        """
        shares: NotRequired[pulumi.Input[str]]
        """
        Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        size_in_mb: NotRequired[pulumi.Input[str]]
        """
        Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
elif False:
    VmSizingPolicyMemoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmSizingPolicyMemoryArgs:
    def __init__(__self__, *,
                 limit_in_mb: Optional[pulumi.Input[str]] = None,
                 reservation_guarantee: Optional[pulumi.Input[str]] = None,
                 shares: Optional[pulumi.Input[str]] = None,
                 size_in_mb: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] limit_in_mb: Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        :param pulumi.Input[str] reservation_guarantee: Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        :param pulumi.Input[str] shares: Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param pulumi.Input[str] size_in_mb: Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        if limit_in_mb is not None:
            pulumi.set(__self__, "limit_in_mb", limit_in_mb)
        if reservation_guarantee is not None:
            pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        if shares is not None:
            pulumi.set(__self__, "shares", shares)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="limitInMb")
    def limit_in_mb(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        """
        return pulumi.get(self, "limit_in_mb")

    @limit_in_mb.setter
    def limit_in_mb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limit_in_mb", value)

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @reservation_guarantee.setter
    def reservation_guarantee(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reservation_guarantee", value)

    @property
    @pulumi.getter
    def shares(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @shares.setter
    def shares(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shares", value)

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        return pulumi.get(self, "size_in_mb")

    @size_in_mb.setter
    def size_in_mb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_in_mb", value)


if not MYPY:
    class VmVgpuPolicyCpuArgsDict(TypedDict):
        cores_per_socket: NotRequired[pulumi.Input[str]]
        """
        The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        """
        count: NotRequired[pulumi.Input[str]]
        """
        Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        """
        limit_in_mhz: NotRequired[pulumi.Input[str]]
        """
        Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        """
        reservation_guarantee: NotRequired[pulumi.Input[str]]
        """
        Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        """
        shares: NotRequired[pulumi.Input[str]]
        """
        Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        speed_in_mhz: NotRequired[pulumi.Input[str]]
        """
        Defines the vCPU speed of a core in MHz.
        """
elif False:
    VmVgpuPolicyCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmVgpuPolicyCpuArgs:
    def __init__(__self__, *,
                 cores_per_socket: Optional[pulumi.Input[str]] = None,
                 count: Optional[pulumi.Input[str]] = None,
                 limit_in_mhz: Optional[pulumi.Input[str]] = None,
                 reservation_guarantee: Optional[pulumi.Input[str]] = None,
                 shares: Optional[pulumi.Input[str]] = None,
                 speed_in_mhz: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cores_per_socket: The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        :param pulumi.Input[str] count: Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        :param pulumi.Input[str] limit_in_mhz: Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        :param pulumi.Input[str] reservation_guarantee: Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        :param pulumi.Input[str] shares: Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param pulumi.Input[str] speed_in_mhz: Defines the vCPU speed of a core in MHz.
        """
        if cores_per_socket is not None:
            pulumi.set(__self__, "cores_per_socket", cores_per_socket)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if limit_in_mhz is not None:
            pulumi.set(__self__, "limit_in_mhz", limit_in_mhz)
        if reservation_guarantee is not None:
            pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        if shares is not None:
            pulumi.set(__self__, "shares", shares)
        if speed_in_mhz is not None:
            pulumi.set(__self__, "speed_in_mhz", speed_in_mhz)

    @property
    @pulumi.getter(name="coresPerSocket")
    def cores_per_socket(self) -> Optional[pulumi.Input[str]]:
        """
        The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        """
        return pulumi.get(self, "cores_per_socket")

    @cores_per_socket.setter
    def cores_per_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cores_per_socket", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="limitInMhz")
    def limit_in_mhz(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        """
        return pulumi.get(self, "limit_in_mhz")

    @limit_in_mhz.setter
    def limit_in_mhz(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limit_in_mhz", value)

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> Optional[pulumi.Input[str]]:
        """
        Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @reservation_guarantee.setter
    def reservation_guarantee(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reservation_guarantee", value)

    @property
    @pulumi.getter
    def shares(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @shares.setter
    def shares(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shares", value)

    @property
    @pulumi.getter(name="speedInMhz")
    def speed_in_mhz(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the vCPU speed of a core in MHz.
        """
        return pulumi.get(self, "speed_in_mhz")

    @speed_in_mhz.setter
    def speed_in_mhz(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "speed_in_mhz", value)


if not MYPY:
    class VmVgpuPolicyMemoryArgsDict(TypedDict):
        limit_in_mb: NotRequired[pulumi.Input[str]]
        """
        Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        """
        reservation_guarantee: NotRequired[pulumi.Input[str]]
        """
        Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        """
        shares: NotRequired[pulumi.Input[str]]
        """
        Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        size_in_mb: NotRequired[pulumi.Input[str]]
        """
        Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
elif False:
    VmVgpuPolicyMemoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmVgpuPolicyMemoryArgs:
    def __init__(__self__, *,
                 limit_in_mb: Optional[pulumi.Input[str]] = None,
                 reservation_guarantee: Optional[pulumi.Input[str]] = None,
                 shares: Optional[pulumi.Input[str]] = None,
                 size_in_mb: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] limit_in_mb: Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        :param pulumi.Input[str] reservation_guarantee: Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        :param pulumi.Input[str] shares: Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param pulumi.Input[str] size_in_mb: Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        if limit_in_mb is not None:
            pulumi.set(__self__, "limit_in_mb", limit_in_mb)
        if reservation_guarantee is not None:
            pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        if shares is not None:
            pulumi.set(__self__, "shares", shares)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="limitInMb")
    def limit_in_mb(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        """
        return pulumi.get(self, "limit_in_mb")

    @limit_in_mb.setter
    def limit_in_mb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limit_in_mb", value)

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @reservation_guarantee.setter
    def reservation_guarantee(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reservation_guarantee", value)

    @property
    @pulumi.getter
    def shares(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @shares.setter
    def shares(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shares", value)

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        return pulumi.get(self, "size_in_mb")

    @size_in_mb.setter
    def size_in_mb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_in_mb", value)


if not MYPY:
    class VmVgpuPolicyProviderVdcScopeArgsDict(TypedDict):
        provider_vdc_id: pulumi.Input[str]
        """
        The ID of the provider VDC that should be in the scope.
        """
        cluster_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of vCenter cluster names on which the provider VDC is hosted. 
        If none are provided, the provider attempts to find one automatically. Can be fetched using `data.vcd_resource_pool.cluster_moref` attribute.
        """
        vm_group_id: NotRequired[pulumi.Input[str]]
        """
        Optional identifier for a VM group within the provider VDC scope.
        """
elif False:
    VmVgpuPolicyProviderVdcScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmVgpuPolicyProviderVdcScopeArgs:
    def __init__(__self__, *,
                 provider_vdc_id: pulumi.Input[str],
                 cluster_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vm_group_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] provider_vdc_id: The ID of the provider VDC that should be in the scope.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cluster_names: A set of vCenter cluster names on which the provider VDC is hosted. 
               If none are provided, the provider attempts to find one automatically. Can be fetched using `data.vcd_resource_pool.cluster_moref` attribute.
        :param pulumi.Input[str] vm_group_id: Optional identifier for a VM group within the provider VDC scope.
        """
        pulumi.set(__self__, "provider_vdc_id", provider_vdc_id)
        if cluster_names is not None:
            pulumi.set(__self__, "cluster_names", cluster_names)
        if vm_group_id is not None:
            pulumi.set(__self__, "vm_group_id", vm_group_id)

    @property
    @pulumi.getter(name="providerVdcId")
    def provider_vdc_id(self) -> pulumi.Input[str]:
        """
        The ID of the provider VDC that should be in the scope.
        """
        return pulumi.get(self, "provider_vdc_id")

    @provider_vdc_id.setter
    def provider_vdc_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider_vdc_id", value)

    @property
    @pulumi.getter(name="clusterNames")
    def cluster_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of vCenter cluster names on which the provider VDC is hosted. 
        If none are provided, the provider attempts to find one automatically. Can be fetched using `data.vcd_resource_pool.cluster_moref` attribute.
        """
        return pulumi.get(self, "cluster_names")

    @cluster_names.setter
    def cluster_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cluster_names", value)

    @property
    @pulumi.getter(name="vmGroupId")
    def vm_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional identifier for a VM group within the provider VDC scope.
        """
        return pulumi.get(self, "vm_group_id")

    @vm_group_id.setter
    def vm_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_group_id", value)


if not MYPY:
    class VmVgpuPolicyVgpuProfileArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        Specifies the number of vGPU profiles. Must be at least 1.
        """
        id: pulumi.Input[str]
        """
        The identifier of the vGPU profile.
        """
elif False:
    VmVgpuPolicyVgpuProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmVgpuPolicyVgpuProfileArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: Specifies the number of vGPU profiles. Must be at least 1.
        :param pulumi.Input[str] id: The identifier of the vGPU profile.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        Specifies the number of vGPU profiles. Must be at least 1.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The identifier of the vGPU profile.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetCatalogFilterArgsDict(TypedDict):
        date: NotRequired[str]
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        earliest: NotRequired[bool]
        """
        Retrieves the oldest item
        """
        latest: NotRequired[bool]
        """
        Retrieves the newest item
        """
        metadatas: NotRequired[Sequence['GetCatalogFilterMetadataArgsDict']]
        """
        (Deprecated; *v3.6+*) Use `metadata_entry` instead. Key value map of metadata.
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetCatalogFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogFilterArgs:
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['GetCatalogFilterMetadataArgs']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetCatalogFilterMetadataArgs'] metadatas: (Deprecated; *v3.6+*) Use `metadata_entry` instead. Key value map of metadata.
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[str]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @earliest.setter
    def earliest(self, value: Optional[bool]):
        pulumi.set(self, "earliest", value)

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @latest.setter
    def latest(self, value: Optional[bool]):
        pulumi.set(self, "latest", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['GetCatalogFilterMetadataArgs']]:
        """
        (Deprecated; *v3.6+*) Use `metadata_entry` instead. Key value map of metadata.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[Sequence['GetCatalogFilterMetadataArgs']]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetCatalogFilterMetadataArgsDict(TypedDict):
        key: str
        """
        Metadata key (field name)
        """
        value: str
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        is_system: NotRequired[bool]
        """
        True if is a metadata@SYSTEM key
        """
        type: NotRequired[str]
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        use_api_search: NotRequired[bool]
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
elif False:
    GetCatalogFilterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogFilterMetadataArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[bool]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")

    @use_api_search.setter
    def use_api_search(self, value: Optional[bool]):
        pulumi.set(self, "use_api_search", value)


if not MYPY:
    class GetCatalogItemFilterArgsDict(TypedDict):
        date: NotRequired[str]
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        earliest: NotRequired[bool]
        """
        Retrieves the oldest item
        """
        latest: NotRequired[bool]
        """
        Retrieves the newest item
        """
        metadatas: NotRequired[Sequence['GetCatalogItemFilterMetadataArgsDict']]
        """
        Key value map of metadata assigned to the associated vApp template.
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetCatalogItemFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogItemFilterArgs:
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['GetCatalogItemFilterMetadataArgs']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetCatalogItemFilterMetadataArgs'] metadatas: Key value map of metadata assigned to the associated vApp template.
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[str]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @earliest.setter
    def earliest(self, value: Optional[bool]):
        pulumi.set(self, "earliest", value)

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @latest.setter
    def latest(self, value: Optional[bool]):
        pulumi.set(self, "latest", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['GetCatalogItemFilterMetadataArgs']]:
        """
        Key value map of metadata assigned to the associated vApp template.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[Sequence['GetCatalogItemFilterMetadataArgs']]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetCatalogItemFilterMetadataArgsDict(TypedDict):
        key: str
        """
        Metadata key (field name)
        """
        value: str
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        is_system: NotRequired[bool]
        """
        True if is a metadata@SYSTEM key
        """
        type: NotRequired[str]
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        use_api_search: NotRequired[bool]
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
elif False:
    GetCatalogItemFilterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogItemFilterMetadataArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[bool]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")

    @use_api_search.setter
    def use_api_search(self, value: Optional[bool]):
        pulumi.set(self, "use_api_search", value)


if not MYPY:
    class GetCatalogMediaFilterArgsDict(TypedDict):
        date: NotRequired[str]
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        earliest: NotRequired[bool]
        """
        Retrieves the oldest item
        """
        latest: NotRequired[bool]
        """
        Retrieves the newest item
        """
        metadatas: NotRequired[Sequence['GetCatalogMediaFilterMetadataArgsDict']]
        """
        metadata filter
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetCatalogMediaFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogMediaFilterArgs:
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['GetCatalogMediaFilterMetadataArgs']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetCatalogMediaFilterMetadataArgs'] metadatas: metadata filter
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[str]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @earliest.setter
    def earliest(self, value: Optional[bool]):
        pulumi.set(self, "earliest", value)

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @latest.setter
    def latest(self, value: Optional[bool]):
        pulumi.set(self, "latest", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['GetCatalogMediaFilterMetadataArgs']]:
        """
        metadata filter
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[Sequence['GetCatalogMediaFilterMetadataArgs']]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetCatalogMediaFilterMetadataArgsDict(TypedDict):
        key: str
        """
        Metadata key (field name)
        """
        value: str
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        is_system: NotRequired[bool]
        """
        True if is a metadata@SYSTEM key
        """
        type: NotRequired[str]
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        use_api_search: NotRequired[bool]
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
elif False:
    GetCatalogMediaFilterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogMediaFilterMetadataArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[bool]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")

    @use_api_search.setter
    def use_api_search(self, value: Optional[bool]):
        pulumi.set(self, "use_api_search", value)


if not MYPY:
    class GetCatalogVappTemplateFilterArgsDict(TypedDict):
        date: NotRequired[str]
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        earliest: NotRequired[bool]
        """
        Retrieves the oldest item
        """
        latest: NotRequired[bool]
        """
        Retrieves the newest item
        """
        metadatas: NotRequired[Sequence['GetCatalogVappTemplateFilterMetadataArgsDict']]
        """
        (Deprecated) Use `metadata_entry` instead. Key/value map of metadata for the associated vApp template.
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetCatalogVappTemplateFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogVappTemplateFilterArgs:
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['GetCatalogVappTemplateFilterMetadataArgs']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetCatalogVappTemplateFilterMetadataArgs'] metadatas: (Deprecated) Use `metadata_entry` instead. Key/value map of metadata for the associated vApp template.
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[str]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @earliest.setter
    def earliest(self, value: Optional[bool]):
        pulumi.set(self, "earliest", value)

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @latest.setter
    def latest(self, value: Optional[bool]):
        pulumi.set(self, "latest", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['GetCatalogVappTemplateFilterMetadataArgs']]:
        """
        (Deprecated) Use `metadata_entry` instead. Key/value map of metadata for the associated vApp template.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[Sequence['GetCatalogVappTemplateFilterMetadataArgs']]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetCatalogVappTemplateFilterMetadataArgsDict(TypedDict):
        key: str
        """
        Metadata key (field name)
        """
        value: str
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        is_system: NotRequired[bool]
        """
        True if is a metadata@SYSTEM key
        """
        type: NotRequired[str]
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        use_api_search: NotRequired[bool]
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
elif False:
    GetCatalogVappTemplateFilterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetCatalogVappTemplateFilterMetadataArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[bool]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")

    @use_api_search.setter
    def use_api_search(self, value: Optional[bool]):
        pulumi.set(self, "use_api_search", value)


if not MYPY:
    class GetEdgegatewayFilterArgsDict(TypedDict):
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetEdgegatewayFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEdgegatewayFilterArgs:
    def __init__(__self__, *,
                 name_regex: Optional[str] = None):
        """
        :param str name_regex: Search by name with a regular expression
        """
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetNetworkDirectFilterArgsDict(TypedDict):
        ip: NotRequired[str]
        """
        Search by IP. The value can be a regular expression
        """
        metadatas: NotRequired[Sequence['GetNetworkDirectFilterMetadataArgsDict']]
        """
        metadata filter
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetNetworkDirectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkDirectFilterArgs:
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 metadatas: Optional[Sequence['GetNetworkDirectFilterMetadataArgs']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param Sequence['GetNetworkDirectFilterMetadataArgs'] metadatas: metadata filter
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['GetNetworkDirectFilterMetadataArgs']]:
        """
        metadata filter
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[Sequence['GetNetworkDirectFilterMetadataArgs']]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetNetworkDirectFilterMetadataArgsDict(TypedDict):
        key: str
        """
        Metadata key (field name)
        """
        value: str
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        is_system: NotRequired[bool]
        """
        True if is a metadata@SYSTEM key
        """
        type: NotRequired[str]
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        use_api_search: NotRequired[bool]
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
elif False:
    GetNetworkDirectFilterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkDirectFilterMetadataArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[bool]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")

    @use_api_search.setter
    def use_api_search(self, value: Optional[bool]):
        pulumi.set(self, "use_api_search", value)


if not MYPY:
    class GetNetworkIsolatedFilterArgsDict(TypedDict):
        ip: NotRequired[str]
        """
        Search by IP. The value can be a regular expression
        """
        metadatas: NotRequired[Sequence['GetNetworkIsolatedFilterMetadataArgsDict']]
        """
        metadata filter
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetNetworkIsolatedFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkIsolatedFilterArgs:
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 metadatas: Optional[Sequence['GetNetworkIsolatedFilterMetadataArgs']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param Sequence['GetNetworkIsolatedFilterMetadataArgs'] metadatas: metadata filter
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['GetNetworkIsolatedFilterMetadataArgs']]:
        """
        metadata filter
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[Sequence['GetNetworkIsolatedFilterMetadataArgs']]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetNetworkIsolatedFilterMetadataArgsDict(TypedDict):
        key: str
        """
        Metadata key (field name)
        """
        value: str
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        is_system: NotRequired[bool]
        """
        True if is a metadata@SYSTEM key
        """
        type: NotRequired[str]
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        use_api_search: NotRequired[bool]
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
elif False:
    GetNetworkIsolatedFilterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkIsolatedFilterMetadataArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[bool]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")

    @use_api_search.setter
    def use_api_search(self, value: Optional[bool]):
        pulumi.set(self, "use_api_search", value)


if not MYPY:
    class GetNetworkIsolatedV2FilterArgsDict(TypedDict):
        ip: NotRequired[str]
        """
        Search by IP. The value can be a regular expression
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetNetworkIsolatedV2FilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkIsolatedV2FilterArgs:
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetNetworkRoutedFilterArgsDict(TypedDict):
        ip: NotRequired[str]
        """
        Search by IP. The value can be a regular expression
        """
        metadatas: NotRequired[Sequence['GetNetworkRoutedFilterMetadataArgsDict']]
        """
        metadata filter
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetNetworkRoutedFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkRoutedFilterArgs:
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 metadatas: Optional[Sequence['GetNetworkRoutedFilterMetadataArgs']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param Sequence['GetNetworkRoutedFilterMetadataArgs'] metadatas: metadata filter
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['GetNetworkRoutedFilterMetadataArgs']]:
        """
        metadata filter
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[Sequence['GetNetworkRoutedFilterMetadataArgs']]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetNetworkRoutedFilterMetadataArgsDict(TypedDict):
        key: str
        """
        Metadata key (field name)
        """
        value: str
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        is_system: NotRequired[bool]
        """
        True if is a metadata@SYSTEM key
        """
        type: NotRequired[str]
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        use_api_search: NotRequired[bool]
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
elif False:
    GetNetworkRoutedFilterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkRoutedFilterMetadataArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[bool]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")

    @use_api_search.setter
    def use_api_search(self, value: Optional[bool]):
        pulumi.set(self, "use_api_search", value)


if not MYPY:
    class GetNetworkRoutedV2FilterArgsDict(TypedDict):
        ip: NotRequired[str]
        """
        Search by IP. The value can be a regular expression
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetNetworkRoutedV2FilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkRoutedV2FilterArgs:
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetNsxtNetworkImportedFilterArgsDict(TypedDict):
        ip: NotRequired[str]
        """
        Search by IP. The value can be a regular expression
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetNsxtNetworkImportedFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNsxtNetworkImportedFilterArgs:
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetSubscribedCatalogFilterArgsDict(TypedDict):
        date: NotRequired[str]
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        earliest: NotRequired[bool]
        """
        Retrieves the oldest item
        """
        latest: NotRequired[bool]
        """
        Retrieves the newest item
        """
        metadatas: NotRequired[Sequence['GetSubscribedCatalogFilterMetadataArgsDict']]
        """
        Optional metadata of the catalog. This is inherited from the publishing catalog
        """
        name_regex: NotRequired[str]
        """
        Search by name with a regular expression
        """
elif False:
    GetSubscribedCatalogFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubscribedCatalogFilterArgs:
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['GetSubscribedCatalogFilterMetadataArgs']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetSubscribedCatalogFilterMetadataArgs'] metadatas: Optional metadata of the catalog. This is inherited from the publishing catalog
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[str]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @earliest.setter
    def earliest(self, value: Optional[bool]):
        pulumi.set(self, "earliest", value)

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @latest.setter
    def latest(self, value: Optional[bool]):
        pulumi.set(self, "latest", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['GetSubscribedCatalogFilterMetadataArgs']]:
        """
        Optional metadata of the catalog. This is inherited from the publishing catalog
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[Sequence['GetSubscribedCatalogFilterMetadataArgs']]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")

    @name_regex.setter
    def name_regex(self, value: Optional[str]):
        pulumi.set(self, "name_regex", value)


if not MYPY:
    class GetSubscribedCatalogFilterMetadataArgsDict(TypedDict):
        key: str
        """
        Metadata key (field name)
        """
        value: str
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        is_system: NotRequired[bool]
        """
        True if is a metadata@SYSTEM key
        """
        type: NotRequired[str]
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        use_api_search: NotRequired[bool]
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
elif False:
    GetSubscribedCatalogFilterMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubscribedCatalogFilterMetadataArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @is_system.setter
    def is_system(self, value: Optional[bool]):
        pulumi.set(self, "is_system", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")

    @use_api_search.setter
    def use_api_search(self, value: Optional[bool]):
        pulumi.set(self, "use_api_search", value)


