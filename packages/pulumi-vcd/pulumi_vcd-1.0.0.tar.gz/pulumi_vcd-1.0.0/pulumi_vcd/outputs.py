# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'CatalogAccessControlSharedWith',
    'CatalogItemMetadataEntry',
    'CatalogMediaMetadataEntry',
    'CatalogMetadataEntry',
    'CatalogVappTemplateCaptureVapp',
    'CatalogVappTemplateLease',
    'CatalogVappTemplateMetadataEntry',
    'CseKubernetesClusterControlPlane',
    'CseKubernetesClusterDefaultStorageClass',
    'CseKubernetesClusterEvent',
    'CseKubernetesClusterWorkerPool',
    'DseRegistryConfigurationContainerRegistry',
    'EdgegatewayExternalNetwork',
    'EdgegatewayExternalNetworkSubnet',
    'EdgegatewayExternalNetworkSubnetSuballocatePool',
    'EdgegatewayVpnLocalSubnet',
    'EdgegatewayVpnPeerSubnet',
    'ExternalNetworkIpScope',
    'ExternalNetworkIpScopeStaticIpPool',
    'ExternalNetworkV2IpScope',
    'ExternalNetworkV2IpScopeStaticIpPool',
    'ExternalNetworkV2NsxtNetwork',
    'ExternalNetworkV2VsphereNetwork',
    'ExternalNetworkVsphereNetwork',
    'IndependentDiskMetadataEntry',
    'IpSpaceCustomQuotaIpPrefixQuota',
    'IpSpaceIpPrefix',
    'IpSpaceIpPrefixPrefix',
    'IpSpaceIpRange',
    'LbServerPoolMember',
    'NetworkDirectMetadataEntry',
    'NetworkIsolatedDhcpPool',
    'NetworkIsolatedMetadataEntry',
    'NetworkIsolatedStaticIpPool',
    'NetworkIsolatedV2MetadataEntry',
    'NetworkIsolatedV2SecondaryStaticIpPool',
    'NetworkIsolatedV2StaticIpPool',
    'NetworkPoolBacking',
    'NetworkPoolBackingDistributedSwitch',
    'NetworkPoolBackingPortGroup',
    'NetworkPoolBackingRangeId',
    'NetworkPoolBackingTransportZone',
    'NetworkRoutedDhcpPool',
    'NetworkRoutedMetadataEntry',
    'NetworkRoutedStaticIpPool',
    'NetworkRoutedV2MetadataEntry',
    'NetworkRoutedV2SecondaryStaticIpPool',
    'NetworkRoutedV2StaticIpPool',
    'NsxtAlbPoolHealthMonitor',
    'NsxtAlbPoolMember',
    'NsxtAlbPoolPersistenceProfile',
    'NsxtAlbVirtualServiceHttpReqRulesRule',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActions',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeader',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect',
    'NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethods',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader',
    'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePorts',
    'NsxtAlbVirtualServiceHttpRespRulesRule',
    'NsxtAlbVirtualServiceHttpRespRulesRuleActions',
    'NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeader',
    'NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethods',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePorts',
    'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode',
    'NsxtAlbVirtualServiceHttpSecRulesRule',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActions',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect',
    'NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethods',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader',
    'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePorts',
    'NsxtAlbVirtualServiceServicePort',
    'NsxtAppPortProfileAppPort',
    'NsxtDistributedFirewallRule',
    'NsxtDynamicSecurityGroupCriteria',
    'NsxtDynamicSecurityGroupCriteriaRule',
    'NsxtDynamicSecurityGroupMemberVm',
    'NsxtEdgegatewayBgpIpPrefixListIpPrefix',
    'NsxtEdgegatewayDnsConditionalForwarderZone',
    'NsxtEdgegatewayDnsDefaultForwarderZone',
    'NsxtEdgegatewayExternalNetwork',
    'NsxtEdgegatewayL2VpnTunnelStretchedNetwork',
    'NsxtEdgegatewayStaticRouteNextHop',
    'NsxtEdgegatewayStaticRouteNextHopScope',
    'NsxtEdgegatewaySubnet',
    'NsxtEdgegatewaySubnetAllocatedIp',
    'NsxtEdgegatewaySubnetWithIpCount',
    'NsxtEdgegatewaySubnetWithTotalIpCount',
    'NsxtFirewallRule',
    'NsxtIpsecVpnTunnelSecurityProfileCustomization',
    'NsxtNetworkDhcpBindingDhcpV4Config',
    'NsxtNetworkDhcpBindingDhcpV6Config',
    'NsxtNetworkDhcpPool',
    'NsxtNetworkImportedSecondaryStaticIpPool',
    'NsxtNetworkImportedStaticIpPool',
    'NsxtSecurityGroupMemberVm',
    'NsxvDhcpRelayRelayAgent',
    'NsxvDistributedFirewallRule',
    'NsxvDistributedFirewallRuleApplication',
    'NsxvDistributedFirewallRuleAppliedTo',
    'NsxvDistributedFirewallRuleDestination',
    'NsxvDistributedFirewallRuleSource',
    'NsxvFirewallRuleDestination',
    'NsxvFirewallRuleService',
    'NsxvFirewallRuleSource',
    'OrgAccountLockout',
    'OrgLdapCustomSettings',
    'OrgLdapCustomSettingsGroupAttributes',
    'OrgLdapCustomSettingsUserAttributes',
    'OrgMetadataEntry',
    'OrgOidcClaimsMapping',
    'OrgOidcKey',
    'OrgVappLease',
    'OrgVappTemplateLease',
    'OrgVdcAccessControlSharedWith',
    'OrgVdcComputeCapacity',
    'OrgVdcComputeCapacityCpu',
    'OrgVdcComputeCapacityMemory',
    'OrgVdcMetadataEntry',
    'OrgVdcStorageProfile',
    'OrgVdcTemplateComputeConfiguration',
    'OrgVdcTemplateEdgeGateway',
    'OrgVdcTemplateEdgeGatewayStaticIpPool',
    'OrgVdcTemplateProviderVdc',
    'OrgVdcTemplateStorageProfile',
    'ProviderVdcComputeCapacity',
    'ProviderVdcComputeCapacityCpus',
    'ProviderVdcComputeCapacityMemory',
    'ProviderVdcMetadataEntry',
    'RdeMetadataEntry',
    'RdeTypeHook',
    'SolutionLandingZoneCatalog',
    'SolutionLandingZoneVdc',
    'SolutionLandingZoneVdcComputePolicy',
    'SolutionLandingZoneVdcOrgVdcNetwork',
    'SolutionLandingZoneVdcStoragePolicy',
    'VappAccessControlSharedWith',
    'VappFirewallRulesRule',
    'VappLease',
    'VappMetadataEntry',
    'VappNatRulesRule',
    'VappNetworkDhcpPool',
    'VappNetworkStaticIpPool',
    'VappStaticRoutingRule',
    'VappVmBootOptions',
    'VappVmCustomization',
    'VappVmDisk',
    'VappVmExtraConfig',
    'VappVmInternalDisk',
    'VappVmMetadataEntry',
    'VappVmNetwork',
    'VappVmOverrideTemplateDisk',
    'VappVmSetExtraConfig',
    'VdcGroupParticipatingOrgVdc',
    'VmBootOptions',
    'VmCustomization',
    'VmDisk',
    'VmExtraConfig',
    'VmInternalDisk',
    'VmMetadataEntry',
    'VmNetwork',
    'VmOverrideTemplateDisk',
    'VmSetExtraConfig',
    'VmSizingPolicyCpu',
    'VmSizingPolicyMemory',
    'VmVgpuPolicyCpu',
    'VmVgpuPolicyMemory',
    'VmVgpuPolicyProviderVdcScope',
    'VmVgpuPolicyVgpuProfile',
    'GetCatalogAccessControlSharedWithResult',
    'GetCatalogFilterResult',
    'GetCatalogFilterMetadataResult',
    'GetCatalogItemFilterResult',
    'GetCatalogItemFilterMetadataResult',
    'GetCatalogItemMetadataEntryResult',
    'GetCatalogMediaFilterResult',
    'GetCatalogMediaFilterMetadataResult',
    'GetCatalogMediaMetadataEntryResult',
    'GetCatalogMetadataEntryResult',
    'GetCatalogVappTemplateFilterResult',
    'GetCatalogVappTemplateFilterMetadataResult',
    'GetCatalogVappTemplateLeaseResult',
    'GetCatalogVappTemplateMetadataEntryResult',
    'GetCseKubernetesClusterControlPlaneResult',
    'GetCseKubernetesClusterDefaultStorageClassResult',
    'GetCseKubernetesClusterEventResult',
    'GetCseKubernetesClusterWorkerPoolResult',
    'GetDseRegistryConfigurationContainerRegistryResult',
    'GetEdgegatewayExternalNetworkResult',
    'GetEdgegatewayExternalNetworkSubnetResult',
    'GetEdgegatewayExternalNetworkSubnetSuballocatePoolResult',
    'GetEdgegatewayFilterResult',
    'GetExternalNetworkIpScopeResult',
    'GetExternalNetworkIpScopeStaticIpPoolResult',
    'GetExternalNetworkV2IpScopeResult',
    'GetExternalNetworkV2IpScopeStaticIpPoolResult',
    'GetExternalNetworkV2NsxtNetworkResult',
    'GetExternalNetworkV2VsphereNetworkResult',
    'GetExternalNetworkVsphereNetworkResult',
    'GetIndependentDiskMetadataEntryResult',
    'GetIpSpaceCustomQuotaIpPrefixQuotaResult',
    'GetIpSpaceIpPrefixResult',
    'GetIpSpaceIpPrefixPrefixResult',
    'GetIpSpaceIpRangeResult',
    'GetLbServerPoolMemberResult',
    'GetNetworkDirectFilterResult',
    'GetNetworkDirectFilterMetadataResult',
    'GetNetworkDirectMetadataEntryResult',
    'GetNetworkIsolatedDhcpPoolResult',
    'GetNetworkIsolatedFilterResult',
    'GetNetworkIsolatedFilterMetadataResult',
    'GetNetworkIsolatedMetadataEntryResult',
    'GetNetworkIsolatedStaticIpPoolResult',
    'GetNetworkIsolatedV2FilterResult',
    'GetNetworkIsolatedV2MetadataEntryResult',
    'GetNetworkIsolatedV2SecondaryStaticIpPoolResult',
    'GetNetworkIsolatedV2StaticIpPoolResult',
    'GetNetworkPoolBackingResult',
    'GetNetworkPoolBackingDistributedSwitchResult',
    'GetNetworkPoolBackingPortGroupResult',
    'GetNetworkPoolBackingRangeIdResult',
    'GetNetworkPoolBackingTransportZoneResult',
    'GetNetworkRoutedDhcpPoolResult',
    'GetNetworkRoutedFilterResult',
    'GetNetworkRoutedFilterMetadataResult',
    'GetNetworkRoutedMetadataEntryResult',
    'GetNetworkRoutedStaticIpPoolResult',
    'GetNetworkRoutedV2FilterResult',
    'GetNetworkRoutedV2MetadataEntryResult',
    'GetNetworkRoutedV2SecondaryStaticIpPoolResult',
    'GetNetworkRoutedV2StaticIpPoolResult',
    'GetNsxtAlbPoolHealthMonitorResult',
    'GetNsxtAlbPoolMemberResult',
    'GetNsxtAlbPoolPersistenceProfileResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleActionResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleActionModifyHeaderResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRedirectResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRewriteUrlResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderResult',
    'GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleActionResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleActionModifyHeaderResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleActionRewriteLocationHeaderResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortResult',
    'GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleActionResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionLocalResponseResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionRedirectResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleActionSendResponseResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderResult',
    'GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortResult',
    'GetNsxtAlbVirtualServiceServicePortResult',
    'GetNsxtAppPortProfileAppPortResult',
    'GetNsxtDistributedFirewallRuleResult',
    'GetNsxtDynamicSecurityGroupCriteriaResult',
    'GetNsxtDynamicSecurityGroupCriteriaRuleResult',
    'GetNsxtDynamicSecurityGroupMemberVmResult',
    'GetNsxtEdgegatewayBgpIpPrefixListIpPrefixResult',
    'GetNsxtEdgegatewayDnsConditionalForwarderZoneResult',
    'GetNsxtEdgegatewayDnsDefaultForwarderZoneResult',
    'GetNsxtEdgegatewayExternalNetworkResult',
    'GetNsxtEdgegatewayL2VpnTunnelStretchedNetworkResult',
    'GetNsxtEdgegatewayStaticRouteNextHopResult',
    'GetNsxtEdgegatewayStaticRouteNextHopScopeResult',
    'GetNsxtEdgegatewaySubnetResult',
    'GetNsxtEdgegatewaySubnetAllocatedIpResult',
    'GetNsxtEdgegatewaySubnetWithIpCountResult',
    'GetNsxtEdgegatewaySubnetWithTotalIpCountResult',
    'GetNsxtFirewallRuleResult',
    'GetNsxtIpsecVpnTunnelSecurityProfileCustomizationResult',
    'GetNsxtNetworkDhcpBindingDhcpV4ConfigResult',
    'GetNsxtNetworkDhcpBindingDhcpV6ConfigResult',
    'GetNsxtNetworkDhcpPoolResult',
    'GetNsxtNetworkImportedFilterResult',
    'GetNsxtNetworkImportedSecondaryStaticIpPoolResult',
    'GetNsxtNetworkImportedStaticIpPoolResult',
    'GetNsxtSecurityGroupMemberVmResult',
    'GetNsxvApplicationFinderObjectResult',
    'GetNsxvApplicationGroupApplicationResult',
    'GetNsxvDhcpRelayRelayAgentResult',
    'GetNsxvDistributedFirewallRuleResult',
    'GetNsxvDistributedFirewallRuleApplicationResult',
    'GetNsxvDistributedFirewallRuleAppliedToResult',
    'GetNsxvDistributedFirewallRuleDestinationResult',
    'GetNsxvDistributedFirewallRuleSourceResult',
    'GetNsxvFirewallRuleDestinationResult',
    'GetNsxvFirewallRuleServiceResult',
    'GetNsxvFirewallRuleSourceResult',
    'GetOrgAccountLockoutResult',
    'GetOrgLdapCustomSettingResult',
    'GetOrgLdapCustomSettingGroupAttributeResult',
    'GetOrgLdapCustomSettingUserAttributeResult',
    'GetOrgMetadataEntryResult',
    'GetOrgOidcClaimsMappingResult',
    'GetOrgOidcKeyResult',
    'GetOrgVappLeaseResult',
    'GetOrgVappTemplateLeaseResult',
    'GetOrgVdcComputeCapacityResult',
    'GetOrgVdcComputeCapacityCpusResult',
    'GetOrgVdcComputeCapacityMemoryResult',
    'GetOrgVdcMetadataEntryResult',
    'GetOrgVdcStorageProfileResult',
    'GetOrgVdcTemplateComputeConfigurationResult',
    'GetOrgVdcTemplateEdgeGatewayResult',
    'GetOrgVdcTemplateEdgeGatewayStaticIpPoolResult',
    'GetOrgVdcTemplateProviderVdcResult',
    'GetOrgVdcTemplateStorageProfileResult',
    'GetProviderVdcComputeCapacityResult',
    'GetProviderVdcComputeCapacityCpusResult',
    'GetProviderVdcComputeCapacityMemoryResult',
    'GetProviderVdcMetadataEntryResult',
    'GetRdeMetadataEntryResult',
    'GetRdeTypeHookResult',
    'GetResourceSchemaAttributeResult',
    'GetResourceSchemaBlockAttributeResult',
    'GetResourceSchemaBlockAttributeAttributeResult',
    'GetRightImpliedRightResult',
    'GetSolutionLandingZoneCatalogResult',
    'GetSolutionLandingZoneVdcResult',
    'GetSolutionLandingZoneVdcComputePolicyResult',
    'GetSolutionLandingZoneVdcOrgVdcNetworkResult',
    'GetSolutionLandingZoneVdcStoragePolicyResult',
    'GetStorageProfileIopsSettingResult',
    'GetStorageProfileMetadataEntryResult',
    'GetSubscribedCatalogFilterResult',
    'GetSubscribedCatalogFilterMetadataResult',
    'GetVappLeaseResult',
    'GetVappMetadataEntryResult',
    'GetVappNetworkDhcpPoolResult',
    'GetVappNetworkStaticIpPoolResult',
    'GetVappVmBootOptionResult',
    'GetVappVmCustomizationResult',
    'GetVappVmDiskResult',
    'GetVappVmExtraConfigResult',
    'GetVappVmInternalDiskResult',
    'GetVappVmMetadataEntryResult',
    'GetVappVmNetworkResult',
    'GetVdcGroupParticipatingOrgVdcResult',
    'GetVmBootOptionResult',
    'GetVmCustomizationResult',
    'GetVmDiskResult',
    'GetVmExtraConfigResult',
    'GetVmInternalDiskResult',
    'GetVmMetadataEntryResult',
    'GetVmNetworkResult',
    'GetVmSizingPolicyCpusResult',
    'GetVmSizingPolicyMemoryResult',
    'GetVmVgpuPolicyCpusResult',
    'GetVmVgpuPolicyMemoryResult',
    'GetVmVgpuPolicyProviderVdcScopeResult',
    'GetVmVgpuPolicyVgpuProfileResult',
]

@pulumi.output_type
class CatalogAccessControlSharedWith(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "orgId":
            suggest = "org_id"
        elif key == "subjectName":
            suggest = "subject_name"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogAccessControlSharedWith. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogAccessControlSharedWith.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogAccessControlSharedWith.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: str,
                 group_id: Optional[str] = None,
                 org_id: Optional[str] = None,
                 subject_name: Optional[str] = None,
                 user_id: Optional[str] = None):
        """
        :param str access_level: The access level for the user or group to which we are sharing. (One of `ReadOnly`, 
               `Change`, `FullControl`, but it can only be `ReadOnly` when we share to an Organization)
        :param str group_id: The ID of a group with which we are sharing. Required if `user_id` or `org_id` is not set.
        :param str org_id: The ID of a group with which we are sharing. Required if `user_id` or `group_id` is not set.
        :param str subject_name: the name of the subject (Org, group, or user) with which we are sharing.
        :param str user_id: The ID of a user with which we are sharing. Required if `group_id` or `org_id` is not set.
        """
        pulumi.set(__self__, "access_level", access_level)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> str:
        """
        The access level for the user or group to which we are sharing. (One of `ReadOnly`, 
        `Change`, `FullControl`, but it can only be `ReadOnly` when we share to an Organization)
        """
        return pulumi.get(self, "access_level")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The ID of a group with which we are sharing. Required if `user_id` or `org_id` is not set.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[str]:
        """
        The ID of a group with which we are sharing. Required if `user_id` or `group_id` is not set.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[str]:
        """
        the name of the subject (Org, group, or user) with which we are sharing.
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The ID of a user with which we are sharing. Required if `group_id` or `org_id` is not set.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class CatalogItemMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogItemMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogItemMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogItemMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CatalogMediaMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogMediaMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogMediaMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogMediaMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CatalogMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CatalogVappTemplateCaptureVapp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyTpmOnInstantiate":
            suggest = "copy_tpm_on_instantiate"
        elif key == "customizeOnInstantiate":
            suggest = "customize_on_instantiate"
        elif key == "overwriteCatalogItemId":
            suggest = "overwrite_catalog_item_id"
        elif key == "sourceId":
            suggest = "source_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogVappTemplateCaptureVapp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogVappTemplateCaptureVapp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogVappTemplateCaptureVapp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_tpm_on_instantiate: Optional[bool] = None,
                 customize_on_instantiate: Optional[bool] = None,
                 overwrite_catalog_item_id: Optional[str] = None,
                 source_id: Optional[str] = None):
        """
        :param bool copy_tpm_on_instantiate: Defines if Trusted Platform Module should be copied (false) or created (true). Default 'false'. VCD 10.4.2+
        :param bool customize_on_instantiate: Marks if instantiating applies customization settings ('true'). Default is 'false` - create an identical copy.
        :param str overwrite_catalog_item_id: An existing catalog item ID to overwrite
        :param str source_id: Source vApp ID (can be a vApp ID or 'vapp_id' field of standalone VM 'vcd_vm')
        """
        if copy_tpm_on_instantiate is not None:
            pulumi.set(__self__, "copy_tpm_on_instantiate", copy_tpm_on_instantiate)
        if customize_on_instantiate is not None:
            pulumi.set(__self__, "customize_on_instantiate", customize_on_instantiate)
        if overwrite_catalog_item_id is not None:
            pulumi.set(__self__, "overwrite_catalog_item_id", overwrite_catalog_item_id)
        if source_id is not None:
            pulumi.set(__self__, "source_id", source_id)

    @property
    @pulumi.getter(name="copyTpmOnInstantiate")
    def copy_tpm_on_instantiate(self) -> Optional[bool]:
        """
        Defines if Trusted Platform Module should be copied (false) or created (true). Default 'false'. VCD 10.4.2+
        """
        return pulumi.get(self, "copy_tpm_on_instantiate")

    @property
    @pulumi.getter(name="customizeOnInstantiate")
    def customize_on_instantiate(self) -> Optional[bool]:
        """
        Marks if instantiating applies customization settings ('true'). Default is 'false` - create an identical copy.
        """
        return pulumi.get(self, "customize_on_instantiate")

    @property
    @pulumi.getter(name="overwriteCatalogItemId")
    def overwrite_catalog_item_id(self) -> Optional[str]:
        """
        An existing catalog item ID to overwrite
        """
        return pulumi.get(self, "overwrite_catalog_item_id")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> Optional[str]:
        """
        Source vApp ID (can be a vApp ID or 'vapp_id' field of standalone VM 'vcd_vm')
        """
        return pulumi.get(self, "source_id")


@pulumi.output_type
class CatalogVappTemplateLease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageLeaseInSec":
            suggest = "storage_lease_in_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogVappTemplateLease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogVappTemplateLease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogVappTemplateLease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_lease_in_sec: int):
        """
        :param int storage_lease_in_sec: How long the vApp Template is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by parent Org). Regular values accepted from 3600+.
        """
        pulumi.set(__self__, "storage_lease_in_sec", storage_lease_in_sec)

    @property
    @pulumi.getter(name="storageLeaseInSec")
    def storage_lease_in_sec(self) -> int:
        """
        How long the vApp Template is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by parent Org). Regular values accepted from 3600+.
        """
        return pulumi.get(self, "storage_lease_in_sec")


@pulumi.output_type
class CatalogVappTemplateMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CatalogVappTemplateMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CatalogVappTemplateMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CatalogVappTemplateMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CseKubernetesClusterControlPlane(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGi":
            suggest = "disk_size_gi"
        elif key == "machineCount":
            suggest = "machine_count"
        elif key == "placementPolicyId":
            suggest = "placement_policy_id"
        elif key == "sizingPolicyId":
            suggest = "sizing_policy_id"
        elif key == "storageProfileId":
            suggest = "storage_profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseKubernetesClusterControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseKubernetesClusterControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseKubernetesClusterControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_gi: Optional[int] = None,
                 ip: Optional[str] = None,
                 machine_count: Optional[int] = None,
                 placement_policy_id: Optional[str] = None,
                 sizing_policy_id: Optional[str] = None,
                 storage_profile_id: Optional[str] = None):
        """
        :param int disk_size_gi: Disk size, in **Gibibytes (Gi)**, for the control plane VMs. Must be at least `20`. Defaults to `20`
        :param str ip: IP for the control plane. It will be automatically assigned during cluster creation if left empty
        :param int machine_count: The number of nodes that the control plane has. Must be an odd number and higher than `0`. Defaults to `3`
        :param str placement_policy_id: VM Placement policy for the control plane VMs
        :param str sizing_policy_id: VM Sizing policy for the control plane VMs. Must be one of the ones made available during CSE installation
        :param str storage_profile_id: Storage profile for the control plane VMs
        """
        if disk_size_gi is not None:
            pulumi.set(__self__, "disk_size_gi", disk_size_gi)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if machine_count is not None:
            pulumi.set(__self__, "machine_count", machine_count)
        if placement_policy_id is not None:
            pulumi.set(__self__, "placement_policy_id", placement_policy_id)
        if sizing_policy_id is not None:
            pulumi.set(__self__, "sizing_policy_id", sizing_policy_id)
        if storage_profile_id is not None:
            pulumi.set(__self__, "storage_profile_id", storage_profile_id)

    @property
    @pulumi.getter(name="diskSizeGi")
    def disk_size_gi(self) -> Optional[int]:
        """
        Disk size, in **Gibibytes (Gi)**, for the control plane VMs. Must be at least `20`. Defaults to `20`
        """
        return pulumi.get(self, "disk_size_gi")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IP for the control plane. It will be automatically assigned during cluster creation if left empty
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="machineCount")
    def machine_count(self) -> Optional[int]:
        """
        The number of nodes that the control plane has. Must be an odd number and higher than `0`. Defaults to `3`
        """
        return pulumi.get(self, "machine_count")

    @property
    @pulumi.getter(name="placementPolicyId")
    def placement_policy_id(self) -> Optional[str]:
        """
        VM Placement policy for the control plane VMs
        """
        return pulumi.get(self, "placement_policy_id")

    @property
    @pulumi.getter(name="sizingPolicyId")
    def sizing_policy_id(self) -> Optional[str]:
        """
        VM Sizing policy for the control plane VMs. Must be one of the ones made available during CSE installation
        """
        return pulumi.get(self, "sizing_policy_id")

    @property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> Optional[str]:
        """
        Storage profile for the control plane VMs
        """
        return pulumi.get(self, "storage_profile_id")


@pulumi.output_type
class CseKubernetesClusterDefaultStorageClass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reclaimPolicy":
            suggest = "reclaim_policy"
        elif key == "storageProfileId":
            suggest = "storage_profile_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseKubernetesClusterDefaultStorageClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseKubernetesClusterDefaultStorageClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseKubernetesClusterDefaultStorageClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filesystem: str,
                 name: str,
                 reclaim_policy: str,
                 storage_profile_id: str):
        """
        :param str filesystem: Filesystem of the storage class, can be either `ext4` or `xfs`
        :param str name: The name of the default storage class. It must contain only lowercase alphanumeric characters or "-",
               start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        :param str reclaim_policy: A value of `delete` deletes the volume when the PersistentVolumeClaim is deleted. `retain` does not,
               and the volume can be manually reclaimed
        :param str storage_profile_id: Storage profile for the default storage class
        """
        pulumi.set(__self__, "filesystem", filesystem)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "reclaim_policy", reclaim_policy)
        pulumi.set(__self__, "storage_profile_id", storage_profile_id)

    @property
    @pulumi.getter
    def filesystem(self) -> str:
        """
        Filesystem of the storage class, can be either `ext4` or `xfs`
        """
        return pulumi.get(self, "filesystem")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the default storage class. It must contain only lowercase alphanumeric characters or "-",
        start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="reclaimPolicy")
    def reclaim_policy(self) -> str:
        """
        A value of `delete` deletes the volume when the PersistentVolumeClaim is deleted. `retain` does not,
        and the volume can be manually reclaimed
        """
        return pulumi.get(self, "reclaim_policy")

    @property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> str:
        """
        Storage profile for the default storage class
        """
        return pulumi.get(self, "storage_profile_id")


@pulumi.output_type
class CseKubernetesClusterEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "occurredAt":
            suggest = "occurred_at"
        elif key == "resourceId":
            suggest = "resource_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseKubernetesClusterEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseKubernetesClusterEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseKubernetesClusterEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 details: Optional[str] = None,
                 name: Optional[str] = None,
                 occurred_at: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str details: Details of the event
        :param str name: The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
               start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        :param str occurred_at: When the event happened
        :param str resource_id: ID of the resource that caused the event
        :param str type: Type of the event, either `event` or `error`
        """
        if details is not None:
            pulumi.set(__self__, "details", details)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if occurred_at is not None:
            pulumi.set(__self__, "occurred_at", occurred_at)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def details(self) -> Optional[str]:
        """
        Details of the event
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
        start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="occurredAt")
    def occurred_at(self) -> Optional[str]:
        """
        When the event happened
        """
        return pulumi.get(self, "occurred_at")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        ID of the resource that caused the event
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the event, either `event` or `error`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CseKubernetesClusterWorkerPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscalerMaxReplicas":
            suggest = "autoscaler_max_replicas"
        elif key == "autoscalerMinReplicas":
            suggest = "autoscaler_min_replicas"
        elif key == "diskSizeGi":
            suggest = "disk_size_gi"
        elif key == "machineCount":
            suggest = "machine_count"
        elif key == "placementPolicyId":
            suggest = "placement_policy_id"
        elif key == "sizingPolicyId":
            suggest = "sizing_policy_id"
        elif key == "storageProfileId":
            suggest = "storage_profile_id"
        elif key == "vgpuPolicyId":
            suggest = "vgpu_policy_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseKubernetesClusterWorkerPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseKubernetesClusterWorkerPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseKubernetesClusterWorkerPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 autoscaler_max_replicas: Optional[int] = None,
                 autoscaler_min_replicas: Optional[int] = None,
                 disk_size_gi: Optional[int] = None,
                 machine_count: Optional[int] = None,
                 placement_policy_id: Optional[str] = None,
                 sizing_policy_id: Optional[str] = None,
                 storage_profile_id: Optional[str] = None,
                 vgpu_policy_id: Optional[str] = None):
        """
        :param str name: The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
               start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        :param int autoscaler_max_replicas: Maximum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_min_replicas'
        :param int autoscaler_min_replicas: Minimum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_max_replicas'
        :param int disk_size_gi: Disk size, in Gibibytes (Gi), for this worker pool
        :param int machine_count: The number of nodes that this worker pool has. Must be higher than or equal to 0. Ignored if 'autoscaler_max_replicas' and 'autoscaler_min_replicas' are set
        :param str placement_policy_id: VM Placement policy for this worker pool
        :param str sizing_policy_id: VM Sizing policy for this worker pool
        :param str storage_profile_id: Storage profile for this worker pool
        :param str vgpu_policy_id: vGPU policy for this worker pool
        """
        pulumi.set(__self__, "name", name)
        if autoscaler_max_replicas is not None:
            pulumi.set(__self__, "autoscaler_max_replicas", autoscaler_max_replicas)
        if autoscaler_min_replicas is not None:
            pulumi.set(__self__, "autoscaler_min_replicas", autoscaler_min_replicas)
        if disk_size_gi is not None:
            pulumi.set(__self__, "disk_size_gi", disk_size_gi)
        if machine_count is not None:
            pulumi.set(__self__, "machine_count", machine_count)
        if placement_policy_id is not None:
            pulumi.set(__self__, "placement_policy_id", placement_policy_id)
        if sizing_policy_id is not None:
            pulumi.set(__self__, "sizing_policy_id", sizing_policy_id)
        if storage_profile_id is not None:
            pulumi.set(__self__, "storage_profile_id", storage_profile_id)
        if vgpu_policy_id is not None:
            pulumi.set(__self__, "vgpu_policy_id", vgpu_policy_id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Kubernetes cluster. It must contain only lowercase alphanumeric characters or "-",
        start with an alphabetic character, end with an alphanumeric, and contain at most 31 characters
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="autoscalerMaxReplicas")
    def autoscaler_max_replicas(self) -> Optional[int]:
        """
        Maximum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_min_replicas'
        """
        return pulumi.get(self, "autoscaler_max_replicas")

    @property
    @pulumi.getter(name="autoscalerMinReplicas")
    def autoscaler_min_replicas(self) -> Optional[int]:
        """
        Minimum replicas for the autoscaling capabilities of this worker pool. Requires 'autoscaler_max_replicas'
        """
        return pulumi.get(self, "autoscaler_min_replicas")

    @property
    @pulumi.getter(name="diskSizeGi")
    def disk_size_gi(self) -> Optional[int]:
        """
        Disk size, in Gibibytes (Gi), for this worker pool
        """
        return pulumi.get(self, "disk_size_gi")

    @property
    @pulumi.getter(name="machineCount")
    def machine_count(self) -> Optional[int]:
        """
        The number of nodes that this worker pool has. Must be higher than or equal to 0. Ignored if 'autoscaler_max_replicas' and 'autoscaler_min_replicas' are set
        """
        return pulumi.get(self, "machine_count")

    @property
    @pulumi.getter(name="placementPolicyId")
    def placement_policy_id(self) -> Optional[str]:
        """
        VM Placement policy for this worker pool
        """
        return pulumi.get(self, "placement_policy_id")

    @property
    @pulumi.getter(name="sizingPolicyId")
    def sizing_policy_id(self) -> Optional[str]:
        """
        VM Sizing policy for this worker pool
        """
        return pulumi.get(self, "sizing_policy_id")

    @property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> Optional[str]:
        """
        Storage profile for this worker pool
        """
        return pulumi.get(self, "storage_profile_id")

    @property
    @pulumi.getter(name="vgpuPolicyId")
    def vgpu_policy_id(self) -> Optional[str]:
        """
        vGPU policy for this worker pool
        """
        return pulumi.get(self, "vgpu_policy_id")


@pulumi.output_type
class DseRegistryConfigurationContainerRegistry(dict):
    def __init__(__self__, *,
                 description: str,
                 host: str,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str description: Registry description
        :param str host: Registry host
        :param str password: Password for registry user
        :param str username: Username for registry access
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Registry description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Registry host
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for registry user
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for registry access
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class EdgegatewayExternalNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableRateLimit":
            suggest = "enable_rate_limit"
        elif key == "incomingRateLimit":
            suggest = "incoming_rate_limit"
        elif key == "outgoingRateLimit":
            suggest = "outgoing_rate_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgegatewayExternalNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgegatewayExternalNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgegatewayExternalNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 enable_rate_limit: Optional[bool] = None,
                 incoming_rate_limit: Optional[float] = None,
                 outgoing_rate_limit: Optional[float] = None,
                 subnets: Optional[Sequence['outputs.EdgegatewayExternalNetworkSubnet']] = None):
        """
        :param str name: A unique name for the edge gateway.
        :param bool enable_rate_limit: Enable rate limiting
        :param float incoming_rate_limit: Incoming rate limit (Mbps)
        :param float outgoing_rate_limit: Outgoing rate limit (Mbps)
        """
        pulumi.set(__self__, "name", name)
        if enable_rate_limit is not None:
            pulumi.set(__self__, "enable_rate_limit", enable_rate_limit)
        if incoming_rate_limit is not None:
            pulumi.set(__self__, "incoming_rate_limit", incoming_rate_limit)
        if outgoing_rate_limit is not None:
            pulumi.set(__self__, "outgoing_rate_limit", outgoing_rate_limit)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A unique name for the edge gateway.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="enableRateLimit")
    def enable_rate_limit(self) -> Optional[bool]:
        """
        Enable rate limiting
        """
        return pulumi.get(self, "enable_rate_limit")

    @property
    @pulumi.getter(name="incomingRateLimit")
    def incoming_rate_limit(self) -> Optional[float]:
        """
        Incoming rate limit (Mbps)
        """
        return pulumi.get(self, "incoming_rate_limit")

    @property
    @pulumi.getter(name="outgoingRateLimit")
    def outgoing_rate_limit(self) -> Optional[float]:
        """
        Outgoing rate limit (Mbps)
        """
        return pulumi.get(self, "outgoing_rate_limit")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence['outputs.EdgegatewayExternalNetworkSubnet']]:
        return pulumi.get(self, "subnets")


@pulumi.output_type
class EdgegatewayExternalNetworkSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "suballocatePools":
            suggest = "suballocate_pools"
        elif key == "useForDefaultRoute":
            suggest = "use_for_default_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgegatewayExternalNetworkSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgegatewayExternalNetworkSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgegatewayExternalNetworkSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: str,
                 netmask: str,
                 ip_address: Optional[str] = None,
                 suballocate_pools: Optional[Sequence['outputs.EdgegatewayExternalNetworkSubnetSuballocatePool']] = None,
                 use_for_default_route: Optional[bool] = None):
        """
        :param str gateway: Gateway address for a subnet
        :param str netmask: Netmask address for a subnet
        :param str ip_address: IP address on the edge gateway - will be auto-assigned if not defined
        :param Sequence['EdgegatewayExternalNetworkSubnetSuballocatePoolArgs'] suballocate_pools: Define zero or more blocks to sub-allocate pools on the edge gateway
        :param bool use_for_default_route: Defines if this subnet should be used as default gateway for edge
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if suballocate_pools is not None:
            pulumi.set(__self__, "suballocate_pools", suballocate_pools)
        if use_for_default_route is not None:
            pulumi.set(__self__, "use_for_default_route", use_for_default_route)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        Netmask address for a subnet
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        IP address on the edge gateway - will be auto-assigned if not defined
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="suballocatePools")
    def suballocate_pools(self) -> Optional[Sequence['outputs.EdgegatewayExternalNetworkSubnetSuballocatePool']]:
        """
        Define zero or more blocks to sub-allocate pools on the edge gateway
        """
        return pulumi.get(self, "suballocate_pools")

    @property
    @pulumi.getter(name="useForDefaultRoute")
    def use_for_default_route(self) -> Optional[bool]:
        """
        Defines if this subnet should be used as default gateway for edge
        """
        return pulumi.get(self, "use_for_default_route")


@pulumi.output_type
class EdgegatewayExternalNetworkSubnetSuballocatePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgegatewayExternalNetworkSubnetSuballocatePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgegatewayExternalNetworkSubnetSuballocatePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgegatewayExternalNetworkSubnetSuballocatePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        return pulumi.get(self, "start_address")


@pulumi.output_type
class EdgegatewayVpnLocalSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localSubnetGateway":
            suggest = "local_subnet_gateway"
        elif key == "localSubnetMask":
            suggest = "local_subnet_mask"
        elif key == "localSubnetName":
            suggest = "local_subnet_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgegatewayVpnLocalSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgegatewayVpnLocalSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgegatewayVpnLocalSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_subnet_gateway: str,
                 local_subnet_mask: str,
                 local_subnet_name: str):
        pulumi.set(__self__, "local_subnet_gateway", local_subnet_gateway)
        pulumi.set(__self__, "local_subnet_mask", local_subnet_mask)
        pulumi.set(__self__, "local_subnet_name", local_subnet_name)

    @property
    @pulumi.getter(name="localSubnetGateway")
    def local_subnet_gateway(self) -> str:
        return pulumi.get(self, "local_subnet_gateway")

    @property
    @pulumi.getter(name="localSubnetMask")
    def local_subnet_mask(self) -> str:
        return pulumi.get(self, "local_subnet_mask")

    @property
    @pulumi.getter(name="localSubnetName")
    def local_subnet_name(self) -> str:
        return pulumi.get(self, "local_subnet_name")


@pulumi.output_type
class EdgegatewayVpnPeerSubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerSubnetGateway":
            suggest = "peer_subnet_gateway"
        elif key == "peerSubnetMask":
            suggest = "peer_subnet_mask"
        elif key == "peerSubnetName":
            suggest = "peer_subnet_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EdgegatewayVpnPeerSubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EdgegatewayVpnPeerSubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EdgegatewayVpnPeerSubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 peer_subnet_gateway: str,
                 peer_subnet_mask: str,
                 peer_subnet_name: str):
        pulumi.set(__self__, "peer_subnet_gateway", peer_subnet_gateway)
        pulumi.set(__self__, "peer_subnet_mask", peer_subnet_mask)
        pulumi.set(__self__, "peer_subnet_name", peer_subnet_name)

    @property
    @pulumi.getter(name="peerSubnetGateway")
    def peer_subnet_gateway(self) -> str:
        return pulumi.get(self, "peer_subnet_gateway")

    @property
    @pulumi.getter(name="peerSubnetMask")
    def peer_subnet_mask(self) -> str:
        return pulumi.get(self, "peer_subnet_mask")

    @property
    @pulumi.getter(name="peerSubnetName")
    def peer_subnet_name(self) -> str:
        return pulumi.get(self, "peer_subnet_name")


@pulumi.output_type
class ExternalNetworkIpScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSuffix":
            suggest = "dns_suffix"
        elif key == "staticIpPools":
            suggest = "static_ip_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNetworkIpScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNetworkIpScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNetworkIpScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: str,
                 netmask: str,
                 dns1: Optional[str] = None,
                 dns2: Optional[str] = None,
                 dns_suffix: Optional[str] = None,
                 static_ip_pools: Optional[Sequence['outputs.ExternalNetworkIpScopeStaticIpPool']] = None):
        """
        :param str gateway: Gateway of the network
        :param str netmask: Network mask
        :param str dns1: Primary DNS server
        :param str dns2: Secondary DNS server
        :param str dns_suffix: DNS suffix
        :param Sequence['ExternalNetworkIpScopeStaticIpPoolArgs'] static_ip_pools: IP ranges used for static pool allocation in the network
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        if dns1 is not None:
            pulumi.set(__self__, "dns1", dns1)
        if dns2 is not None:
            pulumi.set(__self__, "dns2", dns2)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)
        if static_ip_pools is not None:
            pulumi.set(__self__, "static_ip_pools", static_ip_pools)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway of the network
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        Network mask
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter
    def dns1(self) -> Optional[str]:
        """
        Primary DNS server
        """
        return pulumi.get(self, "dns1")

    @property
    @pulumi.getter
    def dns2(self) -> Optional[str]:
        """
        Secondary DNS server
        """
        return pulumi.get(self, "dns2")

    @property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[str]:
        """
        DNS suffix
        """
        return pulumi.get(self, "dns_suffix")

    @property
    @pulumi.getter(name="staticIpPools")
    def static_ip_pools(self) -> Optional[Sequence['outputs.ExternalNetworkIpScopeStaticIpPool']]:
        """
        IP ranges used for static pool allocation in the network
        """
        return pulumi.get(self, "static_ip_pools")


@pulumi.output_type
class ExternalNetworkIpScopeStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNetworkIpScopeStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNetworkIpScopeStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNetworkIpScopeStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class ExternalNetworkV2IpScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixLength":
            suggest = "prefix_length"
        elif key == "dnsSuffix":
            suggest = "dns_suffix"
        elif key == "staticIpPools":
            suggest = "static_ip_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNetworkV2IpScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNetworkV2IpScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNetworkV2IpScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: str,
                 prefix_length: int,
                 dns1: Optional[str] = None,
                 dns2: Optional[str] = None,
                 dns_suffix: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 static_ip_pools: Optional[Sequence['outputs.ExternalNetworkV2IpScopeStaticIpPool']] = None):
        """
        :param str gateway: Gateway of the network
        :param int prefix_length: Network mask
        :param str dns1: Primary DNS server
        :param str dns2: Secondary DNS server
        :param str dns_suffix: DNS suffix
        :param bool enabled: If subnet is enabled
        :param Sequence['ExternalNetworkV2IpScopeStaticIpPoolArgs'] static_ip_pools: IP ranges used for static pool allocation in the network
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if dns1 is not None:
            pulumi.set(__self__, "dns1", dns1)
        if dns2 is not None:
            pulumi.set(__self__, "dns2", dns2)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if static_ip_pools is not None:
            pulumi.set(__self__, "static_ip_pools", static_ip_pools)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway of the network
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Network mask
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def dns1(self) -> Optional[str]:
        """
        Primary DNS server
        """
        return pulumi.get(self, "dns1")

    @property
    @pulumi.getter
    def dns2(self) -> Optional[str]:
        """
        Secondary DNS server
        """
        return pulumi.get(self, "dns2")

    @property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[str]:
        """
        DNS suffix
        """
        return pulumi.get(self, "dns_suffix")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If subnet is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="staticIpPools")
    def static_ip_pools(self) -> Optional[Sequence['outputs.ExternalNetworkV2IpScopeStaticIpPool']]:
        """
        IP ranges used for static pool allocation in the network
        """
        return pulumi.get(self, "static_ip_pools")


@pulumi.output_type
class ExternalNetworkV2IpScopeStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNetworkV2IpScopeStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNetworkV2IpScopeStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNetworkV2IpScopeStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class ExternalNetworkV2NsxtNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nsxtManagerId":
            suggest = "nsxt_manager_id"
        elif key == "nsxtSegmentName":
            suggest = "nsxt_segment_name"
        elif key == "nsxtTier0RouterId":
            suggest = "nsxt_tier0_router_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNetworkV2NsxtNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNetworkV2NsxtNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNetworkV2NsxtNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 nsxt_manager_id: str,
                 nsxt_segment_name: Optional[str] = None,
                 nsxt_tier0_router_id: Optional[str] = None):
        """
        :param str nsxt_manager_id: ID of NSX-T manager
        :param str nsxt_segment_name: Name of NSX-T segment (for NSX-T segment backed external network)
        :param str nsxt_tier0_router_id: ID of NSX-T Tier-0 router (for T0 gateway backed external network)
        """
        pulumi.set(__self__, "nsxt_manager_id", nsxt_manager_id)
        if nsxt_segment_name is not None:
            pulumi.set(__self__, "nsxt_segment_name", nsxt_segment_name)
        if nsxt_tier0_router_id is not None:
            pulumi.set(__self__, "nsxt_tier0_router_id", nsxt_tier0_router_id)

    @property
    @pulumi.getter(name="nsxtManagerId")
    def nsxt_manager_id(self) -> str:
        """
        ID of NSX-T manager
        """
        return pulumi.get(self, "nsxt_manager_id")

    @property
    @pulumi.getter(name="nsxtSegmentName")
    def nsxt_segment_name(self) -> Optional[str]:
        """
        Name of NSX-T segment (for NSX-T segment backed external network)
        """
        return pulumi.get(self, "nsxt_segment_name")

    @property
    @pulumi.getter(name="nsxtTier0RouterId")
    def nsxt_tier0_router_id(self) -> Optional[str]:
        """
        ID of NSX-T Tier-0 router (for T0 gateway backed external network)
        """
        return pulumi.get(self, "nsxt_tier0_router_id")


@pulumi.output_type
class ExternalNetworkV2VsphereNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portgroupId":
            suggest = "portgroup_id"
        elif key == "vcenterId":
            suggest = "vcenter_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalNetworkV2VsphereNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalNetworkV2VsphereNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalNetworkV2VsphereNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 portgroup_id: str,
                 vcenter_id: str):
        """
        :param str portgroup_id: The name of the port group
        :param str vcenter_id: The vCenter server name
        """
        pulumi.set(__self__, "portgroup_id", portgroup_id)
        pulumi.set(__self__, "vcenter_id", vcenter_id)

    @property
    @pulumi.getter(name="portgroupId")
    def portgroup_id(self) -> str:
        """
        The name of the port group
        """
        return pulumi.get(self, "portgroup_id")

    @property
    @pulumi.getter(name="vcenterId")
    def vcenter_id(self) -> str:
        """
        The vCenter server name
        """
        return pulumi.get(self, "vcenter_id")


@pulumi.output_type
class ExternalNetworkVsphereNetwork(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 vcenter: str):
        """
        :param str name: A unique name for the network
        :param str type: The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK
        :param str vcenter: The vCenter server name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vcenter", vcenter)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A unique name for the network
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def vcenter(self) -> str:
        """
        The vCenter server name
        """
        return pulumi.get(self, "vcenter")


@pulumi.output_type
class IndependentDiskMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndependentDiskMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndependentDiskMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndependentDiskMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpSpaceCustomQuotaIpPrefixQuota(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixLength":
            suggest = "prefix_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSpaceCustomQuotaIpPrefixQuota. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSpaceCustomQuotaIpPrefixQuota.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSpaceCustomQuotaIpPrefixQuota.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefix_length: str,
                 quota: str):
        """
        :param str prefix_length: Prefix length
        :param str quota: IP Prefix Quota
        """
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "quota", quota)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> str:
        """
        Prefix length
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def quota(self) -> str:
        """
        IP Prefix Quota
        """
        return pulumi.get(self, "quota")


@pulumi.output_type
class IpSpaceIpPrefix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultQuota":
            suggest = "default_quota"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSpaceIpPrefix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSpaceIpPrefix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSpaceIpPrefix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Sequence['outputs.IpSpaceIpPrefixPrefix'],
                 default_quota: Optional[str] = None):
        """
        :param Sequence['IpSpaceIpPrefixPrefixArgs'] prefixes: One or more prefixes
        :param str default_quota: Floating IP quota
        """
        pulumi.set(__self__, "prefixes", prefixes)
        if default_quota is not None:
            pulumi.set(__self__, "default_quota", default_quota)

    @property
    @pulumi.getter
    def prefixes(self) -> Sequence['outputs.IpSpaceIpPrefixPrefix']:
        """
        One or more prefixes
        """
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="defaultQuota")
    def default_quota(self) -> Optional[str]:
        """
        Floating IP quota
        """
        return pulumi.get(self, "default_quota")


@pulumi.output_type
class IpSpaceIpPrefixPrefix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstIp":
            suggest = "first_ip"
        elif key == "prefixCount":
            suggest = "prefix_count"
        elif key == "prefixLength":
            suggest = "prefix_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSpaceIpPrefixPrefix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSpaceIpPrefixPrefix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSpaceIpPrefixPrefix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 first_ip: str,
                 prefix_count: str,
                 prefix_length: str,
                 id: Optional[str] = None):
        """
        :param str first_ip: First IP
        :param str prefix_count: Number of prefixes to define
        :param str prefix_length: Prefix length
        :param str id: ID of IP Prefix
        """
        pulumi.set(__self__, "first_ip", first_ip)
        pulumi.set(__self__, "prefix_count", prefix_count)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="firstIp")
    def first_ip(self) -> str:
        """
        First IP
        """
        return pulumi.get(self, "first_ip")

    @property
    @pulumi.getter(name="prefixCount")
    def prefix_count(self) -> str:
        """
        Number of prefixes to define
        """
        return pulumi.get(self, "prefix_count")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> str:
        """
        Prefix length
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of IP Prefix
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class IpSpaceIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSpaceIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSpaceIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSpaceIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str,
                 id: Optional[str] = None):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        :param str id: ID of IP Range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of IP Range
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class LbServerPoolMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "monitorPort":
            suggest = "monitor_port"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "minConnections":
            suggest = "min_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbServerPoolMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbServerPoolMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbServerPoolMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: str,
                 ip_address: str,
                 monitor_port: int,
                 name: str,
                 port: int,
                 weight: int,
                 id: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 min_connections: Optional[int] = None):
        """
        :param str condition: Defines member state. One of enabled, drain, disabled.
        :param str ip_address: IP address of member in server pool
        :param int monitor_port: Port at which the member is to receive health monitor requests. Can be the same as port
        :param str name: Server Pool name
        :param int port: Port at which the member is to receive traffic from the load balancer
        :param int weight: Proportion of traffic this member is to handle. Must be an integer in the range 1-256
        :param str id: The NSX ID of the load balancer server pool
        :param int max_connections: The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released
        :param int min_connections: Minimum number of concurrent connections a member must always accept
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "monitor_port", monitor_port)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if min_connections is not None:
            pulumi.set(__self__, "min_connections", min_connections)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Defines member state. One of enabled, drain, disabled.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        IP address of member in server pool
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="monitorPort")
    def monitor_port(self) -> int:
        """
        Port at which the member is to receive health monitor requests. Can be the same as port
        """
        return pulumi.get(self, "monitor_port")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Server Pool name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port at which the member is to receive traffic from the load balancer
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Proportion of traffic this member is to handle. Must be an integer in the range 1-256
        """
        return pulumi.get(self, "weight")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The NSX ID of the load balancer server pool
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="minConnections")
    def min_connections(self) -> Optional[int]:
        """
        Minimum number of concurrent connections a member must always accept
        """
        return pulumi.get(self, "min_connections")


@pulumi.output_type
class NetworkDirectMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkDirectMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkDirectMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkDirectMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkIsolatedDhcpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"
        elif key == "defaultLeaseTime":
            suggest = "default_lease_time"
        elif key == "maxLeaseTime":
            suggest = "max_lease_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkIsolatedDhcpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkIsolatedDhcpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkIsolatedDhcpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str,
                 default_lease_time: Optional[int] = None,
                 max_lease_time: Optional[int] = None):
        """
        :param str end_address: The final address in the IP Range
        :param str start_address: The first address in the IP Range
        :param int default_lease_time: The default DHCP lease time to use
        :param int max_lease_time: The maximum DHCP lease time to use
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)
        if default_lease_time is not None:
            pulumi.set(__self__, "default_lease_time", default_lease_time)
        if max_lease_time is not None:
            pulumi.set(__self__, "max_lease_time", max_lease_time)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")

    @property
    @pulumi.getter(name="defaultLeaseTime")
    def default_lease_time(self) -> Optional[int]:
        """
        The default DHCP lease time to use
        """
        return pulumi.get(self, "default_lease_time")

    @property
    @pulumi.getter(name="maxLeaseTime")
    def max_lease_time(self) -> Optional[int]:
        """
        The maximum DHCP lease time to use
        """
        return pulumi.get(self, "max_lease_time")


@pulumi.output_type
class NetworkIsolatedMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkIsolatedMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkIsolatedMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkIsolatedMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkIsolatedStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkIsolatedStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkIsolatedStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkIsolatedStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: The final address in the IP Range
        :param str start_address: The first address in the IP Range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NetworkIsolatedV2MetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkIsolatedV2MetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkIsolatedV2MetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkIsolatedV2MetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkIsolatedV2SecondaryStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkIsolatedV2SecondaryStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkIsolatedV2SecondaryStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkIsolatedV2SecondaryStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NetworkIsolatedV2StaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkIsolatedV2StaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkIsolatedV2StaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkIsolatedV2StaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NetworkPoolBacking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distributedSwitch":
            suggest = "distributed_switch"
        elif key == "portGroups":
            suggest = "port_groups"
        elif key == "rangeIds":
            suggest = "range_ids"
        elif key == "transportZone":
            suggest = "transport_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPoolBacking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPoolBacking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPoolBacking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 distributed_switch: Optional['outputs.NetworkPoolBackingDistributedSwitch'] = None,
                 port_groups: Optional[Sequence['outputs.NetworkPoolBackingPortGroup']] = None,
                 range_ids: Optional[Sequence['outputs.NetworkPoolBackingRangeId']] = None,
                 transport_zone: Optional['outputs.NetworkPoolBackingTransportZone'] = None):
        """
        :param 'NetworkPoolBackingDistributedSwitchArgs' distributed_switch: (Optional) A backing structure used for `VLAN` network pool
        :param Sequence['NetworkPoolBackingPortGroupArgs'] port_groups: (Optional) A list of backing structure used for `PORTGROUP_BACKED` network pool
        :param Sequence['NetworkPoolBackingRangeIdArgs'] range_ids: (Optional) A list of range IDs, required with `VLAN` network pools
        :param 'NetworkPoolBackingTransportZoneArgs' transport_zone: (Optional) A backing structure used for `GENEVE` network pool
        """
        if distributed_switch is not None:
            pulumi.set(__self__, "distributed_switch", distributed_switch)
        if port_groups is not None:
            pulumi.set(__self__, "port_groups", port_groups)
        if range_ids is not None:
            pulumi.set(__self__, "range_ids", range_ids)
        if transport_zone is not None:
            pulumi.set(__self__, "transport_zone", transport_zone)

    @property
    @pulumi.getter(name="distributedSwitch")
    def distributed_switch(self) -> Optional['outputs.NetworkPoolBackingDistributedSwitch']:
        """
        (Optional) A backing structure used for `VLAN` network pool
        """
        return pulumi.get(self, "distributed_switch")

    @property
    @pulumi.getter(name="portGroups")
    def port_groups(self) -> Optional[Sequence['outputs.NetworkPoolBackingPortGroup']]:
        """
        (Optional) A list of backing structure used for `PORTGROUP_BACKED` network pool
        """
        return pulumi.get(self, "port_groups")

    @property
    @pulumi.getter(name="rangeIds")
    def range_ids(self) -> Optional[Sequence['outputs.NetworkPoolBackingRangeId']]:
        """
        (Optional) A list of range IDs, required with `VLAN` network pools
        """
        return pulumi.get(self, "range_ids")

    @property
    @pulumi.getter(name="transportZone")
    def transport_zone(self) -> Optional['outputs.NetworkPoolBackingTransportZone']:
        """
        (Optional) A backing structure used for `GENEVE` network pool
        """
        return pulumi.get(self, "transport_zone")


@pulumi.output_type
class NetworkPoolBackingDistributedSwitch(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: (Computed) The ID of the backing element
        :param str name: Unique name of network pool
        :param str type: Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Computed) The ID of the backing element
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique name of network pool
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkPoolBackingPortGroup(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: (Computed) The ID of the backing element
        :param str name: Unique name of network pool
        :param str type: Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Computed) The ID of the backing element
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique name of network pool
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkPoolBackingRangeId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endId":
            suggest = "end_id"
        elif key == "startId":
            suggest = "start_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkPoolBackingRangeId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkPoolBackingRangeId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkPoolBackingRangeId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_id: int,
                 start_id: int):
        """
        :param int end_id: (Required) The last ID of the range
        :param int start_id: (Required) The first ID of the range
        """
        pulumi.set(__self__, "end_id", end_id)
        pulumi.set(__self__, "start_id", start_id)

    @property
    @pulumi.getter(name="endId")
    def end_id(self) -> int:
        """
        (Required) The last ID of the range
        """
        return pulumi.get(self, "end_id")

    @property
    @pulumi.getter(name="startId")
    def start_id(self) -> int:
        """
        (Required) The first ID of the range
        """
        return pulumi.get(self, "start_id")


@pulumi.output_type
class NetworkPoolBackingTransportZone(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: (Computed) The ID of the backing element
        :param str name: Unique name of network pool
        :param str type: Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        (Computed) The ID of the backing element
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Unique name of network pool
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the network pool (one of `GENEVE`, `VLAN`, `PORTGROUP_BACKED`)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkRoutedDhcpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"
        elif key == "defaultLeaseTime":
            suggest = "default_lease_time"
        elif key == "maxLeaseTime":
            suggest = "max_lease_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkRoutedDhcpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkRoutedDhcpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkRoutedDhcpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str,
                 default_lease_time: Optional[int] = None,
                 max_lease_time: Optional[int] = None):
        """
        :param str end_address: The final address in the IP Range
        :param str start_address: The first address in the IP Range
        :param int default_lease_time: The default DHCP lease time to use
        :param int max_lease_time: The maximum DHCP lease time to use
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)
        if default_lease_time is not None:
            pulumi.set(__self__, "default_lease_time", default_lease_time)
        if max_lease_time is not None:
            pulumi.set(__self__, "max_lease_time", max_lease_time)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")

    @property
    @pulumi.getter(name="defaultLeaseTime")
    def default_lease_time(self) -> Optional[int]:
        """
        The default DHCP lease time to use
        """
        return pulumi.get(self, "default_lease_time")

    @property
    @pulumi.getter(name="maxLeaseTime")
    def max_lease_time(self) -> Optional[int]:
        """
        The maximum DHCP lease time to use
        """
        return pulumi.get(self, "max_lease_time")


@pulumi.output_type
class NetworkRoutedMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkRoutedMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkRoutedMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkRoutedMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkRoutedStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkRoutedStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkRoutedStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkRoutedStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: The final address in the IP Range
        :param str start_address: The first address in the IP Range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NetworkRoutedV2MetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkRoutedV2MetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkRoutedV2MetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkRoutedV2MetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkRoutedV2SecondaryStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkRoutedV2SecondaryStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkRoutedV2SecondaryStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkRoutedV2SecondaryStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NetworkRoutedV2StaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkRoutedV2StaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkRoutedV2StaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkRoutedV2StaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NsxtAlbPoolHealthMonitor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "systemDefined":
            suggest = "system_defined"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbPoolHealthMonitor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbPoolHealthMonitor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbPoolHealthMonitor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 system_defined: Optional[bool] = None):
        """
        :param str type: Type of health monitor. One of `HTTP`, `HTTPS`, `TCP`, `UDP`, `PING`
        :param str name: A name for ALB Pool
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if system_defined is not None:
            pulumi.set(__self__, "system_defined", system_defined)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of health monitor. One of `HTTP`, `HTTPS`, `TCP`, `UDP`, `PING`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A name for ALB Pool
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemDefined")
    def system_defined(self) -> Optional[bool]:
        return pulumi.get(self, "system_defined")


@pulumi.output_type
class NsxtAlbPoolMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "detailedHealthMessage":
            suggest = "detailed_health_message"
        elif key == "healthStatus":
            suggest = "health_status"
        elif key == "markedDownBies":
            suggest = "marked_down_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbPoolMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbPoolMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbPoolMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: str,
                 detailed_health_message: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 health_status: Optional[str] = None,
                 marked_down_bies: Optional[Sequence[str]] = None,
                 port: Optional[int] = None,
                 ratio: Optional[int] = None):
        """
        :param str ip_address: IP address of pool member
        :param str detailed_health_message: Detailed health message
        :param bool enabled: Boolean value if ALB Pool should be enabled (default `true`)
        :param str health_status: Health status
        :param Sequence[str] marked_down_bies: Marked down by provides a set of health monitors that marked the service down
        :param int port: Member port
        :param int ratio: Ratio of selecting eligible servers in the pool
        """
        pulumi.set(__self__, "ip_address", ip_address)
        if detailed_health_message is not None:
            pulumi.set(__self__, "detailed_health_message", detailed_health_message)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if health_status is not None:
            pulumi.set(__self__, "health_status", health_status)
        if marked_down_bies is not None:
            pulumi.set(__self__, "marked_down_bies", marked_down_bies)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        IP address of pool member
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="detailedHealthMessage")
    def detailed_health_message(self) -> Optional[str]:
        """
        Detailed health message
        """
        return pulumi.get(self, "detailed_health_message")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Boolean value if ALB Pool should be enabled (default `true`)
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="healthStatus")
    def health_status(self) -> Optional[str]:
        """
        Health status
        """
        return pulumi.get(self, "health_status")

    @property
    @pulumi.getter(name="markedDownBies")
    def marked_down_bies(self) -> Optional[Sequence[str]]:
        """
        Marked down by provides a set of health monitors that marked the service down
        """
        return pulumi.get(self, "marked_down_bies")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Member port
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ratio(self) -> Optional[int]:
        """
        Ratio of selecting eligible servers in the pool
        """
        return pulumi.get(self, "ratio")


@pulumi.output_type
class NsxtAlbPoolPersistenceProfile(dict):
    def __init__(__self__, *,
                 type: str,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str type: Type of persistence strategy. One of `CLIENT_IP`, `HTTP_COOKIE`, `CUSTOM_HTTP_HEADER`, `APP_COOKIE`, `TLS`
        :param str name: A name for ALB Pool
        :param str value: Value of attribute based on persistence type
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of persistence strategy. One of `CLIENT_IP`, `HTTP_COOKIE`, `CUSTOM_HTTP_HEADER`, `APP_COOKIE`, `TLS`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A name for ALB Pool
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of attribute based on persistence type
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchCriteria":
            suggest = "match_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpReqRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: 'outputs.NsxtAlbVirtualServiceHttpReqRulesRuleActions',
                 match_criteria: 'outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria',
                 name: str,
                 active: Optional[bool] = None,
                 logging: Optional[bool] = None):
        """
        :param 'NsxtAlbVirtualServiceHttpReqRulesRuleActionsArgs' actions: Actions to perform with the rule that matches
        :param 'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgs' match_criteria: Rule matching Criteria
        :param str name: Name of the rule
        :param bool active: Defines if the rule is active or not
        :param bool logging: Defines whether to enable logging with headers on rule match or not
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_criteria", match_criteria)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @property
    @pulumi.getter
    def actions(self) -> 'outputs.NsxtAlbVirtualServiceHttpReqRulesRuleActions':
        """
        Actions to perform with the rule that matches
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> 'outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria':
        """
        Rule matching Criteria
        """
        return pulumi.get(self, "match_criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        Defines if the rule is active or not
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def logging(self) -> Optional[bool]:
        """
        Defines whether to enable logging with headers on rule match or not
        """
        return pulumi.get(self, "logging")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modifyHeaders":
            suggest = "modify_headers"
        elif key == "rewriteUrl":
            suggest = "rewrite_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpReqRulesRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modify_headers: Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeader']] = None,
                 redirect: Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect'] = None,
                 rewrite_url: Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl'] = None):
        """
        :param Sequence['NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeaderArgs'] modify_headers: A set of header modification rules
        :param 'NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirectArgs' redirect: Redirect request
        :param 'NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrlArgs' rewrite_url: URL rewrite rules
        """
        if modify_headers is not None:
            pulumi.set(__self__, "modify_headers", modify_headers)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if rewrite_url is not None:
            pulumi.set(__self__, "rewrite_url", rewrite_url)

    @property
    @pulumi.getter(name="modifyHeaders")
    def modify_headers(self) -> Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeader']]:
        """
        A set of header modification rules
        """
        return pulumi.get(self, "modify_headers")

    @property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect']:
        """
        Redirect request
        """
        return pulumi.get(self, "redirect")

    @property
    @pulumi.getter(name="rewriteUrl")
    def rewrite_url(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl']:
        """
        URL rewrite rules
        """
        return pulumi.get(self, "rewrite_url")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleActionsModifyHeader(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        :param str name: HTTP header name
        :param str value: HTTP header value
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        HTTP header name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        HTTP header value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"
        elif key == "keepQuery":
            suggest = "keep_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleActionsRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 status_code: int,
                 host: Optional[str] = None,
                 keep_query: Optional[bool] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None):
        """
        :param str protocol: HTTP or HTTPS protocol
        :param int status_code: One of the redirect status codes - 301, 302, 307
        :param str host: Host to which redirect the request
        :param bool keep_query: Should the query part be preserved
        :param str path: Path to which redirect the request
        :param str port: Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol
        """
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "status_code", status_code)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_query is not None:
            pulumi.set(__self__, "keep_query", keep_query)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        HTTP or HTTPS protocol
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        One of the redirect status codes - 301, 302, 307
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host to which redirect the request
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> Optional[bool]:
        """
        Should the query part be preserved
        """
        return pulumi.get(self, "keep_query")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to which redirect the request
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "existingPath":
            suggest = "existing_path"
        elif key == "hostHeader":
            suggest = "host_header"
        elif key == "keepQuery":
            suggest = "keep_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleActionsRewriteUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 existing_path: str,
                 host_header: str,
                 keep_query: Optional[bool] = None,
                 query: Optional[str] = None):
        """
        :param str existing_path: Path to use for the rewritten URL
        :param str host_header: Host to use for the rewritten URL
        :param bool keep_query: Whether or not to keep the existing query string when rewriting the URL
        :param str query: Query string to use or append to the existing query string in the rewritten URL
        """
        pulumi.set(__self__, "existing_path", existing_path)
        pulumi.set(__self__, "host_header", host_header)
        if keep_query is not None:
            pulumi.set(__self__, "keep_query", keep_query)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="existingPath")
    def existing_path(self) -> str:
        """
        Path to use for the rewritten URL
        """
        return pulumi.get(self, "existing_path")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        Host to use for the rewritten URL
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> Optional[bool]:
        """
        Whether or not to keep the existing query string when rewriting the URL
        """
        return pulumi.get(self, "keep_query")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Query string to use or append to the existing query string in the rewritten URL
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIpAddress":
            suggest = "client_ip_address"
        elif key == "httpMethods":
            suggest = "http_methods"
        elif key == "protocolType":
            suggest = "protocol_type"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "servicePorts":
            suggest = "service_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_ip_address: Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress'] = None,
                 cookie: Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie'] = None,
                 http_methods: Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethods'] = None,
                 path: Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath'] = None,
                 protocol_type: Optional[str] = None,
                 queries: Optional[Sequence[str]] = None,
                 request_headers: Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader']] = None,
                 service_ports: Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePorts'] = None):
        """
        :param 'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgs' client_ip_address: Client IP Address criteria
        :param 'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgs' cookie: Criteria for matching cookie
        :param 'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodsArgs' http_methods: HTTP methods that should be matched
        :param 'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgs' path: Request path criteria
        :param str protocol_type: Protocol to match - 'HTTP' or 'HTTPS'
        :param Sequence[str] queries: HTTP request query strings to match
        :param Sequence['NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgs'] request_headers: A set of rules for matching request headers
        :param 'NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortsArgs' service_ports: Service Port criteria
        """
        if client_ip_address is not None:
            pulumi.set(__self__, "client_ip_address", client_ip_address)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if service_ports is not None:
            pulumi.set(__self__, "service_ports", service_ports)

    @property
    @pulumi.getter(name="clientIpAddress")
    def client_ip_address(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress']:
        """
        Client IP Address criteria
        """
        return pulumi.get(self, "client_ip_address")

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie']:
        """
        Criteria for matching cookie
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethods']:
        """
        HTTP methods that should be matched
        """
        return pulumi.get(self, "http_methods")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath']:
        """
        Request path criteria
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[str]:
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence[str]]:
        """
        HTTP request query strings to match
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader']]:
        """
        A set of rules for matching request headers
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePorts']:
        """
        Service Port criteria
        """
        return pulumi.get(self, "service_ports")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 criteria: str,
                 ip_addresses: Sequence[str]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        :param Sequence[str] ip_addresses: A set of IP addresses
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A set of IP addresses
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookie(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 value: str):
        """
        :param str criteria: Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param str name: Name of the HTTP cookie whose value is to be matched
        :param str value: String values to match for an HTTP cookie
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP cookie whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        String values to match for an HTTP cookie
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethods(dict):
    def __init__(__self__, *,
                 criteria: str,
                 methods: Sequence[str]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param Sequence[str] methods: HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        return pulumi.get(self, "methods")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPath(dict):
    def __init__(__self__, *,
                 criteria: str,
                 paths: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        :param Sequence[str] paths: String values to match the path
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        String values to match the path
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeader(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 values: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param str name: Name of the HTTP header whose value is to be matched
        :param Sequence[str] values: String values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        String values to match for an HTTP header
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePorts(dict):
    def __init__(__self__, *,
                 criteria: str,
                 ports: Sequence[int]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param Sequence[int] ports: A set of TCP ports. Allowed values are 1-65535
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        A set of TCP ports. Allowed values are 1-65535
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchCriteria":
            suggest = "match_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpRespRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: 'outputs.NsxtAlbVirtualServiceHttpRespRulesRuleActions',
                 match_criteria: 'outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria',
                 name: str,
                 active: Optional[bool] = None,
                 logging: Optional[bool] = None):
        """
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleActionsArgs' actions: Actions to perform with the rule that matches
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgs' match_criteria: Rule matching Criteria
        :param str name: Name of the rule
        :param bool active: Defines if the rule is active or not
        :param bool logging: Defines whether to enable logging with headers on rule match or not
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_criteria", match_criteria)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @property
    @pulumi.getter
    def actions(self) -> 'outputs.NsxtAlbVirtualServiceHttpRespRulesRuleActions':
        """
        Actions to perform with the rule that matches
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> 'outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria':
        """
        Rule matching Criteria
        """
        return pulumi.get(self, "match_criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        Defines if the rule is active or not
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def logging(self) -> Optional[bool]:
        """
        Defines whether to enable logging with headers on rule match or not
        """
        return pulumi.get(self, "logging")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modifyHeaders":
            suggest = "modify_headers"
        elif key == "rewriteLocationHeader":
            suggest = "rewrite_location_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpRespRulesRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modify_headers: Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeader']] = None,
                 rewrite_location_header: Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader'] = None):
        """
        :param Sequence['NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeaderArgs'] modify_headers: Modify header
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeaderArgs' rewrite_location_header: Rewrite location header
        """
        if modify_headers is not None:
            pulumi.set(__self__, "modify_headers", modify_headers)
        if rewrite_location_header is not None:
            pulumi.set(__self__, "rewrite_location_header", rewrite_location_header)

    @property
    @pulumi.getter(name="modifyHeaders")
    def modify_headers(self) -> Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeader']]:
        """
        Modify header
        """
        return pulumi.get(self, "modify_headers")

    @property
    @pulumi.getter(name="rewriteLocationHeader")
    def rewrite_location_header(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader']:
        """
        Rewrite location header
        """
        return pulumi.get(self, "rewrite_location_header")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleActionsModifyHeader(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: Optional[str] = None):
        """
        :param str action: One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        :param str name: HTTP header name
        :param str value: HTTP header value
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        One of the following HTTP header actions. Options - ADD, REMOVE, REPLACE
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        HTTP header name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        HTTP header value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepQuery":
            suggest = "keep_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleActionsRewriteLocationHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: str,
                 protocol: str,
                 host: Optional[str] = None,
                 keep_query: Optional[bool] = None,
                 path: Optional[str] = None):
        """
        :param str port: Port to which redirect the request
        :param str protocol: HTTP or HTTPS protocol
        :param str host: Host to which redirect the request
        :param bool keep_query: Should the query part be preserved
        :param str path: Path to which redirect the request
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_query is not None:
            pulumi.set(__self__, "keep_query", keep_query)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Port to which redirect the request
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        HTTP or HTTPS protocol
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host to which redirect the request
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> Optional[bool]:
        """
        Should the query part be preserved
        """
        return pulumi.get(self, "keep_query")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to which redirect the request
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIpAddress":
            suggest = "client_ip_address"
        elif key == "httpMethods":
            suggest = "http_methods"
        elif key == "locationHeader":
            suggest = "location_header"
        elif key == "protocolType":
            suggest = "protocol_type"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "responseHeaders":
            suggest = "response_headers"
        elif key == "servicePorts":
            suggest = "service_ports"
        elif key == "statusCode":
            suggest = "status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_ip_address: Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress'] = None,
                 cookie: Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie'] = None,
                 http_methods: Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethods'] = None,
                 location_header: Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader'] = None,
                 path: Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath'] = None,
                 protocol_type: Optional[str] = None,
                 queries: Optional[Sequence[str]] = None,
                 request_headers: Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader']] = None,
                 response_headers: Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader']] = None,
                 service_ports: Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePorts'] = None,
                 status_code: Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode'] = None):
        """
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgs' client_ip_address: Client IP Address criteria
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgs' cookie: Criteria for matching cookie
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodsArgs' http_methods: HTTP methods that should be matched
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgs' location_header: A matching criteria for Location header
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgs' path: Request path criteria
        :param str protocol_type: Protocol to match - 'HTTP' or 'HTTPS'
        :param Sequence[str] queries: HTTP request query strings to match
        :param Sequence['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgs'] request_headers: A set of rules for matching request headers
        :param Sequence['NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgs'] response_headers: A set of criteria to match response headers
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortsArgs' service_ports: Service Port criteria
        :param 'NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgs' status_code: HTTP Status code to match
        """
        if client_ip_address is not None:
            pulumi.set(__self__, "client_ip_address", client_ip_address)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if location_header is not None:
            pulumi.set(__self__, "location_header", location_header)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)
        if service_ports is not None:
            pulumi.set(__self__, "service_ports", service_ports)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter(name="clientIpAddress")
    def client_ip_address(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress']:
        """
        Client IP Address criteria
        """
        return pulumi.get(self, "client_ip_address")

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie']:
        """
        Criteria for matching cookie
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethods']:
        """
        HTTP methods that should be matched
        """
        return pulumi.get(self, "http_methods")

    @property
    @pulumi.getter(name="locationHeader")
    def location_header(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader']:
        """
        A matching criteria for Location header
        """
        return pulumi.get(self, "location_header")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath']:
        """
        Request path criteria
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[str]:
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence[str]]:
        """
        HTTP request query strings to match
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader']]:
        """
        A set of rules for matching request headers
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader']]:
        """
        A set of criteria to match response headers
        """
        return pulumi.get(self, "response_headers")

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePorts']:
        """
        Service Port criteria
        """
        return pulumi.get(self, "service_ports")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode']:
        """
        HTTP Status code to match
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 criteria: str,
                 ip_addresses: Sequence[str]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        :param Sequence[str] ip_addresses: A set of IP addresses
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A set of IP addresses
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookie(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 value: str):
        """
        :param str criteria: Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param str name: Name of the HTTP cookie whose value is to be matched
        :param str value: String values to match for an HTTP cookie
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP cookie whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        String values to match for an HTTP cookie
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethods(dict):
    def __init__(__self__, *,
                 criteria: str,
                 methods: Sequence[str]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param Sequence[str] methods: HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        return pulumi.get(self, "methods")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeader(dict):
    def __init__(__self__, *,
                 criteria: str,
                 values: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching location header. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        :param Sequence[str] values: A set of values to match for criteria
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching location header. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A set of values to match for criteria
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPath(dict):
    def __init__(__self__, *,
                 criteria: str,
                 paths: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        :param Sequence[str] paths: String values to match the path
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        String values to match the path
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeader(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 values: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param str name: Name of the HTTP header whose value is to be matched
        :param Sequence[str] values: String values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        String values to match for an HTTP header
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeader(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str criteria: Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param str name: Name of the HTTP header whose value is to be matched
        :param Sequence[str] values: A set of values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        A set of values to match for an HTTP header
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePorts(dict):
    def __init__(__self__, *,
                 criteria: str,
                 ports: Sequence[int]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param Sequence[int] ports: A set of TCP ports. Allowed values are 1-65535
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        A set of TCP ports. Allowed values are 1-65535
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpStatusCode":
            suggest = "http_status_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 criteria: str,
                 http_status_code: str):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        :param str http_status_code: Enter a http status code or range
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "http_status_code", http_status_code)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="httpStatusCode")
    def http_status_code(self) -> str:
        """
        Enter a http status code or range
        """
        return pulumi.get(self, "http_status_code")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchCriteria":
            suggest = "match_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpSecRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: 'outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActions',
                 match_criteria: 'outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria',
                 name: str,
                 active: Optional[bool] = None,
                 logging: Optional[bool] = None):
        """
        :param 'NsxtAlbVirtualServiceHttpSecRulesRuleActionsArgs' actions: Actions to perform with the rule that matches
        :param 'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgs' match_criteria: Rule matching Criteria
        :param str name: Name of the rule
        :param bool active: Defines is the rule is active or not
        :param bool logging: Defines whether to enable logging with headers on rule match or not
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_criteria", match_criteria)
        pulumi.set(__self__, "name", name)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)

    @property
    @pulumi.getter
    def actions(self) -> 'outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActions':
        """
        Actions to perform with the rule that matches
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> 'outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria':
        """
        Rule matching Criteria
        """
        return pulumi.get(self, "match_criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        """
        Defines is the rule is active or not
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def logging(self) -> Optional[bool]:
        """
        Defines whether to enable logging with headers on rule match or not
        """
        return pulumi.get(self, "logging")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rateLimit":
            suggest = "rate_limit"
        elif key == "redirectToHttps":
            suggest = "redirect_to_https"
        elif key == "sendResponse":
            suggest = "send_response"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpSecRulesRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connections: Optional[str] = None,
                 rate_limit: Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit'] = None,
                 redirect_to_https: Optional[str] = None,
                 send_response: Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse'] = None):
        """
        :param str connections: ALLOW or CLOSE connections
        :param 'NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitArgs' rate_limit: Apply actions based on rate limits
        :param str redirect_to_https: Port number that should be redirected to HTTPS
        :param 'NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponseArgs' send_response: Send custom response
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if redirect_to_https is not None:
            pulumi.set(__self__, "redirect_to_https", redirect_to_https)
        if send_response is not None:
            pulumi.set(__self__, "send_response", send_response)

    @property
    @pulumi.getter
    def connections(self) -> Optional[str]:
        """
        ALLOW or CLOSE connections
        """
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit']:
        """
        Apply actions based on rate limits
        """
        return pulumi.get(self, "rate_limit")

    @property
    @pulumi.getter(name="redirectToHttps")
    def redirect_to_https(self) -> Optional[str]:
        """
        Port number that should be redirected to HTTPS
        """
        return pulumi.get(self, "redirect_to_https")

    @property
    @pulumi.getter(name="sendResponse")
    def send_response(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse']:
        """
        Send custom response
        """
        return pulumi.get(self, "send_response")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionCloseConnection":
            suggest = "action_close_connection"
        elif key == "actionLocalResponses":
            suggest = "action_local_responses"
        elif key == "actionRedirects":
            suggest = "action_redirects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: str,
                 period: str,
                 action_close_connection: Optional[bool] = None,
                 action_local_responses: Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse']] = None,
                 action_redirects: Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect']] = None):
        """
        :param str count: Maximum number of connections, requests or packets permitted each period. The count must be between 1 and 1000000000
        :param str period: Time value in seconds to enforce rate count. The period must be between 1 and 1000000000
        :param bool action_close_connection: Set to true if the connection should be closed
        :param Sequence['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponseArgs'] action_local_responses: Send custom response
        :param Sequence['NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirectArgs'] action_redirects: Redirect based on rate limits
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "period", period)
        if action_close_connection is not None:
            pulumi.set(__self__, "action_close_connection", action_close_connection)
        if action_local_responses is not None:
            pulumi.set(__self__, "action_local_responses", action_local_responses)
        if action_redirects is not None:
            pulumi.set(__self__, "action_redirects", action_redirects)

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        Maximum number of connections, requests or packets permitted each period. The count must be between 1 and 1000000000
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def period(self) -> str:
        """
        Time value in seconds to enforce rate count. The period must be between 1 and 1000000000
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="actionCloseConnection")
    def action_close_connection(self) -> Optional[bool]:
        """
        Set to true if the connection should be closed
        """
        return pulumi.get(self, "action_close_connection")

    @property
    @pulumi.getter(name="actionLocalResponses")
    def action_local_responses(self) -> Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse']]:
        """
        Send custom response
        """
        return pulumi.get(self, "action_local_responses")

    @property
    @pulumi.getter(name="actionRedirects")
    def action_redirects(self) -> Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect']]:
        """
        Redirect based on rate limits
        """
        return pulumi.get(self, "action_redirects")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"
        elif key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionLocalResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: str,
                 content: Optional[str] = None,
                 content_type: Optional[str] = None):
        """
        :param str status_code: HTTP Status code to send
        :param str content: Base64 encoded content
        :param str content_type: MIME type for the content
        """
        pulumi.set(__self__, "status_code", status_code)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        """
        HTTP Status code to send
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Base64 encoded content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        MIME type for the content
        """
        return pulumi.get(self, "content_type")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"
        elif key == "keepQuery":
            suggest = "keep_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActionsRateLimitActionRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: str,
                 protocol: str,
                 status_code: int,
                 host: Optional[str] = None,
                 keep_query: Optional[bool] = None,
                 path: Optional[str] = None):
        """
        :param str port: Port to which redirect the request
        :param str protocol: HTTP or HTTPS protocol
        :param int status_code: One of the redirect status codes - 301, 302, 307
        :param str host: Host to which redirect the request
        :param bool keep_query: Should the query part be preserved
        :param str path: Path to which redirect the request
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "status_code", status_code)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if keep_query is not None:
            pulumi.set(__self__, "keep_query", keep_query)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Port to which redirect the request
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        HTTP or HTTPS protocol
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        One of the redirect status codes - 301, 302, 307
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host to which redirect the request
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> Optional[bool]:
        """
        Should the query part be preserved
        """
        return pulumi.get(self, "keep_query")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to which redirect the request
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "statusCode":
            suggest = "status_code"
        elif key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleActionsSendResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status_code: str,
                 content: Optional[str] = None,
                 content_type: Optional[str] = None):
        """
        :param str status_code: HTTP Status code to send
        :param str content: Base64 encoded content
        :param str content_type: MIME type for the content
        """
        pulumi.set(__self__, "status_code", status_code)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        """
        HTTP Status code to send
        """
        return pulumi.get(self, "status_code")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Base64 encoded content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        MIME type for the content
        """
        return pulumi.get(self, "content_type")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIpAddress":
            suggest = "client_ip_address"
        elif key == "httpMethods":
            suggest = "http_methods"
        elif key == "protocolType":
            suggest = "protocol_type"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "servicePorts":
            suggest = "service_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_ip_address: Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress'] = None,
                 cookie: Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie'] = None,
                 http_methods: Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethods'] = None,
                 path: Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath'] = None,
                 protocol_type: Optional[str] = None,
                 queries: Optional[Sequence[str]] = None,
                 request_headers: Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader']] = None,
                 service_ports: Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePorts'] = None):
        """
        :param 'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgs' client_ip_address: Client IP Address criteria
        :param 'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgs' cookie: Criteria for matching cookie
        :param 'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodsArgs' http_methods: HTTP methods that should be matched
        :param 'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgs' path: Request path criteria
        :param str protocol_type: Protocol to match - 'HTTP' or 'HTTPS'
        :param Sequence[str] queries: HTTP request query strings to match
        :param Sequence['NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgs'] request_headers: A set of rules for matching request headers
        :param 'NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortsArgs' service_ports: Service Port criteria
        """
        if client_ip_address is not None:
            pulumi.set(__self__, "client_ip_address", client_ip_address)
        if cookie is not None:
            pulumi.set(__self__, "cookie", cookie)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol_type is not None:
            pulumi.set(__self__, "protocol_type", protocol_type)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if service_ports is not None:
            pulumi.set(__self__, "service_ports", service_ports)

    @property
    @pulumi.getter(name="clientIpAddress")
    def client_ip_address(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress']:
        """
        Client IP Address criteria
        """
        return pulumi.get(self, "client_ip_address")

    @property
    @pulumi.getter
    def cookie(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie']:
        """
        Criteria for matching cookie
        """
        return pulumi.get(self, "cookie")

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethods']:
        """
        HTTP methods that should be matched
        """
        return pulumi.get(self, "http_methods")

    @property
    @pulumi.getter
    def path(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath']:
        """
        Request path criteria
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> Optional[str]:
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence[str]]:
        """
        HTTP request query strings to match
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Sequence['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader']]:
        """
        A set of rules for matching request headers
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Optional['outputs.NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePorts']:
        """
        Service Port criteria
        """
        return pulumi.get(self, "service_ports")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 criteria: str,
                 ip_addresses: Sequence[str]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        :param Sequence[str] ip_addresses: A set of IP addresses
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN.
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A set of IP addresses
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookie(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 value: str):
        """
        :param str criteria: Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param str name: Name of the HTTP cookie whose value is to be matched
        :param str value: String values to match for an HTTP cookie
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching cookies in the HTTP request. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP cookie whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        String values to match for an HTTP cookie
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethods(dict):
    def __init__(__self__, *,
                 criteria: str,
                 methods: Sequence[str]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param Sequence[str] methods: HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        HTTP methods to match. Options - GET, PUT, POST, DELETE, HEAD, OPTIONS, TRACE, CONNECT, PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK
        """
        return pulumi.get(self, "methods")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPath(dict):
    def __init__(__self__, *,
                 criteria: str,
                 paths: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        :param Sequence[str] paths: String values to match the path
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching the path in the HTTP request URI. Options - BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL, REGEX_MATCH, REGEX_DOES_NOT_MATCH
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        String values to match the path
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeader(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 values: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        :param str name: Name of the HTTP header whose value is to be matched
        :param Sequence[str] values: String values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response. Options - EXISTS, DOES_NOT_EXIST, BEGINS_WITH, DOES_NOT_BEGIN_WITH, CONTAINS, DOES_NOT_CONTAIN, ENDS_WITH, DOES_NOT_END_WITH, EQUALS, DOES_NOT_EQUAL
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        String values to match for an HTTP header
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class NsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePorts(dict):
    def __init__(__self__, *,
                 criteria: str,
                 ports: Sequence[int]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        :param Sequence[int] ports: A set of TCP ports. Allowed values are 1-65535
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request. Options - IS_IN, IS_NOT_IN
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        A set of TCP ports. Allowed values are 1-65535
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NsxtAlbVirtualServiceServicePort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startPort":
            suggest = "start_port"
        elif key == "endPort":
            suggest = "end_port"
        elif key == "sslEnabled":
            suggest = "ssl_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtAlbVirtualServiceServicePort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtAlbVirtualServiceServicePort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtAlbVirtualServiceServicePort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_port: int,
                 type: str,
                 end_port: Optional[int] = None,
                 ssl_enabled: Optional[bool] = None):
        """
        :param int start_port: Starting port in the range
        :param str type: One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'
        :param int end_port: Last port in the range
        :param bool ssl_enabled: Defines if certificate should be used
        """
        pulumi.set(__self__, "start_port", start_port)
        pulumi.set(__self__, "type", type)
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if ssl_enabled is not None:
            pulumi.set(__self__, "ssl_enabled", ssl_enabled)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> int:
        """
        Starting port in the range
        """
        return pulumi.get(self, "start_port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[int]:
        """
        Last port in the range
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter(name="sslEnabled")
    def ssl_enabled(self) -> Optional[bool]:
        """
        Defines if certificate should be used
        """
        return pulumi.get(self, "ssl_enabled")


@pulumi.output_type
class NsxtAppPortProfileAppPort(dict):
    def __init__(__self__, *,
                 protocol: str,
                 ports: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] ports: Set of ports or ranges
        """
        pulumi.set(__self__, "protocol", protocol)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[str]]:
        """
        Set of ports or ranges
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class NsxtDistributedFirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appPortProfileIds":
            suggest = "app_port_profile_ids"
        elif key == "destinationGroupsExcluded":
            suggest = "destination_groups_excluded"
        elif key == "destinationIds":
            suggest = "destination_ids"
        elif key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "networkContextProfileIds":
            suggest = "network_context_profile_ids"
        elif key == "sourceGroupsExcluded":
            suggest = "source_groups_excluded"
        elif key == "sourceIds":
            suggest = "source_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtDistributedFirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtDistributedFirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtDistributedFirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 name: str,
                 app_port_profile_ids: Optional[Sequence[str]] = None,
                 comment: Optional[str] = None,
                 description: Optional[str] = None,
                 destination_groups_excluded: Optional[bool] = None,
                 destination_ids: Optional[Sequence[str]] = None,
                 direction: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 ip_protocol: Optional[str] = None,
                 logging: Optional[bool] = None,
                 network_context_profile_ids: Optional[Sequence[str]] = None,
                 source_groups_excluded: Optional[bool] = None,
                 source_ids: Optional[Sequence[str]] = None):
        """
        :param str action: Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic
        :param str name: Firewall Rule name
        :param Sequence[str] app_port_profile_ids: A set of Application Port Profile IDs. Leaving it empty means 'Any'
        :param str comment: Comment that is shown next to rule in UI (VCD 10.3.2+)
        :param str description: Description is not shown in UI
        :param bool destination_groups_excluded: Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)
        :param Sequence[str] destination_ids: A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        :param str direction: Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        :param bool enabled: Defined if Firewall Rule is active
        :param str id: Firewall Rule ID
        :param str ip_protocol: Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        :param bool logging: Defines if matching traffic should be logged
        :param Sequence[str] network_context_profile_ids: A set of Network Context Profile IDs. Leaving it empty means 'Any'
        :param bool source_groups_excluded: Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)
        :param Sequence[str] source_ids: A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if app_port_profile_ids is not None:
            pulumi.set(__self__, "app_port_profile_ids", app_port_profile_ids)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_groups_excluded is not None:
            pulumi.set(__self__, "destination_groups_excluded", destination_groups_excluded)
        if destination_ids is not None:
            pulumi.set(__self__, "destination_ids", destination_ids)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if network_context_profile_ids is not None:
            pulumi.set(__self__, "network_context_profile_ids", network_context_profile_ids)
        if source_groups_excluded is not None:
            pulumi.set(__self__, "source_groups_excluded", source_groups_excluded)
        if source_ids is not None:
            pulumi.set(__self__, "source_ids", source_ids)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="appPortProfileIds")
    def app_port_profile_ids(self) -> Optional[Sequence[str]]:
        """
        A set of Application Port Profile IDs. Leaving it empty means 'Any'
        """
        return pulumi.get(self, "app_port_profile_ids")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Comment that is shown next to rule in UI (VCD 10.3.2+)
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description is not shown in UI
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationGroupsExcluded")
    def destination_groups_excluded(self) -> Optional[bool]:
        """
        Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)
        """
        return pulumi.get(self, "destination_groups_excluded")

    @property
    @pulumi.getter(name="destinationIds")
    def destination_ids(self) -> Optional[Sequence[str]]:
        """
        A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "destination_ids")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Defined if Firewall Rule is active
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Firewall Rule ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[str]:
        """
        Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        """
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter
    def logging(self) -> Optional[bool]:
        """
        Defines if matching traffic should be logged
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="networkContextProfileIds")
    def network_context_profile_ids(self) -> Optional[Sequence[str]]:
        """
        A set of Network Context Profile IDs. Leaving it empty means 'Any'
        """
        return pulumi.get(self, "network_context_profile_ids")

    @property
    @pulumi.getter(name="sourceGroupsExcluded")
    def source_groups_excluded(self) -> Optional[bool]:
        """
        Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)
        """
        return pulumi.get(self, "source_groups_excluded")

    @property
    @pulumi.getter(name="sourceIds")
    def source_ids(self) -> Optional[Sequence[str]]:
        """
        A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "source_ids")


@pulumi.output_type
class NsxtDynamicSecurityGroupCriteria(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.NsxtDynamicSecurityGroupCriteriaRule']] = None):
        """
        :param Sequence['NsxtDynamicSecurityGroupCriteriaRuleArgs'] rules: Up to 4 rules for matching VMs. List of rules are matched with boolean `AND`
               operation and all defines rules must match to include object. See Rule for rule
               definition structure.
               
               
               <a id="rule"></a>
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.NsxtDynamicSecurityGroupCriteriaRule']]:
        """
        Up to 4 rules for matching VMs. List of rules are matched with boolean `AND`
        operation and all defines rules must match to include object. See Rule for rule
        definition structure.


        <a id="rule"></a>
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class NsxtDynamicSecurityGroupCriteriaRule(dict):
    def __init__(__self__, *,
                 operator: str,
                 type: str,
                 value: str):
        """
        :param str operator: Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'
        :param str type: Type of object matching 'VM_TAG' or 'VM_NAME'
        :param str value: Filter value
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of object matching 'VM_TAG' or 'VM_NAME'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Filter value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxtDynamicSecurityGroupMemberVm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vappId":
            suggest = "vapp_id"
        elif key == "vappName":
            suggest = "vapp_name"
        elif key == "vmId":
            suggest = "vm_id"
        elif key == "vmName":
            suggest = "vm_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtDynamicSecurityGroupMemberVm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtDynamicSecurityGroupMemberVm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtDynamicSecurityGroupMemberVm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vapp_id: Optional[str] = None,
                 vapp_name: Optional[str] = None,
                 vm_id: Optional[str] = None,
                 vm_name: Optional[str] = None):
        """
        :param str vapp_id: Parent vApp name (if exists) for member VM
        :param str vapp_name: Parent vApp ID (if exists) for member VM
        :param str vm_id: Member VM ID
        :param str vm_name: Member VM Name
        """
        if vapp_id is not None:
            pulumi.set(__self__, "vapp_id", vapp_id)
        if vapp_name is not None:
            pulumi.set(__self__, "vapp_name", vapp_name)
        if vm_id is not None:
            pulumi.set(__self__, "vm_id", vm_id)
        if vm_name is not None:
            pulumi.set(__self__, "vm_name", vm_name)

    @property
    @pulumi.getter(name="vappId")
    def vapp_id(self) -> Optional[str]:
        """
        Parent vApp name (if exists) for member VM
        """
        return pulumi.get(self, "vapp_id")

    @property
    @pulumi.getter(name="vappName")
    def vapp_name(self) -> Optional[str]:
        """
        Parent vApp ID (if exists) for member VM
        """
        return pulumi.get(self, "vapp_name")

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> Optional[str]:
        """
        Member VM ID
        """
        return pulumi.get(self, "vm_id")

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> Optional[str]:
        """
        Member VM Name
        """
        return pulumi.get(self, "vm_name")


@pulumi.output_type
class NsxtEdgegatewayBgpIpPrefixListIpPrefix(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "greaterThanOrEqualTo":
            suggest = "greater_than_or_equal_to"
        elif key == "lessThanOrEqualTo":
            suggest = "less_than_or_equal_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewayBgpIpPrefixListIpPrefix. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewayBgpIpPrefixListIpPrefix.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewayBgpIpPrefixListIpPrefix.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 network: str,
                 greater_than_or_equal_to: Optional[int] = None,
                 less_than_or_equal_to: Optional[int] = None):
        """
        :param str action: Action 'PERMIT' or 'DENY'
        :param str network: Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')
        :param int greater_than_or_equal_to: Greater than or equal to subnet mask
        :param int less_than_or_equal_to: Less than or equal to subnet mask
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "network", network)
        if greater_than_or_equal_to is not None:
            pulumi.set(__self__, "greater_than_or_equal_to", greater_than_or_equal_to)
        if less_than_or_equal_to is not None:
            pulumi.set(__self__, "less_than_or_equal_to", less_than_or_equal_to)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action 'PERMIT' or 'DENY'
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')
        """
        return pulumi.get(self, "network")

    @property
    @pulumi.getter(name="greaterThanOrEqualTo")
    def greater_than_or_equal_to(self) -> Optional[int]:
        """
        Greater than or equal to subnet mask
        """
        return pulumi.get(self, "greater_than_or_equal_to")

    @property
    @pulumi.getter(name="lessThanOrEqualTo")
    def less_than_or_equal_to(self) -> Optional[int]:
        """
        Less than or equal to subnet mask
        """
        return pulumi.get(self, "less_than_or_equal_to")


@pulumi.output_type
class NsxtEdgegatewayDnsConditionalForwarderZone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNames":
            suggest = "domain_names"
        elif key == "upstreamServers":
            suggest = "upstream_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewayDnsConditionalForwarderZone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewayDnsConditionalForwarderZone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewayDnsConditionalForwarderZone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_names: Sequence[str],
                 name: str,
                 upstream_servers: Sequence[str],
                 id: Optional[str] = None):
        """
        :param Sequence[str] domain_names: Set of domain names on which conditional forwarding is based.
        :param str name: Name of the forwarder zone.
        :param Sequence[str] upstream_servers: Servers to which DNS requests should be forwarded to.
        :param str id: Unique ID of the forwarder zone.
        """
        pulumi.set(__self__, "domain_names", domain_names)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "upstream_servers", upstream_servers)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Sequence[str]:
        """
        Set of domain names on which conditional forwarding is based.
        """
        return pulumi.get(self, "domain_names")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the forwarder zone.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="upstreamServers")
    def upstream_servers(self) -> Sequence[str]:
        """
        Servers to which DNS requests should be forwarded to.
        """
        return pulumi.get(self, "upstream_servers")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique ID of the forwarder zone.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NsxtEdgegatewayDnsDefaultForwarderZone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "upstreamServers":
            suggest = "upstream_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewayDnsDefaultForwarderZone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewayDnsDefaultForwarderZone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewayDnsDefaultForwarderZone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 upstream_servers: Sequence[str],
                 id: Optional[str] = None):
        """
        :param str name: Name of the forwarder zone.
        :param Sequence[str] upstream_servers: Servers to which DNS requests should be forwarded to.
        :param str id: Unique ID of the forwarder zone.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "upstream_servers", upstream_servers)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the forwarder zone.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="upstreamServers")
    def upstream_servers(self) -> Sequence[str]:
        """
        Servers to which DNS requests should be forwarded to.
        """
        return pulumi.get(self, "upstream_servers")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique ID of the forwarder zone.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NsxtEdgegatewayExternalNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedIpCount":
            suggest = "allocated_ip_count"
        elif key == "externalNetworkId":
            suggest = "external_network_id"
        elif key == "prefixLength":
            suggest = "prefix_length"
        elif key == "primaryIp":
            suggest = "primary_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewayExternalNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewayExternalNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewayExternalNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_ip_count: int,
                 external_network_id: str,
                 gateway: str,
                 prefix_length: int,
                 primary_ip: Optional[str] = None):
        """
        :param int allocated_ip_count: Number of allocated IPs
        :param str external_network_id: An external network ID. **Note:** Data source [ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
               can be used to lookup ID by name.
        :param str gateway: Gateway IP Address
        :param int prefix_length: Prefix length for a subnet (e.g. 24)
        :param str primary_ip: Primary IP address exposed for an easy access without nesting.
        """
        pulumi.set(__self__, "allocated_ip_count", allocated_ip_count)
        pulumi.set(__self__, "external_network_id", external_network_id)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if primary_ip is not None:
            pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter(name="allocatedIpCount")
    def allocated_ip_count(self) -> int:
        """
        Number of allocated IPs
        """
        return pulumi.get(self, "allocated_ip_count")

    @property
    @pulumi.getter(name="externalNetworkId")
    def external_network_id(self) -> str:
        """
        An external network ID. **Note:** Data source [ExternalNetworkV2](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
        can be used to lookup ID by name.
        """
        return pulumi.get(self, "external_network_id")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway IP Address
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[str]:
        """
        Primary IP address exposed for an easy access without nesting.
        """
        return pulumi.get(self, "primary_ip")


@pulumi.output_type
class NsxtEdgegatewayL2VpnTunnelStretchedNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "tunnelId":
            suggest = "tunnel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewayL2VpnTunnelStretchedNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewayL2VpnTunnelStretchedNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewayL2VpnTunnelStretchedNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 tunnel_id: Optional[int] = None):
        """
        :param str network_id: ID of the Org VDC network
        :param int tunnel_id: Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.
        """
        pulumi.set(__self__, "network_id", network_id)
        if tunnel_id is not None:
            pulumi.set(__self__, "tunnel_id", tunnel_id)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        ID of the Org VDC network
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="tunnelId")
    def tunnel_id(self) -> Optional[int]:
        """
        Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.
        """
        return pulumi.get(self, "tunnel_id")


@pulumi.output_type
class NsxtEdgegatewayStaticRouteNextHop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminDistance":
            suggest = "admin_distance"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewayStaticRouteNextHop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewayStaticRouteNextHop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewayStaticRouteNextHop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_distance: int,
                 ip_address: str,
                 scope: Optional['outputs.NsxtEdgegatewayStaticRouteNextHopScope'] = None):
        """
        :param int admin_distance: Admin distance of next hop
        :param str ip_address: IP Address of next hop
        """
        pulumi.set(__self__, "admin_distance", admin_distance)
        pulumi.set(__self__, "ip_address", ip_address)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="adminDistance")
    def admin_distance(self) -> int:
        """
        Admin distance of next hop
        """
        return pulumi.get(self, "admin_distance")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        IP Address of next hop
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def scope(self) -> Optional['outputs.NsxtEdgegatewayStaticRouteNextHopScope']:
        return pulumi.get(self, "scope")


@pulumi.output_type
class NsxtEdgegatewayStaticRouteNextHopScope(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str,
                 name: Optional[str] = None):
        """
        :param str id: ID of Scope element
        :param str type: Scope type - One of 'NETWORK', 'SYSTEM_OWNED'
        :param str name: Name for NSX-T Edge Gateway Static Route
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Scope element
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Scope type - One of 'NETWORK', 'SYSTEM_OWNED'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name for NSX-T Edge Gateway Static Route
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class NsxtEdgegatewaySubnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixLength":
            suggest = "prefix_length"
        elif key == "allocatedIps":
            suggest = "allocated_ips"
        elif key == "primaryIp":
            suggest = "primary_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewaySubnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewaySubnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewaySubnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: str,
                 prefix_length: int,
                 allocated_ips: Optional[Sequence['outputs.NsxtEdgegatewaySubnetAllocatedIp']] = None,
                 primary_ip: Optional[str] = None):
        """
        :param str gateway: Gateway address for a subnet
        :param int prefix_length: Prefix length for a subnet (e.g. 24)
        :param Sequence['NsxtEdgegatewaySubnetAllocatedIpArgs'] allocated_ips: Define one or more blocks to sub-allocate pools on the edge gateway
        :param str primary_ip: Primary IP address exposed for an easy access without nesting.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if allocated_ips is not None:
            pulumi.set(__self__, "allocated_ips", allocated_ips)
        if primary_ip is not None:
            pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter(name="allocatedIps")
    def allocated_ips(self) -> Optional[Sequence['outputs.NsxtEdgegatewaySubnetAllocatedIp']]:
        """
        Define one or more blocks to sub-allocate pools on the edge gateway
        """
        return pulumi.get(self, "allocated_ips")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[str]:
        """
        Primary IP address exposed for an easy access without nesting.
        """
        return pulumi.get(self, "primary_ip")


@pulumi.output_type
class NsxtEdgegatewaySubnetAllocatedIp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewaySubnetAllocatedIp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewaySubnetAllocatedIp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewaySubnetAllocatedIp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NsxtEdgegatewaySubnetWithIpCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocatedIpCount":
            suggest = "allocated_ip_count"
        elif key == "prefixLength":
            suggest = "prefix_length"
        elif key == "primaryIp":
            suggest = "primary_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewaySubnetWithIpCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewaySubnetWithIpCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewaySubnetWithIpCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocated_ip_count: int,
                 gateway: str,
                 prefix_length: int,
                 primary_ip: Optional[str] = None):
        """
        :param int allocated_ip_count: Number of IP addresses to allocate
        :param str gateway: Gateway address for a subnet
        :param int prefix_length: Prefix length for a subnet (e.g. 24)
        :param str primary_ip: Primary IP address exposed for an easy access without nesting.
        """
        pulumi.set(__self__, "allocated_ip_count", allocated_ip_count)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if primary_ip is not None:
            pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter(name="allocatedIpCount")
    def allocated_ip_count(self) -> int:
        """
        Number of IP addresses to allocate
        """
        return pulumi.get(self, "allocated_ip_count")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[str]:
        """
        Primary IP address exposed for an easy access without nesting.
        """
        return pulumi.get(self, "primary_ip")


@pulumi.output_type
class NsxtEdgegatewaySubnetWithTotalIpCount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prefixLength":
            suggest = "prefix_length"
        elif key == "primaryIp":
            suggest = "primary_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtEdgegatewaySubnetWithTotalIpCount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtEdgegatewaySubnetWithTotalIpCount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtEdgegatewaySubnetWithTotalIpCount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway: str,
                 prefix_length: int,
                 primary_ip: Optional[str] = None):
        """
        :param str gateway: Gateway address for a subnet
        :param int prefix_length: Prefix length for a subnet (e.g. 24)
        :param str primary_ip: Primary IP address exposed for an easy access without nesting.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if primary_ip is not None:
            pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> Optional[str]:
        """
        Primary IP address exposed for an easy access without nesting.
        """
        return pulumi.get(self, "primary_ip")


@pulumi.output_type
class NsxtFirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "appPortProfileIds":
            suggest = "app_port_profile_ids"
        elif key == "destinationIds":
            suggest = "destination_ids"
        elif key == "sourceIds":
            suggest = "source_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtFirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtFirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtFirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 direction: str,
                 ip_protocol: str,
                 name: str,
                 app_port_profile_ids: Optional[Sequence[str]] = None,
                 destination_ids: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 logging: Optional[bool] = None,
                 source_ids: Optional[Sequence[str]] = None):
        """
        :param str action: Defines if the rule should 'ALLOW', 'DROP' or 'REJECT' matching traffic
        :param str direction: Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        :param str ip_protocol: Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        :param str name: Firewall Rule name
        :param Sequence[str] app_port_profile_ids: A set of Application Port Profile IDs. Leaving it empty means 'Any'
        :param Sequence[str] destination_ids: A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        :param bool enabled: Defined if Firewall Rule is active
        :param str id: Firewall Rule ID
        :param bool logging: Defines if matching traffic should be logged
        :param Sequence[str] source_ids: A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        pulumi.set(__self__, "name", name)
        if app_port_profile_ids is not None:
            pulumi.set(__self__, "app_port_profile_ids", app_port_profile_ids)
        if destination_ids is not None:
            pulumi.set(__self__, "destination_ids", destination_ids)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if source_ids is not None:
            pulumi.set(__self__, "source_ids", source_ids)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Defines if the rule should 'ALLOW', 'DROP' or 'REJECT' matching traffic
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        """
        Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        """
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="appPortProfileIds")
    def app_port_profile_ids(self) -> Optional[Sequence[str]]:
        """
        A set of Application Port Profile IDs. Leaving it empty means 'Any'
        """
        return pulumi.get(self, "app_port_profile_ids")

    @property
    @pulumi.getter(name="destinationIds")
    def destination_ids(self) -> Optional[Sequence[str]]:
        """
        A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "destination_ids")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Defined if Firewall Rule is active
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Firewall Rule ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logging(self) -> Optional[bool]:
        """
        Defines if matching traffic should be logged
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="sourceIds")
    def source_ids(self) -> Optional[Sequence[str]]:
        """
        A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "source_ids")


@pulumi.output_type
class NsxtIpsecVpnTunnelSecurityProfileCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ikeDhGroups":
            suggest = "ike_dh_groups"
        elif key == "ikeEncryptionAlgorithms":
            suggest = "ike_encryption_algorithms"
        elif key == "ikeVersion":
            suggest = "ike_version"
        elif key == "tunnelDhGroups":
            suggest = "tunnel_dh_groups"
        elif key == "tunnelEncryptionAlgorithms":
            suggest = "tunnel_encryption_algorithms"
        elif key == "dpdProbeInternal":
            suggest = "dpd_probe_internal"
        elif key == "ikeDigestAlgorithms":
            suggest = "ike_digest_algorithms"
        elif key == "ikeSaLifetime":
            suggest = "ike_sa_lifetime"
        elif key == "tunnelDfPolicy":
            suggest = "tunnel_df_policy"
        elif key == "tunnelDigestAlgorithms":
            suggest = "tunnel_digest_algorithms"
        elif key == "tunnelPfsEnabled":
            suggest = "tunnel_pfs_enabled"
        elif key == "tunnelSaLifetime":
            suggest = "tunnel_sa_lifetime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtIpsecVpnTunnelSecurityProfileCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtIpsecVpnTunnelSecurityProfileCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtIpsecVpnTunnelSecurityProfileCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ike_dh_groups: Sequence[str],
                 ike_encryption_algorithms: Sequence[str],
                 ike_version: str,
                 tunnel_dh_groups: Sequence[str],
                 tunnel_encryption_algorithms: Sequence[str],
                 dpd_probe_internal: Optional[int] = None,
                 ike_digest_algorithms: Optional[Sequence[str]] = None,
                 ike_sa_lifetime: Optional[int] = None,
                 tunnel_df_policy: Optional[str] = None,
                 tunnel_digest_algorithms: Optional[Sequence[str]] = None,
                 tunnel_pfs_enabled: Optional[bool] = None,
                 tunnel_sa_lifetime: Optional[int] = None):
        """
        :param Sequence[str] ike_dh_groups: Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        :param Sequence[str] ike_encryption_algorithms: Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        :param str ike_version: IKE version one of IKE_V1, IKE_V2, IKE_FLEX
        :param Sequence[str] tunnel_dh_groups: Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        :param Sequence[str] tunnel_encryption_algorithms: Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
        :param int dpd_probe_internal: Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
        :param Sequence[str] ike_digest_algorithms: Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        :param int ike_sa_lifetime: Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
        :param str tunnel_df_policy: Policy for handling defragmentation bit. One of COPY, CLEAR
        :param Sequence[str] tunnel_digest_algorithms: Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        :param bool tunnel_pfs_enabled: Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
        :param int tunnel_sa_lifetime: Security Association life time (in seconds)
        """
        pulumi.set(__self__, "ike_dh_groups", ike_dh_groups)
        pulumi.set(__self__, "ike_encryption_algorithms", ike_encryption_algorithms)
        pulumi.set(__self__, "ike_version", ike_version)
        pulumi.set(__self__, "tunnel_dh_groups", tunnel_dh_groups)
        pulumi.set(__self__, "tunnel_encryption_algorithms", tunnel_encryption_algorithms)
        if dpd_probe_internal is not None:
            pulumi.set(__self__, "dpd_probe_internal", dpd_probe_internal)
        if ike_digest_algorithms is not None:
            pulumi.set(__self__, "ike_digest_algorithms", ike_digest_algorithms)
        if ike_sa_lifetime is not None:
            pulumi.set(__self__, "ike_sa_lifetime", ike_sa_lifetime)
        if tunnel_df_policy is not None:
            pulumi.set(__self__, "tunnel_df_policy", tunnel_df_policy)
        if tunnel_digest_algorithms is not None:
            pulumi.set(__self__, "tunnel_digest_algorithms", tunnel_digest_algorithms)
        if tunnel_pfs_enabled is not None:
            pulumi.set(__self__, "tunnel_pfs_enabled", tunnel_pfs_enabled)
        if tunnel_sa_lifetime is not None:
            pulumi.set(__self__, "tunnel_sa_lifetime", tunnel_sa_lifetime)

    @property
    @pulumi.getter(name="ikeDhGroups")
    def ike_dh_groups(self) -> Sequence[str]:
        """
        Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        """
        return pulumi.get(self, "ike_dh_groups")

    @property
    @pulumi.getter(name="ikeEncryptionAlgorithms")
    def ike_encryption_algorithms(self) -> Sequence[str]:
        """
        Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        return pulumi.get(self, "ike_encryption_algorithms")

    @property
    @pulumi.getter(name="ikeVersion")
    def ike_version(self) -> str:
        """
        IKE version one of IKE_V1, IKE_V2, IKE_FLEX
        """
        return pulumi.get(self, "ike_version")

    @property
    @pulumi.getter(name="tunnelDhGroups")
    def tunnel_dh_groups(self) -> Sequence[str]:
        """
        Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        """
        return pulumi.get(self, "tunnel_dh_groups")

    @property
    @pulumi.getter(name="tunnelEncryptionAlgorithms")
    def tunnel_encryption_algorithms(self) -> Sequence[str]:
        """
        Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
        """
        return pulumi.get(self, "tunnel_encryption_algorithms")

    @property
    @pulumi.getter(name="dpdProbeInternal")
    def dpd_probe_internal(self) -> Optional[int]:
        """
        Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
        """
        return pulumi.get(self, "dpd_probe_internal")

    @property
    @pulumi.getter(name="ikeDigestAlgorithms")
    def ike_digest_algorithms(self) -> Optional[Sequence[str]]:
        """
        Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        return pulumi.get(self, "ike_digest_algorithms")

    @property
    @pulumi.getter(name="ikeSaLifetime")
    def ike_sa_lifetime(self) -> Optional[int]:
        """
        Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
        """
        return pulumi.get(self, "ike_sa_lifetime")

    @property
    @pulumi.getter(name="tunnelDfPolicy")
    def tunnel_df_policy(self) -> Optional[str]:
        """
        Policy for handling defragmentation bit. One of COPY, CLEAR
        """
        return pulumi.get(self, "tunnel_df_policy")

    @property
    @pulumi.getter(name="tunnelDigestAlgorithms")
    def tunnel_digest_algorithms(self) -> Optional[Sequence[str]]:
        """
        Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        return pulumi.get(self, "tunnel_digest_algorithms")

    @property
    @pulumi.getter(name="tunnelPfsEnabled")
    def tunnel_pfs_enabled(self) -> Optional[bool]:
        """
        Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
        """
        return pulumi.get(self, "tunnel_pfs_enabled")

    @property
    @pulumi.getter(name="tunnelSaLifetime")
    def tunnel_sa_lifetime(self) -> Optional[int]:
        """
        Security Association life time (in seconds)
        """
        return pulumi.get(self, "tunnel_sa_lifetime")


@pulumi.output_type
class NsxtNetworkDhcpBindingDhcpV4Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayIpAddress":
            suggest = "gateway_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtNetworkDhcpBindingDhcpV4Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtNetworkDhcpBindingDhcpV4Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtNetworkDhcpBindingDhcpV4Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gateway_ip_address: Optional[str] = None,
                 hostname: Optional[str] = None):
        """
        :param str gateway_ip_address: IPv4 gateway address
        :param str hostname: Hostname for the DHCP client
        """
        if gateway_ip_address is not None:
            pulumi.set(__self__, "gateway_ip_address", gateway_ip_address)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter(name="gatewayIpAddress")
    def gateway_ip_address(self) -> Optional[str]:
        """
        IPv4 gateway address
        """
        return pulumi.get(self, "gateway_ip_address")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname for the DHCP client
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class NsxtNetworkDhcpBindingDhcpV6Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainNames":
            suggest = "domain_names"
        elif key == "sntpServers":
            suggest = "sntp_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtNetworkDhcpBindingDhcpV6Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtNetworkDhcpBindingDhcpV6Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtNetworkDhcpBindingDhcpV6Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_names: Optional[Sequence[str]] = None,
                 sntp_servers: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] domain_names: Set of domain names
        :param Sequence[str] sntp_servers: Set of SNTP servers
        """
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if sntp_servers is not None:
            pulumi.set(__self__, "sntp_servers", sntp_servers)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[Sequence[str]]:
        """
        Set of domain names
        """
        return pulumi.get(self, "domain_names")

    @property
    @pulumi.getter(name="sntpServers")
    def sntp_servers(self) -> Optional[Sequence[str]]:
        """
        Set of SNTP servers
        """
        return pulumi.get(self, "sntp_servers")


@pulumi.output_type
class NsxtNetworkDhcpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtNetworkDhcpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtNetworkDhcpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtNetworkDhcpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of DHCP pool IP range
        :param str start_address: Start address of DHCP pool IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of DHCP pool IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of DHCP pool IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NsxtNetworkImportedSecondaryStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtNetworkImportedSecondaryStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtNetworkImportedSecondaryStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtNetworkImportedSecondaryStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NsxtNetworkImportedStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtNetworkImportedStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtNetworkImportedStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtNetworkImportedStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class NsxtSecurityGroupMemberVm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vappId":
            suggest = "vapp_id"
        elif key == "vappName":
            suggest = "vapp_name"
        elif key == "vmId":
            suggest = "vm_id"
        elif key == "vmName":
            suggest = "vm_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxtSecurityGroupMemberVm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxtSecurityGroupMemberVm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxtSecurityGroupMemberVm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vapp_id: Optional[str] = None,
                 vapp_name: Optional[str] = None,
                 vm_id: Optional[str] = None,
                 vm_name: Optional[str] = None):
        """
        :param str vapp_id: Parent vApp name (if exists) for member VM
        :param str vapp_name: Parent vApp ID (if exists) for member VM
        :param str vm_id: Member VM ID
        :param str vm_name: Member VM Name
        """
        if vapp_id is not None:
            pulumi.set(__self__, "vapp_id", vapp_id)
        if vapp_name is not None:
            pulumi.set(__self__, "vapp_name", vapp_name)
        if vm_id is not None:
            pulumi.set(__self__, "vm_id", vm_id)
        if vm_name is not None:
            pulumi.set(__self__, "vm_name", vm_name)

    @property
    @pulumi.getter(name="vappId")
    def vapp_id(self) -> Optional[str]:
        """
        Parent vApp name (if exists) for member VM
        """
        return pulumi.get(self, "vapp_id")

    @property
    @pulumi.getter(name="vappName")
    def vapp_name(self) -> Optional[str]:
        """
        Parent vApp ID (if exists) for member VM
        """
        return pulumi.get(self, "vapp_name")

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> Optional[str]:
        """
        Member VM ID
        """
        return pulumi.get(self, "vm_id")

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> Optional[str]:
        """
        Member VM Name
        """
        return pulumi.get(self, "vm_name")


@pulumi.output_type
class NsxvDhcpRelayRelayAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkName":
            suggest = "network_name"
        elif key == "gatewayIpAddress":
            suggest = "gateway_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxvDhcpRelayRelayAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxvDhcpRelayRelayAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxvDhcpRelayRelayAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_name: str,
                 gateway_ip_address: Optional[str] = None):
        """
        :param str network_name: Org network which is to be used for relaying DHCP message to specified servers
        :param str gateway_ip_address: Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers
        """
        pulumi.set(__self__, "network_name", network_name)
        if gateway_ip_address is not None:
            pulumi.set(__self__, "gateway_ip_address", gateway_ip_address)

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Org network which is to be used for relaying DHCP message to specified servers
        """
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="gatewayIpAddress")
    def gateway_ip_address(self) -> Optional[str]:
        """
        Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers
        """
        return pulumi.get(self, "gateway_ip_address")


@pulumi.output_type
class NsxvDistributedFirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliedTos":
            suggest = "applied_tos"
        elif key == "excludeDestination":
            suggest = "exclude_destination"
        elif key == "excludeSource":
            suggest = "exclude_source"
        elif key == "packetType":
            suggest = "packet_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxvDistributedFirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxvDistributedFirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxvDistributedFirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 applied_tos: Sequence['outputs.NsxvDistributedFirewallRuleAppliedTo'],
                 direction: str,
                 applications: Optional[Sequence['outputs.NsxvDistributedFirewallRuleApplication']] = None,
                 destinations: Optional[Sequence['outputs.NsxvDistributedFirewallRuleDestination']] = None,
                 enabled: Optional[bool] = None,
                 exclude_destination: Optional[bool] = None,
                 exclude_source: Optional[bool] = None,
                 id: Optional[int] = None,
                 logged: Optional[bool] = None,
                 name: Optional[str] = None,
                 packet_type: Optional[str] = None,
                 sources: Optional[Sequence['outputs.NsxvDistributedFirewallRuleSource']] = None):
        """
        :param str action: Action of the rule (allow, deny)
        :param Sequence['NsxvDistributedFirewallRuleAppliedToArgs'] applied_tos: List of elements to which this rule applies
        :param str direction: Direction of the rule (in, out, inout)
        :param Sequence['NsxvDistributedFirewallRuleApplicationArgs'] applications: Application definitions for this rule. An empty value means 'any'
        :param Sequence['NsxvDistributedFirewallRuleDestinationArgs'] destinations: List of destination traffic for this rule. An empty value means 'any'
        :param bool enabled: Shows whether the NSX-V Distributed Firewall is enabled.
        :param bool exclude_destination: If true, the content of the destination elements is reversed
        :param bool exclude_source: If true, the content of the source elements is reversed
        :param int id: Firewall Rule ID
        :param bool logged: Whether the rule traffic is logged
        :param str name: Firewall Rule name
        :param str packet_type: Packet type of the rule (any, ipv4, ipv6)
        :param Sequence['NsxvDistributedFirewallRuleSourceArgs'] sources: List of source traffic for this rule. An empty value means 'any'
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "applied_tos", applied_tos)
        pulumi.set(__self__, "direction", direction)
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if exclude_destination is not None:
            pulumi.set(__self__, "exclude_destination", exclude_destination)
        if exclude_source is not None:
            pulumi.set(__self__, "exclude_source", exclude_source)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if logged is not None:
            pulumi.set(__self__, "logged", logged)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if packet_type is not None:
            pulumi.set(__self__, "packet_type", packet_type)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action of the rule (allow, deny)
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="appliedTos")
    def applied_tos(self) -> Sequence['outputs.NsxvDistributedFirewallRuleAppliedTo']:
        """
        List of elements to which this rule applies
        """
        return pulumi.get(self, "applied_tos")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction of the rule (in, out, inout)
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.NsxvDistributedFirewallRuleApplication']]:
        """
        Application definitions for this rule. An empty value means 'any'
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence['outputs.NsxvDistributedFirewallRuleDestination']]:
        """
        List of destination traffic for this rule. An empty value means 'any'
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Shows whether the NSX-V Distributed Firewall is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="excludeDestination")
    def exclude_destination(self) -> Optional[bool]:
        """
        If true, the content of the destination elements is reversed
        """
        return pulumi.get(self, "exclude_destination")

    @property
    @pulumi.getter(name="excludeSource")
    def exclude_source(self) -> Optional[bool]:
        """
        If true, the content of the source elements is reversed
        """
        return pulumi.get(self, "exclude_source")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Firewall Rule ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logged(self) -> Optional[bool]:
        """
        Whether the rule traffic is logged
        """
        return pulumi.get(self, "logged")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="packetType")
    def packet_type(self) -> Optional[str]:
        """
        Packet type of the rule (any, ipv4, ipv6)
        """
        return pulumi.get(self, "packet_type")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.NsxvDistributedFirewallRuleSource']]:
        """
        List of source traffic for this rule. An empty value means 'any'
        """
        return pulumi.get(self, "sources")


@pulumi.output_type
class NsxvDistributedFirewallRuleApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPort":
            suggest = "destination_port"
        elif key == "sourcePort":
            suggest = "source_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxvDistributedFirewallRuleApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxvDistributedFirewallRuleApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxvDistributedFirewallRuleApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_port: Optional[str] = None,
                 name: Optional[str] = None,
                 protocol: Optional[str] = None,
                 source_port: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str destination_port: Destination port for this application. Leaving it empty means 'any' port
        :param str name: Name of application (Application, ApplicationGroup)
        :param str protocol: Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)
        :param str source_port: Source port for this application. Leaving it empty means 'any' port
        :param str type: Type of application
        :param str value: Value of the application
        """
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[str]:
        """
        Destination port for this application. Leaving it empty means 'any' port
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of application (Application, ApplicationGroup)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[str]:
        """
        Source port for this application. Leaving it empty means 'any' port
        """
        return pulumi.get(self, "source_port")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of application
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the application
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxvDistributedFirewallRuleAppliedTo(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Name of the applied-to entity
        :param str type: Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)
        :param str value: Value of the applied-to entity
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the applied-to entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the applied-to entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxvDistributedFirewallRuleDestination(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Name of the destination entity
        :param str type: Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        :param str value: Value of the destination entity
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the destination entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the destination entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxvDistributedFirewallRuleSource(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Name of the source entity
        :param str type: Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        :param str value: Value of the source entity
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the source entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the source entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class NsxvFirewallRuleDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayInterfaces":
            suggest = "gateway_interfaces"
        elif key == "ipAddresses":
            suggest = "ip_addresses"
        elif key == "ipSets":
            suggest = "ip_sets"
        elif key == "orgNetworks":
            suggest = "org_networks"
        elif key == "vmIds":
            suggest = "vm_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxvFirewallRuleDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxvFirewallRuleDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxvFirewallRuleDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude: Optional[bool] = None,
                 gateway_interfaces: Optional[Sequence[str]] = None,
                 ip_addresses: Optional[Sequence[str]] = None,
                 ip_sets: Optional[Sequence[str]] = None,
                 org_networks: Optional[Sequence[str]] = None,
                 vm_ids: Optional[Sequence[str]] = None):
        """
        :param bool exclude: Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'
        :param Sequence[str] gateway_interfaces: 'vse', 'internal', 'external' or network name
        :param Sequence[str] ip_addresses: IP address, CIDR, an IP range, or the keyword 'any'
        :param Sequence[str] ip_sets: Set of IP set names
        :param Sequence[str] org_networks: Set of org network names
        :param Sequence[str] vm_ids: Set of VM IDs
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if gateway_interfaces is not None:
            pulumi.set(__self__, "gateway_interfaces", gateway_interfaces)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ip_sets is not None:
            pulumi.set(__self__, "ip_sets", ip_sets)
        if org_networks is not None:
            pulumi.set(__self__, "org_networks", org_networks)
        if vm_ids is not None:
            pulumi.set(__self__, "vm_ids", vm_ids)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[bool]:
        """
        Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'
        """
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter(name="gatewayInterfaces")
    def gateway_interfaces(self) -> Optional[Sequence[str]]:
        """
        'vse', 'internal', 'external' or network name
        """
        return pulumi.get(self, "gateway_interfaces")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        IP address, CIDR, an IP range, or the keyword 'any'
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[Sequence[str]]:
        """
        Set of IP set names
        """
        return pulumi.get(self, "ip_sets")

    @property
    @pulumi.getter(name="orgNetworks")
    def org_networks(self) -> Optional[Sequence[str]]:
        """
        Set of org network names
        """
        return pulumi.get(self, "org_networks")

    @property
    @pulumi.getter(name="vmIds")
    def vm_ids(self) -> Optional[Sequence[str]]:
        """
        Set of VM IDs
        """
        return pulumi.get(self, "vm_ids")


@pulumi.output_type
class NsxvFirewallRuleService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourcePort":
            suggest = "source_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxvFirewallRuleService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxvFirewallRuleService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxvFirewallRuleService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: str,
                 port: Optional[str] = None,
                 source_port: Optional[str] = None):
        pulumi.set(__self__, "protocol", protocol)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[str]:
        return pulumi.get(self, "source_port")


@pulumi.output_type
class NsxvFirewallRuleSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gatewayInterfaces":
            suggest = "gateway_interfaces"
        elif key == "ipAddresses":
            suggest = "ip_addresses"
        elif key == "ipSets":
            suggest = "ip_sets"
        elif key == "orgNetworks":
            suggest = "org_networks"
        elif key == "vmIds":
            suggest = "vm_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NsxvFirewallRuleSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NsxvFirewallRuleSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NsxvFirewallRuleSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude: Optional[bool] = None,
                 gateway_interfaces: Optional[Sequence[str]] = None,
                 ip_addresses: Optional[Sequence[str]] = None,
                 ip_sets: Optional[Sequence[str]] = None,
                 org_networks: Optional[Sequence[str]] = None,
                 vm_ids: Optional[Sequence[str]] = None):
        """
        :param bool exclude: Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'
        :param Sequence[str] gateway_interfaces: 'vse', 'internal', 'external' or network name
        :param Sequence[str] ip_addresses: IP address, CIDR, an IP range, or the keyword 'any'
        :param Sequence[str] ip_sets: Set of IP set names
        :param Sequence[str] org_networks: Set of org network names
        :param Sequence[str] vm_ids: Set of VM IDs
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if gateway_interfaces is not None:
            pulumi.set(__self__, "gateway_interfaces", gateway_interfaces)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ip_sets is not None:
            pulumi.set(__self__, "ip_sets", ip_sets)
        if org_networks is not None:
            pulumi.set(__self__, "org_networks", org_networks)
        if vm_ids is not None:
            pulumi.set(__self__, "vm_ids", vm_ids)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[bool]:
        """
        Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'
        """
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter(name="gatewayInterfaces")
    def gateway_interfaces(self) -> Optional[Sequence[str]]:
        """
        'vse', 'internal', 'external' or network name
        """
        return pulumi.get(self, "gateway_interfaces")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence[str]]:
        """
        IP address, CIDR, an IP range, or the keyword 'any'
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[Sequence[str]]:
        """
        Set of IP set names
        """
        return pulumi.get(self, "ip_sets")

    @property
    @pulumi.getter(name="orgNetworks")
    def org_networks(self) -> Optional[Sequence[str]]:
        """
        Set of org network names
        """
        return pulumi.get(self, "org_networks")

    @property
    @pulumi.getter(name="vmIds")
    def vm_ids(self) -> Optional[Sequence[str]]:
        """
        Set of VM IDs
        """
        return pulumi.get(self, "vm_ids")


@pulumi.output_type
class OrgAccountLockout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "invalidLoginsBeforeLockout":
            suggest = "invalid_logins_before_lockout"
        elif key == "lockoutIntervalMinutes":
            suggest = "lockout_interval_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgAccountLockout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgAccountLockout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgAccountLockout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 invalid_logins_before_lockout: int,
                 lockout_interval_minutes: int):
        """
        :param bool enabled: Whether account lockout is enabled or not
        :param int invalid_logins_before_lockout: Number of login attempts that will trigger an account lockout for the given user
        :param int lockout_interval_minutes: Once a user is locked out, they will not be able to log back in for this time period
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "invalid_logins_before_lockout", invalid_logins_before_lockout)
        pulumi.set(__self__, "lockout_interval_minutes", lockout_interval_minutes)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether account lockout is enabled or not
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="invalidLoginsBeforeLockout")
    def invalid_logins_before_lockout(self) -> int:
        """
        Number of login attempts that will trigger an account lockout for the given user
        """
        return pulumi.get(self, "invalid_logins_before_lockout")

    @property
    @pulumi.getter(name="lockoutIntervalMinutes")
    def lockout_interval_minutes(self) -> int:
        """
        Once a user is locked out, they will not be able to log back in for this time period
        """
        return pulumi.get(self, "lockout_interval_minutes")


@pulumi.output_type
class OrgLdapCustomSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethod":
            suggest = "authentication_method"
        elif key == "connectorType":
            suggest = "connector_type"
        elif key == "groupAttributes":
            suggest = "group_attributes"
        elif key == "userAttributes":
            suggest = "user_attributes"
        elif key == "baseDistinguishedName":
            suggest = "base_distinguished_name"
        elif key == "isSsl":
            suggest = "is_ssl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLdapCustomSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLdapCustomSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLdapCustomSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication_method: str,
                 connector_type: str,
                 group_attributes: 'outputs.OrgLdapCustomSettingsGroupAttributes',
                 port: int,
                 server: str,
                 user_attributes: 'outputs.OrgLdapCustomSettingsUserAttributes',
                 base_distinguished_name: Optional[str] = None,
                 is_ssl: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str authentication_method: authentication method: one of SIMPLE, MD5DIGEST, NTLM
        :param str connector_type: type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY
        :param 'OrgLdapCustomSettingsGroupAttributesArgs' group_attributes: Group settings when `ldap_mode` is CUSTOM
        :param int port: Port number for LDAP service
        :param str server: host name or IP of the LDAP server
        :param 'OrgLdapCustomSettingsUserAttributesArgs' user_attributes: User settings when `ldap_mode` is CUSTOM
        :param str base_distinguished_name: LDAP search base
        :param bool is_ssl: True if the LDAP service requires an SSL connection
        :param str password: Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed
        :param str username: Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn="ldap-admin", c="example", dc="com")
        """
        pulumi.set(__self__, "authentication_method", authentication_method)
        pulumi.set(__self__, "connector_type", connector_type)
        pulumi.set(__self__, "group_attributes", group_attributes)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "user_attributes", user_attributes)
        if base_distinguished_name is not None:
            pulumi.set(__self__, "base_distinguished_name", base_distinguished_name)
        if is_ssl is not None:
            pulumi.set(__self__, "is_ssl", is_ssl)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> str:
        """
        authentication method: one of SIMPLE, MD5DIGEST, NTLM
        """
        return pulumi.get(self, "authentication_method")

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> str:
        """
        type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter(name="groupAttributes")
    def group_attributes(self) -> 'outputs.OrgLdapCustomSettingsGroupAttributes':
        """
        Group settings when `ldap_mode` is CUSTOM
        """
        return pulumi.get(self, "group_attributes")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number for LDAP service
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        host name or IP of the LDAP server
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="userAttributes")
    def user_attributes(self) -> 'outputs.OrgLdapCustomSettingsUserAttributes':
        """
        User settings when `ldap_mode` is CUSTOM
        """
        return pulumi.get(self, "user_attributes")

    @property
    @pulumi.getter(name="baseDistinguishedName")
    def base_distinguished_name(self) -> Optional[str]:
        """
        LDAP search base
        """
        return pulumi.get(self, "base_distinguished_name")

    @property
    @pulumi.getter(name="isSsl")
    def is_ssl(self) -> Optional[bool]:
        """
        True if the LDAP service requires an SSL connection
        """
        return pulumi.get(self, "is_ssl")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn="ldap-admin", c="example", dc="com")
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class OrgLdapCustomSettingsGroupAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupMembershipIdentifier":
            suggest = "group_membership_identifier"
        elif key == "objectClass":
            suggest = "object_class"
        elif key == "uniqueIdentifier":
            suggest = "unique_identifier"
        elif key == "groupBackLinkIdentifier":
            suggest = "group_back_link_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLdapCustomSettingsGroupAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLdapCustomSettingsGroupAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLdapCustomSettingsGroupAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_membership_identifier: str,
                 membership: str,
                 name: str,
                 object_class: str,
                 unique_identifier: str,
                 group_back_link_identifier: Optional[str] = None):
        """
        :param str group_membership_identifier: LDAP attribute that identifies a group as a member of another group. For example, dn
        :param str membership: LDAP attribute to use when getting the members of a group. For example, member
        :param str name: LDAP attribute to use for the group name. For example, cn
        :param str object_class: LDAP objectClass of which imported groups are members. For example, group
        :param str unique_identifier: LDAP attribute to use as the unique identifier for a group. For example, objectGuid
        :param str group_back_link_identifier: LDAP group attribute used to identify a group member
        """
        pulumi.set(__self__, "group_membership_identifier", group_membership_identifier)
        pulumi.set(__self__, "membership", membership)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "object_class", object_class)
        pulumi.set(__self__, "unique_identifier", unique_identifier)
        if group_back_link_identifier is not None:
            pulumi.set(__self__, "group_back_link_identifier", group_back_link_identifier)

    @property
    @pulumi.getter(name="groupMembershipIdentifier")
    def group_membership_identifier(self) -> str:
        """
        LDAP attribute that identifies a group as a member of another group. For example, dn
        """
        return pulumi.get(self, "group_membership_identifier")

    @property
    @pulumi.getter
    def membership(self) -> str:
        """
        LDAP attribute to use when getting the members of a group. For example, member
        """
        return pulumi.get(self, "membership")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        LDAP attribute to use for the group name. For example, cn
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objectClass")
    def object_class(self) -> str:
        """
        LDAP objectClass of which imported groups are members. For example, group
        """
        return pulumi.get(self, "object_class")

    @property
    @pulumi.getter(name="uniqueIdentifier")
    def unique_identifier(self) -> str:
        """
        LDAP attribute to use as the unique identifier for a group. For example, objectGuid
        """
        return pulumi.get(self, "unique_identifier")

    @property
    @pulumi.getter(name="groupBackLinkIdentifier")
    def group_back_link_identifier(self) -> Optional[str]:
        """
        LDAP group attribute used to identify a group member
        """
        return pulumi.get(self, "group_back_link_identifier")


@pulumi.output_type
class OrgLdapCustomSettingsUserAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "givenName":
            suggest = "given_name"
        elif key == "groupMembershipIdentifier":
            suggest = "group_membership_identifier"
        elif key == "objectClass":
            suggest = "object_class"
        elif key == "uniqueIdentifier":
            suggest = "unique_identifier"
        elif key == "groupBackLinkIdentifier":
            suggest = "group_back_link_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLdapCustomSettingsUserAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLdapCustomSettingsUserAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLdapCustomSettingsUserAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: str,
                 email: str,
                 given_name: str,
                 group_membership_identifier: str,
                 object_class: str,
                 surname: str,
                 telephone: str,
                 unique_identifier: str,
                 username: str,
                 group_back_link_identifier: Optional[str] = None):
        """
        :param str display_name: LDAP attribute to use for the user's full name. For example, displayName
        :param str email: LDAP attribute to use for the user's email address. For example, mail
        :param str given_name: LDAP attribute to use for the user's given name. For example, givenName
        :param str group_membership_identifier: LDAP attribute that identifies a user as a member of a group. For example, dn
        :param str object_class: LDAP objectClass of which imported users are members. For example, user or person
        :param str surname: LDAP attribute to use for the user's surname. For example, sn
        :param str telephone: LDAP attribute to use for the user's telephone number. For example, telephoneNumber
        :param str unique_identifier: LDAP attribute to use as the unique identifier for a user. For example, objectGuid
        :param str username: LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName
        :param str group_back_link_identifier: LDAP attribute that returns the identifiers of all the groups of which the user is a member
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "given_name", given_name)
        pulumi.set(__self__, "group_membership_identifier", group_membership_identifier)
        pulumi.set(__self__, "object_class", object_class)
        pulumi.set(__self__, "surname", surname)
        pulumi.set(__self__, "telephone", telephone)
        pulumi.set(__self__, "unique_identifier", unique_identifier)
        pulumi.set(__self__, "username", username)
        if group_back_link_identifier is not None:
            pulumi.set(__self__, "group_back_link_identifier", group_back_link_identifier)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        LDAP attribute to use for the user's full name. For example, displayName
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        LDAP attribute to use for the user's email address. For example, mail
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="givenName")
    def given_name(self) -> str:
        """
        LDAP attribute to use for the user's given name. For example, givenName
        """
        return pulumi.get(self, "given_name")

    @property
    @pulumi.getter(name="groupMembershipIdentifier")
    def group_membership_identifier(self) -> str:
        """
        LDAP attribute that identifies a user as a member of a group. For example, dn
        """
        return pulumi.get(self, "group_membership_identifier")

    @property
    @pulumi.getter(name="objectClass")
    def object_class(self) -> str:
        """
        LDAP objectClass of which imported users are members. For example, user or person
        """
        return pulumi.get(self, "object_class")

    @property
    @pulumi.getter
    def surname(self) -> str:
        """
        LDAP attribute to use for the user's surname. For example, sn
        """
        return pulumi.get(self, "surname")

    @property
    @pulumi.getter
    def telephone(self) -> str:
        """
        LDAP attribute to use for the user's telephone number. For example, telephoneNumber
        """
        return pulumi.get(self, "telephone")

    @property
    @pulumi.getter(name="uniqueIdentifier")
    def unique_identifier(self) -> str:
        """
        LDAP attribute to use as the unique identifier for a user. For example, objectGuid
        """
        return pulumi.get(self, "unique_identifier")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="groupBackLinkIdentifier")
    def group_back_link_identifier(self) -> Optional[str]:
        """
        LDAP attribute that returns the identifiers of all the groups of which the user is a member
        """
        return pulumi.get(self, "group_back_link_identifier")


@pulumi.output_type
class OrgMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OrgOidcClaimsMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "fullName":
            suggest = "full_name"
        elif key == "lastName":
            suggest = "last_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgOidcClaimsMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgOidcClaimsMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgOidcClaimsMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: Optional[str] = None,
                 first_name: Optional[str] = None,
                 full_name: Optional[str] = None,
                 groups: Optional[str] = None,
                 last_name: Optional[str] = None,
                 roles: Optional[str] = None,
                 subject: Optional[str] = None):
        """
        :param str email: Required if `wellknown_endpoint` doesn't give info about it
        :param str first_name: Required if `wellknown_endpoint` doesn't give info about it
        :param str full_name: Required if `wellknown_endpoint` doesn't give info about it
        :param str groups: Optional
        :param str last_name: Required if `wellknown_endpoint` doesn't give info about it
        :param str roles: Optional
        :param str subject: Required if `wellknown_endpoint` doesn't give info about it
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if full_name is not None:
            pulumi.set(__self__, "full_name", full_name)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> Optional[str]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "full_name")

    @property
    @pulumi.getter
    def groups(self) -> Optional[str]:
        """
        Optional
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def roles(self) -> Optional[str]:
        """
        Optional
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        """
        Required if `wellknown_endpoint` doesn't give info about it
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class OrgOidcKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDate":
            suggest = "expiration_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgOidcKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgOidcKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgOidcKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 algorithm: str,
                 certificate: str,
                 id: str,
                 expiration_date: Optional[str] = None):
        """
        :param str algorithm: Algorithm used by the key. Can be `RSA` or `EC`
        :param str certificate: The contents of a PEM file to create/update the key
        :param str id: Identifier of the key
        :param str expiration_date: Expiration date for the key. The accepted format is `YYYY-MM-DD`, like `2077-12-31`
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "id", id)
        if expiration_date is not None:
            pulumi.set(__self__, "expiration_date", expiration_date)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        Algorithm used by the key. Can be `RSA` or `EC`
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The contents of a PEM file to create/update the key
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Identifier of the key
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[str]:
        """
        Expiration date for the key. The accepted format is `YYYY-MM-DD`, like `2077-12-31`
        """
        return pulumi.get(self, "expiration_date")


@pulumi.output_type
class OrgVappLease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnStorageLeaseExpiration":
            suggest = "delete_on_storage_lease_expiration"
        elif key == "maximumRuntimeLeaseInSec":
            suggest = "maximum_runtime_lease_in_sec"
        elif key == "maximumStorageLeaseInSec":
            suggest = "maximum_storage_lease_in_sec"
        elif key == "powerOffOnRuntimeLeaseExpiration":
            suggest = "power_off_on_runtime_lease_expiration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgVappLease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgVappLease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgVappLease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_storage_lease_expiration: bool,
                 maximum_runtime_lease_in_sec: int,
                 maximum_storage_lease_in_sec: int,
                 power_off_on_runtime_lease_expiration: bool):
        """
        :param bool delete_on_storage_lease_expiration: If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.
        :param int maximum_runtime_lease_in_sec: How long vApps can run before they are automatically stopped (in seconds). 0 means never expires
        :param int maximum_storage_lease_in_sec: How long stopped vApps are available before being automatically cleaned up (in seconds). 0 means never expires
        :param bool power_off_on_runtime_lease_expiration: When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires
        """
        pulumi.set(__self__, "delete_on_storage_lease_expiration", delete_on_storage_lease_expiration)
        pulumi.set(__self__, "maximum_runtime_lease_in_sec", maximum_runtime_lease_in_sec)
        pulumi.set(__self__, "maximum_storage_lease_in_sec", maximum_storage_lease_in_sec)
        pulumi.set(__self__, "power_off_on_runtime_lease_expiration", power_off_on_runtime_lease_expiration)

    @property
    @pulumi.getter(name="deleteOnStorageLeaseExpiration")
    def delete_on_storage_lease_expiration(self) -> bool:
        """
        If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.
        """
        return pulumi.get(self, "delete_on_storage_lease_expiration")

    @property
    @pulumi.getter(name="maximumRuntimeLeaseInSec")
    def maximum_runtime_lease_in_sec(self) -> int:
        """
        How long vApps can run before they are automatically stopped (in seconds). 0 means never expires
        """
        return pulumi.get(self, "maximum_runtime_lease_in_sec")

    @property
    @pulumi.getter(name="maximumStorageLeaseInSec")
    def maximum_storage_lease_in_sec(self) -> int:
        """
        How long stopped vApps are available before being automatically cleaned up (in seconds). 0 means never expires
        """
        return pulumi.get(self, "maximum_storage_lease_in_sec")

    @property
    @pulumi.getter(name="powerOffOnRuntimeLeaseExpiration")
    def power_off_on_runtime_lease_expiration(self) -> bool:
        """
        When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires
        """
        return pulumi.get(self, "power_off_on_runtime_lease_expiration")


@pulumi.output_type
class OrgVappTemplateLease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnStorageLeaseExpiration":
            suggest = "delete_on_storage_lease_expiration"
        elif key == "maximumStorageLeaseInSec":
            suggest = "maximum_storage_lease_in_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgVappTemplateLease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgVappTemplateLease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgVappTemplateLease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_storage_lease_expiration: bool,
                 maximum_storage_lease_in_sec: int):
        """
        :param bool delete_on_storage_lease_expiration: If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted
        :param int maximum_storage_lease_in_sec: How long vApp templates are available before being automatically cleaned up (in seconds). 0 means never expires
        """
        pulumi.set(__self__, "delete_on_storage_lease_expiration", delete_on_storage_lease_expiration)
        pulumi.set(__self__, "maximum_storage_lease_in_sec", maximum_storage_lease_in_sec)

    @property
    @pulumi.getter(name="deleteOnStorageLeaseExpiration")
    def delete_on_storage_lease_expiration(self) -> bool:
        """
        If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted
        """
        return pulumi.get(self, "delete_on_storage_lease_expiration")

    @property
    @pulumi.getter(name="maximumStorageLeaseInSec")
    def maximum_storage_lease_in_sec(self) -> int:
        """
        How long vApp templates are available before being automatically cleaned up (in seconds). 0 means never expires
        """
        return pulumi.get(self, "maximum_storage_lease_in_sec")


@pulumi.output_type
class OrgVdcAccessControlSharedWith(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "subjectName":
            suggest = "subject_name"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgVdcAccessControlSharedWith. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgVdcAccessControlSharedWith.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgVdcAccessControlSharedWith.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: str,
                 group_id: Optional[str] = None,
                 subject_name: Optional[str] = None,
                 user_id: Optional[str] = None):
        """
        :param str access_level: The access level for the user or group to which we are sharing. (Only `ReadOnly` is available)
        :param str group_id: The ID of a group which we are sharing with. Required if `user_id` is not set.
        :param str subject_name: The name of the subject (group or user) which we are sharing with.
        :param str user_id: The ID of a user which we are sharing with. Required if `group_id` is not set.
        """
        pulumi.set(__self__, "access_level", access_level)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> str:
        """
        The access level for the user or group to which we are sharing. (Only `ReadOnly` is available)
        """
        return pulumi.get(self, "access_level")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The ID of a group which we are sharing with. Required if `user_id` is not set.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[str]:
        """
        The name of the subject (group or user) which we are sharing with.
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The ID of a user which we are sharing with. Required if `group_id` is not set.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class OrgVdcComputeCapacity(dict):
    def __init__(__self__, *,
                 cpu: 'outputs.OrgVdcComputeCapacityCpu',
                 memory: 'outputs.OrgVdcComputeCapacityMemory'):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> 'outputs.OrgVdcComputeCapacityCpu':
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def memory(self) -> 'outputs.OrgVdcComputeCapacityMemory':
        return pulumi.get(self, "memory")


@pulumi.output_type
class OrgVdcComputeCapacityCpu(dict):
    def __init__(__self__, *,
                 allocated: Optional[int] = None,
                 limit: Optional[int] = None,
                 reserved: Optional[int] = None,
                 used: Optional[int] = None):
        """
        :param int allocated: Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        :param int limit: Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        if allocated is not None:
            pulumi.set(__self__, "allocated", allocated)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)
        if used is not None:
            pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocated(self) -> Optional[int]:
        """
        Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        """
        return pulumi.get(self, "allocated")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def reserved(self) -> Optional[int]:
        return pulumi.get(self, "reserved")

    @property
    @pulumi.getter
    def used(self) -> Optional[int]:
        return pulumi.get(self, "used")


@pulumi.output_type
class OrgVdcComputeCapacityMemory(dict):
    def __init__(__self__, *,
                 allocated: Optional[int] = None,
                 limit: Optional[int] = None,
                 reserved: Optional[int] = None,
                 used: Optional[int] = None):
        """
        :param int allocated: Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        :param int limit: Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        if allocated is not None:
            pulumi.set(__self__, "allocated", allocated)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)
        if used is not None:
            pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocated(self) -> Optional[int]:
        """
        Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        """
        return pulumi.get(self, "allocated")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def reserved(self) -> Optional[int]:
        return pulumi.get(self, "reserved")

    @property
    @pulumi.getter
    def used(self) -> Optional[int]:
        return pulumi.get(self, "used")


@pulumi.output_type
class OrgVdcMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgVdcMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgVdcMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgVdcMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class OrgVdcStorageProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageUsedInMb":
            suggest = "storage_used_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgVdcStorageProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgVdcStorageProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgVdcStorageProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default: bool,
                 limit: int,
                 name: str,
                 enabled: Optional[bool] = None,
                 storage_used_in_mb: Optional[int] = None):
        """
        :param bool default: True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.
        :param int limit: Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.
        :param str name: VDC name
        :param bool enabled: True if this VDC is enabled for use by the organization VDCs. Default is true.
        :param int storage_used_in_mb: Storage used in MB
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "name", name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if storage_used_in_mb is not None:
            pulumi.set(__self__, "storage_used_in_mb", storage_used_in_mb)

    @property
    @pulumi.getter
    def default(self) -> bool:
        """
        True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        VDC name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if this VDC is enabled for use by the organization VDCs. Default is true.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="storageUsedInMb")
    def storage_used_in_mb(self) -> Optional[int]:
        """
        Storage used in MB
        """
        return pulumi.get(self, "storage_used_in_mb")


@pulumi.output_type
class OrgVdcTemplateComputeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuAllocated":
            suggest = "cpu_allocated"
        elif key == "cpuGuaranteed":
            suggest = "cpu_guaranteed"
        elif key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuSpeed":
            suggest = "cpu_speed"
        elif key == "includeVmMemoryOverhead":
            suggest = "include_vm_memory_overhead"
        elif key == "memoryAllocated":
            suggest = "memory_allocated"
        elif key == "memoryGuaranteed":
            suggest = "memory_guaranteed"
        elif key == "memoryLimit":
            suggest = "memory_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgVdcTemplateComputeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgVdcTemplateComputeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgVdcTemplateComputeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_allocated: Optional[int] = None,
                 cpu_guaranteed: Optional[int] = None,
                 cpu_limit: Optional[int] = None,
                 cpu_speed: Optional[int] = None,
                 elasticity: Optional[bool] = None,
                 include_vm_memory_overhead: Optional[bool] = None,
                 memory_allocated: Optional[int] = None,
                 memory_guaranteed: Optional[int] = None,
                 memory_limit: Optional[int] = None):
        """
        :param int cpu_allocated: The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template. Minimum is 256MHz
        :param int cpu_guaranteed: The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template
        :param int cpu_limit: The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. Minimum is 256MHz. 0 means unlimited
        :param int cpu_speed: Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM. Minimum is 256MHz
        :param bool elasticity: True if compute capacity can grow or shrink based on demand
        :param bool include_vm_memory_overhead: True if the instantiated VDC includes memory overhead into its accounting for admission control
        :param int memory_allocated: The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template
        :param int memory_guaranteed: The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template
        :param int memory_limit: The limit amount of Memory, in MB, of the VDC that is instantiated from this template. Minimum is 1024MB. 0 means unlimited
        """
        if cpu_allocated is not None:
            pulumi.set(__self__, "cpu_allocated", cpu_allocated)
        if cpu_guaranteed is not None:
            pulumi.set(__self__, "cpu_guaranteed", cpu_guaranteed)
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_speed is not None:
            pulumi.set(__self__, "cpu_speed", cpu_speed)
        if elasticity is not None:
            pulumi.set(__self__, "elasticity", elasticity)
        if include_vm_memory_overhead is not None:
            pulumi.set(__self__, "include_vm_memory_overhead", include_vm_memory_overhead)
        if memory_allocated is not None:
            pulumi.set(__self__, "memory_allocated", memory_allocated)
        if memory_guaranteed is not None:
            pulumi.set(__self__, "memory_guaranteed", memory_guaranteed)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)

    @property
    @pulumi.getter(name="cpuAllocated")
    def cpu_allocated(self) -> Optional[int]:
        """
        The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template. Minimum is 256MHz
        """
        return pulumi.get(self, "cpu_allocated")

    @property
    @pulumi.getter(name="cpuGuaranteed")
    def cpu_guaranteed(self) -> Optional[int]:
        """
        The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template
        """
        return pulumi.get(self, "cpu_guaranteed")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[int]:
        """
        The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. Minimum is 256MHz. 0 means unlimited
        """
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuSpeed")
    def cpu_speed(self) -> Optional[int]:
        """
        Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM. Minimum is 256MHz
        """
        return pulumi.get(self, "cpu_speed")

    @property
    @pulumi.getter
    def elasticity(self) -> Optional[bool]:
        """
        True if compute capacity can grow or shrink based on demand
        """
        return pulumi.get(self, "elasticity")

    @property
    @pulumi.getter(name="includeVmMemoryOverhead")
    def include_vm_memory_overhead(self) -> Optional[bool]:
        """
        True if the instantiated VDC includes memory overhead into its accounting for admission control
        """
        return pulumi.get(self, "include_vm_memory_overhead")

    @property
    @pulumi.getter(name="memoryAllocated")
    def memory_allocated(self) -> Optional[int]:
        """
        The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template
        """
        return pulumi.get(self, "memory_allocated")

    @property
    @pulumi.getter(name="memoryGuaranteed")
    def memory_guaranteed(self) -> Optional[int]:
        """
        The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template
        """
        return pulumi.get(self, "memory_guaranteed")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[int]:
        """
        The limit amount of Memory, in MB, of the VDC that is instantiated from this template. Minimum is 1024MB. 0 means unlimited
        """
        return pulumi.get(self, "memory_limit")


@pulumi.output_type
class OrgVdcTemplateEdgeGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routedNetworkGatewayCidr":
            suggest = "routed_network_gateway_cidr"
        elif key == "routedNetworkName":
            suggest = "routed_network_name"
        elif key == "ipAllocationCount":
            suggest = "ip_allocation_count"
        elif key == "routedNetworkDescription":
            suggest = "routed_network_description"
        elif key == "staticIpPool":
            suggest = "static_ip_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgVdcTemplateEdgeGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgVdcTemplateEdgeGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgVdcTemplateEdgeGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 routed_network_gateway_cidr: str,
                 routed_network_name: str,
                 description: Optional[str] = None,
                 ip_allocation_count: Optional[int] = None,
                 routed_network_description: Optional[str] = None,
                 static_ip_pool: Optional['outputs.OrgVdcTemplateEdgeGatewayStaticIpPool'] = None):
        """
        :param str name: Name of the Edge Gateway
        :param str routed_network_gateway_cidr: CIDR of the Edge Gateway for the created routed network
        :param str routed_network_name: Name of the routed network to create with the Edge Gateway
        :param str description: Description of the Edge Gateway
        :param int ip_allocation_count: Allocated IPs for the Edge Gateway. Defaults to 0
        :param str routed_network_description: Description of the routed network to create with the Edge Gateway
        :param 'OrgVdcTemplateEdgeGatewayStaticIpPoolArgs' static_ip_pool: **One block** with a single IP range (this is a constraint due to a bug in VCD 10.5+) that has two properties: `start_address`, the start address of the IP range;
               `end_address`, the end address of the IP range
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routed_network_gateway_cidr", routed_network_gateway_cidr)
        pulumi.set(__self__, "routed_network_name", routed_network_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip_allocation_count is not None:
            pulumi.set(__self__, "ip_allocation_count", ip_allocation_count)
        if routed_network_description is not None:
            pulumi.set(__self__, "routed_network_description", routed_network_description)
        if static_ip_pool is not None:
            pulumi.set(__self__, "static_ip_pool", static_ip_pool)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Edge Gateway
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="routedNetworkGatewayCidr")
    def routed_network_gateway_cidr(self) -> str:
        """
        CIDR of the Edge Gateway for the created routed network
        """
        return pulumi.get(self, "routed_network_gateway_cidr")

    @property
    @pulumi.getter(name="routedNetworkName")
    def routed_network_name(self) -> str:
        """
        Name of the routed network to create with the Edge Gateway
        """
        return pulumi.get(self, "routed_network_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the Edge Gateway
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipAllocationCount")
    def ip_allocation_count(self) -> Optional[int]:
        """
        Allocated IPs for the Edge Gateway. Defaults to 0
        """
        return pulumi.get(self, "ip_allocation_count")

    @property
    @pulumi.getter(name="routedNetworkDescription")
    def routed_network_description(self) -> Optional[str]:
        """
        Description of the routed network to create with the Edge Gateway
        """
        return pulumi.get(self, "routed_network_description")

    @property
    @pulumi.getter(name="staticIpPool")
    def static_ip_pool(self) -> Optional['outputs.OrgVdcTemplateEdgeGatewayStaticIpPool']:
        """
        **One block** with a single IP range (this is a constraint due to a bug in VCD 10.5+) that has two properties: `start_address`, the start address of the IP range;
        `end_address`, the end address of the IP range
        """
        return pulumi.get(self, "static_ip_pool")


@pulumi.output_type
class OrgVdcTemplateEdgeGatewayStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgVdcTemplateEdgeGatewayStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgVdcTemplateEdgeGatewayStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgVdcTemplateEdgeGatewayStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class OrgVdcTemplateProviderVdc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalNetworkId":
            suggest = "external_network_id"
        elif key == "gatewayEdgeClusterId":
            suggest = "gateway_edge_cluster_id"
        elif key == "servicesEdgeClusterId":
            suggest = "services_edge_cluster_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgVdcTemplateProviderVdc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgVdcTemplateProviderVdc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgVdcTemplateProviderVdc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_network_id: str,
                 id: str,
                 gateway_edge_cluster_id: Optional[str] = None,
                 services_edge_cluster_id: Optional[str] = None):
        """
        :param str external_network_id: ID of the Provider Gateway to use, can be obtained with
               [`ExternalNetworkV2` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
        :param str id: ID of the Provider VDC, can be obtained with
               [`ProviderVdc` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/provider_vdc)
        :param str gateway_edge_cluster_id: ID of the Edge Cluster that the VDCs instantiated from this template will use with the Edge Gateway.
               Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster).
               If set, a `edge_gateway` block **must** be present in the VDC Template configuration (see below).
        :param str services_edge_cluster_id: ID of the Edge Cluster that the VDCs instantiated from this template will use for services.
               Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster)
        """
        pulumi.set(__self__, "external_network_id", external_network_id)
        pulumi.set(__self__, "id", id)
        if gateway_edge_cluster_id is not None:
            pulumi.set(__self__, "gateway_edge_cluster_id", gateway_edge_cluster_id)
        if services_edge_cluster_id is not None:
            pulumi.set(__self__, "services_edge_cluster_id", services_edge_cluster_id)

    @property
    @pulumi.getter(name="externalNetworkId")
    def external_network_id(self) -> str:
        """
        ID of the Provider Gateway to use, can be obtained with
        [`ExternalNetworkV2` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/external_network_v2)
        """
        return pulumi.get(self, "external_network_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the Provider VDC, can be obtained with
        [`ProviderVdc` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/provider_vdc)
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="gatewayEdgeClusterId")
    def gateway_edge_cluster_id(self) -> Optional[str]:
        """
        ID of the Edge Cluster that the VDCs instantiated from this template will use with the Edge Gateway.
        Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster).
        If set, a `edge_gateway` block **must** be present in the VDC Template configuration (see below).
        """
        return pulumi.get(self, "gateway_edge_cluster_id")

    @property
    @pulumi.getter(name="servicesEdgeClusterId")
    def services_edge_cluster_id(self) -> Optional[str]:
        """
        ID of the Edge Cluster that the VDCs instantiated from this template will use for services.
        Can be obtained with [`get_nsxt_edge_cluster` data source](https://www.terraform.io/providers/vmware/vcd/latest/docs/data-sources/nsxt_edge_cluster)
        """
        return pulumi.get(self, "services_edge_cluster_id")


@pulumi.output_type
class OrgVdcTemplateStorageProfile(dict):
    def __init__(__self__, *,
                 default: bool,
                 limit: int,
                 name: str):
        """
        :param bool default: True if this is default storage profile for the VDCs instantiated from this template. Only **one** block should have this set to `true`
        :param int limit: Storage limit for the VDCs instantiated from this template, in MB. 0 means unlimited
        :param str name: Name of Provider VDC storage profile to use for the VDCs instantiated from this template
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> bool:
        """
        True if this is default storage profile for the VDCs instantiated from this template. Only **one** block should have this set to `true`
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        Storage limit for the VDCs instantiated from this template, in MB. 0 means unlimited
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of Provider VDC storage profile to use for the VDCs instantiated from this template
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProviderVdcComputeCapacity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isElastic":
            suggest = "is_elastic"
        elif key == "isHa":
            suggest = "is_ha"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProviderVdcComputeCapacity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProviderVdcComputeCapacity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProviderVdcComputeCapacity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpus: Optional[Sequence['outputs.ProviderVdcComputeCapacityCpus']] = None,
                 is_elastic: Optional[bool] = None,
                 is_ha: Optional[bool] = None,
                 memories: Optional[Sequence['outputs.ProviderVdcComputeCapacityMemory']] = None):
        """
        :param Sequence['ProviderVdcComputeCapacityCpusArgs'] cpus: Single-element list with an indicator of CPU capacity available in the Provider VDC
        :param bool is_elastic: True if compute capacity can grow or shrink based on demand
        :param bool is_ha: True if compute capacity is highly available
        :param Sequence['ProviderVdcComputeCapacityMemoryArgs'] memories: Single-element list with an indicator of Memory capacity available in the Provider VDC
        """
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if is_elastic is not None:
            pulumi.set(__self__, "is_elastic", is_elastic)
        if is_ha is not None:
            pulumi.set(__self__, "is_ha", is_ha)
        if memories is not None:
            pulumi.set(__self__, "memories", memories)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[Sequence['outputs.ProviderVdcComputeCapacityCpus']]:
        """
        Single-element list with an indicator of CPU capacity available in the Provider VDC
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter(name="isElastic")
    def is_elastic(self) -> Optional[bool]:
        """
        True if compute capacity can grow or shrink based on demand
        """
        return pulumi.get(self, "is_elastic")

    @property
    @pulumi.getter(name="isHa")
    def is_ha(self) -> Optional[bool]:
        """
        True if compute capacity is highly available
        """
        return pulumi.get(self, "is_ha")

    @property
    @pulumi.getter
    def memories(self) -> Optional[Sequence['outputs.ProviderVdcComputeCapacityMemory']]:
        """
        Single-element list with an indicator of Memory capacity available in the Provider VDC
        """
        return pulumi.get(self, "memories")


@pulumi.output_type
class ProviderVdcComputeCapacityCpus(dict):
    def __init__(__self__, *,
                 allocation: Optional[int] = None,
                 overhead: Optional[int] = None,
                 reserved: Optional[int] = None,
                 total: Optional[int] = None,
                 units: Optional[str] = None,
                 used: Optional[int] = None):
        """
        :param int allocation: Allocated CPU for this Provider VDC
        :param int overhead: CPU overhead for this Provider VDC
        :param int reserved: Reserved CPU for this Provider VDC
        :param int total: Total CPU for this Provider VDC
        :param str units: Units for the CPU of this Provider VDC
        :param int used: Used CPU in this Provider VDC
        """
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if overhead is not None:
            pulumi.set(__self__, "overhead", overhead)
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)
        if total is not None:
            pulumi.set(__self__, "total", total)
        if units is not None:
            pulumi.set(__self__, "units", units)
        if used is not None:
            pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocation(self) -> Optional[int]:
        """
        Allocated CPU for this Provider VDC
        """
        return pulumi.get(self, "allocation")

    @property
    @pulumi.getter
    def overhead(self) -> Optional[int]:
        """
        CPU overhead for this Provider VDC
        """
        return pulumi.get(self, "overhead")

    @property
    @pulumi.getter
    def reserved(self) -> Optional[int]:
        """
        Reserved CPU for this Provider VDC
        """
        return pulumi.get(self, "reserved")

    @property
    @pulumi.getter
    def total(self) -> Optional[int]:
        """
        Total CPU for this Provider VDC
        """
        return pulumi.get(self, "total")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        """
        Units for the CPU of this Provider VDC
        """
        return pulumi.get(self, "units")

    @property
    @pulumi.getter
    def used(self) -> Optional[int]:
        """
        Used CPU in this Provider VDC
        """
        return pulumi.get(self, "used")


@pulumi.output_type
class ProviderVdcComputeCapacityMemory(dict):
    def __init__(__self__, *,
                 allocation: Optional[int] = None,
                 overhead: Optional[int] = None,
                 reserved: Optional[int] = None,
                 total: Optional[int] = None,
                 units: Optional[str] = None,
                 used: Optional[int] = None):
        """
        :param int allocation: Allocated Memory for this Provider VDC
        :param int overhead: Memory overhead for this Provider VDC
        :param int reserved: Reserved Memory for this Provider VDC
        :param int total: Total Memory for this Provider VDC
        :param str units: Units for the Memory of this Provider VDC
        :param int used: Used Memory in this Provider VDC
        """
        if allocation is not None:
            pulumi.set(__self__, "allocation", allocation)
        if overhead is not None:
            pulumi.set(__self__, "overhead", overhead)
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)
        if total is not None:
            pulumi.set(__self__, "total", total)
        if units is not None:
            pulumi.set(__self__, "units", units)
        if used is not None:
            pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocation(self) -> Optional[int]:
        """
        Allocated Memory for this Provider VDC
        """
        return pulumi.get(self, "allocation")

    @property
    @pulumi.getter
    def overhead(self) -> Optional[int]:
        """
        Memory overhead for this Provider VDC
        """
        return pulumi.get(self, "overhead")

    @property
    @pulumi.getter
    def reserved(self) -> Optional[int]:
        """
        Reserved Memory for this Provider VDC
        """
        return pulumi.get(self, "reserved")

    @property
    @pulumi.getter
    def total(self) -> Optional[int]:
        """
        Total Memory for this Provider VDC
        """
        return pulumi.get(self, "total")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        """
        Units for the Memory of this Provider VDC
        """
        return pulumi.get(self, "units")

    @property
    @pulumi.getter
    def used(self) -> Optional[int]:
        """
        Used Memory in this Provider VDC
        """
        return pulumi.get(self, "used")


@pulumi.output_type
class ProviderVdcMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProviderVdcMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProviderVdcMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProviderVdcMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None):
        """
        :param str key: Key of this metadata entry
        :param str value: Value of this metadata entry
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL. Defaults to false
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'. Defaults to 'MetadataStringValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'. Defaults to 'READWRITE'
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL. Defaults to false
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'. Defaults to 'MetadataStringValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'. Defaults to 'READWRITE'
        """
        return pulumi.get(self, "user_access")


@pulumi.output_type
class RdeMetadataEntry(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 domain: Optional[str] = None,
                 id: Optional[str] = None,
                 namespace: Optional[str] = None,
                 persistent: Optional[bool] = None,
                 readonly: Optional[bool] = None,
                 type: Optional[str] = None):
        """
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        :param str domain: Only meaningful for providers. Allows them to share entries with their tenants. Currently, accepted values are: `TENANT`, `PROVIDER`
        :param str id: ID of the metadata entry
        :param str namespace: Namespace of the metadata entry
        :param bool persistent: Persistent metadata entries can be copied over on some entity operation
        :param bool readonly: True if the metadata entry is read only
        :param str type: Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if persistent is not None:
            pulumi.set(__self__, "persistent", persistent)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Only meaningful for providers. Allows them to share entries with their tenants. Currently, accepted values are: `TENANT`, `PROVIDER`
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the metadata entry
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the metadata entry
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def persistent(self) -> Optional[bool]:
        """
        Persistent metadata entries can be copied over on some entity operation
        """
        return pulumi.get(self, "persistent")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[bool]:
        """
        True if the metadata entry is read only
        """
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RdeTypeHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "behaviorId":
            suggest = "behavior_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdeTypeHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdeTypeHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdeTypeHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 behavior_id: str,
                 event: str):
        """
        :param str behavior_id: Existing Behavior that will be automatically invoked when any RDE of this RDE Type triggers the event.
        :param str event: Event that will invoke the Behavior, one of `PostCreate`, `PostUpdate`, `PreDelete`, `PostDelete`.
        """
        pulumi.set(__self__, "behavior_id", behavior_id)
        pulumi.set(__self__, "event", event)

    @property
    @pulumi.getter(name="behaviorId")
    def behavior_id(self) -> str:
        """
        Existing Behavior that will be automatically invoked when any RDE of this RDE Type triggers the event.
        """
        return pulumi.get(self, "behavior_id")

    @property
    @pulumi.getter
    def event(self) -> str:
        """
        Event that will invoke the Behavior, one of `PostCreate`, `PostUpdate`, `PreDelete`, `PostDelete`.
        """
        return pulumi.get(self, "event")


@pulumi.output_type
class SolutionLandingZoneCatalog(dict):
    def __init__(__self__, *,
                 id: str,
                 capabilities: Optional[Sequence[str]] = None,
                 name: Optional[str] = None):
        """
        :param str id: ID of catalog
        :param Sequence[str] capabilities: Capability set for catalog
        :param str name: Catalog Name
        """
        pulumi.set(__self__, "id", id)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of catalog
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence[str]]:
        """
        Capability set for catalog
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Catalog Name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SolutionLandingZoneVdc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computePolicies":
            suggest = "compute_policies"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "orgVdcNetworks":
            suggest = "org_vdc_networks"
        elif key == "storagePolicies":
            suggest = "storage_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SolutionLandingZoneVdc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SolutionLandingZoneVdc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SolutionLandingZoneVdc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_policies: Sequence['outputs.SolutionLandingZoneVdcComputePolicy'],
                 id: str,
                 is_default: bool,
                 org_vdc_networks: Sequence['outputs.SolutionLandingZoneVdcOrgVdcNetwork'],
                 storage_policies: Sequence['outputs.SolutionLandingZoneVdcStoragePolicy'],
                 capabilities: Optional[Sequence[str]] = None,
                 name: Optional[str] = None):
        """
        :param Sequence['SolutionLandingZoneVdcComputePolicyArgs'] compute_policies: Structure for Compute Policy
        :param str id: ID of VDC
        :param bool is_default: Defines if the entity should be considered as default
        :param Sequence['SolutionLandingZoneVdcOrgVdcNetworkArgs'] org_vdc_networks: Structure for Org VDC Network
        :param Sequence['SolutionLandingZoneVdcStoragePolicyArgs'] storage_policies: Structure for Storage Policy
        :param Sequence[str] capabilities: Capability set for VDC
        :param str name: VDC Name
        """
        pulumi.set(__self__, "compute_policies", compute_policies)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "org_vdc_networks", org_vdc_networks)
        pulumi.set(__self__, "storage_policies", storage_policies)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="computePolicies")
    def compute_policies(self) -> Sequence['outputs.SolutionLandingZoneVdcComputePolicy']:
        """
        Structure for Compute Policy
        """
        return pulumi.get(self, "compute_policies")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of VDC
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Defines if the entity should be considered as default
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter(name="orgVdcNetworks")
    def org_vdc_networks(self) -> Sequence['outputs.SolutionLandingZoneVdcOrgVdcNetwork']:
        """
        Structure for Org VDC Network
        """
        return pulumi.get(self, "org_vdc_networks")

    @property
    @pulumi.getter(name="storagePolicies")
    def storage_policies(self) -> Sequence['outputs.SolutionLandingZoneVdcStoragePolicy']:
        """
        Structure for Storage Policy
        """
        return pulumi.get(self, "storage_policies")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence[str]]:
        """
        Capability set for VDC
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        VDC Name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SolutionLandingZoneVdcComputePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SolutionLandingZoneVdcComputePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SolutionLandingZoneVdcComputePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SolutionLandingZoneVdcComputePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 capabilities: Optional[Sequence[str]] = None,
                 is_default: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str id: ID of Compute Policy
        :param Sequence[str] capabilities: Set of capabilities for Compute Policy
        :param bool is_default: Boolean value that marks if this Compute Policy should be default
        :param str name: Name of Compute Policy
        """
        pulumi.set(__self__, "id", id)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Compute Policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence[str]]:
        """
        Set of capabilities for Compute Policy
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        Boolean value that marks if this Compute Policy should be default
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of Compute Policy
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SolutionLandingZoneVdcOrgVdcNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SolutionLandingZoneVdcOrgVdcNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SolutionLandingZoneVdcOrgVdcNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SolutionLandingZoneVdcOrgVdcNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 capabilities: Optional[Sequence[str]] = None,
                 is_default: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str id: ID of Org VDC Network
        :param Sequence[str] capabilities: Set of capabilities for Org VDC Network
        :param bool is_default: Boolean value that marks if this Org VDC Network should be default
        :param str name: Name of Org VDC Network
        """
        pulumi.set(__self__, "id", id)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Org VDC Network
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence[str]]:
        """
        Set of capabilities for Org VDC Network
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        Boolean value that marks if this Org VDC Network should be default
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of Org VDC Network
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SolutionLandingZoneVdcStoragePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isDefault":
            suggest = "is_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SolutionLandingZoneVdcStoragePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SolutionLandingZoneVdcStoragePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SolutionLandingZoneVdcStoragePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 capabilities: Optional[Sequence[str]] = None,
                 is_default: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str id: ID of Storage Policy
        :param Sequence[str] capabilities: Set of capabilities for Storage Policy
        :param bool is_default: Boolean value that marks if this Storage Policy should be default
        :param str name: Name of Storage Policy
        """
        pulumi.set(__self__, "id", id)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Storage Policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[Sequence[str]]:
        """
        Set of capabilities for Storage Policy
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[bool]:
        """
        Boolean value that marks if this Storage Policy should be default
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of Storage Policy
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VappAccessControlSharedWith(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessLevel":
            suggest = "access_level"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "subjectName":
            suggest = "subject_name"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappAccessControlSharedWith. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappAccessControlSharedWith.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappAccessControlSharedWith.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_level: str,
                 group_id: Optional[str] = None,
                 subject_name: Optional[str] = None,
                 user_id: Optional[str] = None):
        """
        :param str access_level: The access level for the user or group to which we are sharing. (One of `ReadOnly`, `Change`, `FullControl`)
        :param str group_id: The ID of a group with which we are sharing. Required if `user_id` is not set.
        :param str subject_name: the name of the subject (group or user) with which we are sharing.
        :param str user_id: The ID of a user with which we are sharing. Required if `group_id` is not set.
        """
        pulumi.set(__self__, "access_level", access_level)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if subject_name is not None:
            pulumi.set(__self__, "subject_name", subject_name)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> str:
        """
        The access level for the user or group to which we are sharing. (One of `ReadOnly`, `Change`, `FullControl`)
        """
        return pulumi.get(self, "access_level")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The ID of a group with which we are sharing. Required if `user_id` is not set.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> Optional[str]:
        """
        the name of the subject (group or user) with which we are sharing.
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        The ID of a user with which we are sharing. Required if `group_id` is not set.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class VappFirewallRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationIp":
            suggest = "destination_ip"
        elif key == "destinationPort":
            suggest = "destination_port"
        elif key == "destinationVmId":
            suggest = "destination_vm_id"
        elif key == "destinationVmIpType":
            suggest = "destination_vm_ip_type"
        elif key == "destinationVmNicId":
            suggest = "destination_vm_nic_id"
        elif key == "enableLogging":
            suggest = "enable_logging"
        elif key == "sourceIp":
            suggest = "source_ip"
        elif key == "sourcePort":
            suggest = "source_port"
        elif key == "sourceVmId":
            suggest = "source_vm_id"
        elif key == "sourceVmIpType":
            suggest = "source_vm_ip_type"
        elif key == "sourceVmNicId":
            suggest = "source_vm_nic_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappFirewallRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappFirewallRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappFirewallRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_ip: Optional[str] = None,
                 destination_port: Optional[str] = None,
                 destination_vm_id: Optional[str] = None,
                 destination_vm_ip_type: Optional[str] = None,
                 destination_vm_nic_id: Optional[int] = None,
                 enable_logging: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 policy: Optional[str] = None,
                 protocol: Optional[str] = None,
                 source_ip: Optional[str] = None,
                 source_port: Optional[str] = None,
                 source_vm_id: Optional[str] = None,
                 source_vm_ip_type: Optional[str] = None,
                 source_vm_nic_id: Optional[int] = None):
        """
        :param str destination_ip: Destination IP address to which the rule applies. A value of `Any` matches any IP address.
        :param str destination_port: Destination port to which this rule applies.
        :param str destination_vm_id: Destination VM identifier
        :param str destination_vm_ip_type: The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        :param int destination_vm_nic_id: Destination VM NIC ID to which this rule applies.
        :param bool enable_logging: 'true' value will enable rule logging. Default is false
        :param bool enabled: Enable or disable firewall. Default is `true`.
        :param str name: Rule name
        :param str policy: One of: `drop` (drop packets that match the rule), `allow` (allow packets that match the rule to pass through the firewall)
        :param str protocol: Specify the protocols to which the rule should be applied. One of: `any`, `icmp`, `tcp`, `udp`, `tcp&udp`
        :param str source_ip: Source IP address to which the rule applies. A value of `Any` matches any IP address.
        :param str source_port: Source port to which this rule applies.
        :param str source_vm_id: Source VM identifier
        :param str source_vm_ip_type: The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        :param int source_vm_nic_id: Source VM NIC ID to which this rule applies.
        """
        if destination_ip is not None:
            pulumi.set(__self__, "destination_ip", destination_ip)
        if destination_port is not None:
            pulumi.set(__self__, "destination_port", destination_port)
        if destination_vm_id is not None:
            pulumi.set(__self__, "destination_vm_id", destination_vm_id)
        if destination_vm_ip_type is not None:
            pulumi.set(__self__, "destination_vm_ip_type", destination_vm_ip_type)
        if destination_vm_nic_id is not None:
            pulumi.set(__self__, "destination_vm_nic_id", destination_vm_nic_id)
        if enable_logging is not None:
            pulumi.set(__self__, "enable_logging", enable_logging)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)
        if source_vm_id is not None:
            pulumi.set(__self__, "source_vm_id", source_vm_id)
        if source_vm_ip_type is not None:
            pulumi.set(__self__, "source_vm_ip_type", source_vm_ip_type)
        if source_vm_nic_id is not None:
            pulumi.set(__self__, "source_vm_nic_id", source_vm_nic_id)

    @property
    @pulumi.getter(name="destinationIp")
    def destination_ip(self) -> Optional[str]:
        """
        Destination IP address to which the rule applies. A value of `Any` matches any IP address.
        """
        return pulumi.get(self, "destination_ip")

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> Optional[str]:
        """
        Destination port to which this rule applies.
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter(name="destinationVmId")
    def destination_vm_id(self) -> Optional[str]:
        """
        Destination VM identifier
        """
        return pulumi.get(self, "destination_vm_id")

    @property
    @pulumi.getter(name="destinationVmIpType")
    def destination_vm_ip_type(self) -> Optional[str]:
        """
        The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        """
        return pulumi.get(self, "destination_vm_ip_type")

    @property
    @pulumi.getter(name="destinationVmNicId")
    def destination_vm_nic_id(self) -> Optional[int]:
        """
        Destination VM NIC ID to which this rule applies.
        """
        return pulumi.get(self, "destination_vm_nic_id")

    @property
    @pulumi.getter(name="enableLogging")
    def enable_logging(self) -> Optional[bool]:
        """
        'true' value will enable rule logging. Default is false
        """
        return pulumi.get(self, "enable_logging")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable or disable firewall. Default is `true`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Rule name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        One of: `drop` (drop packets that match the rule), `allow` (allow packets that match the rule to pass through the firewall)
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Specify the protocols to which the rule should be applied. One of: `any`, `icmp`, `tcp`, `udp`, `tcp&udp`
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[str]:
        """
        Source IP address to which the rule applies. A value of `Any` matches any IP address.
        """
        return pulumi.get(self, "source_ip")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[str]:
        """
        Source port to which this rule applies.
        """
        return pulumi.get(self, "source_port")

    @property
    @pulumi.getter(name="sourceVmId")
    def source_vm_id(self) -> Optional[str]:
        """
        Source VM identifier
        """
        return pulumi.get(self, "source_vm_id")

    @property
    @pulumi.getter(name="sourceVmIpType")
    def source_vm_ip_type(self) -> Optional[str]:
        """
        The value can be one of: `assigned` - assigned internal IP will be automatically chosen. `NAT`: NATed external IP will be automatically chosen.
        """
        return pulumi.get(self, "source_vm_ip_type")

    @property
    @pulumi.getter(name="sourceVmNicId")
    def source_vm_nic_id(self) -> Optional[int]:
        """
        Source VM NIC ID to which this rule applies.
        """
        return pulumi.get(self, "source_vm_nic_id")


@pulumi.output_type
class VappLease(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeLeaseInSec":
            suggest = "runtime_lease_in_sec"
        elif key == "storageLeaseInSec":
            suggest = "storage_lease_in_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappLease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappLease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappLease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 runtime_lease_in_sec: int,
                 storage_lease_in_sec: int):
        """
        :param int runtime_lease_in_sec: How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        :param int storage_lease_in_sec: How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        """
        pulumi.set(__self__, "runtime_lease_in_sec", runtime_lease_in_sec)
        pulumi.set(__self__, "storage_lease_in_sec", storage_lease_in_sec)

    @property
    @pulumi.getter(name="runtimeLeaseInSec")
    def runtime_lease_in_sec(self) -> int:
        """
        How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        """
        return pulumi.get(self, "runtime_lease_in_sec")

    @property
    @pulumi.getter(name="storageLeaseInSec")
    def storage_lease_in_sec(self) -> int:
        """
        How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by Org). Regular values accepted from 3600+.
        """
        return pulumi.get(self, "storage_lease_in_sec")


@pulumi.output_type
class VappMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VappNatRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vmId":
            suggest = "vm_id"
        elif key == "vmNicId":
            suggest = "vm_nic_id"
        elif key == "externalIp":
            suggest = "external_ip"
        elif key == "externalPort":
            suggest = "external_port"
        elif key == "forwardToPort":
            suggest = "forward_to_port"
        elif key == "mappingMode":
            suggest = "mapping_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappNatRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappNatRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappNatRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vm_id: str,
                 vm_nic_id: int,
                 external_ip: Optional[str] = None,
                 external_port: Optional[int] = None,
                 forward_to_port: Optional[int] = None,
                 id: Optional[str] = None,
                 mapping_mode: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str vm_id: VM to which this rule applies.
        :param int vm_nic_id: VM NIC ID to which this rule applies.
        :param str external_ip: External IP address to forward to or External IP address to map to VM
        :param int external_port: External port to forward.
        :param int forward_to_port: Internal port to forward.
        :param str id: ID of the rule. Can be used to track syslog messages.
        :param str mapping_mode: Mapping mode. One of: `automatic`, `manual`
        :param str protocol: Protocol to forward. One of: `TCP` (forward TCP packets), `UDP` (forward UDP packets), `TCP_UDP` (forward TCP and UDP packets).
        """
        pulumi.set(__self__, "vm_id", vm_id)
        pulumi.set(__self__, "vm_nic_id", vm_nic_id)
        if external_ip is not None:
            pulumi.set(__self__, "external_ip", external_ip)
        if external_port is not None:
            pulumi.set(__self__, "external_port", external_port)
        if forward_to_port is not None:
            pulumi.set(__self__, "forward_to_port", forward_to_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mapping_mode is not None:
            pulumi.set(__self__, "mapping_mode", mapping_mode)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> str:
        """
        VM to which this rule applies.
        """
        return pulumi.get(self, "vm_id")

    @property
    @pulumi.getter(name="vmNicId")
    def vm_nic_id(self) -> int:
        """
        VM NIC ID to which this rule applies.
        """
        return pulumi.get(self, "vm_nic_id")

    @property
    @pulumi.getter(name="externalIp")
    def external_ip(self) -> Optional[str]:
        """
        External IP address to forward to or External IP address to map to VM
        """
        return pulumi.get(self, "external_ip")

    @property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> Optional[int]:
        """
        External port to forward.
        """
        return pulumi.get(self, "external_port")

    @property
    @pulumi.getter(name="forwardToPort")
    def forward_to_port(self) -> Optional[int]:
        """
        Internal port to forward.
        """
        return pulumi.get(self, "forward_to_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the rule. Can be used to track syslog messages.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="mappingMode")
    def mapping_mode(self) -> Optional[str]:
        """
        Mapping mode. One of: `automatic`, `manual`
        """
        return pulumi.get(self, "mapping_mode")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol to forward. One of: `TCP` (forward TCP packets), `UDP` (forward UDP packets), `TCP_UDP` (forward TCP and UDP packets).
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class VappNetworkDhcpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startAddress":
            suggest = "start_address"
        elif key == "defaultLeaseTime":
            suggest = "default_lease_time"
        elif key == "endAddress":
            suggest = "end_address"
        elif key == "maxLeaseTime":
            suggest = "max_lease_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappNetworkDhcpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappNetworkDhcpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappNetworkDhcpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_address: str,
                 default_lease_time: Optional[int] = None,
                 enabled: Optional[bool] = None,
                 end_address: Optional[str] = None,
                 max_lease_time: Optional[int] = None):
        pulumi.set(__self__, "start_address", start_address)
        if default_lease_time is not None:
            pulumi.set(__self__, "default_lease_time", default_lease_time)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if end_address is not None:
            pulumi.set(__self__, "end_address", end_address)
        if max_lease_time is not None:
            pulumi.set(__self__, "max_lease_time", max_lease_time)

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        return pulumi.get(self, "start_address")

    @property
    @pulumi.getter(name="defaultLeaseTime")
    def default_lease_time(self) -> Optional[int]:
        return pulumi.get(self, "default_lease_time")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> Optional[str]:
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="maxLeaseTime")
    def max_lease_time(self) -> Optional[int]:
        return pulumi.get(self, "max_lease_time")


@pulumi.output_type
class VappNetworkStaticIpPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endAddress":
            suggest = "end_address"
        elif key == "startAddress":
            suggest = "start_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappNetworkStaticIpPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappNetworkStaticIpPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappNetworkStaticIpPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        return pulumi.get(self, "start_address")


@pulumi.output_type
class VappStaticRoutingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkCidr":
            suggest = "network_cidr"
        elif key == "nextHopIp":
            suggest = "next_hop_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappStaticRoutingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappStaticRoutingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappStaticRoutingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 network_cidr: str,
                 next_hop_ip: str):
        """
        :param str name: Name for the static route.
        :param str network_cidr: network specification in CIDR.
        :param str next_hop_ip: IP Address of Next Hop router/gateway.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_cidr", network_cidr)
        pulumi.set(__self__, "next_hop_ip", next_hop_ip)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the static route.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkCidr")
    def network_cidr(self) -> str:
        """
        network specification in CIDR.
        """
        return pulumi.get(self, "network_cidr")

    @property
    @pulumi.getter(name="nextHopIp")
    def next_hop_ip(self) -> str:
        """
        IP Address of Next Hop router/gateway.
        """
        return pulumi.get(self, "next_hop_ip")


@pulumi.output_type
class VappVmBootOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDelay":
            suggest = "boot_delay"
        elif key == "bootRetryDelay":
            suggest = "boot_retry_delay"
        elif key == "bootRetryEnabled":
            suggest = "boot_retry_enabled"
        elif key == "efiSecureBoot":
            suggest = "efi_secure_boot"
        elif key == "enterBiosSetupOnNextBoot":
            suggest = "enter_bios_setup_on_next_boot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappVmBootOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappVmBootOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappVmBootOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_delay: Optional[int] = None,
                 boot_retry_delay: Optional[int] = None,
                 boot_retry_enabled: Optional[bool] = None,
                 efi_secure_boot: Optional[bool] = None,
                 enter_bios_setup_on_next_boot: Optional[bool] = None):
        """
        :param int boot_delay: Number of milliseconds to wait between powering-on and booting the VM
        :param int boot_retry_delay: Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        :param bool boot_retry_enabled: If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        :param bool efi_secure_boot: If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        if boot_delay is not None:
            pulumi.set(__self__, "boot_delay", boot_delay)
        if boot_retry_delay is not None:
            pulumi.set(__self__, "boot_retry_delay", boot_retry_delay)
        if boot_retry_enabled is not None:
            pulumi.set(__self__, "boot_retry_enabled", boot_retry_enabled)
        if efi_secure_boot is not None:
            pulumi.set(__self__, "efi_secure_boot", efi_secure_boot)
        if enter_bios_setup_on_next_boot is not None:
            pulumi.set(__self__, "enter_bios_setup_on_next_boot", enter_bios_setup_on_next_boot)

    @property
    @pulumi.getter(name="bootDelay")
    def boot_delay(self) -> Optional[int]:
        """
        Number of milliseconds to wait between powering-on and booting the VM
        """
        return pulumi.get(self, "boot_delay")

    @property
    @pulumi.getter(name="bootRetryDelay")
    def boot_retry_delay(self) -> Optional[int]:
        """
        Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        """
        return pulumi.get(self, "boot_retry_delay")

    @property
    @pulumi.getter(name="bootRetryEnabled")
    def boot_retry_enabled(self) -> Optional[bool]:
        """
        If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        """
        return pulumi.get(self, "boot_retry_enabled")

    @property
    @pulumi.getter(name="efiSecureBoot")
    def efi_secure_boot(self) -> Optional[bool]:
        """
        If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        return pulumi.get(self, "efi_secure_boot")

    @property
    @pulumi.getter(name="enterBiosSetupOnNextBoot")
    def enter_bios_setup_on_next_boot(self) -> Optional[bool]:
        return pulumi.get(self, "enter_bios_setup_on_next_boot")


@pulumi.output_type
class VappVmCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "allowLocalAdminPassword":
            suggest = "allow_local_admin_password"
        elif key == "autoGeneratePassword":
            suggest = "auto_generate_password"
        elif key == "changeSid":
            suggest = "change_sid"
        elif key == "joinDomain":
            suggest = "join_domain"
        elif key == "joinDomainAccountOu":
            suggest = "join_domain_account_ou"
        elif key == "joinDomainName":
            suggest = "join_domain_name"
        elif key == "joinDomainPassword":
            suggest = "join_domain_password"
        elif key == "joinDomainUser":
            suggest = "join_domain_user"
        elif key == "joinOrgDomain":
            suggest = "join_org_domain"
        elif key == "mustChangePasswordOnFirstLogin":
            suggest = "must_change_password_on_first_login"
        elif key == "numberOfAutoLogons":
            suggest = "number_of_auto_logons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappVmCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappVmCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappVmCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 allow_local_admin_password: Optional[bool] = None,
                 auto_generate_password: Optional[bool] = None,
                 change_sid: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 force: Optional[bool] = None,
                 initscript: Optional[str] = None,
                 join_domain: Optional[bool] = None,
                 join_domain_account_ou: Optional[str] = None,
                 join_domain_name: Optional[str] = None,
                 join_domain_password: Optional[str] = None,
                 join_domain_user: Optional[str] = None,
                 join_org_domain: Optional[bool] = None,
                 must_change_password_on_first_login: Optional[bool] = None,
                 number_of_auto_logons: Optional[int] = None):
        """
        :param str admin_password: Manually specify admin password
        :param bool allow_local_admin_password: Allow local administrator password
        :param bool auto_generate_password: Auto generate password
        :param bool change_sid: 'true' value will change SID. Applicable only for Windows VMs
        :param bool enabled: 'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        :param bool force: 'true' value will cause the VM to reboot on every 'apply' operation
        :param str initscript: Script to run on initial boot or with customization.force=true set
        :param bool join_domain: Enable this VM to join a domain
        :param str join_domain_account_ou: Account organizational unit for domain name join
        :param str join_domain_name: Custom domain name for join
        :param str join_domain_password: Password for custom domain name join
        :param str join_domain_user: Username for custom domain name join
        :param bool join_org_domain: Use organization's domain for joining
        :param bool must_change_password_on_first_login: Require Administrator to change password on first login
        :param int number_of_auto_logons: Number of times to log on automatically. '0' - disabled.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if allow_local_admin_password is not None:
            pulumi.set(__self__, "allow_local_admin_password", allow_local_admin_password)
        if auto_generate_password is not None:
            pulumi.set(__self__, "auto_generate_password", auto_generate_password)
        if change_sid is not None:
            pulumi.set(__self__, "change_sid", change_sid)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if initscript is not None:
            pulumi.set(__self__, "initscript", initscript)
        if join_domain is not None:
            pulumi.set(__self__, "join_domain", join_domain)
        if join_domain_account_ou is not None:
            pulumi.set(__self__, "join_domain_account_ou", join_domain_account_ou)
        if join_domain_name is not None:
            pulumi.set(__self__, "join_domain_name", join_domain_name)
        if join_domain_password is not None:
            pulumi.set(__self__, "join_domain_password", join_domain_password)
        if join_domain_user is not None:
            pulumi.set(__self__, "join_domain_user", join_domain_user)
        if join_org_domain is not None:
            pulumi.set(__self__, "join_org_domain", join_org_domain)
        if must_change_password_on_first_login is not None:
            pulumi.set(__self__, "must_change_password_on_first_login", must_change_password_on_first_login)
        if number_of_auto_logons is not None:
            pulumi.set(__self__, "number_of_auto_logons", number_of_auto_logons)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        Manually specify admin password
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="allowLocalAdminPassword")
    def allow_local_admin_password(self) -> Optional[bool]:
        """
        Allow local administrator password
        """
        return pulumi.get(self, "allow_local_admin_password")

    @property
    @pulumi.getter(name="autoGeneratePassword")
    def auto_generate_password(self) -> Optional[bool]:
        """
        Auto generate password
        """
        return pulumi.get(self, "auto_generate_password")

    @property
    @pulumi.getter(name="changeSid")
    def change_sid(self) -> Optional[bool]:
        """
        'true' value will change SID. Applicable only for Windows VMs
        """
        return pulumi.get(self, "change_sid")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        """
        'true' value will cause the VM to reboot on every 'apply' operation
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter
    def initscript(self) -> Optional[str]:
        """
        Script to run on initial boot or with customization.force=true set
        """
        return pulumi.get(self, "initscript")

    @property
    @pulumi.getter(name="joinDomain")
    def join_domain(self) -> Optional[bool]:
        """
        Enable this VM to join a domain
        """
        return pulumi.get(self, "join_domain")

    @property
    @pulumi.getter(name="joinDomainAccountOu")
    def join_domain_account_ou(self) -> Optional[str]:
        """
        Account organizational unit for domain name join
        """
        return pulumi.get(self, "join_domain_account_ou")

    @property
    @pulumi.getter(name="joinDomainName")
    def join_domain_name(self) -> Optional[str]:
        """
        Custom domain name for join
        """
        return pulumi.get(self, "join_domain_name")

    @property
    @pulumi.getter(name="joinDomainPassword")
    def join_domain_password(self) -> Optional[str]:
        """
        Password for custom domain name join
        """
        return pulumi.get(self, "join_domain_password")

    @property
    @pulumi.getter(name="joinDomainUser")
    def join_domain_user(self) -> Optional[str]:
        """
        Username for custom domain name join
        """
        return pulumi.get(self, "join_domain_user")

    @property
    @pulumi.getter(name="joinOrgDomain")
    def join_org_domain(self) -> Optional[bool]:
        """
        Use organization's domain for joining
        """
        return pulumi.get(self, "join_org_domain")

    @property
    @pulumi.getter(name="mustChangePasswordOnFirstLogin")
    def must_change_password_on_first_login(self) -> Optional[bool]:
        """
        Require Administrator to change password on first login
        """
        return pulumi.get(self, "must_change_password_on_first_login")

    @property
    @pulumi.getter(name="numberOfAutoLogons")
    def number_of_auto_logons(self) -> Optional[int]:
        """
        Number of times to log on automatically. '0' - disabled.
        """
        return pulumi.get(self, "number_of_auto_logons")


@pulumi.output_type
class VappVmDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "busNumber":
            suggest = "bus_number"
        elif key == "unitNumber":
            suggest = "unit_number"
        elif key == "sizeInMb":
            suggest = "size_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappVmDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappVmDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappVmDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bus_number: str,
                 name: str,
                 unit_number: str,
                 size_in_mb: Optional[int] = None):
        """
        :param str bus_number: Bus number on which to place the disk controller
        :param str name: A name for the VM, unique within the vApp
        :param str unit_number: Unit number (slot) on the bus specified by BusNumber
        :param int size_in_mb: (*v2.7+*) Independent disk size in MB.
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "unit_number", unit_number)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> str:
        """
        Bus number on which to place the disk controller
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name for the VM, unique within the vApp
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> str:
        """
        Unit number (slot) on the bus specified by BusNumber
        """
        return pulumi.get(self, "unit_number")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[int]:
        """
        (*v2.7+*) Independent disk size in MB.
        """
        return pulumi.get(self, "size_in_mb")


@pulumi.output_type
class VappVmExtraConfig(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 required: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the extra configuration item
        :param bool required: Whether the extra configuration item is required
        :param str value: The value of the extra configuration item
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Whether the extra configuration item is required
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the extra configuration item
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VappVmInternalDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "busNumber":
            suggest = "bus_number"
        elif key == "busType":
            suggest = "bus_type"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "sizeInMb":
            suggest = "size_in_mb"
        elif key == "storageProfile":
            suggest = "storage_profile"
        elif key == "thinProvisioned":
            suggest = "thin_provisioned"
        elif key == "unitNumber":
            suggest = "unit_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappVmInternalDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappVmInternalDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappVmInternalDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bus_number: Optional[int] = None,
                 bus_type: Optional[str] = None,
                 disk_id: Optional[str] = None,
                 iops: Optional[int] = None,
                 size_in_mb: Optional[int] = None,
                 storage_profile: Optional[str] = None,
                 thin_provisioned: Optional[bool] = None,
                 unit_number: Optional[int] = None):
        """
        :param int bus_number: The number of the SCSI or IDE controller itself.
        :param str bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param str disk_id: The disk ID.
        :param int iops: Specifies the IOPS for the disk. Default is 0.
        :param int size_in_mb: The size of the disk in MB.
        :param str storage_profile: Storage profile to override the default one
        :param bool thin_provisioned: Specifies whether the disk storage is pre-allocated or allocated on demand.
        :param int unit_number: The device number on the SCSI or IDE controller of the disk.
        """
        if bus_number is not None:
            pulumi.set(__self__, "bus_number", bus_number)
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if thin_provisioned is not None:
            pulumi.set(__self__, "thin_provisioned", thin_provisioned)
        if unit_number is not None:
            pulumi.set(__self__, "unit_number", unit_number)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> Optional[int]:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[str]:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[str]:
        """
        The disk ID.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[int]:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[str]:
        """
        Storage profile to override the default one
        """
        return pulumi.get(self, "storage_profile")

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> Optional[bool]:
        """
        Specifies whether the disk storage is pre-allocated or allocated on demand.
        """
        return pulumi.get(self, "thin_provisioned")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> Optional[int]:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")


@pulumi.output_type
class VappVmMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappVmMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappVmMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappVmMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VappVmNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAllocationMode":
            suggest = "ip_allocation_mode"
        elif key == "adapterType":
            suggest = "adapter_type"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "secondaryIp":
            suggest = "secondary_ip"
        elif key == "secondaryIpAllocationMode":
            suggest = "secondary_ip_allocation_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappVmNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappVmNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappVmNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_allocation_mode: str,
                 type: str,
                 adapter_type: Optional[str] = None,
                 connected: Optional[bool] = None,
                 ip: Optional[str] = None,
                 is_primary: Optional[bool] = None,
                 mac: Optional[str] = None,
                 name: Optional[str] = None,
                 secondary_ip: Optional[str] = None,
                 secondary_ip_allocation_mode: Optional[str] = None):
        """
        :param str ip_allocation_mode: IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        :param str type: Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        :param str adapter_type: Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        :param bool connected: It defines if NIC is connected or not.
        :param str ip: IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param bool is_primary: Set to true if network interface should be primary. First network card in the list will be primary by default
        :param str mac: Mac address of network interface
        :param str name: A name for the VM, unique within the vApp
        :param str secondary_ip: Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param str secondary_ip_allocation_mode: Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        pulumi.set(__self__, "ip_allocation_mode", ip_allocation_mode)
        pulumi.set(__self__, "type", type)
        if adapter_type is not None:
            pulumi.set(__self__, "adapter_type", adapter_type)
        if connected is not None:
            pulumi.set(__self__, "connected", connected)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secondary_ip is not None:
            pulumi.set(__self__, "secondary_ip", secondary_ip)
        if secondary_ip_allocation_mode is not None:
            pulumi.set(__self__, "secondary_ip_allocation_mode", secondary_ip_allocation_mode)

    @property
    @pulumi.getter(name="ipAllocationMode")
    def ip_allocation_mode(self) -> str:
        """
        IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "ip_allocation_mode")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> Optional[str]:
        """
        Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        """
        return pulumi.get(self, "adapter_type")

    @property
    @pulumi.getter
    def connected(self) -> Optional[bool]:
        """
        It defines if NIC is connected or not.
        """
        return pulumi.get(self, "connected")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[bool]:
        """
        Set to true if network interface should be primary. First network card in the list will be primary by default
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        Mac address of network interface
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        A name for the VM, unique within the vApp
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secondaryIp")
    def secondary_ip(self) -> Optional[str]:
        """
        Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "secondary_ip")

    @property
    @pulumi.getter(name="secondaryIpAllocationMode")
    def secondary_ip_allocation_mode(self) -> Optional[str]:
        """
        Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "secondary_ip_allocation_mode")


@pulumi.output_type
class VappVmOverrideTemplateDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "busNumber":
            suggest = "bus_number"
        elif key == "busType":
            suggest = "bus_type"
        elif key == "sizeInMb":
            suggest = "size_in_mb"
        elif key == "unitNumber":
            suggest = "unit_number"
        elif key == "storageProfile":
            suggest = "storage_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VappVmOverrideTemplateDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VappVmOverrideTemplateDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VappVmOverrideTemplateDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bus_number: int,
                 bus_type: str,
                 size_in_mb: int,
                 unit_number: int,
                 iops: Optional[int] = None,
                 storage_profile: Optional[str] = None):
        """
        :param int bus_number: The number of the SCSI or IDE controller itself.
        :param str bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param int size_in_mb: The size of the disk in MB.
        :param int unit_number: The device number on the SCSI or IDE controller of the disk.
        :param int iops: Specifies the IOPS for the disk. Default is 0.
        :param str storage_profile: Storage profile to override the default one
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "bus_type", bus_type)
        pulumi.set(__self__, "size_in_mb", size_in_mb)
        pulumi.set(__self__, "unit_number", unit_number)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> int:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> str:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> int:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> int:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[str]:
        """
        Storage profile to override the default one
        """
        return pulumi.get(self, "storage_profile")


@pulumi.output_type
class VappVmSetExtraConfig(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key of the extra configuration item
        :param str value: The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VdcGroupParticipatingOrgVdc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "faultDomainTag":
            suggest = "fault_domain_tag"
        elif key == "isRemoteOrg":
            suggest = "is_remote_org"
        elif key == "networkProviderScope":
            suggest = "network_provider_scope"
        elif key == "orgId":
            suggest = "org_id"
        elif key == "orgName":
            suggest = "org_name"
        elif key == "siteId":
            suggest = "site_id"
        elif key == "siteName":
            suggest = "site_name"
        elif key == "vdcId":
            suggest = "vdc_id"
        elif key == "vdcName":
            suggest = "vdc_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VdcGroupParticipatingOrgVdc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VdcGroupParticipatingOrgVdc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VdcGroupParticipatingOrgVdc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fault_domain_tag: Optional[str] = None,
                 is_remote_org: Optional[bool] = None,
                 network_provider_scope: Optional[str] = None,
                 org_id: Optional[str] = None,
                 org_name: Optional[str] = None,
                 site_id: Optional[str] = None,
                 site_name: Optional[str] = None,
                 status: Optional[str] = None,
                 vdc_id: Optional[str] = None,
                 vdc_name: Optional[str] = None):
        """
        :param str fault_domain_tag: Represents the fault domain of a given organization VDC
        :param bool is_remote_org: Specifies whether the VDC is local to this VCD site
        :param str network_provider_scope: Specifies the network provider scope of the VDC
        :param str org_id: Organization VDC belongs
        :param str org_name: Organization VDC belongs
        :param str site_id: Site VDC belongs
        :param str site_name: Site VDC belongs
        :param str status: The status that the group can be in (e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED').
        :param str vdc_id: VDC ID
        :param str vdc_name: VDC name
        """
        if fault_domain_tag is not None:
            pulumi.set(__self__, "fault_domain_tag", fault_domain_tag)
        if is_remote_org is not None:
            pulumi.set(__self__, "is_remote_org", is_remote_org)
        if network_provider_scope is not None:
            pulumi.set(__self__, "network_provider_scope", network_provider_scope)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)
        if site_id is not None:
            pulumi.set(__self__, "site_id", site_id)
        if site_name is not None:
            pulumi.set(__self__, "site_name", site_name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if vdc_id is not None:
            pulumi.set(__self__, "vdc_id", vdc_id)
        if vdc_name is not None:
            pulumi.set(__self__, "vdc_name", vdc_name)

    @property
    @pulumi.getter(name="faultDomainTag")
    def fault_domain_tag(self) -> Optional[str]:
        """
        Represents the fault domain of a given organization VDC
        """
        return pulumi.get(self, "fault_domain_tag")

    @property
    @pulumi.getter(name="isRemoteOrg")
    def is_remote_org(self) -> Optional[bool]:
        """
        Specifies whether the VDC is local to this VCD site
        """
        return pulumi.get(self, "is_remote_org")

    @property
    @pulumi.getter(name="networkProviderScope")
    def network_provider_scope(self) -> Optional[str]:
        """
        Specifies the network provider scope of the VDC
        """
        return pulumi.get(self, "network_provider_scope")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[str]:
        """
        Organization VDC belongs
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[str]:
        """
        Organization VDC belongs
        """
        return pulumi.get(self, "org_name")

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> Optional[str]:
        """
        Site VDC belongs
        """
        return pulumi.get(self, "site_id")

    @property
    @pulumi.getter(name="siteName")
    def site_name(self) -> Optional[str]:
        """
        Site VDC belongs
        """
        return pulumi.get(self, "site_name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status that the group can be in (e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED').
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="vdcId")
    def vdc_id(self) -> Optional[str]:
        """
        VDC ID
        """
        return pulumi.get(self, "vdc_id")

    @property
    @pulumi.getter(name="vdcName")
    def vdc_name(self) -> Optional[str]:
        """
        VDC name
        """
        return pulumi.get(self, "vdc_name")


@pulumi.output_type
class VmBootOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bootDelay":
            suggest = "boot_delay"
        elif key == "bootRetryDelay":
            suggest = "boot_retry_delay"
        elif key == "bootRetryEnabled":
            suggest = "boot_retry_enabled"
        elif key == "efiSecureBoot":
            suggest = "efi_secure_boot"
        elif key == "enterBiosSetupOnNextBoot":
            suggest = "enter_bios_setup_on_next_boot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmBootOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmBootOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmBootOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot_delay: Optional[int] = None,
                 boot_retry_delay: Optional[int] = None,
                 boot_retry_enabled: Optional[bool] = None,
                 efi_secure_boot: Optional[bool] = None,
                 enter_bios_setup_on_next_boot: Optional[bool] = None):
        """
        :param int boot_delay: Number of milliseconds to wait between powering-on and booting the VM
        :param int boot_retry_delay: Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        :param bool boot_retry_enabled: If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        :param bool efi_secure_boot: If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        if boot_delay is not None:
            pulumi.set(__self__, "boot_delay", boot_delay)
        if boot_retry_delay is not None:
            pulumi.set(__self__, "boot_retry_delay", boot_retry_delay)
        if boot_retry_enabled is not None:
            pulumi.set(__self__, "boot_retry_enabled", boot_retry_enabled)
        if efi_secure_boot is not None:
            pulumi.set(__self__, "efi_secure_boot", efi_secure_boot)
        if enter_bios_setup_on_next_boot is not None:
            pulumi.set(__self__, "enter_bios_setup_on_next_boot", enter_bios_setup_on_next_boot)

    @property
    @pulumi.getter(name="bootDelay")
    def boot_delay(self) -> Optional[int]:
        """
        Number of milliseconds to wait between powering-on and booting the VM
        """
        return pulumi.get(self, "boot_delay")

    @property
    @pulumi.getter(name="bootRetryDelay")
    def boot_retry_delay(self) -> Optional[int]:
        """
        Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        """
        return pulumi.get(self, "boot_retry_delay")

    @property
    @pulumi.getter(name="bootRetryEnabled")
    def boot_retry_enabled(self) -> Optional[bool]:
        """
        If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        """
        return pulumi.get(self, "boot_retry_enabled")

    @property
    @pulumi.getter(name="efiSecureBoot")
    def efi_secure_boot(self) -> Optional[bool]:
        """
        If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        return pulumi.get(self, "efi_secure_boot")

    @property
    @pulumi.getter(name="enterBiosSetupOnNextBoot")
    def enter_bios_setup_on_next_boot(self) -> Optional[bool]:
        return pulumi.get(self, "enter_bios_setup_on_next_boot")


@pulumi.output_type
class VmCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminPassword":
            suggest = "admin_password"
        elif key == "allowLocalAdminPassword":
            suggest = "allow_local_admin_password"
        elif key == "autoGeneratePassword":
            suggest = "auto_generate_password"
        elif key == "changeSid":
            suggest = "change_sid"
        elif key == "joinDomain":
            suggest = "join_domain"
        elif key == "joinDomainAccountOu":
            suggest = "join_domain_account_ou"
        elif key == "joinDomainName":
            suggest = "join_domain_name"
        elif key == "joinDomainPassword":
            suggest = "join_domain_password"
        elif key == "joinDomainUser":
            suggest = "join_domain_user"
        elif key == "joinOrgDomain":
            suggest = "join_org_domain"
        elif key == "mustChangePasswordOnFirstLogin":
            suggest = "must_change_password_on_first_login"
        elif key == "numberOfAutoLogons":
            suggest = "number_of_auto_logons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_password: Optional[str] = None,
                 allow_local_admin_password: Optional[bool] = None,
                 auto_generate_password: Optional[bool] = None,
                 change_sid: Optional[bool] = None,
                 enabled: Optional[bool] = None,
                 force: Optional[bool] = None,
                 initscript: Optional[str] = None,
                 join_domain: Optional[bool] = None,
                 join_domain_account_ou: Optional[str] = None,
                 join_domain_name: Optional[str] = None,
                 join_domain_password: Optional[str] = None,
                 join_domain_user: Optional[str] = None,
                 join_org_domain: Optional[bool] = None,
                 must_change_password_on_first_login: Optional[bool] = None,
                 number_of_auto_logons: Optional[int] = None):
        """
        :param str admin_password: Manually specify admin password
        :param bool allow_local_admin_password: Allow local administrator password
        :param bool auto_generate_password: Auto generate password
        :param bool change_sid: 'true' value will change SID. Applicable only for Windows VMs
        :param bool enabled: 'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        :param bool force: 'true' value will cause the VM to reboot on every 'apply' operation
        :param str initscript: Script to run on initial boot or with customization.force=true set
        :param bool join_domain: Enable this VM to join a domain
        :param str join_domain_account_ou: Account organizational unit for domain name join
        :param str join_domain_name: Custom domain name for join
        :param str join_domain_password: Password for custom domain name join
        :param str join_domain_user: Username for custom domain name join
        :param bool join_org_domain: Use organization's domain for joining
        :param bool must_change_password_on_first_login: Require Administrator to change password on first login
        :param int number_of_auto_logons: Number of times to log on automatically. '0' - disabled.
        """
        if admin_password is not None:
            pulumi.set(__self__, "admin_password", admin_password)
        if allow_local_admin_password is not None:
            pulumi.set(__self__, "allow_local_admin_password", allow_local_admin_password)
        if auto_generate_password is not None:
            pulumi.set(__self__, "auto_generate_password", auto_generate_password)
        if change_sid is not None:
            pulumi.set(__self__, "change_sid", change_sid)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if initscript is not None:
            pulumi.set(__self__, "initscript", initscript)
        if join_domain is not None:
            pulumi.set(__self__, "join_domain", join_domain)
        if join_domain_account_ou is not None:
            pulumi.set(__self__, "join_domain_account_ou", join_domain_account_ou)
        if join_domain_name is not None:
            pulumi.set(__self__, "join_domain_name", join_domain_name)
        if join_domain_password is not None:
            pulumi.set(__self__, "join_domain_password", join_domain_password)
        if join_domain_user is not None:
            pulumi.set(__self__, "join_domain_user", join_domain_user)
        if join_org_domain is not None:
            pulumi.set(__self__, "join_org_domain", join_org_domain)
        if must_change_password_on_first_login is not None:
            pulumi.set(__self__, "must_change_password_on_first_login", must_change_password_on_first_login)
        if number_of_auto_logons is not None:
            pulumi.set(__self__, "number_of_auto_logons", number_of_auto_logons)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> Optional[str]:
        """
        Manually specify admin password
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="allowLocalAdminPassword")
    def allow_local_admin_password(self) -> Optional[bool]:
        """
        Allow local administrator password
        """
        return pulumi.get(self, "allow_local_admin_password")

    @property
    @pulumi.getter(name="autoGeneratePassword")
    def auto_generate_password(self) -> Optional[bool]:
        """
        Auto generate password
        """
        return pulumi.get(self, "auto_generate_password")

    @property
    @pulumi.getter(name="changeSid")
    def change_sid(self) -> Optional[bool]:
        """
        'true' value will change SID. Applicable only for Windows VMs
        """
        return pulumi.get(self, "change_sid")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def force(self) -> Optional[bool]:
        """
        'true' value will cause the VM to reboot on every 'apply' operation
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter
    def initscript(self) -> Optional[str]:
        """
        Script to run on initial boot or with customization.force=true set
        """
        return pulumi.get(self, "initscript")

    @property
    @pulumi.getter(name="joinDomain")
    def join_domain(self) -> Optional[bool]:
        """
        Enable this VM to join a domain
        """
        return pulumi.get(self, "join_domain")

    @property
    @pulumi.getter(name="joinDomainAccountOu")
    def join_domain_account_ou(self) -> Optional[str]:
        """
        Account organizational unit for domain name join
        """
        return pulumi.get(self, "join_domain_account_ou")

    @property
    @pulumi.getter(name="joinDomainName")
    def join_domain_name(self) -> Optional[str]:
        """
        Custom domain name for join
        """
        return pulumi.get(self, "join_domain_name")

    @property
    @pulumi.getter(name="joinDomainPassword")
    def join_domain_password(self) -> Optional[str]:
        """
        Password for custom domain name join
        """
        return pulumi.get(self, "join_domain_password")

    @property
    @pulumi.getter(name="joinDomainUser")
    def join_domain_user(self) -> Optional[str]:
        """
        Username for custom domain name join
        """
        return pulumi.get(self, "join_domain_user")

    @property
    @pulumi.getter(name="joinOrgDomain")
    def join_org_domain(self) -> Optional[bool]:
        """
        Use organization's domain for joining
        """
        return pulumi.get(self, "join_org_domain")

    @property
    @pulumi.getter(name="mustChangePasswordOnFirstLogin")
    def must_change_password_on_first_login(self) -> Optional[bool]:
        """
        Require Administrator to change password on first login
        """
        return pulumi.get(self, "must_change_password_on_first_login")

    @property
    @pulumi.getter(name="numberOfAutoLogons")
    def number_of_auto_logons(self) -> Optional[int]:
        """
        Number of times to log on automatically. '0' - disabled.
        """
        return pulumi.get(self, "number_of_auto_logons")


@pulumi.output_type
class VmDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "busNumber":
            suggest = "bus_number"
        elif key == "unitNumber":
            suggest = "unit_number"
        elif key == "sizeInMb":
            suggest = "size_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bus_number: str,
                 name: str,
                 unit_number: str,
                 size_in_mb: Optional[int] = None):
        """
        :param str bus_number: Bus number on which to place the disk controller
        :param str name: Independent disk name
        :param str unit_number: Unit number (slot) on the bus specified by BusNumber
        :param int size_in_mb: The size of the disk in MB.
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "unit_number", unit_number)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> str:
        """
        Bus number on which to place the disk controller
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Independent disk name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> str:
        """
        Unit number (slot) on the bus specified by BusNumber
        """
        return pulumi.get(self, "unit_number")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[int]:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")


@pulumi.output_type
class VmExtraConfig(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 required: Optional[bool] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the extra configuration item
        :param bool required: Whether the extra configuration item is required
        :param str value: The value of the extra configuration item
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def required(self) -> Optional[bool]:
        """
        Whether the extra configuration item is required
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the extra configuration item
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VmInternalDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "busNumber":
            suggest = "bus_number"
        elif key == "busType":
            suggest = "bus_type"
        elif key == "diskId":
            suggest = "disk_id"
        elif key == "sizeInMb":
            suggest = "size_in_mb"
        elif key == "storageProfile":
            suggest = "storage_profile"
        elif key == "thinProvisioned":
            suggest = "thin_provisioned"
        elif key == "unitNumber":
            suggest = "unit_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmInternalDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmInternalDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmInternalDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bus_number: Optional[int] = None,
                 bus_type: Optional[str] = None,
                 disk_id: Optional[str] = None,
                 iops: Optional[int] = None,
                 size_in_mb: Optional[int] = None,
                 storage_profile: Optional[str] = None,
                 thin_provisioned: Optional[bool] = None,
                 unit_number: Optional[int] = None):
        """
        :param int bus_number: The number of the SCSI or IDE controller itself.
        :param str bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param str disk_id: The disk ID.
        :param int iops: Specifies the IOPS for the disk. Default is 0.
        :param int size_in_mb: The size of the disk in MB.
        :param str storage_profile: Storage profile to override the VM default one
        :param bool thin_provisioned: Specifies whether the disk storage is pre-allocated or allocated on demand.
        :param int unit_number: The device number on the SCSI or IDE controller of the disk.
        """
        if bus_number is not None:
            pulumi.set(__self__, "bus_number", bus_number)
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if disk_id is not None:
            pulumi.set(__self__, "disk_id", disk_id)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)
        if thin_provisioned is not None:
            pulumi.set(__self__, "thin_provisioned", thin_provisioned)
        if unit_number is not None:
            pulumi.set(__self__, "unit_number", unit_number)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> Optional[int]:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[str]:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> Optional[str]:
        """
        The disk ID.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[int]:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[str]:
        """
        Storage profile to override the VM default one
        """
        return pulumi.get(self, "storage_profile")

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> Optional[bool]:
        """
        Specifies whether the disk storage is pre-allocated or allocated on demand.
        """
        return pulumi.get(self, "thin_provisioned")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> Optional[int]:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")


@pulumi.output_type
class VmMetadataEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSystem":
            suggest = "is_system"
        elif key == "userAccess":
            suggest = "user_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmMetadataEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmMetadataEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmMetadataEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_system: Optional[bool] = None,
                 key: Optional[str] = None,
                 type: Optional[str] = None,
                 user_access: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry. Required if the metadata entry is not empty
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry. Required if the metadata entry is not empty
        """
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if user_access is not None:
            pulumi.set(__self__, "user_access", user_access)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> Optional[str]:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of this metadata entry. Required if the metadata entry is not empty
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VmNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAllocationMode":
            suggest = "ip_allocation_mode"
        elif key == "adapterType":
            suggest = "adapter_type"
        elif key == "isPrimary":
            suggest = "is_primary"
        elif key == "secondaryIp":
            suggest = "secondary_ip"
        elif key == "secondaryIpAllocationMode":
            suggest = "secondary_ip_allocation_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_allocation_mode: str,
                 type: str,
                 adapter_type: Optional[str] = None,
                 connected: Optional[bool] = None,
                 ip: Optional[str] = None,
                 is_primary: Optional[bool] = None,
                 mac: Optional[str] = None,
                 name: Optional[str] = None,
                 secondary_ip: Optional[str] = None,
                 secondary_ip_allocation_mode: Optional[str] = None):
        """
        :param str ip_allocation_mode: IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        :param str type: Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        :param str adapter_type: Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        :param bool connected: It defines if NIC is connected or not.
        :param str ip: IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param bool is_primary: Set to true if network interface should be primary. First network card in the list will be primary by default
        :param str mac: Mac address of network interface
        :param str name: Name of the network this VM should connect to. Always required except for `type` `NONE`
        :param str secondary_ip: Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param str secondary_ip_allocation_mode: Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        pulumi.set(__self__, "ip_allocation_mode", ip_allocation_mode)
        pulumi.set(__self__, "type", type)
        if adapter_type is not None:
            pulumi.set(__self__, "adapter_type", adapter_type)
        if connected is not None:
            pulumi.set(__self__, "connected", connected)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if is_primary is not None:
            pulumi.set(__self__, "is_primary", is_primary)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secondary_ip is not None:
            pulumi.set(__self__, "secondary_ip", secondary_ip)
        if secondary_ip_allocation_mode is not None:
            pulumi.set(__self__, "secondary_ip_allocation_mode", secondary_ip_allocation_mode)

    @property
    @pulumi.getter(name="ipAllocationMode")
    def ip_allocation_mode(self) -> str:
        """
        IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "ip_allocation_mode")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Network type to use: 'vapp', 'org' or 'none'. Use 'vapp' for vApp network, 'org' to attach Org VDC network. 'none' for empty NIC.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> Optional[str]:
        """
        Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        """
        return pulumi.get(self, "adapter_type")

    @property
    @pulumi.getter
    def connected(self) -> Optional[bool]:
        """
        It defines if NIC is connected or not.
        """
        return pulumi.get(self, "connected")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> Optional[bool]:
        """
        Set to true if network interface should be primary. First network card in the list will be primary by default
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        Mac address of network interface
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the network this VM should connect to. Always required except for `type` `NONE`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secondaryIp")
    def secondary_ip(self) -> Optional[str]:
        """
        Secondary (IPv6) IP of the VM. Settings depend on `secondary_ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "secondary_ip")

    @property
    @pulumi.getter(name="secondaryIpAllocationMode")
    def secondary_ip_allocation_mode(self) -> Optional[str]:
        """
        Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "secondary_ip_allocation_mode")


@pulumi.output_type
class VmOverrideTemplateDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "busNumber":
            suggest = "bus_number"
        elif key == "busType":
            suggest = "bus_type"
        elif key == "sizeInMb":
            suggest = "size_in_mb"
        elif key == "unitNumber":
            suggest = "unit_number"
        elif key == "storageProfile":
            suggest = "storage_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmOverrideTemplateDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmOverrideTemplateDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmOverrideTemplateDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bus_number: int,
                 bus_type: str,
                 size_in_mb: int,
                 unit_number: int,
                 iops: Optional[int] = None,
                 storage_profile: Optional[str] = None):
        """
        :param int bus_number: The number of the SCSI or IDE controller itself.
        :param str bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param int size_in_mb: The size of the disk in MB.
        :param int unit_number: The device number on the SCSI or IDE controller of the disk.
        :param int iops: Specifies the IOPS for the disk. Default is 0.
        :param str storage_profile: Storage profile to override the VM default one
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "bus_type", bus_type)
        pulumi.set(__self__, "size_in_mb", size_in_mb)
        pulumi.set(__self__, "unit_number", unit_number)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if storage_profile is not None:
            pulumi.set(__self__, "storage_profile", storage_profile)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> int:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> str:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> int:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> int:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> Optional[str]:
        """
        Storage profile to override the VM default one
        """
        return pulumi.get(self, "storage_profile")


@pulumi.output_type
class VmSetExtraConfig(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key of the extra configuration item
        :param str value: The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the extra configuration item. Leaving the `value` field empty will result in the item deletion
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VmSizingPolicyCpu(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coresPerSocket":
            suggest = "cores_per_socket"
        elif key == "limitInMhz":
            suggest = "limit_in_mhz"
        elif key == "reservationGuarantee":
            suggest = "reservation_guarantee"
        elif key == "speedInMhz":
            suggest = "speed_in_mhz"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmSizingPolicyCpu. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmSizingPolicyCpu.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmSizingPolicyCpu.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores_per_socket: Optional[str] = None,
                 count: Optional[str] = None,
                 limit_in_mhz: Optional[str] = None,
                 reservation_guarantee: Optional[str] = None,
                 shares: Optional[str] = None,
                 speed_in_mhz: Optional[str] = None):
        """
        :param str cores_per_socket: The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        :param str count: Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        :param str limit_in_mhz: Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        :param str reservation_guarantee: Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        :param str shares: Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param str speed_in_mhz: Defines the vCPU speed of a core in MHz.
        """
        if cores_per_socket is not None:
            pulumi.set(__self__, "cores_per_socket", cores_per_socket)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if limit_in_mhz is not None:
            pulumi.set(__self__, "limit_in_mhz", limit_in_mhz)
        if reservation_guarantee is not None:
            pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        if shares is not None:
            pulumi.set(__self__, "shares", shares)
        if speed_in_mhz is not None:
            pulumi.set(__self__, "speed_in_mhz", speed_in_mhz)

    @property
    @pulumi.getter(name="coresPerSocket")
    def cores_per_socket(self) -> Optional[str]:
        """
        The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        """
        return pulumi.get(self, "cores_per_socket")

    @property
    @pulumi.getter
    def count(self) -> Optional[str]:
        """
        Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="limitInMhz")
    def limit_in_mhz(self) -> Optional[str]:
        """
        Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        """
        return pulumi.get(self, "limit_in_mhz")

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> Optional[str]:
        """
        Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @property
    @pulumi.getter
    def shares(self) -> Optional[str]:
        """
        Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @property
    @pulumi.getter(name="speedInMhz")
    def speed_in_mhz(self) -> Optional[str]:
        """
        Defines the vCPU speed of a core in MHz.
        """
        return pulumi.get(self, "speed_in_mhz")


@pulumi.output_type
class VmSizingPolicyMemory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitInMb":
            suggest = "limit_in_mb"
        elif key == "reservationGuarantee":
            suggest = "reservation_guarantee"
        elif key == "sizeInMb":
            suggest = "size_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmSizingPolicyMemory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmSizingPolicyMemory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmSizingPolicyMemory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_in_mb: Optional[str] = None,
                 reservation_guarantee: Optional[str] = None,
                 shares: Optional[str] = None,
                 size_in_mb: Optional[str] = None):
        """
        :param str limit_in_mb: Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        :param str reservation_guarantee: Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        :param str shares: Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param str size_in_mb: Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        if limit_in_mb is not None:
            pulumi.set(__self__, "limit_in_mb", limit_in_mb)
        if reservation_guarantee is not None:
            pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        if shares is not None:
            pulumi.set(__self__, "shares", shares)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="limitInMb")
    def limit_in_mb(self) -> Optional[str]:
        """
        Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        """
        return pulumi.get(self, "limit_in_mb")

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> Optional[str]:
        """
        Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @property
    @pulumi.getter
    def shares(self) -> Optional[str]:
        """
        Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[str]:
        """
        Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        return pulumi.get(self, "size_in_mb")


@pulumi.output_type
class VmVgpuPolicyCpu(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coresPerSocket":
            suggest = "cores_per_socket"
        elif key == "limitInMhz":
            suggest = "limit_in_mhz"
        elif key == "reservationGuarantee":
            suggest = "reservation_guarantee"
        elif key == "speedInMhz":
            suggest = "speed_in_mhz"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmVgpuPolicyCpu. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmVgpuPolicyCpu.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmVgpuPolicyCpu.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores_per_socket: Optional[str] = None,
                 count: Optional[str] = None,
                 limit_in_mhz: Optional[str] = None,
                 reservation_guarantee: Optional[str] = None,
                 shares: Optional[str] = None,
                 speed_in_mhz: Optional[str] = None):
        """
        :param str cores_per_socket: The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        :param str count: Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        :param str limit_in_mhz: Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        :param str reservation_guarantee: Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        :param str shares: Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param str speed_in_mhz: Defines the vCPU speed of a core in MHz.
        """
        if cores_per_socket is not None:
            pulumi.set(__self__, "cores_per_socket", cores_per_socket)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if limit_in_mhz is not None:
            pulumi.set(__self__, "limit_in_mhz", limit_in_mhz)
        if reservation_guarantee is not None:
            pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        if shares is not None:
            pulumi.set(__self__, "shares", shares)
        if speed_in_mhz is not None:
            pulumi.set(__self__, "speed_in_mhz", speed_in_mhz)

    @property
    @pulumi.getter(name="coresPerSocket")
    def cores_per_socket(self) -> Optional[str]:
        """
        The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        """
        return pulumi.get(self, "cores_per_socket")

    @property
    @pulumi.getter
    def count(self) -> Optional[str]:
        """
        Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="limitInMhz")
    def limit_in_mhz(self) -> Optional[str]:
        """
        Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs. -1 means unlimited
        """
        return pulumi.get(self, "limit_in_mhz")

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> Optional[str]:
        """
        Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @property
    @pulumi.getter
    def shares(self) -> Optional[str]:
        """
        Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @property
    @pulumi.getter(name="speedInMhz")
    def speed_in_mhz(self) -> Optional[str]:
        """
        Defines the vCPU speed of a core in MHz.
        """
        return pulumi.get(self, "speed_in_mhz")


@pulumi.output_type
class VmVgpuPolicyMemory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitInMb":
            suggest = "limit_in_mb"
        elif key == "reservationGuarantee":
            suggest = "reservation_guarantee"
        elif key == "sizeInMb":
            suggest = "size_in_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmVgpuPolicyMemory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmVgpuPolicyMemory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmVgpuPolicyMemory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limit_in_mb: Optional[str] = None,
                 reservation_guarantee: Optional[str] = None,
                 shares: Optional[str] = None,
                 size_in_mb: Optional[str] = None):
        """
        :param str limit_in_mb: Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        :param str reservation_guarantee: Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        :param str shares: Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param str size_in_mb: Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        if limit_in_mb is not None:
            pulumi.set(__self__, "limit_in_mb", limit_in_mb)
        if reservation_guarantee is not None:
            pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        if shares is not None:
            pulumi.set(__self__, "shares", shares)
        if size_in_mb is not None:
            pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="limitInMb")
    def limit_in_mb(self) -> Optional[str]:
        """
        Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        """
        return pulumi.get(self, "limit_in_mb")

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> Optional[str]:
        """
        Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @property
    @pulumi.getter
    def shares(self) -> Optional[str]:
        """
        Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> Optional[str]:
        """
        Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        return pulumi.get(self, "size_in_mb")


@pulumi.output_type
class VmVgpuPolicyProviderVdcScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerVdcId":
            suggest = "provider_vdc_id"
        elif key == "clusterNames":
            suggest = "cluster_names"
        elif key == "vmGroupId":
            suggest = "vm_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmVgpuPolicyProviderVdcScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmVgpuPolicyProviderVdcScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmVgpuPolicyProviderVdcScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider_vdc_id: str,
                 cluster_names: Optional[Sequence[str]] = None,
                 vm_group_id: Optional[str] = None):
        """
        :param str provider_vdc_id: The ID of the provider VDC that should be in the scope.
        :param Sequence[str] cluster_names: A set of vCenter cluster names on which the provider VDC is hosted. 
               If none are provided, the provider attempts to find one automatically. Can be fetched using `data.vcd_resource_pool.cluster_moref` attribute.
        :param str vm_group_id: Optional identifier for a VM group within the provider VDC scope.
        """
        pulumi.set(__self__, "provider_vdc_id", provider_vdc_id)
        if cluster_names is not None:
            pulumi.set(__self__, "cluster_names", cluster_names)
        if vm_group_id is not None:
            pulumi.set(__self__, "vm_group_id", vm_group_id)

    @property
    @pulumi.getter(name="providerVdcId")
    def provider_vdc_id(self) -> str:
        """
        The ID of the provider VDC that should be in the scope.
        """
        return pulumi.get(self, "provider_vdc_id")

    @property
    @pulumi.getter(name="clusterNames")
    def cluster_names(self) -> Optional[Sequence[str]]:
        """
        A set of vCenter cluster names on which the provider VDC is hosted. 
        If none are provided, the provider attempts to find one automatically. Can be fetched using `data.vcd_resource_pool.cluster_moref` attribute.
        """
        return pulumi.get(self, "cluster_names")

    @property
    @pulumi.getter(name="vmGroupId")
    def vm_group_id(self) -> Optional[str]:
        """
        Optional identifier for a VM group within the provider VDC scope.
        """
        return pulumi.get(self, "vm_group_id")


@pulumi.output_type
class VmVgpuPolicyVgpuProfile(dict):
    def __init__(__self__, *,
                 count: int,
                 id: str):
        """
        :param int count: Specifies the number of vGPU profiles. Must be at least 1.
        :param str id: The identifier of the vGPU profile.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        Specifies the number of vGPU profiles. Must be at least 1.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The identifier of the vGPU profile.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetCatalogAccessControlSharedWithResult(dict):
    def __init__(__self__, *,
                 access_level: str,
                 group_id: str,
                 org_id: str,
                 subject_name: str,
                 user_id: str):
        """
        :param str access_level: The access level for the org, user, or group to which we are sharing. One of [ReadOnly, Change, FullControl] for users and groups, but just ReadOnly for Organizations
        :param str group_id: ID of the group to which we are sharing
        :param str org_id: ID of the Org to which we are sharing
        :param str subject_name: Name of the subject (org, group, or user) with which we are sharing
        :param str user_id: ID of the user to which we are sharing
        """
        pulumi.set(__self__, "access_level", access_level)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "subject_name", subject_name)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> str:
        """
        The access level for the org, user, or group to which we are sharing. One of [ReadOnly, Change, FullControl] for users and groups, but just ReadOnly for Organizations
        """
        return pulumi.get(self, "access_level")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        ID of the group to which we are sharing
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        ID of the Org to which we are sharing
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="subjectName")
    def subject_name(self) -> str:
        """
        Name of the subject (org, group, or user) with which we are sharing
        """
        return pulumi.get(self, "subject_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        ID of the user to which we are sharing
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetCatalogFilterResult(dict):
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['outputs.GetCatalogFilterMetadataResult']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetCatalogFilterMetadataArgs'] metadatas: (Deprecated; *v3.6+*) Use `metadata_entry` instead. Key value map of metadata.
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GetCatalogFilterMetadataResult']]:
        """
        (Deprecated; *v3.6+*) Use `metadata_entry` instead. Key value map of metadata.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetCatalogFilterMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")


@pulumi.output_type
class GetCatalogItemFilterResult(dict):
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['outputs.GetCatalogItemFilterMetadataResult']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetCatalogItemFilterMetadataArgs'] metadatas: Key value map of metadata assigned to the associated vApp template.
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GetCatalogItemFilterMetadataResult']]:
        """
        Key value map of metadata assigned to the associated vApp template.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetCatalogItemFilterMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")


@pulumi.output_type
class GetCatalogItemMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCatalogMediaFilterResult(dict):
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['outputs.GetCatalogMediaFilterMetadataResult']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetCatalogMediaFilterMetadataArgs'] metadatas: metadata filter
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GetCatalogMediaFilterMetadataResult']]:
        """
        metadata filter
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetCatalogMediaFilterMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")


@pulumi.output_type
class GetCatalogMediaMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCatalogMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCatalogVappTemplateFilterResult(dict):
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['outputs.GetCatalogVappTemplateFilterMetadataResult']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetCatalogVappTemplateFilterMetadataArgs'] metadatas: (Deprecated) Use `metadata_entry` instead. Key/value map of metadata for the associated vApp template.
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GetCatalogVappTemplateFilterMetadataResult']]:
        """
        (Deprecated) Use `metadata_entry` instead. Key/value map of metadata for the associated vApp template.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetCatalogVappTemplateFilterMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")


@pulumi.output_type
class GetCatalogVappTemplateLeaseResult(dict):
    def __init__(__self__, *,
                 storage_lease_in_sec: int):
        """
        :param int storage_lease_in_sec: How long the vApp Template is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by parent Org allows).
        """
        pulumi.set(__self__, "storage_lease_in_sec", storage_lease_in_sec)

    @property
    @pulumi.getter(name="storageLeaseInSec")
    def storage_lease_in_sec(self) -> int:
        """
        How long the vApp Template is available before being automatically deleted or marked as expired. 0 means never expires (or maximum allowed by parent Org allows).
        """
        return pulumi.get(self, "storage_lease_in_sec")


@pulumi.output_type
class GetCatalogVappTemplateMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCseKubernetesClusterControlPlaneResult(dict):
    def __init__(__self__, *,
                 disk_size_gi: int,
                 ip: str,
                 machine_count: int,
                 placement_policy_id: str,
                 sizing_policy_id: str,
                 storage_profile_id: str):
        """
        :param int disk_size_gi: Disk size, in Gibibytes (Gi), of the control plane nodes
        :param str ip: IP of the control plane
        :param int machine_count: The number of nodes that the control plane has
        :param str placement_policy_id: VM Placement policy of the control plane nodes
        :param str sizing_policy_id: VM Sizing policy of the control plane nodes
        :param str storage_profile_id: Storage profile of the control plane nodes
        """
        pulumi.set(__self__, "disk_size_gi", disk_size_gi)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "machine_count", machine_count)
        pulumi.set(__self__, "placement_policy_id", placement_policy_id)
        pulumi.set(__self__, "sizing_policy_id", sizing_policy_id)
        pulumi.set(__self__, "storage_profile_id", storage_profile_id)

    @property
    @pulumi.getter(name="diskSizeGi")
    def disk_size_gi(self) -> int:
        """
        Disk size, in Gibibytes (Gi), of the control plane nodes
        """
        return pulumi.get(self, "disk_size_gi")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP of the control plane
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="machineCount")
    def machine_count(self) -> int:
        """
        The number of nodes that the control plane has
        """
        return pulumi.get(self, "machine_count")

    @property
    @pulumi.getter(name="placementPolicyId")
    def placement_policy_id(self) -> str:
        """
        VM Placement policy of the control plane nodes
        """
        return pulumi.get(self, "placement_policy_id")

    @property
    @pulumi.getter(name="sizingPolicyId")
    def sizing_policy_id(self) -> str:
        """
        VM Sizing policy of the control plane nodes
        """
        return pulumi.get(self, "sizing_policy_id")

    @property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> str:
        """
        Storage profile of the control plane nodes
        """
        return pulumi.get(self, "storage_profile_id")


@pulumi.output_type
class GetCseKubernetesClusterDefaultStorageClassResult(dict):
    def __init__(__self__, *,
                 filesystem: str,
                 name: str,
                 reclaim_policy: str,
                 storage_profile_id: str):
        """
        :param str filesystem: Filesystem of the storage class, can be either 'ext4' or 'xfs'
        :param str name: Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.
        :param str reclaim_policy: 'delete' deletes the volume when the PersistentVolumeClaim is deleted. 'retain' does not, and the volume can be manually reclaimed
        :param str storage_profile_id: ID of the storage profile used by the storage class
        """
        pulumi.set(__self__, "filesystem", filesystem)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "reclaim_policy", reclaim_policy)
        pulumi.set(__self__, "storage_profile_id", storage_profile_id)

    @property
    @pulumi.getter
    def filesystem(self) -> str:
        """
        Filesystem of the storage class, can be either 'ext4' or 'xfs'
        """
        return pulumi.get(self, "filesystem")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="reclaimPolicy")
    def reclaim_policy(self) -> str:
        """
        'delete' deletes the volume when the PersistentVolumeClaim is deleted. 'retain' does not, and the volume can be manually reclaimed
        """
        return pulumi.get(self, "reclaim_policy")

    @property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> str:
        """
        ID of the storage profile used by the storage class
        """
        return pulumi.get(self, "storage_profile_id")


@pulumi.output_type
class GetCseKubernetesClusterEventResult(dict):
    def __init__(__self__, *,
                 details: str,
                 name: str,
                 occurred_at: str,
                 resource_id: str,
                 type: str):
        """
        :param str details: Details of the event
        :param str name: Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.
        :param str occurred_at: When the event happened
        :param str resource_id: ID of the resource that caused the event
        :param str type: Type of the event, either 'event' or 'error'
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "occurred_at", occurred_at)
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def details(self) -> str:
        """
        Details of the event
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="occurredAt")
    def occurred_at(self) -> str:
        """
        When the event happened
        """
        return pulumi.get(self, "occurred_at")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        ID of the resource that caused the event
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the event, either 'event' or 'error'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCseKubernetesClusterWorkerPoolResult(dict):
    def __init__(__self__, *,
                 autoscaler_max_replicas: int,
                 autoscaler_min_replicas: int,
                 disk_size_gi: int,
                 machine_count: int,
                 name: str,
                 placement_policy_id: str,
                 sizing_policy_id: str,
                 storage_profile_id: str,
                 vgpu_policy_id: str):
        """
        :param int autoscaler_max_replicas: Maximum replicas of the autoscaling capabilities of this worker pool
        :param int autoscaler_min_replicas: Minimum replicas of the autoscaling capabilities of this worker pool
        :param int disk_size_gi: Disk size, in Gibibytes (Gi), of the control plane nodes
        :param int machine_count: The number of nodes that this node pool has
        :param str name: Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.
        :param str placement_policy_id: VM Placement policy of the control plane nodes
        :param str sizing_policy_id: VM Sizing policy of the control plane nodes
        :param str storage_profile_id: Storage profile of the control plane nodes
        :param str vgpu_policy_id: vGPU policy of the control plane nodes
        """
        pulumi.set(__self__, "autoscaler_max_replicas", autoscaler_max_replicas)
        pulumi.set(__self__, "autoscaler_min_replicas", autoscaler_min_replicas)
        pulumi.set(__self__, "disk_size_gi", disk_size_gi)
        pulumi.set(__self__, "machine_count", machine_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "placement_policy_id", placement_policy_id)
        pulumi.set(__self__, "sizing_policy_id", sizing_policy_id)
        pulumi.set(__self__, "storage_profile_id", storage_profile_id)
        pulumi.set(__self__, "vgpu_policy_id", vgpu_policy_id)

    @property
    @pulumi.getter(name="autoscalerMaxReplicas")
    def autoscaler_max_replicas(self) -> int:
        """
        Maximum replicas of the autoscaling capabilities of this worker pool
        """
        return pulumi.get(self, "autoscaler_max_replicas")

    @property
    @pulumi.getter(name="autoscalerMinReplicas")
    def autoscaler_min_replicas(self) -> int:
        """
        Minimum replicas of the autoscaling capabilities of this worker pool
        """
        return pulumi.get(self, "autoscaler_min_replicas")

    @property
    @pulumi.getter(name="diskSizeGi")
    def disk_size_gi(self) -> int:
        """
        Disk size, in Gibibytes (Gi), of the control plane nodes
        """
        return pulumi.get(self, "disk_size_gi")

    @property
    @pulumi.getter(name="machineCount")
    def machine_count(self) -> int:
        """
        The number of nodes that this node pool has
        """
        return pulumi.get(self, "machine_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Allows to find a Kubernetes cluster by name inside the given Organization with ID `org_id`. Either `cluster_id` or `name` must be set. This argument requires `cse_version` and `org_id` to be set.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="placementPolicyId")
    def placement_policy_id(self) -> str:
        """
        VM Placement policy of the control plane nodes
        """
        return pulumi.get(self, "placement_policy_id")

    @property
    @pulumi.getter(name="sizingPolicyId")
    def sizing_policy_id(self) -> str:
        """
        VM Sizing policy of the control plane nodes
        """
        return pulumi.get(self, "sizing_policy_id")

    @property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> str:
        """
        Storage profile of the control plane nodes
        """
        return pulumi.get(self, "storage_profile_id")

    @property
    @pulumi.getter(name="vgpuPolicyId")
    def vgpu_policy_id(self) -> str:
        """
        vGPU policy of the control plane nodes
        """
        return pulumi.get(self, "vgpu_policy_id")


@pulumi.output_type
class GetDseRegistryConfigurationContainerRegistryResult(dict):
    def __init__(__self__, *,
                 description: str,
                 host: str,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str description: Registry description
        :param str host: Registry host
        :param str password: Password for registry user
        :param str username: Username for registry access
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Registry description
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Registry host
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for registry user
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for registry access
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetEdgegatewayExternalNetworkResult(dict):
    def __init__(__self__, *,
                 enable_rate_limit: bool,
                 incoming_rate_limit: float,
                 name: str,
                 outgoing_rate_limit: float,
                 subnets: Sequence['outputs.GetEdgegatewayExternalNetworkSubnetResult']):
        """
        :param bool enable_rate_limit: Enable rate limiting
        :param float incoming_rate_limit: Incoming rate limit (Mbps)
        :param str name: A unique name for the edge gateway (optional when `filter` is used)
        :param float outgoing_rate_limit: Outgoing rate limit (Mbps)
        """
        pulumi.set(__self__, "enable_rate_limit", enable_rate_limit)
        pulumi.set(__self__, "incoming_rate_limit", incoming_rate_limit)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "outgoing_rate_limit", outgoing_rate_limit)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="enableRateLimit")
    def enable_rate_limit(self) -> bool:
        """
        Enable rate limiting
        """
        return pulumi.get(self, "enable_rate_limit")

    @property
    @pulumi.getter(name="incomingRateLimit")
    def incoming_rate_limit(self) -> float:
        """
        Incoming rate limit (Mbps)
        """
        return pulumi.get(self, "incoming_rate_limit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A unique name for the edge gateway (optional when `filter` is used)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="outgoingRateLimit")
    def outgoing_rate_limit(self) -> float:
        """
        Outgoing rate limit (Mbps)
        """
        return pulumi.get(self, "outgoing_rate_limit")

    @property
    @pulumi.getter
    def subnets(self) -> Sequence['outputs.GetEdgegatewayExternalNetworkSubnetResult']:
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GetEdgegatewayExternalNetworkSubnetResult(dict):
    def __init__(__self__, *,
                 gateway: str,
                 ip_address: str,
                 netmask: str,
                 suballocate_pools: Sequence['outputs.GetEdgegatewayExternalNetworkSubnetSuballocatePoolResult'],
                 use_for_default_route: bool):
        """
        :param str gateway: Gateway address for a subnet
        :param str ip_address: IP address on the edge gateway - will be auto-assigned if not defined
        :param str netmask: Netmask address for a subnet
        :param Sequence['GetEdgegatewayExternalNetworkSubnetSuballocatePoolArgs'] suballocate_pools: Define zero or more blocks to sub-allocate pools on the edge gateway
        :param bool use_for_default_route: Defines if this subnet should be used as default gateway for edge
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "suballocate_pools", suballocate_pools)
        pulumi.set(__self__, "use_for_default_route", use_for_default_route)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        IP address on the edge gateway - will be auto-assigned if not defined
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        Netmask address for a subnet
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="suballocatePools")
    def suballocate_pools(self) -> Sequence['outputs.GetEdgegatewayExternalNetworkSubnetSuballocatePoolResult']:
        """
        Define zero or more blocks to sub-allocate pools on the edge gateway
        """
        return pulumi.get(self, "suballocate_pools")

    @property
    @pulumi.getter(name="useForDefaultRoute")
    def use_for_default_route(self) -> bool:
        """
        Defines if this subnet should be used as default gateway for edge
        """
        return pulumi.get(self, "use_for_default_route")


@pulumi.output_type
class GetEdgegatewayExternalNetworkSubnetSuballocatePoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetEdgegatewayFilterResult(dict):
    def __init__(__self__, *,
                 name_regex: Optional[str] = None):
        """
        :param str name_regex: Search by name with a regular expression
        """
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetExternalNetworkIpScopeResult(dict):
    def __init__(__self__, *,
                 dns1: str,
                 dns2: str,
                 dns_suffix: str,
                 gateway: str,
                 netmask: str,
                 static_ip_pools: Sequence['outputs.GetExternalNetworkIpScopeStaticIpPoolResult']):
        """
        :param str dns1: Primary DNS server
        :param str dns2: Secondary DNS server
        :param str dns_suffix: DNS suffix
        :param str gateway: Gateway of the network
        :param str netmask: Network mask
        :param Sequence['GetExternalNetworkIpScopeStaticIpPoolArgs'] static_ip_pools: IP ranges used for static pool allocation in the network
        """
        pulumi.set(__self__, "dns1", dns1)
        pulumi.set(__self__, "dns2", dns2)
        pulumi.set(__self__, "dns_suffix", dns_suffix)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "static_ip_pools", static_ip_pools)

    @property
    @pulumi.getter
    def dns1(self) -> str:
        """
        Primary DNS server
        """
        return pulumi.get(self, "dns1")

    @property
    @pulumi.getter
    def dns2(self) -> str:
        """
        Secondary DNS server
        """
        return pulumi.get(self, "dns2")

    @property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> str:
        """
        DNS suffix
        """
        return pulumi.get(self, "dns_suffix")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway of the network
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        Network mask
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter(name="staticIpPools")
    def static_ip_pools(self) -> Sequence['outputs.GetExternalNetworkIpScopeStaticIpPoolResult']:
        """
        IP ranges used for static pool allocation in the network
        """
        return pulumi.get(self, "static_ip_pools")


@pulumi.output_type
class GetExternalNetworkIpScopeStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetExternalNetworkV2IpScopeResult(dict):
    def __init__(__self__, *,
                 gateway: str,
                 prefix_length: int,
                 dns1: Optional[str] = None,
                 dns2: Optional[str] = None,
                 dns_suffix: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 static_ip_pools: Optional[Sequence['outputs.GetExternalNetworkV2IpScopeStaticIpPoolResult']] = None):
        """
        :param str gateway: Gateway of the network
        :param int prefix_length: Network mask
        :param str dns1: Primary DNS server
        :param str dns2: Secondary DNS server
        :param str dns_suffix: DNS suffix
        :param bool enabled: If subnet is enabled
        :param Sequence['GetExternalNetworkV2IpScopeStaticIpPoolArgs'] static_ip_pools: IP ranges used for static pool allocation in the network
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if dns1 is not None:
            pulumi.set(__self__, "dns1", dns1)
        if dns2 is not None:
            pulumi.set(__self__, "dns2", dns2)
        if dns_suffix is not None:
            pulumi.set(__self__, "dns_suffix", dns_suffix)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if static_ip_pools is not None:
            pulumi.set(__self__, "static_ip_pools", static_ip_pools)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway of the network
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Network mask
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def dns1(self) -> Optional[str]:
        """
        Primary DNS server
        """
        return pulumi.get(self, "dns1")

    @property
    @pulumi.getter
    def dns2(self) -> Optional[str]:
        """
        Secondary DNS server
        """
        return pulumi.get(self, "dns2")

    @property
    @pulumi.getter(name="dnsSuffix")
    def dns_suffix(self) -> Optional[str]:
        """
        DNS suffix
        """
        return pulumi.get(self, "dns_suffix")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If subnet is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="staticIpPools")
    def static_ip_pools(self) -> Optional[Sequence['outputs.GetExternalNetworkV2IpScopeStaticIpPoolResult']]:
        """
        IP ranges used for static pool allocation in the network
        """
        return pulumi.get(self, "static_ip_pools")


@pulumi.output_type
class GetExternalNetworkV2IpScopeStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetExternalNetworkV2NsxtNetworkResult(dict):
    def __init__(__self__, *,
                 nsxt_manager_id: str,
                 nsxt_segment_name: str,
                 nsxt_tier0_router_id: str):
        """
        :param str nsxt_manager_id: ID of NSX-T manager
        :param str nsxt_segment_name: Name of NSX-T segment (for NSX-T segment backed external network)
        :param str nsxt_tier0_router_id: ID of NSX-T Tier-0 router (for T0 gateway backed external network)
        """
        pulumi.set(__self__, "nsxt_manager_id", nsxt_manager_id)
        pulumi.set(__self__, "nsxt_segment_name", nsxt_segment_name)
        pulumi.set(__self__, "nsxt_tier0_router_id", nsxt_tier0_router_id)

    @property
    @pulumi.getter(name="nsxtManagerId")
    def nsxt_manager_id(self) -> str:
        """
        ID of NSX-T manager
        """
        return pulumi.get(self, "nsxt_manager_id")

    @property
    @pulumi.getter(name="nsxtSegmentName")
    def nsxt_segment_name(self) -> str:
        """
        Name of NSX-T segment (for NSX-T segment backed external network)
        """
        return pulumi.get(self, "nsxt_segment_name")

    @property
    @pulumi.getter(name="nsxtTier0RouterId")
    def nsxt_tier0_router_id(self) -> str:
        """
        ID of NSX-T Tier-0 router (for T0 gateway backed external network)
        """
        return pulumi.get(self, "nsxt_tier0_router_id")


@pulumi.output_type
class GetExternalNetworkV2VsphereNetworkResult(dict):
    def __init__(__self__, *,
                 portgroup_id: str,
                 vcenter_id: str):
        """
        :param str portgroup_id: The portgroup ID
        :param str vcenter_id: The vCenter server ID
        """
        pulumi.set(__self__, "portgroup_id", portgroup_id)
        pulumi.set(__self__, "vcenter_id", vcenter_id)

    @property
    @pulumi.getter(name="portgroupId")
    def portgroup_id(self) -> str:
        """
        The portgroup ID
        """
        return pulumi.get(self, "portgroup_id")

    @property
    @pulumi.getter(name="vcenterId")
    def vcenter_id(self) -> str:
        """
        The vCenter server ID
        """
        return pulumi.get(self, "vcenter_id")


@pulumi.output_type
class GetExternalNetworkVsphereNetworkResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 vcenter: str):
        """
        :param str name: external network name
        :param str type: The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK
        :param str vcenter: The vCenter server name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vcenter", vcenter)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        external network name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The vSphere port group type. One of: DV_PORTGROUP (distributed virtual port group), NETWORK
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def vcenter(self) -> str:
        """
        The vCenter server name
        """
        return pulumi.get(self, "vcenter")


@pulumi.output_type
class GetIndependentDiskMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetIpSpaceCustomQuotaIpPrefixQuotaResult(dict):
    def __init__(__self__, *,
                 prefix_length: str,
                 quota: str):
        """
        :param str prefix_length: Prefix length
        :param str quota: IP Prefix Quota
        """
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "quota", quota)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> str:
        """
        Prefix length
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def quota(self) -> str:
        """
        IP Prefix Quota
        """
        return pulumi.get(self, "quota")


@pulumi.output_type
class GetIpSpaceIpPrefixResult(dict):
    def __init__(__self__, *,
                 default_quota: str,
                 prefixes: Sequence['outputs.GetIpSpaceIpPrefixPrefixResult']):
        """
        :param str default_quota: Floating IP quota
        :param Sequence['GetIpSpaceIpPrefixPrefixArgs'] prefixes: IP Prefix
        """
        pulumi.set(__self__, "default_quota", default_quota)
        pulumi.set(__self__, "prefixes", prefixes)

    @property
    @pulumi.getter(name="defaultQuota")
    def default_quota(self) -> str:
        """
        Floating IP quota
        """
        return pulumi.get(self, "default_quota")

    @property
    @pulumi.getter
    def prefixes(self) -> Sequence['outputs.GetIpSpaceIpPrefixPrefixResult']:
        """
        IP Prefix
        """
        return pulumi.get(self, "prefixes")


@pulumi.output_type
class GetIpSpaceIpPrefixPrefixResult(dict):
    def __init__(__self__, *,
                 first_ip: str,
                 id: str,
                 prefix_count: str,
                 prefix_length: str):
        """
        :param str first_ip: First IP
        :param str id: ID of IP Prefix
        :param str prefix_count: Prefix count
        :param str prefix_length: Prefix length
        """
        pulumi.set(__self__, "first_ip", first_ip)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "prefix_count", prefix_count)
        pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter(name="firstIp")
    def first_ip(self) -> str:
        """
        First IP
        """
        return pulumi.get(self, "first_ip")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of IP Prefix
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="prefixCount")
    def prefix_count(self) -> str:
        """
        Prefix count
        """
        return pulumi.get(self, "prefix_count")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> str:
        """
        Prefix length
        """
        return pulumi.get(self, "prefix_length")


@pulumi.output_type
class GetIpSpaceIpRangeResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 id: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str id: ID of IP Range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of IP Range
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetLbServerPoolMemberResult(dict):
    def __init__(__self__, *,
                 condition: str,
                 id: str,
                 ip_address: str,
                 max_connections: int,
                 min_connections: int,
                 monitor_port: int,
                 name: str,
                 port: int,
                 weight: int):
        """
        :param str condition: Defines member state. One of enabled, drain, disabled.
        :param str id: Pool member id (formatted as member-xx, where xx is a number)
        :param str ip_address: IP address of member in server pool
        :param int max_connections: The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released
        :param int min_connections: Minimum number of concurrent connections a member must always accept
        :param int monitor_port: Port at which the member is to receive health monitor requests. Can be the same as port
        :param str name: Server Pool name for identifying the exact server pool
        :param int port: Port at which the member is to receive traffic from the load balancer
        :param int weight: Proportion of traffic this member is to handle. Must be an integer in the range 1-256
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "max_connections", max_connections)
        pulumi.set(__self__, "min_connections", min_connections)
        pulumi.set(__self__, "monitor_port", monitor_port)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Defines member state. One of enabled, drain, disabled.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Pool member id (formatted as member-xx, where xx is a number)
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        IP address of member in server pool
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> int:
        """
        The maximum number of concurrent connections the member can handle. If exceeded requests are queued and the load balancer waits for a connection to be released
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="minConnections")
    def min_connections(self) -> int:
        """
        Minimum number of concurrent connections a member must always accept
        """
        return pulumi.get(self, "min_connections")

    @property
    @pulumi.getter(name="monitorPort")
    def monitor_port(self) -> int:
        """
        Port at which the member is to receive health monitor requests. Can be the same as port
        """
        return pulumi.get(self, "monitor_port")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Server Pool name for identifying the exact server pool
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port at which the member is to receive traffic from the load balancer
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        Proportion of traffic this member is to handle. Must be an integer in the range 1-256
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetNetworkDirectFilterResult(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 metadatas: Optional[Sequence['outputs.GetNetworkDirectFilterMetadataResult']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param Sequence['GetNetworkDirectFilterMetadataArgs'] metadatas: metadata filter
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GetNetworkDirectFilterMetadataResult']]:
        """
        metadata filter
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetNetworkDirectFilterMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")


@pulumi.output_type
class GetNetworkDirectMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNetworkIsolatedDhcpPoolResult(dict):
    def __init__(__self__, *,
                 default_lease_time: int,
                 end_address: str,
                 max_lease_time: int,
                 start_address: str):
        """
        :param int default_lease_time: The default DHCP lease time to use
        :param str end_address: The final address in the IP Range
        :param int max_lease_time: The maximum DHCP lease time to use
        :param str start_address: The first address in the IP Range
        """
        pulumi.set(__self__, "default_lease_time", default_lease_time)
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "max_lease_time", max_lease_time)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="defaultLeaseTime")
    def default_lease_time(self) -> int:
        """
        The default DHCP lease time to use
        """
        return pulumi.get(self, "default_lease_time")

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="maxLeaseTime")
    def max_lease_time(self) -> int:
        """
        The maximum DHCP lease time to use
        """
        return pulumi.get(self, "max_lease_time")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNetworkIsolatedFilterResult(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 metadatas: Optional[Sequence['outputs.GetNetworkIsolatedFilterMetadataResult']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param Sequence['GetNetworkIsolatedFilterMetadataArgs'] metadatas: metadata filter
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GetNetworkIsolatedFilterMetadataResult']]:
        """
        metadata filter
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetNetworkIsolatedFilterMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")


@pulumi.output_type
class GetNetworkIsolatedMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNetworkIsolatedStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: The final address in the IP Range
        :param str start_address: The first address in the IP Range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNetworkIsolatedV2FilterResult(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetNetworkIsolatedV2MetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNetworkIsolatedV2SecondaryStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNetworkIsolatedV2StaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNetworkPoolBackingResult(dict):
    def __init__(__self__, *,
                 distributed_switches: Sequence['outputs.GetNetworkPoolBackingDistributedSwitchResult'],
                 port_groups: Sequence['outputs.GetNetworkPoolBackingPortGroupResult'],
                 range_ids: Sequence['outputs.GetNetworkPoolBackingRangeIdResult'],
                 transport_zones: Sequence['outputs.GetNetworkPoolBackingTransportZoneResult']):
        """
        :param Sequence['GetNetworkPoolBackingDistributedSwitchArgs'] distributed_switches: Distributed switch backing
        :param Sequence['GetNetworkPoolBackingPortGroupArgs'] port_groups: Port Group backing
        :param Sequence['GetNetworkPoolBackingRangeIdArgs'] range_ids: Distributed Switch ID ranges (used with VLAN backing)
        :param Sequence['GetNetworkPoolBackingTransportZoneArgs'] transport_zones: Transport Zone Backing
        """
        pulumi.set(__self__, "distributed_switches", distributed_switches)
        pulumi.set(__self__, "port_groups", port_groups)
        pulumi.set(__self__, "range_ids", range_ids)
        pulumi.set(__self__, "transport_zones", transport_zones)

    @property
    @pulumi.getter(name="distributedSwitches")
    def distributed_switches(self) -> Sequence['outputs.GetNetworkPoolBackingDistributedSwitchResult']:
        """
        Distributed switch backing
        """
        return pulumi.get(self, "distributed_switches")

    @property
    @pulumi.getter(name="portGroups")
    def port_groups(self) -> Sequence['outputs.GetNetworkPoolBackingPortGroupResult']:
        """
        Port Group backing
        """
        return pulumi.get(self, "port_groups")

    @property
    @pulumi.getter(name="rangeIds")
    def range_ids(self) -> Sequence['outputs.GetNetworkPoolBackingRangeIdResult']:
        """
        Distributed Switch ID ranges (used with VLAN backing)
        """
        return pulumi.get(self, "range_ids")

    @property
    @pulumi.getter(name="transportZones")
    def transport_zones(self) -> Sequence['outputs.GetNetworkPoolBackingTransportZoneResult']:
        """
        Transport Zone Backing
        """
        return pulumi.get(self, "transport_zones")


@pulumi.output_type
class GetNetworkPoolBackingDistributedSwitchResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        """
        :param str id: Backing ID
        :param str name: network pool name.
        :param str type: Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Backing ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        network pool name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkPoolBackingPortGroupResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        """
        :param str id: Backing ID
        :param str name: network pool name.
        :param str type: Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Backing ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        network pool name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkPoolBackingRangeIdResult(dict):
    def __init__(__self__, *,
                 end_id: int,
                 start_id: int):
        """
        :param int end_id: End of the IDs range
        :param int start_id: Start of the IDs range
        """
        pulumi.set(__self__, "end_id", end_id)
        pulumi.set(__self__, "start_id", start_id)

    @property
    @pulumi.getter(name="endId")
    def end_id(self) -> int:
        """
        End of the IDs range
        """
        return pulumi.get(self, "end_id")

    @property
    @pulumi.getter(name="startId")
    def start_id(self) -> int:
        """
        Start of the IDs range
        """
        return pulumi.get(self, "start_id")


@pulumi.output_type
class GetNetworkPoolBackingTransportZoneResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        """
        :param str id: Backing ID
        :param str name: network pool name.
        :param str type: Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Backing ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        network pool name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Backing Type (one of 'Transport Zone', 'Port Group', 'Distributed Switch')
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNetworkRoutedDhcpPoolResult(dict):
    def __init__(__self__, *,
                 default_lease_time: int,
                 end_address: str,
                 max_lease_time: int,
                 start_address: str):
        """
        :param int default_lease_time: The default DHCP lease time to use
        :param str end_address: The final address in the IP Range
        :param int max_lease_time: The maximum DHCP lease time to use
        :param str start_address: The first address in the IP Range
        """
        pulumi.set(__self__, "default_lease_time", default_lease_time)
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "max_lease_time", max_lease_time)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="defaultLeaseTime")
    def default_lease_time(self) -> int:
        """
        The default DHCP lease time to use
        """
        return pulumi.get(self, "default_lease_time")

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="maxLeaseTime")
    def max_lease_time(self) -> int:
        """
        The maximum DHCP lease time to use
        """
        return pulumi.get(self, "max_lease_time")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNetworkRoutedFilterResult(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 metadatas: Optional[Sequence['outputs.GetNetworkRoutedFilterMetadataResult']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param Sequence['GetNetworkRoutedFilterMetadataArgs'] metadatas: metadata filter
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GetNetworkRoutedFilterMetadataResult']]:
        """
        metadata filter
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetNetworkRoutedFilterMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")


@pulumi.output_type
class GetNetworkRoutedMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNetworkRoutedStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: The final address in the IP Range
        :param str start_address: The first address in the IP Range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        The final address in the IP Range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        The first address in the IP Range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNetworkRoutedV2FilterResult(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetNetworkRoutedV2MetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNetworkRoutedV2SecondaryStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNetworkRoutedV2StaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNsxtAlbPoolHealthMonitorResult(dict):
    def __init__(__self__, *,
                 name: str,
                 system_defined: bool,
                 type: str):
        """
        :param str name: Name of existing ALB Pool.
        :param str type: Type of health monitor
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "system_defined", system_defined)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of existing ALB Pool.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="systemDefined")
    def system_defined(self) -> bool:
        return pulumi.get(self, "system_defined")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of health monitor
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNsxtAlbPoolMemberResult(dict):
    def __init__(__self__, *,
                 detailed_health_message: str,
                 enabled: bool,
                 health_status: str,
                 ip_address: str,
                 marked_down_bies: Sequence[str],
                 port: int,
                 ratio: int):
        """
        :param str detailed_health_message: Detailed health message
        :param bool enabled: Shows is the member is enabled or not
        :param str health_status: Health status
        :param str ip_address: IP Address of pool member
        :param Sequence[str] marked_down_bies: Marked down by provides a set of health monitors that marked the service down
        :param int port: Service port
        :param int ratio: Load ratio
        """
        pulumi.set(__self__, "detailed_health_message", detailed_health_message)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "health_status", health_status)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "marked_down_bies", marked_down_bies)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "ratio", ratio)

    @property
    @pulumi.getter(name="detailedHealthMessage")
    def detailed_health_message(self) -> str:
        """
        Detailed health message
        """
        return pulumi.get(self, "detailed_health_message")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Shows is the member is enabled or not
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="healthStatus")
    def health_status(self) -> str:
        """
        Health status
        """
        return pulumi.get(self, "health_status")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        IP Address of pool member
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="markedDownBies")
    def marked_down_bies(self) -> Sequence[str]:
        """
        Marked down by provides a set of health monitors that marked the service down
        """
        return pulumi.get(self, "marked_down_bies")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Service port
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ratio(self) -> int:
        """
        Load ratio
        """
        return pulumi.get(self, "ratio")


@pulumi.output_type
class GetNsxtAlbPoolPersistenceProfileResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Name of existing ALB Pool.
        :param str type: Type of persistence strategy
        :param str value: Value of attribute based on persistence type
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of existing ALB Pool.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of persistence strategy
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of attribute based on persistence type
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleActionResult'],
                 active: bool,
                 logging: bool,
                 match_criterias: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaResult'],
                 name: str):
        """
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleActionArgs'] actions: Actions to perform with the rule that matches
        :param bool active: Defines if the rule is active or not
        :param bool logging: Defines whether logging with headers on rule match is enabled or not
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaArgs'] match_criterias: Rule matching Criteria
        :param str name: Name of the rule
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "logging", logging)
        pulumi.set(__self__, "match_criterias", match_criterias)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleActionResult']:
        """
        Actions to perform with the rule that matches
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Defines if the rule is active or not
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def logging(self) -> bool:
        """
        Defines whether logging with headers on rule match is enabled or not
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="matchCriterias")
    def match_criterias(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaResult']:
        """
        Rule matching Criteria
        """
        return pulumi.get(self, "match_criterias")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleActionResult(dict):
    def __init__(__self__, *,
                 modify_headers: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleActionModifyHeaderResult'],
                 redirects: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRedirectResult'],
                 rewrite_urls: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRewriteUrlResult']):
        """
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleActionModifyHeaderArgs'] modify_headers: A set of header modification rules
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRedirectArgs'] redirects: Redirect request
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRewriteUrlArgs'] rewrite_urls: URL rewrite rules
        """
        pulumi.set(__self__, "modify_headers", modify_headers)
        pulumi.set(__self__, "redirects", redirects)
        pulumi.set(__self__, "rewrite_urls", rewrite_urls)

    @property
    @pulumi.getter(name="modifyHeaders")
    def modify_headers(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleActionModifyHeaderResult']:
        """
        A set of header modification rules
        """
        return pulumi.get(self, "modify_headers")

    @property
    @pulumi.getter
    def redirects(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRedirectResult']:
        """
        Redirect request
        """
        return pulumi.get(self, "redirects")

    @property
    @pulumi.getter(name="rewriteUrls")
    def rewrite_urls(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRewriteUrlResult']:
        """
        URL rewrite rules
        """
        return pulumi.get(self, "rewrite_urls")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleActionModifyHeaderResult(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: str):
        """
        :param str action: One of the following HTTP header actions
        :param str name: HTTP header name
        :param str value: HTTP header value
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        One of the following HTTP header actions
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        HTTP header name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        HTTP header value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRedirectResult(dict):
    def __init__(__self__, *,
                 host: str,
                 keep_query: bool,
                 path: str,
                 port: str,
                 protocol: str,
                 status_code: int):
        """
        :param str host: Host to which redirect the request
        :param bool keep_query: Path to which redirect the request
        :param str path: Port to which redirect the request
        :param str port: Port to which the request will be redirected
        :param str protocol: HTTP or HTTPS protocol
        :param int status_code: Redirect status code
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "keep_query", keep_query)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host to which redirect the request
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> bool:
        """
        Path to which redirect the request
        """
        return pulumi.get(self, "keep_query")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Port to which redirect the request
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Port to which the request will be redirected
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        HTTP or HTTPS protocol
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        Redirect status code
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleActionRewriteUrlResult(dict):
    def __init__(__self__, *,
                 existing_path: str,
                 host_header: str,
                 keep_query: bool,
                 query: str):
        """
        :param str existing_path: Path to use for the rewritten URL
        :param str host_header: Host to use for the rewritten URL
        :param bool keep_query: Whether or not to keep the existing query string when rewriting the URL
        :param str query: Query string to use or append to the existing query string in the rewritten URL
        """
        pulumi.set(__self__, "existing_path", existing_path)
        pulumi.set(__self__, "host_header", host_header)
        pulumi.set(__self__, "keep_query", keep_query)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter(name="existingPath")
    def existing_path(self) -> str:
        """
        Path to use for the rewritten URL
        """
        return pulumi.get(self, "existing_path")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        Host to use for the rewritten URL
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> bool:
        """
        Whether or not to keep the existing query string when rewriting the URL
        """
        return pulumi.get(self, "keep_query")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query string to use or append to the existing query string in the rewritten URL
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaResult(dict):
    def __init__(__self__, *,
                 client_ip_addresses: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressResult'],
                 cookies: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieResult'],
                 http_methods: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodResult'],
                 paths: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathResult'],
                 protocol_type: str,
                 queries: Sequence[str],
                 request_headers: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderResult'],
                 service_ports: Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortResult']):
        """
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressArgs'] client_ip_addresses: Client IP Address criteria
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieArgs'] cookies: Rule for matching cookie
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodArgs'] http_methods: HTTP methods that are matched
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathArgs'] paths: HTTP request path that will be matched
        :param str protocol_type: Protocol to match - 'HTTP' or 'HTTPS'
        :param Sequence[str] queries: HTTP request query strings to match
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderArgs'] request_headers: A set of rules for matching request headers
        :param Sequence['GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortArgs'] service_ports: Service Port criteria
        """
        pulumi.set(__self__, "client_ip_addresses", client_ip_addresses)
        pulumi.set(__self__, "cookies", cookies)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "protocol_type", protocol_type)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "request_headers", request_headers)
        pulumi.set(__self__, "service_ports", service_ports)

    @property
    @pulumi.getter(name="clientIpAddresses")
    def client_ip_addresses(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressResult']:
        """
        Client IP Address criteria
        """
        return pulumi.get(self, "client_ip_addresses")

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieResult']:
        """
        Rule for matching cookie
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodResult']:
        """
        HTTP methods that are matched
        """
        return pulumi.get(self, "http_methods")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathResult']:
        """
        HTTP request path that will be matched
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> str:
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter
    def queries(self) -> Sequence[str]:
        """
        HTTP request query strings to match
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderResult']:
        """
        A set of rules for matching request headers
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortResult']:
        """
        Service Port criteria
        """
        return pulumi.get(self, "service_ports")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaClientIpAddressResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 ip_addresses: Sequence[str]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request
        :param Sequence[str] ip_addresses: A set of IP addresses
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A set of IP addresses
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaCookieResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 value: str):
        """
        :param str criteria: Criteria to use for matching cookies in the HTTP request
        :param str name: Name of the HTTP cookie whose value is to be matched
        :param str value: String values to match for an HTTP cookie
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching cookies in the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP cookie whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        String values to match for an HTTP cookie
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaHttpMethodResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 methods: Sequence[str]):
        """
        :param str criteria: Criteria to use for HTTP method matching in the HTTP request
        :param Sequence[str] methods: HTTP methods that will be matched
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for HTTP method matching in the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        HTTP methods that will be matched
        """
        return pulumi.get(self, "methods")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaPathResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 paths: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching the path in the HTTP request URI
        :param Sequence[str] paths: String values to match the path
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching the path in the HTTP request URI
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        String values to match the path
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaRequestHeaderResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 values: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching headers and cookies in the HTTP request amd response
        :param str name: Name of the HTTP header whose value is to be matched
        :param Sequence[str] values: String values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        String values to match for an HTTP header
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpReqRulesRuleMatchCriteriaServicePortResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 ports: Sequence[int]):
        """
        :param str criteria: Criteria to use for service port matching the HTTP request
        :param Sequence[int] ports: A set of TCP ports
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for service port matching the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        A set of TCP ports
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleActionResult'],
                 active: bool,
                 logging: bool,
                 match_criterias: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResult'],
                 name: str):
        """
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleActionArgs'] actions: Actions to perform with the rule that matches
        :param bool active: Defines if the rule is active or not
        :param bool logging: Defines whether logging with headers on rule match is enabled or not
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaArgs'] match_criterias: Rule matching Criteria
        :param str name: Name of the rule
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "logging", logging)
        pulumi.set(__self__, "match_criterias", match_criterias)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleActionResult']:
        """
        Actions to perform with the rule that matches
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Defines if the rule is active or not
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def logging(self) -> bool:
        """
        Defines whether logging with headers on rule match is enabled or not
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="matchCriterias")
    def match_criterias(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResult']:
        """
        Rule matching Criteria
        """
        return pulumi.get(self, "match_criterias")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleActionResult(dict):
    def __init__(__self__, *,
                 modify_headers: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleActionModifyHeaderResult'],
                 rewrite_location_headers: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleActionRewriteLocationHeaderResult']):
        """
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleActionModifyHeaderArgs'] modify_headers: Modify header
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleActionRewriteLocationHeaderArgs'] rewrite_location_headers: Rewrite location header
        """
        pulumi.set(__self__, "modify_headers", modify_headers)
        pulumi.set(__self__, "rewrite_location_headers", rewrite_location_headers)

    @property
    @pulumi.getter(name="modifyHeaders")
    def modify_headers(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleActionModifyHeaderResult']:
        """
        Modify header
        """
        return pulumi.get(self, "modify_headers")

    @property
    @pulumi.getter(name="rewriteLocationHeaders")
    def rewrite_location_headers(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleActionRewriteLocationHeaderResult']:
        """
        Rewrite location header
        """
        return pulumi.get(self, "rewrite_location_headers")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleActionModifyHeaderResult(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 value: str):
        """
        :param str action: One of the following HTTP header actions
        :param str name: HTTP header name
        :param str value: HTTP header value
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        One of the following HTTP header actions
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        HTTP header name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        HTTP header value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleActionRewriteLocationHeaderResult(dict):
    def __init__(__self__, *,
                 host: str,
                 keep_query: bool,
                 path: str,
                 port: str,
                 protocol: str):
        """
        :param str host: Host to which redirect the request
        :param bool keep_query: Path to which redirect the request
        :param str path: Port to which redirect the request
        :param str port: Port to which redirect the request
        :param str protocol: HTTP or HTTPS protocol
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "keep_query", keep_query)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host to which redirect the request
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> bool:
        """
        Path to which redirect the request
        """
        return pulumi.get(self, "keep_query")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Port to which redirect the request
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Port to which redirect the request
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        HTTP or HTTPS protocol
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResult(dict):
    def __init__(__self__, *,
                 client_ip_addresses: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressResult'],
                 cookies: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieResult'],
                 http_methods: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodResult'],
                 location_headers: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderResult'],
                 paths: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathResult'],
                 protocol_type: str,
                 queries: Sequence[str],
                 request_headers: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderResult'],
                 response_headers: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderResult'],
                 service_ports: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortResult'],
                 status_codes: Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeResult']):
        """
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressArgs'] client_ip_addresses: Criteria for matching client IP Address
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieArgs'] cookies: Rule for matching cookie
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodArgs'] http_methods: Criteria to match HTTP methods
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderArgs'] location_headers: A matching criteria for Location header
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathArgs'] paths: Criteria for matching request paths
        :param str protocol_type: Protocol to match - 'HTTP' or 'HTTPS'
        :param Sequence[str] queries: HTTP request query strings to match
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderArgs'] request_headers: A set of rules for matching request headers
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderArgs'] response_headers: A set of criteria to match response headers
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortArgs'] service_ports: Criteria for matching service ports
        :param Sequence['GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeArgs'] status_codes: HTTP Status code to match
        """
        pulumi.set(__self__, "client_ip_addresses", client_ip_addresses)
        pulumi.set(__self__, "cookies", cookies)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "location_headers", location_headers)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "protocol_type", protocol_type)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "request_headers", request_headers)
        pulumi.set(__self__, "response_headers", response_headers)
        pulumi.set(__self__, "service_ports", service_ports)
        pulumi.set(__self__, "status_codes", status_codes)

    @property
    @pulumi.getter(name="clientIpAddresses")
    def client_ip_addresses(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressResult']:
        """
        Criteria for matching client IP Address
        """
        return pulumi.get(self, "client_ip_addresses")

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieResult']:
        """
        Rule for matching cookie
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodResult']:
        """
        Criteria to match HTTP methods
        """
        return pulumi.get(self, "http_methods")

    @property
    @pulumi.getter(name="locationHeaders")
    def location_headers(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderResult']:
        """
        A matching criteria for Location header
        """
        return pulumi.get(self, "location_headers")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathResult']:
        """
        Criteria for matching request paths
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> str:
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter
    def queries(self) -> Sequence[str]:
        """
        HTTP request query strings to match
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderResult']:
        """
        A set of rules for matching request headers
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderResult']:
        """
        A set of criteria to match response headers
        """
        return pulumi.get(self, "response_headers")

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortResult']:
        """
        Criteria for matching service ports
        """
        return pulumi.get(self, "service_ports")

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeResult']:
        """
        HTTP Status code to match
        """
        return pulumi.get(self, "status_codes")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaClientIpAddressResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 ip_addresses: Sequence[str]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request
        :param Sequence[str] ip_addresses: A set of IP addresses
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A set of IP addresses
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaCookieResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 value: str):
        """
        :param str criteria: Criteria to use for matching cookies in the HTTP request
        :param str name: Name of the HTTP cookie whose value is to be matched
        :param str value: String values to match for an HTTP cookie
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching cookies in the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP cookie whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        String values to match for an HTTP cookie
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaHttpMethodResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 methods: Sequence[str]):
        """
        :param str criteria: Criteria to use for HTTP methods matching the request
        :param Sequence[str] methods: HTTP methods to match
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for HTTP methods matching the request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        HTTP methods to match
        """
        return pulumi.get(self, "methods")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaLocationHeaderResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 values: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching location header
        :param Sequence[str] values: A set of values to match for criteria
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching location header
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A set of values to match for criteria
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaPathResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 paths: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching the path in the HTTP request URI
        :param Sequence[str] paths: String values to match the path
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching the path in the HTTP request URI
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        String values to match the path
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaRequestHeaderResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 values: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching headers and cookies in the HTTP request amd response
        :param str name: Name of the HTTP header whose value is to be matched
        :param Sequence[str] values: String values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        String values to match for an HTTP header
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaResponseHeaderResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 values: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching headers and cookies in the HTTP request amd response
        :param str name: Name of the HTTP header whose value is to be matched
        :param Sequence[str] values: A set of values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A set of values to match for an HTTP header
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaServicePortResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 ports: Sequence[int]):
        """
        :param str criteria: Criteria to use for service ports matching the HTTP request
        :param Sequence[int] ports: A set of TCP ports
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for service ports matching the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        A set of TCP ports
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpRespRulesRuleMatchCriteriaStatusCodeResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 http_status_code: str):
        """
        :param str criteria: Criteria to use for status code matching the HTTP request.
        :param str http_status_code: HTTP status code or range of this rule matching
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "http_status_code", http_status_code)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for status code matching the HTTP request.
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="httpStatusCode")
    def http_status_code(self) -> str:
        """
        HTTP status code or range of this rule matching
        """
        return pulumi.get(self, "http_status_code")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionResult'],
                 active: bool,
                 logging: bool,
                 match_criterias: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaResult'],
                 name: str):
        """
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleActionArgs'] actions: Actions to perform with the rule that matches
        :param bool active: Defines is the rule is active or not
        :param bool logging: Defines whether to enable logging with headers on rule match or not
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaArgs'] match_criterias: Rule matching Criteria
        :param str name: Name of the rule
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "logging", logging)
        pulumi.set(__self__, "match_criterias", match_criterias)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionResult']:
        """
        Actions to perform with the rule that matches
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def active(self) -> bool:
        """
        Defines is the rule is active or not
        """
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def logging(self) -> bool:
        """
        Defines whether to enable logging with headers on rule match or not
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter(name="matchCriterias")
    def match_criterias(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaResult']:
        """
        Rule matching Criteria
        """
        return pulumi.get(self, "match_criterias")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the rule
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleActionResult(dict):
    def __init__(__self__, *,
                 connections: str,
                 rate_limits: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitResult'],
                 redirect_to_https: str,
                 send_responses: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionSendResponseResult']):
        """
        :param str connections: ALLOW or CLOSE connections
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitArgs'] rate_limits: Apply actions based on rate limits
        :param str redirect_to_https: Port number that should be redirected to HTTPS
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleActionSendResponseArgs'] send_responses: Send custom response
        """
        pulumi.set(__self__, "connections", connections)
        pulumi.set(__self__, "rate_limits", rate_limits)
        pulumi.set(__self__, "redirect_to_https", redirect_to_https)
        pulumi.set(__self__, "send_responses", send_responses)

    @property
    @pulumi.getter
    def connections(self) -> str:
        """
        ALLOW or CLOSE connections
        """
        return pulumi.get(self, "connections")

    @property
    @pulumi.getter(name="rateLimits")
    def rate_limits(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitResult']:
        """
        Apply actions based on rate limits
        """
        return pulumi.get(self, "rate_limits")

    @property
    @pulumi.getter(name="redirectToHttps")
    def redirect_to_https(self) -> str:
        """
        Port number that should be redirected to HTTPS
        """
        return pulumi.get(self, "redirect_to_https")

    @property
    @pulumi.getter(name="sendResponses")
    def send_responses(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionSendResponseResult']:
        """
        Send custom response
        """
        return pulumi.get(self, "send_responses")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitResult(dict):
    def __init__(__self__, *,
                 action_close_connection: bool,
                 action_local_responses: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionLocalResponseResult'],
                 action_redirects: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionRedirectResult'],
                 count: str,
                 period: str):
        """
        :param bool action_close_connection: True if the connection should be closed
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionLocalResponseArgs'] action_local_responses: Send custom response
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionRedirectArgs'] action_redirects: Redirect request
        :param str count: Maximum number of connections, requests or packets permitted each period. The count must be between 1 and 1000000000
        :param str period: Time value in seconds to enforce rate count. The period must be between 1 and 1000000000
        """
        pulumi.set(__self__, "action_close_connection", action_close_connection)
        pulumi.set(__self__, "action_local_responses", action_local_responses)
        pulumi.set(__self__, "action_redirects", action_redirects)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "period", period)

    @property
    @pulumi.getter(name="actionCloseConnection")
    def action_close_connection(self) -> bool:
        """
        True if the connection should be closed
        """
        return pulumi.get(self, "action_close_connection")

    @property
    @pulumi.getter(name="actionLocalResponses")
    def action_local_responses(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionLocalResponseResult']:
        """
        Send custom response
        """
        return pulumi.get(self, "action_local_responses")

    @property
    @pulumi.getter(name="actionRedirects")
    def action_redirects(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionRedirectResult']:
        """
        Redirect request
        """
        return pulumi.get(self, "action_redirects")

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        Maximum number of connections, requests or packets permitted each period. The count must be between 1 and 1000000000
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def period(self) -> str:
        """
        Time value in seconds to enforce rate count. The period must be between 1 and 1000000000
        """
        return pulumi.get(self, "period")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionLocalResponseResult(dict):
    def __init__(__self__, *,
                 content: str,
                 content_type: str,
                 status_code: str):
        """
        :param str content: Base64 encoded content
        :param str content_type: MIME type for the content
        :param str status_code: HTTP Status code to send
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Base64 encoded content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        MIME type for the content
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        """
        HTTP Status code to send
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleActionRateLimitActionRedirectResult(dict):
    def __init__(__self__, *,
                 host: str,
                 keep_query: bool,
                 path: str,
                 port: str,
                 protocol: str,
                 status_code: int):
        """
        :param str host: Host to which redirect the request. Default is the original host
        :param bool keep_query: Path to which redirect the request. Default is the original path
        :param str path: Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol
        :param str port: Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol
        :param str protocol: HTTP or HTTPS protocol
        :param int status_code: One of the redirect status codes - 301, 302, 307
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "keep_query", keep_query)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host to which redirect the request. Default is the original host
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="keepQuery")
    def keep_query(self) -> bool:
        """
        Path to which redirect the request. Default is the original path
        """
        return pulumi.get(self, "keep_query")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> str:
        """
        Port to which redirect the request. Default is 80 for HTTP and 443 for HTTPS protocol
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        HTTP or HTTPS protocol
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> int:
        """
        One of the redirect status codes - 301, 302, 307
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleActionSendResponseResult(dict):
    def __init__(__self__, *,
                 content: str,
                 content_type: str,
                 status_code: str):
        """
        :param str content: Base64 encoded content
        :param str content_type: MIME type for the content
        :param str status_code: HTTP Status code to send
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "status_code", status_code)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Base64 encoded content
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> str:
        """
        MIME type for the content
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> str:
        """
        HTTP Status code to send
        """
        return pulumi.get(self, "status_code")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaResult(dict):
    def __init__(__self__, *,
                 client_ip_addresses: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressResult'],
                 cookies: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieResult'],
                 http_methods: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodResult'],
                 paths: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathResult'],
                 protocol_type: str,
                 queries: Sequence[str],
                 request_headers: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderResult'],
                 service_ports: Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortResult']):
        """
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressArgs'] client_ip_addresses: Client IP Address criteria
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieArgs'] cookies: Rule for matching cookie
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodArgs'] http_methods: HTTP methods that are matched
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathArgs'] paths: HTTP request path that will be matched
        :param str protocol_type: Protocol to match - 'HTTP' or 'HTTPS'
        :param Sequence[str] queries: HTTP request query strings to match
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderArgs'] request_headers: A set of rules for matching request headers
        :param Sequence['GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortArgs'] service_ports: Service Port criteria
        """
        pulumi.set(__self__, "client_ip_addresses", client_ip_addresses)
        pulumi.set(__self__, "cookies", cookies)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "paths", paths)
        pulumi.set(__self__, "protocol_type", protocol_type)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "request_headers", request_headers)
        pulumi.set(__self__, "service_ports", service_ports)

    @property
    @pulumi.getter(name="clientIpAddresses")
    def client_ip_addresses(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressResult']:
        """
        Client IP Address criteria
        """
        return pulumi.get(self, "client_ip_addresses")

    @property
    @pulumi.getter
    def cookies(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieResult']:
        """
        Rule for matching cookie
        """
        return pulumi.get(self, "cookies")

    @property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodResult']:
        """
        HTTP methods that are matched
        """
        return pulumi.get(self, "http_methods")

    @property
    @pulumi.getter
    def paths(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathResult']:
        """
        HTTP request path that will be matched
        """
        return pulumi.get(self, "paths")

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> str:
        """
        Protocol to match - 'HTTP' or 'HTTPS'
        """
        return pulumi.get(self, "protocol_type")

    @property
    @pulumi.getter
    def queries(self) -> Sequence[str]:
        """
        HTTP request query strings to match
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderResult']:
        """
        A set of rules for matching request headers
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="servicePorts")
    def service_ports(self) -> Sequence['outputs.GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortResult']:
        """
        Service Port criteria
        """
        return pulumi.get(self, "service_ports")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaClientIpAddressResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 ip_addresses: Sequence[str]):
        """
        :param str criteria: Criteria to use for IP address matching the HTTP request
        :param Sequence[str] ip_addresses: A set of IP addresses
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for IP address matching the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        A set of IP addresses
        """
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaCookieResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 value: str):
        """
        :param str criteria: Criteria to use for matching cookies in the HTTP request
        :param str name: Name of the HTTP cookie whose value is to be matched
        :param str value: String values to match for an HTTP cookie
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching cookies in the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP cookie whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        String values to match for an HTTP cookie
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaHttpMethodResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 methods: Sequence[str]):
        """
        :param str criteria: Criteria to use for HTTP method matching in the HTTP request
        :param Sequence[str] methods: HTTP methods that will be matched
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "methods", methods)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for HTTP method matching in the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def methods(self) -> Sequence[str]:
        """
        HTTP methods that will be matched
        """
        return pulumi.get(self, "methods")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaPathResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 paths: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching the path in the HTTP request URI
        :param Sequence[str] paths: String values to match the path
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching the path in the HTTP request URI
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def paths(self) -> Sequence[str]:
        """
        String values to match the path
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaRequestHeaderResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 name: str,
                 values: Sequence[str]):
        """
        :param str criteria: Criteria to use for matching headers and cookies in the HTTP request amd response
        :param str name: Name of the HTTP header whose value is to be matched
        :param Sequence[str] values: String values to match for an HTTP header
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for matching headers and cookies in the HTTP request amd response
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the HTTP header whose value is to be matched
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        String values to match for an HTTP header
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetNsxtAlbVirtualServiceHttpSecRulesRuleMatchCriteriaServicePortResult(dict):
    def __init__(__self__, *,
                 criteria: str,
                 ports: Sequence[int]):
        """
        :param str criteria: Criteria to use for service port matching the HTTP request
        :param Sequence[int] ports: A set of TCP ports
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "ports", ports)

    @property
    @pulumi.getter
    def criteria(self) -> str:
        """
        Criteria to use for service port matching the HTTP request
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        """
        A set of TCP ports
        """
        return pulumi.get(self, "ports")


@pulumi.output_type
class GetNsxtAlbVirtualServiceServicePortResult(dict):
    def __init__(__self__, *,
                 end_port: int,
                 ssl_enabled: bool,
                 start_port: int,
                 type: str):
        """
        :param int end_port: Last port in the range
        :param bool ssl_enabled: Starting port in the range
        :param int start_port: Starting port in the range
        :param str type: One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "ssl_enabled", ssl_enabled)
        pulumi.set(__self__, "start_port", start_port)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> int:
        """
        Last port in the range
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter(name="sslEnabled")
    def ssl_enabled(self) -> bool:
        """
        Starting port in the range
        """
        return pulumi.get(self, "ssl_enabled")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> int:
        """
        Starting port in the range
        """
        return pulumi.get(self, "start_port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        One of 'TCP_PROXY', 'TCP_FAST_PATH', 'UDP_FAST_PATH'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNsxtAppPortProfileAppPortResult(dict):
    def __init__(__self__, *,
                 ports: Sequence[str],
                 protocol: str):
        """
        :param Sequence[str] ports: Set of ports or ranges
        """
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def ports(self) -> Sequence[str]:
        """
        Set of ports or ranges
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetNsxtDistributedFirewallRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 app_port_profile_ids: Sequence[str],
                 comment: str,
                 description: str,
                 destination_groups_excluded: bool,
                 destination_ids: Sequence[str],
                 direction: str,
                 enabled: bool,
                 id: str,
                 ip_protocol: str,
                 logging: bool,
                 name: str,
                 network_context_profile_ids: Sequence[str],
                 source_groups_excluded: bool,
                 source_ids: Sequence[str]):
        """
        :param str action: Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic
        :param Sequence[str] app_port_profile_ids: A set of Application Port Profile IDs.'
        :param str comment: Comment that is shown next to rule in UI (VCD 10.3.2+)
        :param str description: Description (not shown in UI)
        :param bool destination_groups_excluded: Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)
        :param Sequence[str] destination_ids: A set of Destination Firewall Group IDs (IP Sets or Security Groups). Empty means 'Any'
        :param str direction: Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        :param bool enabled: Defines if Firewall Rule is active
        :param str id: Firewall Rule ID
        :param str ip_protocol: Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        :param bool logging: Defines if matching traffic should be logged
        :param str name: Firewall Rule name
        :param Sequence[str] network_context_profile_ids: A set of Network Context Profile IDs.
        :param bool source_groups_excluded: Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)
        :param Sequence[str] source_ids: A set of Source Firewall Group IDs (IP Sets or Security Groups). Empty means 'Any'
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "app_port_profile_ids", app_port_profile_ids)
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "destination_groups_excluded", destination_groups_excluded)
        pulumi.set(__self__, "destination_ids", destination_ids)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        pulumi.set(__self__, "logging", logging)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_context_profile_ids", network_context_profile_ids)
        pulumi.set(__self__, "source_groups_excluded", source_groups_excluded)
        pulumi.set(__self__, "source_ids", source_ids)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Defines if the rule should 'ALLOW', 'DROP', 'REJECT' matching traffic
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="appPortProfileIds")
    def app_port_profile_ids(self) -> Sequence[str]:
        """
        A set of Application Port Profile IDs.'
        """
        return pulumi.get(self, "app_port_profile_ids")

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Comment that is shown next to rule in UI (VCD 10.3.2+)
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description (not shown in UI)
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationGroupsExcluded")
    def destination_groups_excluded(self) -> bool:
        """
        Reverses firewall matching for to match all except Destinations Groups specified in 'destination_ids' (VCD 10.3.2+)
        """
        return pulumi.get(self, "destination_groups_excluded")

    @property
    @pulumi.getter(name="destinationIds")
    def destination_ids(self) -> Sequence[str]:
        """
        A set of Destination Firewall Group IDs (IP Sets or Security Groups). Empty means 'Any'
        """
        return pulumi.get(self, "destination_ids")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction on which Firewall Rule applies (One of 'IN', 'OUT', 'IN_OUT')
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Defines if Firewall Rule is active
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Firewall Rule ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        """
        Firewall Rule Protocol (One of 'IPV4', 'IPV6', 'IPV4_IPV6')
        """
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter
    def logging(self) -> bool:
        """
        Defines if matching traffic should be logged
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="networkContextProfileIds")
    def network_context_profile_ids(self) -> Sequence[str]:
        """
        A set of Network Context Profile IDs.
        """
        return pulumi.get(self, "network_context_profile_ids")

    @property
    @pulumi.getter(name="sourceGroupsExcluded")
    def source_groups_excluded(self) -> bool:
        """
        Reverses firewall matching for to match all except Source Groups specified in 'source_ids' (VCD 10.3.2+)
        """
        return pulumi.get(self, "source_groups_excluded")

    @property
    @pulumi.getter(name="sourceIds")
    def source_ids(self) -> Sequence[str]:
        """
        A set of Source Firewall Group IDs (IP Sets or Security Groups). Empty means 'Any'
        """
        return pulumi.get(self, "source_ids")


@pulumi.output_type
class GetNsxtDynamicSecurityGroupCriteriaResult(dict):
    def __init__(__self__, *,
                 rules: Sequence['outputs.GetNsxtDynamicSecurityGroupCriteriaRuleResult']):
        """
        :param Sequence['GetNsxtDynamicSecurityGroupCriteriaRuleArgs'] rules: Up to 4 rules can be used to define single criteria
        """
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetNsxtDynamicSecurityGroupCriteriaRuleResult']:
        """
        Up to 4 rules can be used to define single criteria
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetNsxtDynamicSecurityGroupCriteriaRuleResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 type: str,
                 value: str):
        """
        :param str operator: Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'
        :param str type: Type of object matching 'VM_TAG' or 'VM_NAME'
        :param str value: Filter value
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator can be one of 'EQUALS', 'CONTAINS', 'STARTS_WITH', 'ENDS_WITH'
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of object matching 'VM_TAG' or 'VM_NAME'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Filter value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxtDynamicSecurityGroupMemberVmResult(dict):
    def __init__(__self__, *,
                 vapp_id: str,
                 vapp_name: str,
                 vm_id: str,
                 vm_name: str):
        """
        :param str vapp_id: Parent vApp name (if exists) for member VM
        :param str vapp_name: Parent vApp ID (if exists) for member VM
        :param str vm_id: Member VM ID
        :param str vm_name: Member VM Name
        """
        pulumi.set(__self__, "vapp_id", vapp_id)
        pulumi.set(__self__, "vapp_name", vapp_name)
        pulumi.set(__self__, "vm_id", vm_id)
        pulumi.set(__self__, "vm_name", vm_name)

    @property
    @pulumi.getter(name="vappId")
    def vapp_id(self) -> str:
        """
        Parent vApp name (if exists) for member VM
        """
        return pulumi.get(self, "vapp_id")

    @property
    @pulumi.getter(name="vappName")
    def vapp_name(self) -> str:
        """
        Parent vApp ID (if exists) for member VM
        """
        return pulumi.get(self, "vapp_name")

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> str:
        """
        Member VM ID
        """
        return pulumi.get(self, "vm_id")

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> str:
        """
        Member VM Name
        """
        return pulumi.get(self, "vm_name")


@pulumi.output_type
class GetNsxtEdgegatewayBgpIpPrefixListIpPrefixResult(dict):
    def __init__(__self__, *,
                 action: str,
                 greater_than_or_equal_to: int,
                 less_than_or_equal_to: int,
                 network: str):
        """
        :param str action: Action 'PERMIT' or 'DENY'
        :param int greater_than_or_equal_to: Greater than or equal to (ge) subnet mask
        :param int less_than_or_equal_to: Less than or equal to (le) subnet mask
        :param str network: Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "greater_than_or_equal_to", greater_than_or_equal_to)
        pulumi.set(__self__, "less_than_or_equal_to", less_than_or_equal_to)
        pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action 'PERMIT' or 'DENY'
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="greaterThanOrEqualTo")
    def greater_than_or_equal_to(self) -> int:
        """
        Greater than or equal to (ge) subnet mask
        """
        return pulumi.get(self, "greater_than_or_equal_to")

    @property
    @pulumi.getter(name="lessThanOrEqualTo")
    def less_than_or_equal_to(self) -> int:
        """
        Less than or equal to (le) subnet mask
        """
        return pulumi.get(self, "less_than_or_equal_to")

    @property
    @pulumi.getter
    def network(self) -> str:
        """
        Network in CIDR notation (e.g. '192.168.100.0/24', '2001:db8::/48')
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class GetNsxtEdgegatewayDnsConditionalForwarderZoneResult(dict):
    def __init__(__self__, *,
                 domain_names: Sequence[str],
                 id: str,
                 name: str,
                 upstream_servers: Sequence[str]):
        """
        :param Sequence[str] domain_names: Set of domain names on which conditional forwarding is based.
        :param str id: Unique ID of the forwarder zone.
        :param str name: Name of the forwarder zone.
        :param Sequence[str] upstream_servers: Servers to which DNS requests should be forwarded to.
        """
        pulumi.set(__self__, "domain_names", domain_names)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "upstream_servers", upstream_servers)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Sequence[str]:
        """
        Set of domain names on which conditional forwarding is based.
        """
        return pulumi.get(self, "domain_names")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique ID of the forwarder zone.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the forwarder zone.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="upstreamServers")
    def upstream_servers(self) -> Sequence[str]:
        """
        Servers to which DNS requests should be forwarded to.
        """
        return pulumi.get(self, "upstream_servers")


@pulumi.output_type
class GetNsxtEdgegatewayDnsDefaultForwarderZoneResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 upstream_servers: Sequence[str]):
        """
        :param str id: Unique ID of the forwarder zone.
        :param str name: Name of the forwarder zone.
        :param Sequence[str] upstream_servers: Servers to which DNS requests should be forwarded to.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "upstream_servers", upstream_servers)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique ID of the forwarder zone.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the forwarder zone.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="upstreamServers")
    def upstream_servers(self) -> Sequence[str]:
        """
        Servers to which DNS requests should be forwarded to.
        """
        return pulumi.get(self, "upstream_servers")


@pulumi.output_type
class GetNsxtEdgegatewayExternalNetworkResult(dict):
    def __init__(__self__, *,
                 allocated_ip_count: int,
                 external_network_id: str,
                 gateway: str,
                 prefix_length: int,
                 primary_ip: str):
        """
        :param int allocated_ip_count: Number of allocated IPs
        :param str external_network_id: NSX-T Segment backed External Network ID
        :param str gateway: Gateway IP Address
        :param int prefix_length: Prefix length for a subnet (e.g. 24)
        :param str primary_ip: Primary IP address for the Edge Gateway
        """
        pulumi.set(__self__, "allocated_ip_count", allocated_ip_count)
        pulumi.set(__self__, "external_network_id", external_network_id)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter(name="allocatedIpCount")
    def allocated_ip_count(self) -> int:
        """
        Number of allocated IPs
        """
        return pulumi.get(self, "allocated_ip_count")

    @property
    @pulumi.getter(name="externalNetworkId")
    def external_network_id(self) -> str:
        """
        NSX-T Segment backed External Network ID
        """
        return pulumi.get(self, "external_network_id")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway IP Address
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> str:
        """
        Primary IP address for the Edge Gateway
        """
        return pulumi.get(self, "primary_ip")


@pulumi.output_type
class GetNsxtEdgegatewayL2VpnTunnelStretchedNetworkResult(dict):
    def __init__(__self__, *,
                 network_id: str,
                 tunnel_id: int):
        """
        :param str network_id: ID of the Org VDC network
        :param int tunnel_id: Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.
        """
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "tunnel_id", tunnel_id)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        """
        ID of the Org VDC network
        """
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter(name="tunnelId")
    def tunnel_id(self) -> int:
        """
        Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.
        """
        return pulumi.get(self, "tunnel_id")


@pulumi.output_type
class GetNsxtEdgegatewayStaticRouteNextHopResult(dict):
    def __init__(__self__, *,
                 admin_distance: int,
                 ip_address: str,
                 scopes: Sequence['outputs.GetNsxtEdgegatewayStaticRouteNextHopScopeResult']):
        """
        :param int admin_distance: Admin distance of next hop
        :param str ip_address: IP Address of next hop
        """
        pulumi.set(__self__, "admin_distance", admin_distance)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "scopes", scopes)

    @property
    @pulumi.getter(name="adminDistance")
    def admin_distance(self) -> int:
        """
        Admin distance of next hop
        """
        return pulumi.get(self, "admin_distance")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        IP Address of next hop
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.GetNsxtEdgegatewayStaticRouteNextHopScopeResult']:
        return pulumi.get(self, "scopes")


@pulumi.output_type
class GetNsxtEdgegatewayStaticRouteNextHopScopeResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        """
        :param str id: ID of Scope element
        :param str name: Name of Static Route. **Note** names *can be duplicate* and one can use
               `network_cidr` to make filtering more precise
        :param str type: Scope type - One of 'NETWORK', 'SYSTEM_OWNED'
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Scope element
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of Static Route. **Note** names *can be duplicate* and one can use
        `network_cidr` to make filtering more precise
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Scope type - One of 'NETWORK', 'SYSTEM_OWNED'
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetNsxtEdgegatewaySubnetResult(dict):
    def __init__(__self__, *,
                 allocated_ips: Sequence['outputs.GetNsxtEdgegatewaySubnetAllocatedIpResult'],
                 gateway: str,
                 prefix_length: int,
                 primary_ip: str):
        """
        :param Sequence['GetNsxtEdgegatewaySubnetAllocatedIpArgs'] allocated_ips: One or more blocks to sub-allocate pools on the edge gateway
        :param str gateway: Gateway address for a subnet
        :param int prefix_length: Prefix length for a subnet (e.g. 24)
        :param str primary_ip: IP address on the edge gateway
        """
        pulumi.set(__self__, "allocated_ips", allocated_ips)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter(name="allocatedIps")
    def allocated_ips(self) -> Sequence['outputs.GetNsxtEdgegatewaySubnetAllocatedIpResult']:
        """
        One or more blocks to sub-allocate pools on the edge gateway
        """
        return pulumi.get(self, "allocated_ips")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> str:
        """
        IP address on the edge gateway
        """
        return pulumi.get(self, "primary_ip")


@pulumi.output_type
class GetNsxtEdgegatewaySubnetAllocatedIpResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNsxtEdgegatewaySubnetWithIpCountResult(dict):
    def __init__(__self__, *,
                 allocated_ip_count: int,
                 gateway: str,
                 prefix_length: int,
                 primary_ip: str):
        """
        :param int allocated_ip_count: Number of IP addresses to allocate
        :param str gateway: Gateway address for a subnet
        :param int prefix_length: Prefix length for a subnet (e.g. 24)
        :param str primary_ip: Primary IP address for the Edge Gateway - will be auto-assigned if not defined
        """
        pulumi.set(__self__, "allocated_ip_count", allocated_ip_count)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter(name="allocatedIpCount")
    def allocated_ip_count(self) -> int:
        """
        Number of IP addresses to allocate
        """
        return pulumi.get(self, "allocated_ip_count")

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> str:
        """
        Primary IP address for the Edge Gateway - will be auto-assigned if not defined
        """
        return pulumi.get(self, "primary_ip")


@pulumi.output_type
class GetNsxtEdgegatewaySubnetWithTotalIpCountResult(dict):
    def __init__(__self__, *,
                 gateway: str,
                 prefix_length: int,
                 primary_ip: str):
        """
        :param str gateway: Gateway address for a subnet
        :param int prefix_length: Prefix length for a subnet (e.g. 24)
        :param str primary_ip: Primary IP address for the Edge Gateway
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "primary_ip", primary_ip)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        Gateway address for a subnet
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        Prefix length for a subnet (e.g. 24)
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter(name="primaryIp")
    def primary_ip(self) -> str:
        """
        Primary IP address for the Edge Gateway
        """
        return pulumi.get(self, "primary_ip")


@pulumi.output_type
class GetNsxtFirewallRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 app_port_profile_ids: Sequence[str],
                 destination_ids: Sequence[str],
                 direction: str,
                 enabled: bool,
                 id: str,
                 ip_protocol: str,
                 logging: bool,
                 name: str,
                 source_ids: Sequence[str]):
        """
        :param Sequence[str] app_port_profile_ids: A set of Application Port Profile IDs. Leaving it empty means 'Any'
        :param Sequence[str] destination_ids: A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        :param str direction: IN OUT IN_OUT
        :param bool enabled: Firewall Rule name
        :param str id: Firewall Rule ID
        :param str ip_protocol: IPV4,  IPV6, IPV4_IPV6
        :param bool logging: Firewall Rule name
        :param str name: Firewall Rule name
        :param Sequence[str] source_ids: A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "app_port_profile_ids", app_port_profile_ids)
        pulumi.set(__self__, "destination_ids", destination_ids)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        pulumi.set(__self__, "logging", logging)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_ids", source_ids)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="appPortProfileIds")
    def app_port_profile_ids(self) -> Sequence[str]:
        """
        A set of Application Port Profile IDs. Leaving it empty means 'Any'
        """
        return pulumi.get(self, "app_port_profile_ids")

    @property
    @pulumi.getter(name="destinationIds")
    def destination_ids(self) -> Sequence[str]:
        """
        A set of Destination Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "destination_ids")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        IN OUT IN_OUT
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Firewall Rule ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        """
        IPV4,  IPV6, IPV4_IPV6
        """
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter
    def logging(self) -> bool:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "logging")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceIds")
    def source_ids(self) -> Sequence[str]:
        """
        A set of Source Firewall Group IDs (IP Sets or Security Groups). Leaving it empty means 'Any'
        """
        return pulumi.get(self, "source_ids")


@pulumi.output_type
class GetNsxtIpsecVpnTunnelSecurityProfileCustomizationResult(dict):
    def __init__(__self__, *,
                 dpd_probe_internal: int,
                 ike_dh_groups: Sequence[str],
                 ike_digest_algorithms: Sequence[str],
                 ike_encryption_algorithms: Sequence[str],
                 ike_sa_lifetime: int,
                 ike_version: str,
                 tunnel_df_policy: str,
                 tunnel_dh_groups: Sequence[str],
                 tunnel_digest_algorithms: Sequence[str],
                 tunnel_encryption_algorithms: Sequence[str],
                 tunnel_pfs_enabled: bool,
                 tunnel_sa_lifetime: int):
        """
        :param int dpd_probe_internal: Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
        :param Sequence[str] ike_dh_groups: Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        :param Sequence[str] ike_digest_algorithms: Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        :param Sequence[str] ike_encryption_algorithms: Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        :param int ike_sa_lifetime: Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
        :param str ike_version: IKE version one of IKE_V1, IKE_V2, IKE_FLEX
        :param str tunnel_df_policy: Policy for handling defragmentation bit. One of COPY, CLEAR
        :param Sequence[str] tunnel_dh_groups: Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        :param Sequence[str] tunnel_digest_algorithms: Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        :param Sequence[str] tunnel_encryption_algorithms: Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
        :param bool tunnel_pfs_enabled: Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
        :param int tunnel_sa_lifetime: Security Association life time (in seconds)
        """
        pulumi.set(__self__, "dpd_probe_internal", dpd_probe_internal)
        pulumi.set(__self__, "ike_dh_groups", ike_dh_groups)
        pulumi.set(__self__, "ike_digest_algorithms", ike_digest_algorithms)
        pulumi.set(__self__, "ike_encryption_algorithms", ike_encryption_algorithms)
        pulumi.set(__self__, "ike_sa_lifetime", ike_sa_lifetime)
        pulumi.set(__self__, "ike_version", ike_version)
        pulumi.set(__self__, "tunnel_df_policy", tunnel_df_policy)
        pulumi.set(__self__, "tunnel_dh_groups", tunnel_dh_groups)
        pulumi.set(__self__, "tunnel_digest_algorithms", tunnel_digest_algorithms)
        pulumi.set(__self__, "tunnel_encryption_algorithms", tunnel_encryption_algorithms)
        pulumi.set(__self__, "tunnel_pfs_enabled", tunnel_pfs_enabled)
        pulumi.set(__self__, "tunnel_sa_lifetime", tunnel_sa_lifetime)

    @property
    @pulumi.getter(name="dpdProbeInternal")
    def dpd_probe_internal(self) -> int:
        """
        Value in seconds of dead probe detection interval. Minimum is 3 seconds and the maximum is 60 seconds
        """
        return pulumi.get(self, "dpd_probe_internal")

    @property
    @pulumi.getter(name="ikeDhGroups")
    def ike_dh_groups(self) -> Sequence[str]:
        """
        Diffie-Hellman groups to be used if Perfect Forward Secrecy is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        """
        return pulumi.get(self, "ike_dh_groups")

    @property
    @pulumi.getter(name="ikeDigestAlgorithms")
    def ike_digest_algorithms(self) -> Sequence[str]:
        """
        Secure hashing algorithms to use during the IKE negotiation. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        return pulumi.get(self, "ike_digest_algorithms")

    @property
    @pulumi.getter(name="ikeEncryptionAlgorithms")
    def ike_encryption_algorithms(self) -> Sequence[str]:
        """
        Encryption algorithms. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        return pulumi.get(self, "ike_encryption_algorithms")

    @property
    @pulumi.getter(name="ikeSaLifetime")
    def ike_sa_lifetime(self) -> int:
        """
        Security Association life time (in seconds). It is number of seconds before the IPsec tunnel needs to reestablish
        """
        return pulumi.get(self, "ike_sa_lifetime")

    @property
    @pulumi.getter(name="ikeVersion")
    def ike_version(self) -> str:
        """
        IKE version one of IKE_V1, IKE_V2, IKE_FLEX
        """
        return pulumi.get(self, "ike_version")

    @property
    @pulumi.getter(name="tunnelDfPolicy")
    def tunnel_df_policy(self) -> str:
        """
        Policy for handling defragmentation bit. One of COPY, CLEAR
        """
        return pulumi.get(self, "tunnel_df_policy")

    @property
    @pulumi.getter(name="tunnelDhGroups")
    def tunnel_dh_groups(self) -> Sequence[str]:
        """
        Diffie-Hellman groups to be used is PFS is enabled. One of GROUP2, GROUP5, GROUP14, GROUP15, GROUP16, GROUP19, GROUP20, GROUP21
        """
        return pulumi.get(self, "tunnel_dh_groups")

    @property
    @pulumi.getter(name="tunnelDigestAlgorithms")
    def tunnel_digest_algorithms(self) -> Sequence[str]:
        """
        Digest algorithms to be used for message digest. One of SHA1, SHA2_256, SHA2_384, SHA2_512
        """
        return pulumi.get(self, "tunnel_digest_algorithms")

    @property
    @pulumi.getter(name="tunnelEncryptionAlgorithms")
    def tunnel_encryption_algorithms(self) -> Sequence[str]:
        """
        Encryption algorithms to use in IPSec tunnel establishment. One of AES_128, AES_256, AES_GCM_128, AES_GCM_192, AES_GCM_256, NO_ENCRYPTION_AUTH_AES_GMAC_128, NO_ENCRYPTION_AUTH_AES_GMAC_192, NO_ENCRYPTION_AUTH_AES_GMAC_256, NO_ENCRYPTION
        """
        return pulumi.get(self, "tunnel_encryption_algorithms")

    @property
    @pulumi.getter(name="tunnelPfsEnabled")
    def tunnel_pfs_enabled(self) -> bool:
        """
        Perfect Forward Secrecy Enabled or Disabled. Default (enabled)
        """
        return pulumi.get(self, "tunnel_pfs_enabled")

    @property
    @pulumi.getter(name="tunnelSaLifetime")
    def tunnel_sa_lifetime(self) -> int:
        """
        Security Association life time (in seconds)
        """
        return pulumi.get(self, "tunnel_sa_lifetime")


@pulumi.output_type
class GetNsxtNetworkDhcpBindingDhcpV4ConfigResult(dict):
    def __init__(__self__, *,
                 gateway_ip_address: str,
                 hostname: str):
        """
        :param str gateway_ip_address: Gateway IP address to be used by the DHCP client
        :param str hostname: Hostname to be used by the DHCP client
        """
        pulumi.set(__self__, "gateway_ip_address", gateway_ip_address)
        pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter(name="gatewayIpAddress")
    def gateway_ip_address(self) -> str:
        """
        Gateway IP address to be used by the DHCP client
        """
        return pulumi.get(self, "gateway_ip_address")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Hostname to be used by the DHCP client
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class GetNsxtNetworkDhcpBindingDhcpV6ConfigResult(dict):
    def __init__(__self__, *,
                 dns_servers: Sequence[str],
                 sntp_servers: Sequence[str]):
        """
        :param Sequence[str] dns_servers: List of DNS servers to be used by the DHCP client
        :param Sequence[str] sntp_servers: List of SNTP servers to be used by the DHCP client
        """
        pulumi.set(__self__, "dns_servers", dns_servers)
        pulumi.set(__self__, "sntp_servers", sntp_servers)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Sequence[str]:
        """
        List of DNS servers to be used by the DHCP client
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="sntpServers")
    def sntp_servers(self) -> Sequence[str]:
        """
        List of SNTP servers to be used by the DHCP client
        """
        return pulumi.get(self, "sntp_servers")


@pulumi.output_type
class GetNsxtNetworkDhcpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of DHCP pool IP range
        :param str start_address: Start address of DHCP pool IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of DHCP pool IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of DHCP pool IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNsxtNetworkImportedFilterResult(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 name_regex: Optional[str] = None):
        """
        :param str ip: Search by IP. The value can be a regular expression
        :param str name_regex: Search by name with a regular expression
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Search by IP. The value can be a regular expression
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetNsxtNetworkImportedSecondaryStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNsxtNetworkImportedStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetNsxtSecurityGroupMemberVmResult(dict):
    def __init__(__self__, *,
                 vapp_id: str,
                 vapp_name: str,
                 vm_id: str,
                 vm_name: str):
        """
        :param str vapp_id: Parent vApp name (if exists) for member VM
        :param str vapp_name: Parent vApp ID (if exists) for member VM
        :param str vm_id: Member VM ID
        :param str vm_name: Member VM Name
        """
        pulumi.set(__self__, "vapp_id", vapp_id)
        pulumi.set(__self__, "vapp_name", vapp_name)
        pulumi.set(__self__, "vm_id", vm_id)
        pulumi.set(__self__, "vm_name", vm_name)

    @property
    @pulumi.getter(name="vappId")
    def vapp_id(self) -> str:
        """
        Parent vApp name (if exists) for member VM
        """
        return pulumi.get(self, "vapp_id")

    @property
    @pulumi.getter(name="vappName")
    def vapp_name(self) -> str:
        """
        Parent vApp ID (if exists) for member VM
        """
        return pulumi.get(self, "vapp_name")

    @property
    @pulumi.getter(name="vmId")
    def vm_id(self) -> str:
        """
        Member VM ID
        """
        return pulumi.get(self, "vm_id")

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> str:
        """
        Member VM Name
        """
        return pulumi.get(self, "vm_name")


@pulumi.output_type
class GetNsxvApplicationFinderObjectResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the object
        :param str type: What kind of application we seek. One of `application`, `application_group`
        :param str value: The identifier of the object
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the object
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        What kind of application we seek. One of `application`, `application_group`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The identifier of the object
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxvApplicationGroupApplicationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the application group
        :param str value: The identifier of the application
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the application group
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The identifier of the application
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxvDhcpRelayRelayAgentResult(dict):
    def __init__(__self__, *,
                 gateway_ip_address: str,
                 network_name: str):
        """
        :param str gateway_ip_address: Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers
        :param str network_name: Org network which is to be used for relaying DHCP message to specified servers
        """
        pulumi.set(__self__, "gateway_ip_address", gateway_ip_address)
        pulumi.set(__self__, "network_name", network_name)

    @property
    @pulumi.getter(name="gatewayIpAddress")
    def gateway_ip_address(self) -> str:
        """
        Optional gateway IP address of org network which is to be used for relaying DHCP message to specified servers
        """
        return pulumi.get(self, "gateway_ip_address")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Org network which is to be used for relaying DHCP message to specified servers
        """
        return pulumi.get(self, "network_name")


@pulumi.output_type
class GetNsxvDistributedFirewallRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 applications: Sequence['outputs.GetNsxvDistributedFirewallRuleApplicationResult'],
                 applied_tos: Sequence['outputs.GetNsxvDistributedFirewallRuleAppliedToResult'],
                 destinations: Sequence['outputs.GetNsxvDistributedFirewallRuleDestinationResult'],
                 direction: str,
                 enabled: bool,
                 exclude_destination: bool,
                 exclude_source: bool,
                 id: int,
                 logged: bool,
                 name: str,
                 packet_type: str,
                 sources: Sequence['outputs.GetNsxvDistributedFirewallRuleSourceResult']):
        """
        :param str action: Action of the rule (allow, deny)
        :param Sequence['GetNsxvDistributedFirewallRuleApplicationArgs'] applications: Application definitions for this rule. An empty value means 'any'
        :param Sequence['GetNsxvDistributedFirewallRuleAppliedToArgs'] applied_tos: List of elements to which this rule applies
        :param Sequence['GetNsxvDistributedFirewallRuleDestinationArgs'] destinations: List of destination traffic for this rule. An empty value means 'any'
        :param str direction: Direction of the rule (in, out, inout)
        :param bool enabled: Whether the rule is enabled
        :param bool exclude_destination: If true, the content of the destination elements is reversed
        :param bool exclude_source: If true, the content of the source elements is reversed
        :param int id: Firewall Rule ID
        :param bool logged: Whether the rule traffic is logged
        :param str name: Firewall Rule name
        :param str packet_type: Packet type of the rule (any, ipv4, ipv6)
        :param Sequence['GetNsxvDistributedFirewallRuleSourceArgs'] sources: List of source traffic for this rule. An empty value means 'any'
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "applications", applications)
        pulumi.set(__self__, "applied_tos", applied_tos)
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "exclude_destination", exclude_destination)
        pulumi.set(__self__, "exclude_source", exclude_source)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "logged", logged)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "packet_type", packet_type)
        pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action of the rule (allow, deny)
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def applications(self) -> Sequence['outputs.GetNsxvDistributedFirewallRuleApplicationResult']:
        """
        Application definitions for this rule. An empty value means 'any'
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="appliedTos")
    def applied_tos(self) -> Sequence['outputs.GetNsxvDistributedFirewallRuleAppliedToResult']:
        """
        List of elements to which this rule applies
        """
        return pulumi.get(self, "applied_tos")

    @property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.GetNsxvDistributedFirewallRuleDestinationResult']:
        """
        List of destination traffic for this rule. An empty value means 'any'
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def direction(self) -> str:
        """
        Direction of the rule (in, out, inout)
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the rule is enabled
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="excludeDestination")
    def exclude_destination(self) -> bool:
        """
        If true, the content of the destination elements is reversed
        """
        return pulumi.get(self, "exclude_destination")

    @property
    @pulumi.getter(name="excludeSource")
    def exclude_source(self) -> bool:
        """
        If true, the content of the source elements is reversed
        """
        return pulumi.get(self, "exclude_source")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Firewall Rule ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def logged(self) -> bool:
        """
        Whether the rule traffic is logged
        """
        return pulumi.get(self, "logged")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Firewall Rule name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="packetType")
    def packet_type(self) -> str:
        """
        Packet type of the rule (any, ipv4, ipv6)
        """
        return pulumi.get(self, "packet_type")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetNsxvDistributedFirewallRuleSourceResult']:
        """
        List of source traffic for this rule. An empty value means 'any'
        """
        return pulumi.get(self, "sources")


@pulumi.output_type
class GetNsxvDistributedFirewallRuleApplicationResult(dict):
    def __init__(__self__, *,
                 destination_port: str,
                 name: str,
                 protocol: str,
                 source_port: str,
                 type: str,
                 value: str):
        """
        :param str destination_port: Destination port for this application. Leaving it empty means 'any' port
        :param str name: Name of application (Application, ApplicationGroup)
        :param str protocol: Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)
        :param str source_port: Source port for this application. Leaving it empty means 'any' port
        :param str type: Type of application
        :param str value: Value of the application
        """
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_port", source_port)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> str:
        """
        Destination port for this application. Leaving it empty means 'any' port
        """
        return pulumi.get(self, "destination_port")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of application (Application, ApplicationGroup)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Protocol of the application (one of TCP, UDP, ICMP) (When not using name/value)
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> str:
        """
        Source port for this application. Leaving it empty means 'any' port
        """
        return pulumi.get(self, "source_port")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of application
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the application
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxvDistributedFirewallRuleAppliedToResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Name of the applied-to entity
        :param str type: Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)
        :param str value: Value of the applied-to entity
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the applied-to entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the applied-to entity (one of Network, Edge, VirtualMachine, IPSet, VDC, Ipv4Address)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the applied-to entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxvDistributedFirewallRuleDestinationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Name of the destination entity
        :param str type: Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        :param str value: Value of the destination entity
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the destination entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the destination entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the destination entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxvDistributedFirewallRuleSourceResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Name of the source entity
        :param str type: Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        :param str value: Value of the source entity
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the source entity
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the source entity (one of Network, Edge, VirtualMachine, IpSet, VDC, Ipv4Address)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the source entity
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNsxvFirewallRuleDestinationResult(dict):
    def __init__(__self__, *,
                 exclude: bool,
                 gateway_interfaces: Sequence[str],
                 ip_addresses: Sequence[str],
                 ip_sets: Sequence[str],
                 org_networks: Sequence[str],
                 vm_ids: Sequence[str]):
        """
        :param bool exclude: Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'
        :param Sequence[str] gateway_interfaces: 'vse', 'internal', 'external' or network name
        :param Sequence[str] ip_addresses: IP address, CIDR, an IP range, or the keyword 'any'
        :param Sequence[str] ip_sets: Set of IP set names
        :param Sequence[str] org_networks: Set of org network names
        :param Sequence[str] vm_ids: Set of VM IDs
        """
        pulumi.set(__self__, "exclude", exclude)
        pulumi.set(__self__, "gateway_interfaces", gateway_interfaces)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "ip_sets", ip_sets)
        pulumi.set(__self__, "org_networks", org_networks)
        pulumi.set(__self__, "vm_ids", vm_ids)

    @property
    @pulumi.getter
    def exclude(self) -> bool:
        """
        Rule is applied to traffic going to any destinations except for the excluded destination. Default 'false'
        """
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter(name="gatewayInterfaces")
    def gateway_interfaces(self) -> Sequence[str]:
        """
        'vse', 'internal', 'external' or network name
        """
        return pulumi.get(self, "gateway_interfaces")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        IP address, CIDR, an IP range, or the keyword 'any'
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Sequence[str]:
        """
        Set of IP set names
        """
        return pulumi.get(self, "ip_sets")

    @property
    @pulumi.getter(name="orgNetworks")
    def org_networks(self) -> Sequence[str]:
        """
        Set of org network names
        """
        return pulumi.get(self, "org_networks")

    @property
    @pulumi.getter(name="vmIds")
    def vm_ids(self) -> Sequence[str]:
        """
        Set of VM IDs
        """
        return pulumi.get(self, "vm_ids")


@pulumi.output_type
class GetNsxvFirewallRuleServiceResult(dict):
    def __init__(__self__, *,
                 port: str,
                 protocol: str,
                 source_port: str):
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def port(self) -> str:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> str:
        return pulumi.get(self, "source_port")


@pulumi.output_type
class GetNsxvFirewallRuleSourceResult(dict):
    def __init__(__self__, *,
                 exclude: bool,
                 gateway_interfaces: Sequence[str],
                 ip_addresses: Sequence[str],
                 ip_sets: Sequence[str],
                 org_networks: Sequence[str],
                 vm_ids: Sequence[str]):
        """
        :param bool exclude: Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'
        :param Sequence[str] gateway_interfaces: 'vse', 'internal', 'external' or network name
        :param Sequence[str] ip_addresses: IP address, CIDR, an IP range, or the keyword 'any'
        :param Sequence[str] ip_sets: Set of IP set names
        :param Sequence[str] org_networks: Set of org network names
        :param Sequence[str] vm_ids: Set of VM IDs
        """
        pulumi.set(__self__, "exclude", exclude)
        pulumi.set(__self__, "gateway_interfaces", gateway_interfaces)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "ip_sets", ip_sets)
        pulumi.set(__self__, "org_networks", org_networks)
        pulumi.set(__self__, "vm_ids", vm_ids)

    @property
    @pulumi.getter
    def exclude(self) -> bool:
        """
        Rule is applied to traffic coming from all sources except for the excluded source. Default 'false'
        """
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter(name="gatewayInterfaces")
    def gateway_interfaces(self) -> Sequence[str]:
        """
        'vse', 'internal', 'external' or network name
        """
        return pulumi.get(self, "gateway_interfaces")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Sequence[str]:
        """
        IP address, CIDR, an IP range, or the keyword 'any'
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Sequence[str]:
        """
        Set of IP set names
        """
        return pulumi.get(self, "ip_sets")

    @property
    @pulumi.getter(name="orgNetworks")
    def org_networks(self) -> Sequence[str]:
        """
        Set of org network names
        """
        return pulumi.get(self, "org_networks")

    @property
    @pulumi.getter(name="vmIds")
    def vm_ids(self) -> Sequence[str]:
        """
        Set of VM IDs
        """
        return pulumi.get(self, "vm_ids")


@pulumi.output_type
class GetOrgAccountLockoutResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 invalid_logins_before_lockout: int,
                 lockout_interval_minutes: int):
        """
        :param bool enabled: Whether account lockout is enabled or not
        :param int invalid_logins_before_lockout: Number of login attempts that will trigger an account lockout for the given user
        :param int lockout_interval_minutes: Once a user is locked out, they will not be able to log back in for this time period
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "invalid_logins_before_lockout", invalid_logins_before_lockout)
        pulumi.set(__self__, "lockout_interval_minutes", lockout_interval_minutes)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether account lockout is enabled or not
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="invalidLoginsBeforeLockout")
    def invalid_logins_before_lockout(self) -> int:
        """
        Number of login attempts that will trigger an account lockout for the given user
        """
        return pulumi.get(self, "invalid_logins_before_lockout")

    @property
    @pulumi.getter(name="lockoutIntervalMinutes")
    def lockout_interval_minutes(self) -> int:
        """
        Once a user is locked out, they will not be able to log back in for this time period
        """
        return pulumi.get(self, "lockout_interval_minutes")


@pulumi.output_type
class GetOrgLdapCustomSettingResult(dict):
    def __init__(__self__, *,
                 authentication_method: str,
                 base_distinguished_name: str,
                 connector_type: str,
                 group_attributes: Sequence['outputs.GetOrgLdapCustomSettingGroupAttributeResult'],
                 is_ssl: bool,
                 password: str,
                 port: int,
                 server: str,
                 user_attributes: Sequence['outputs.GetOrgLdapCustomSettingUserAttributeResult'],
                 username: str):
        """
        :param str authentication_method: authentication method: one of SIMPLE, MD5DIGEST, NTLM
        :param str base_distinguished_name: LDAP search base
        :param str connector_type: type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY
        :param Sequence['GetOrgLdapCustomSettingGroupAttributeArgs'] group_attributes: Custom settings when `ldap_mode` is CUSTOM
        :param bool is_ssl: True if the LDAP service requires an SSL connection
        :param str password: Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed
        :param int port: Port number for LDAP service
        :param str server: host name or IP of the LDAP server
        :param Sequence['GetOrgLdapCustomSettingUserAttributeArgs'] user_attributes: Custom settings when `ldap_mode` is CUSTOM
        :param str username: Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn="ldap-admin", c="example", dc="com")
        """
        pulumi.set(__self__, "authentication_method", authentication_method)
        pulumi.set(__self__, "base_distinguished_name", base_distinguished_name)
        pulumi.set(__self__, "connector_type", connector_type)
        pulumi.set(__self__, "group_attributes", group_attributes)
        pulumi.set(__self__, "is_ssl", is_ssl)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "server", server)
        pulumi.set(__self__, "user_attributes", user_attributes)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> str:
        """
        authentication method: one of SIMPLE, MD5DIGEST, NTLM
        """
        return pulumi.get(self, "authentication_method")

    @property
    @pulumi.getter(name="baseDistinguishedName")
    def base_distinguished_name(self) -> str:
        """
        LDAP search base
        """
        return pulumi.get(self, "base_distinguished_name")

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> str:
        """
        type of connector: one of OPEN_LDAP, ACTIVE_DIRECTORY
        """
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter(name="groupAttributes")
    def group_attributes(self) -> Sequence['outputs.GetOrgLdapCustomSettingGroupAttributeResult']:
        """
        Custom settings when `ldap_mode` is CUSTOM
        """
        return pulumi.get(self, "group_attributes")

    @property
    @pulumi.getter(name="isSsl")
    def is_ssl(self) -> bool:
        """
        True if the LDAP service requires an SSL connection
        """
        return pulumi.get(self, "is_ssl")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password for the user identified by UserName. This value is never returned by GET. It is inspected on create and modify. On modify, the absence of this element indicates that the password should not be changed
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Port number for LDAP service
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        host name or IP of the LDAP server
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter(name="userAttributes")
    def user_attributes(self) -> Sequence['outputs.GetOrgLdapCustomSettingUserAttributeResult']:
        """
        Custom settings when `ldap_mode` is CUSTOM
        """
        return pulumi.get(self, "user_attributes")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use when logging in to LDAP, specified using LDAP attribute=value pairs (for example: cn="ldap-admin", c="example", dc="com")
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetOrgLdapCustomSettingGroupAttributeResult(dict):
    def __init__(__self__, *,
                 group_back_link_identifier: str,
                 group_membership_identifier: str,
                 membership: str,
                 name: str,
                 object_class: str,
                 unique_identifier: str):
        """
        :param str group_back_link_identifier: LDAP group attribute used to identify a group member
        :param str group_membership_identifier: LDAP attribute that identifies a group as a member of another group. For example, dn
        :param str membership: LDAP attribute to use when getting the members of a group. For example, member
        :param str name: LDAP attribute to use for the group name. For example, cn
        :param str object_class: LDAP objectClass of which imported groups are members. For example, group
        :param str unique_identifier: LDAP attribute to use as the unique identifier for a group. For example, objectGuid
        """
        pulumi.set(__self__, "group_back_link_identifier", group_back_link_identifier)
        pulumi.set(__self__, "group_membership_identifier", group_membership_identifier)
        pulumi.set(__self__, "membership", membership)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "object_class", object_class)
        pulumi.set(__self__, "unique_identifier", unique_identifier)

    @property
    @pulumi.getter(name="groupBackLinkIdentifier")
    def group_back_link_identifier(self) -> str:
        """
        LDAP group attribute used to identify a group member
        """
        return pulumi.get(self, "group_back_link_identifier")

    @property
    @pulumi.getter(name="groupMembershipIdentifier")
    def group_membership_identifier(self) -> str:
        """
        LDAP attribute that identifies a group as a member of another group. For example, dn
        """
        return pulumi.get(self, "group_membership_identifier")

    @property
    @pulumi.getter
    def membership(self) -> str:
        """
        LDAP attribute to use when getting the members of a group. For example, member
        """
        return pulumi.get(self, "membership")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        LDAP attribute to use for the group name. For example, cn
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objectClass")
    def object_class(self) -> str:
        """
        LDAP objectClass of which imported groups are members. For example, group
        """
        return pulumi.get(self, "object_class")

    @property
    @pulumi.getter(name="uniqueIdentifier")
    def unique_identifier(self) -> str:
        """
        LDAP attribute to use as the unique identifier for a group. For example, objectGuid
        """
        return pulumi.get(self, "unique_identifier")


@pulumi.output_type
class GetOrgLdapCustomSettingUserAttributeResult(dict):
    def __init__(__self__, *,
                 display_name: str,
                 email: str,
                 given_name: str,
                 group_back_link_identifier: str,
                 group_membership_identifier: str,
                 object_class: str,
                 surname: str,
                 telephone: str,
                 unique_identifier: str,
                 username: str):
        """
        :param str display_name: LDAP attribute to use for the user's full name. For example, displayName
        :param str email: LDAP attribute to use for the user's email address. For example, mail
        :param str given_name: LDAP attribute to use for the user's given name. For example, givenName
        :param str group_back_link_identifier: LDAP attribute that returns the identifiers of all the groups of which the user is a member
        :param str group_membership_identifier: LDAP attribute that identifies a user as a member of a group. For example, dn
        :param str object_class: LDAP objectClass of which imported users are members. For example, user or person
        :param str surname: LDAP attribute to use for the user's surname. For example, sn
        :param str telephone: LDAP attribute to use for the user's telephone number. For example, telephoneNumber
        :param str unique_identifier: LDAP attribute to use as the unique identifier for a user. For example, objectGuid
        :param str username: LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName
        """
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "given_name", given_name)
        pulumi.set(__self__, "group_back_link_identifier", group_back_link_identifier)
        pulumi.set(__self__, "group_membership_identifier", group_membership_identifier)
        pulumi.set(__self__, "object_class", object_class)
        pulumi.set(__self__, "surname", surname)
        pulumi.set(__self__, "telephone", telephone)
        pulumi.set(__self__, "unique_identifier", unique_identifier)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        LDAP attribute to use for the user's full name. For example, displayName
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        LDAP attribute to use for the user's email address. For example, mail
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="givenName")
    def given_name(self) -> str:
        """
        LDAP attribute to use for the user's given name. For example, givenName
        """
        return pulumi.get(self, "given_name")

    @property
    @pulumi.getter(name="groupBackLinkIdentifier")
    def group_back_link_identifier(self) -> str:
        """
        LDAP attribute that returns the identifiers of all the groups of which the user is a member
        """
        return pulumi.get(self, "group_back_link_identifier")

    @property
    @pulumi.getter(name="groupMembershipIdentifier")
    def group_membership_identifier(self) -> str:
        """
        LDAP attribute that identifies a user as a member of a group. For example, dn
        """
        return pulumi.get(self, "group_membership_identifier")

    @property
    @pulumi.getter(name="objectClass")
    def object_class(self) -> str:
        """
        LDAP objectClass of which imported users are members. For example, user or person
        """
        return pulumi.get(self, "object_class")

    @property
    @pulumi.getter
    def surname(self) -> str:
        """
        LDAP attribute to use for the user's surname. For example, sn
        """
        return pulumi.get(self, "surname")

    @property
    @pulumi.getter
    def telephone(self) -> str:
        """
        LDAP attribute to use for the user's telephone number. For example, telephoneNumber
        """
        return pulumi.get(self, "telephone")

    @property
    @pulumi.getter(name="uniqueIdentifier")
    def unique_identifier(self) -> str:
        """
        LDAP attribute to use as the unique identifier for a user. For example, objectGuid
        """
        return pulumi.get(self, "unique_identifier")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        LDAP attribute to use when looking up a user name to import. For example, userPrincipalName or samAccountName
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetOrgMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetOrgOidcClaimsMappingResult(dict):
    def __init__(__self__, *,
                 email: str,
                 first_name: str,
                 full_name: str,
                 groups: str,
                 last_name: str,
                 roles: str,
                 subject: str):
        """
        :param str email: Email claim mapping
        :param str first_name: First name claim mapping
        :param str full_name: Full name claim mapping
        :param str groups: Groups claim mapping
        :param str last_name: Last name claim mapping
        :param str roles: Roles claim mapping
        :param str subject: Subject claim mapping
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "full_name", full_name)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        Email claim mapping
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name claim mapping
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="fullName")
    def full_name(self) -> str:
        """
        Full name claim mapping
        """
        return pulumi.get(self, "full_name")

    @property
    @pulumi.getter
    def groups(self) -> str:
        """
        Groups claim mapping
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name claim mapping
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def roles(self) -> str:
        """
        Roles claim mapping
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        Subject claim mapping
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class GetOrgOidcKeyResult(dict):
    def __init__(__self__, *,
                 algorithm: str,
                 certificate: str,
                 expiration_date: str,
                 id: str):
        """
        :param str algorithm: Algorithm of the key
        :param str certificate: The certificate contents
        :param str expiration_date: Expiration date for the certificate
        :param str id: ID of the key
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def algorithm(self) -> str:
        """
        Algorithm of the key
        """
        return pulumi.get(self, "algorithm")

    @property
    @pulumi.getter
    def certificate(self) -> str:
        """
        The certificate contents
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> str:
        """
        Expiration date for the certificate
        """
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the key
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetOrgVappLeaseResult(dict):
    def __init__(__self__, *,
                 delete_on_storage_lease_expiration: bool,
                 maximum_runtime_lease_in_sec: int,
                 maximum_storage_lease_in_sec: int,
                 power_off_on_runtime_lease_expiration: bool):
        """
        :param bool delete_on_storage_lease_expiration: If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.
        :param int maximum_runtime_lease_in_sec: How long vApps can run before they are automatically stopped (in seconds)
        :param int maximum_storage_lease_in_sec: How long stopped vApps are available before being automatically cleaned up (in seconds)
        :param bool power_off_on_runtime_lease_expiration: When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires
        """
        pulumi.set(__self__, "delete_on_storage_lease_expiration", delete_on_storage_lease_expiration)
        pulumi.set(__self__, "maximum_runtime_lease_in_sec", maximum_runtime_lease_in_sec)
        pulumi.set(__self__, "maximum_storage_lease_in_sec", maximum_storage_lease_in_sec)
        pulumi.set(__self__, "power_off_on_runtime_lease_expiration", power_off_on_runtime_lease_expiration)

    @property
    @pulumi.getter(name="deleteOnStorageLeaseExpiration")
    def delete_on_storage_lease_expiration(self) -> bool:
        """
        If true, storage for a vApp is deleted when the vApp's lease expires. If false, the storage is flagged for deletion, but not deleted.
        """
        return pulumi.get(self, "delete_on_storage_lease_expiration")

    @property
    @pulumi.getter(name="maximumRuntimeLeaseInSec")
    def maximum_runtime_lease_in_sec(self) -> int:
        """
        How long vApps can run before they are automatically stopped (in seconds)
        """
        return pulumi.get(self, "maximum_runtime_lease_in_sec")

    @property
    @pulumi.getter(name="maximumStorageLeaseInSec")
    def maximum_storage_lease_in_sec(self) -> int:
        """
        How long stopped vApps are available before being automatically cleaned up (in seconds)
        """
        return pulumi.get(self, "maximum_storage_lease_in_sec")

    @property
    @pulumi.getter(name="powerOffOnRuntimeLeaseExpiration")
    def power_off_on_runtime_lease_expiration(self) -> bool:
        """
        When true, vApps are powered off when the runtime lease expires. When false, vApps are suspended when the runtime lease expires
        """
        return pulumi.get(self, "power_off_on_runtime_lease_expiration")


@pulumi.output_type
class GetOrgVappTemplateLeaseResult(dict):
    def __init__(__self__, *,
                 delete_on_storage_lease_expiration: bool,
                 maximum_storage_lease_in_sec: int):
        """
        :param bool delete_on_storage_lease_expiration: If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted
        :param int maximum_storage_lease_in_sec: How long vApp templates are available before being automatically cleaned up (in seconds)
        """
        pulumi.set(__self__, "delete_on_storage_lease_expiration", delete_on_storage_lease_expiration)
        pulumi.set(__self__, "maximum_storage_lease_in_sec", maximum_storage_lease_in_sec)

    @property
    @pulumi.getter(name="deleteOnStorageLeaseExpiration")
    def delete_on_storage_lease_expiration(self) -> bool:
        """
        If true, storage for a vAppTemplate is deleted when the vAppTemplate lease expires. If false, the storage is flagged for deletion, but not deleted
        """
        return pulumi.get(self, "delete_on_storage_lease_expiration")

    @property
    @pulumi.getter(name="maximumStorageLeaseInSec")
    def maximum_storage_lease_in_sec(self) -> int:
        """
        How long vApp templates are available before being automatically cleaned up (in seconds)
        """
        return pulumi.get(self, "maximum_storage_lease_in_sec")


@pulumi.output_type
class GetOrgVdcComputeCapacityResult(dict):
    def __init__(__self__, *,
                 cpus: Sequence['outputs.GetOrgVdcComputeCapacityCpusResult'],
                 memories: Sequence['outputs.GetOrgVdcComputeCapacityMemoryResult']):
        pulumi.set(__self__, "cpus", cpus)
        pulumi.set(__self__, "memories", memories)

    @property
    @pulumi.getter
    def cpus(self) -> Sequence['outputs.GetOrgVdcComputeCapacityCpusResult']:
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter
    def memories(self) -> Sequence['outputs.GetOrgVdcComputeCapacityMemoryResult']:
        return pulumi.get(self, "memories")


@pulumi.output_type
class GetOrgVdcComputeCapacityCpusResult(dict):
    def __init__(__self__, *,
                 allocated: int,
                 limit: int,
                 reserved: int,
                 used: int):
        """
        :param int allocated: Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        :param int limit: Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        pulumi.set(__self__, "allocated", allocated)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "reserved", reserved)
        pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocated(self) -> int:
        """
        Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        """
        return pulumi.get(self, "allocated")

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def reserved(self) -> int:
        return pulumi.get(self, "reserved")

    @property
    @pulumi.getter
    def used(self) -> int:
        return pulumi.get(self, "used")


@pulumi.output_type
class GetOrgVdcComputeCapacityMemoryResult(dict):
    def __init__(__self__, *,
                 allocated: int,
                 limit: int,
                 reserved: int,
                 used: int):
        """
        :param int allocated: Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        :param int limit: Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        pulumi.set(__self__, "allocated", allocated)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "reserved", reserved)
        pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocated(self) -> int:
        """
        Capacity that is committed to be available. Value in MB or MHz. Used with AllocationPool (Allocation pool) and ReservationPool (Reservation pool).
        """
        return pulumi.get(self, "allocated")

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        Capacity limit relative to the value specified for Allocation. It must not be less than that value. If it is greater than that value, it implies over provisioning. A value of 0 specifies unlimited units. Value in MB or MHz. Used with AllocationVApp (Pay as you go).
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def reserved(self) -> int:
        return pulumi.get(self, "reserved")

    @property
    @pulumi.getter
    def used(self) -> int:
        return pulumi.get(self, "used")


@pulumi.output_type
class GetOrgVdcMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetOrgVdcStorageProfileResult(dict):
    def __init__(__self__, *,
                 default: bool,
                 enabled: bool,
                 limit: int,
                 name: str,
                 storage_used_in_mb: int):
        """
        :param bool default: True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.
        :param bool enabled: True if this storage profile is enabled for use in the VDC.
        :param int limit: Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.
        :param str name: Organization VDC name
        :param int storage_used_in_mb: Storage used in MB
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "storage_used_in_mb", storage_used_in_mb)

    @property
    @pulumi.getter
    def default(self) -> bool:
        """
        True if this is default storage profile for this VDC. The default storage profile is used when an object that can specify a storage profile is created with no storage profile specified.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        True if this storage profile is enabled for use in the VDC.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        Maximum number of MB allocated for this storage profile. A value of 0 specifies unlimited MB.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Organization VDC name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="storageUsedInMb")
    def storage_used_in_mb(self) -> int:
        """
        Storage used in MB
        """
        return pulumi.get(self, "storage_used_in_mb")


@pulumi.output_type
class GetOrgVdcTemplateComputeConfigurationResult(dict):
    def __init__(__self__, *,
                 cpu_allocated: int,
                 cpu_guaranteed: int,
                 cpu_limit: int,
                 cpu_speed: int,
                 elasticity: bool,
                 include_vm_memory_overhead: bool,
                 memory_allocated: int,
                 memory_guaranteed: int,
                 memory_limit: int):
        """
        :param int cpu_allocated: The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template
        :param int cpu_guaranteed: The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template
        :param int cpu_limit: The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. 0 means unlimited
        :param int cpu_speed: Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM
        :param bool elasticity: True if compute capacity can grow or shrink based on demand
        :param bool include_vm_memory_overhead: True if the instantiated VDC includes memory overhead into its accounting for admission control
        :param int memory_allocated: The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template
        :param int memory_guaranteed: The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template
        :param int memory_limit: The limit amount of Memory, in MB, of the VDC that is instantiated from this template. 0 means unlimited
        """
        pulumi.set(__self__, "cpu_allocated", cpu_allocated)
        pulumi.set(__self__, "cpu_guaranteed", cpu_guaranteed)
        pulumi.set(__self__, "cpu_limit", cpu_limit)
        pulumi.set(__self__, "cpu_speed", cpu_speed)
        pulumi.set(__self__, "elasticity", elasticity)
        pulumi.set(__self__, "include_vm_memory_overhead", include_vm_memory_overhead)
        pulumi.set(__self__, "memory_allocated", memory_allocated)
        pulumi.set(__self__, "memory_guaranteed", memory_guaranteed)
        pulumi.set(__self__, "memory_limit", memory_limit)

    @property
    @pulumi.getter(name="cpuAllocated")
    def cpu_allocated(self) -> int:
        """
        The maximum amount of CPU, in MHz, available to the VMs running within the VDC that is instantiated from this template
        """
        return pulumi.get(self, "cpu_allocated")

    @property
    @pulumi.getter(name="cpuGuaranteed")
    def cpu_guaranteed(self) -> int:
        """
        The percentage of the CPU guaranteed to be available to VMs running within the VDC instantiated from this template
        """
        return pulumi.get(self, "cpu_guaranteed")

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> int:
        """
        The limit amount of CPU, in MHz, of the VDC that is instantiated from this template. 0 means unlimited
        """
        return pulumi.get(self, "cpu_limit")

    @property
    @pulumi.getter(name="cpuSpeed")
    def cpu_speed(self) -> int:
        """
        Specifies the clock frequency, in MHz, for any virtual CPU that is allocated to a VM
        """
        return pulumi.get(self, "cpu_speed")

    @property
    @pulumi.getter
    def elasticity(self) -> bool:
        """
        True if compute capacity can grow or shrink based on demand
        """
        return pulumi.get(self, "elasticity")

    @property
    @pulumi.getter(name="includeVmMemoryOverhead")
    def include_vm_memory_overhead(self) -> bool:
        """
        True if the instantiated VDC includes memory overhead into its accounting for admission control
        """
        return pulumi.get(self, "include_vm_memory_overhead")

    @property
    @pulumi.getter(name="memoryAllocated")
    def memory_allocated(self) -> int:
        """
        The maximum amount of Memory, in MB, available to the VMs running within the VDC that is instantiated from this template
        """
        return pulumi.get(self, "memory_allocated")

    @property
    @pulumi.getter(name="memoryGuaranteed")
    def memory_guaranteed(self) -> int:
        """
        The percentage of the Memory guaranteed to be available to VMs running within the VDC instantiated from this template
        """
        return pulumi.get(self, "memory_guaranteed")

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> int:
        """
        The limit amount of Memory, in MB, of the VDC that is instantiated from this template. 0 means unlimited
        """
        return pulumi.get(self, "memory_limit")


@pulumi.output_type
class GetOrgVdcTemplateEdgeGatewayResult(dict):
    def __init__(__self__, *,
                 description: str,
                 ip_allocation_count: int,
                 name: str,
                 routed_network_description: str,
                 routed_network_gateway_cidr: str,
                 routed_network_name: str,
                 static_ip_pools: Sequence['outputs.GetOrgVdcTemplateEdgeGatewayStaticIpPoolResult']):
        """
        :param str description: Description of the Edge Gateway
        :param int ip_allocation_count: Storage used in MB
        :param str name: Name of the existing Organization VDC Template to read
        :param str routed_network_description: Description of the routed network to create with the Edge Gateway
        :param str routed_network_gateway_cidr: CIDR of the Edge Gateway for the routed network created with the Edge Gateway
        :param str routed_network_name: Name of the routed network to create with the Edge Gateway
        :param Sequence['GetOrgVdcTemplateEdgeGatewayStaticIpPoolArgs'] static_ip_pools: IP ranges used for the network created with the Edge Gateway. Only required if the 'edge_gateway' block is used
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "ip_allocation_count", ip_allocation_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routed_network_description", routed_network_description)
        pulumi.set(__self__, "routed_network_gateway_cidr", routed_network_gateway_cidr)
        pulumi.set(__self__, "routed_network_name", routed_network_name)
        pulumi.set(__self__, "static_ip_pools", static_ip_pools)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the Edge Gateway
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="ipAllocationCount")
    def ip_allocation_count(self) -> int:
        """
        Storage used in MB
        """
        return pulumi.get(self, "ip_allocation_count")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the existing Organization VDC Template to read
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="routedNetworkDescription")
    def routed_network_description(self) -> str:
        """
        Description of the routed network to create with the Edge Gateway
        """
        return pulumi.get(self, "routed_network_description")

    @property
    @pulumi.getter(name="routedNetworkGatewayCidr")
    def routed_network_gateway_cidr(self) -> str:
        """
        CIDR of the Edge Gateway for the routed network created with the Edge Gateway
        """
        return pulumi.get(self, "routed_network_gateway_cidr")

    @property
    @pulumi.getter(name="routedNetworkName")
    def routed_network_name(self) -> str:
        """
        Name of the routed network to create with the Edge Gateway
        """
        return pulumi.get(self, "routed_network_name")

    @property
    @pulumi.getter(name="staticIpPools")
    def static_ip_pools(self) -> Sequence['outputs.GetOrgVdcTemplateEdgeGatewayStaticIpPoolResult']:
        """
        IP ranges used for the network created with the Edge Gateway. Only required if the 'edge_gateway' block is used
        """
        return pulumi.get(self, "static_ip_pools")


@pulumi.output_type
class GetOrgVdcTemplateEdgeGatewayStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        """
        :param str end_address: End address of the IP range
        :param str start_address: Start address of the IP range
        """
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        """
        End address of the IP range
        """
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        """
        Start address of the IP range
        """
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetOrgVdcTemplateProviderVdcResult(dict):
    def __init__(__self__, *,
                 external_network_id: str,
                 gateway_edge_cluster_id: str,
                 id: str,
                 services_edge_cluster_id: str):
        """
        :param str external_network_id: ID of the External network that the VDCs instantiated from this template use
        :param str gateway_edge_cluster_id: ID of the Edge Cluster that the VDCs instantiated from this template use with the NSX-T Gateway
        :param str id: ID of Provider VDC
        :param str services_edge_cluster_id: ID of the Edge Cluster that the VDCs instantiated from this template use for services
        """
        pulumi.set(__self__, "external_network_id", external_network_id)
        pulumi.set(__self__, "gateway_edge_cluster_id", gateway_edge_cluster_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "services_edge_cluster_id", services_edge_cluster_id)

    @property
    @pulumi.getter(name="externalNetworkId")
    def external_network_id(self) -> str:
        """
        ID of the External network that the VDCs instantiated from this template use
        """
        return pulumi.get(self, "external_network_id")

    @property
    @pulumi.getter(name="gatewayEdgeClusterId")
    def gateway_edge_cluster_id(self) -> str:
        """
        ID of the Edge Cluster that the VDCs instantiated from this template use with the NSX-T Gateway
        """
        return pulumi.get(self, "gateway_edge_cluster_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Provider VDC
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="servicesEdgeClusterId")
    def services_edge_cluster_id(self) -> str:
        """
        ID of the Edge Cluster that the VDCs instantiated from this template use for services
        """
        return pulumi.get(self, "services_edge_cluster_id")


@pulumi.output_type
class GetOrgVdcTemplateStorageProfileResult(dict):
    def __init__(__self__, *,
                 default: bool,
                 limit: int,
                 name: str):
        """
        :param bool default: True if this is default storage profile for the VDCs instantiated from this template
        :param int limit: Storage limit of the VDCs instantiated from this template, in Megabytes. 0 means unlimited
        :param str name: Name of the existing Organization VDC Template to read
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def default(self) -> bool:
        """
        True if this is default storage profile for the VDCs instantiated from this template
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        Storage limit of the VDCs instantiated from this template, in Megabytes. 0 means unlimited
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the existing Organization VDC Template to read
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProviderVdcComputeCapacityResult(dict):
    def __init__(__self__, *,
                 cpus: Sequence['outputs.GetProviderVdcComputeCapacityCpusResult'],
                 is_elastic: bool,
                 is_ha: bool,
                 memories: Sequence['outputs.GetProviderVdcComputeCapacityMemoryResult']):
        """
        :param Sequence['GetProviderVdcComputeCapacityCpusArgs'] cpus: Single-element list with an indicator of CPU capacity available in the Provider VDC
        :param bool is_elastic: True if compute capacity can grow or shrink based on demand
        :param bool is_ha: True if compute capacity is highly available
        :param Sequence['GetProviderVdcComputeCapacityMemoryArgs'] memories: Single-element list with an indicator of Memory capacity available in the Provider VDC
        """
        pulumi.set(__self__, "cpus", cpus)
        pulumi.set(__self__, "is_elastic", is_elastic)
        pulumi.set(__self__, "is_ha", is_ha)
        pulumi.set(__self__, "memories", memories)

    @property
    @pulumi.getter
    def cpus(self) -> Sequence['outputs.GetProviderVdcComputeCapacityCpusResult']:
        """
        Single-element list with an indicator of CPU capacity available in the Provider VDC
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter(name="isElastic")
    def is_elastic(self) -> bool:
        """
        True if compute capacity can grow or shrink based on demand
        """
        return pulumi.get(self, "is_elastic")

    @property
    @pulumi.getter(name="isHa")
    def is_ha(self) -> bool:
        """
        True if compute capacity is highly available
        """
        return pulumi.get(self, "is_ha")

    @property
    @pulumi.getter
    def memories(self) -> Sequence['outputs.GetProviderVdcComputeCapacityMemoryResult']:
        """
        Single-element list with an indicator of Memory capacity available in the Provider VDC
        """
        return pulumi.get(self, "memories")


@pulumi.output_type
class GetProviderVdcComputeCapacityCpusResult(dict):
    def __init__(__self__, *,
                 allocation: int,
                 overhead: int,
                 reserved: int,
                 total: int,
                 units: str,
                 used: int):
        """
        :param int allocation: Allocated CPU for this Provider VDC
        :param int overhead: CPU overhead for this Provider VDC
        :param int reserved: Reserved CPU for this Provider VDC
        :param int total: Total CPU for this Provider VDC
        :param str units: Units for the CPU of this Provider VDC
        :param int used: Used CPU in this Provider VDC
        """
        pulumi.set(__self__, "allocation", allocation)
        pulumi.set(__self__, "overhead", overhead)
        pulumi.set(__self__, "reserved", reserved)
        pulumi.set(__self__, "total", total)
        pulumi.set(__self__, "units", units)
        pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocation(self) -> int:
        """
        Allocated CPU for this Provider VDC
        """
        return pulumi.get(self, "allocation")

    @property
    @pulumi.getter
    def overhead(self) -> int:
        """
        CPU overhead for this Provider VDC
        """
        return pulumi.get(self, "overhead")

    @property
    @pulumi.getter
    def reserved(self) -> int:
        """
        Reserved CPU for this Provider VDC
        """
        return pulumi.get(self, "reserved")

    @property
    @pulumi.getter
    def total(self) -> int:
        """
        Total CPU for this Provider VDC
        """
        return pulumi.get(self, "total")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        Units for the CPU of this Provider VDC
        """
        return pulumi.get(self, "units")

    @property
    @pulumi.getter
    def used(self) -> int:
        """
        Used CPU in this Provider VDC
        """
        return pulumi.get(self, "used")


@pulumi.output_type
class GetProviderVdcComputeCapacityMemoryResult(dict):
    def __init__(__self__, *,
                 allocation: int,
                 overhead: int,
                 reserved: int,
                 total: int,
                 units: str,
                 used: int):
        """
        :param int allocation: Allocated Memory for this Provider VDC
        :param int overhead: Memory overhead for this Provider VDC
        :param int reserved: Reserved Memory for this Provider VDC
        :param int total: Total Memory for this Provider VDC
        :param str units: Units for the Memory of this Provider VDC
        :param int used: Used Memory in this Provider VDC
        """
        pulumi.set(__self__, "allocation", allocation)
        pulumi.set(__self__, "overhead", overhead)
        pulumi.set(__self__, "reserved", reserved)
        pulumi.set(__self__, "total", total)
        pulumi.set(__self__, "units", units)
        pulumi.set(__self__, "used", used)

    @property
    @pulumi.getter
    def allocation(self) -> int:
        """
        Allocated Memory for this Provider VDC
        """
        return pulumi.get(self, "allocation")

    @property
    @pulumi.getter
    def overhead(self) -> int:
        """
        Memory overhead for this Provider VDC
        """
        return pulumi.get(self, "overhead")

    @property
    @pulumi.getter
    def reserved(self) -> int:
        """
        Reserved Memory for this Provider VDC
        """
        return pulumi.get(self, "reserved")

    @property
    @pulumi.getter
    def total(self) -> int:
        """
        Total Memory for this Provider VDC
        """
        return pulumi.get(self, "total")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        Units for the Memory of this Provider VDC
        """
        return pulumi.get(self, "units")

    @property
    @pulumi.getter
    def used(self) -> int:
        """
        Used Memory in this Provider VDC
        """
        return pulumi.get(self, "used")


@pulumi.output_type
class GetProviderVdcMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRdeMetadataEntryResult(dict):
    def __init__(__self__, *,
                 domain: str,
                 id: str,
                 key: str,
                 namespace: str,
                 persistent: bool,
                 readonly: bool,
                 type: str,
                 value: str):
        """
        :param str domain: Only meaningful for providers. Allows them to share entries with their tenants. One of: `TENANT`, `PROVIDER`
        :param str id: ID of the metadata entry
        :param str key: Key of this metadata entry
        :param str namespace: Namespace of the metadata entry
        :param bool persistent: Persistent metadata entries can be copied over on some entity operation
        :param bool readonly: True if the metadata entry is read only
        :param str type: Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "persistent", persistent)
        pulumi.set(__self__, "readonly", readonly)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Only meaningful for providers. Allows them to share entries with their tenants. One of: `TENANT`, `PROVIDER`
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the metadata entry
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace of the metadata entry
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def persistent(self) -> bool:
        """
        Persistent metadata entries can be copied over on some entity operation
        """
        return pulumi.get(self, "persistent")

    @property
    @pulumi.getter
    def readonly(self) -> bool:
        """
        True if the metadata entry is read only
        """
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'StringEntry', 'NumberEntry', 'BoolEntry'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetRdeTypeHookResult(dict):
    def __init__(__self__, *,
                 behavior_id: str,
                 event: str):
        """
        :param str behavior_id: Existing Behavior that will be automatically invoked when the RDE of this RDE Type triggers the event
        :param str event: Event that will invoke the Behavior, one of PostCreate, PostUpdate, PreDelete, PostDelete
        """
        pulumi.set(__self__, "behavior_id", behavior_id)
        pulumi.set(__self__, "event", event)

    @property
    @pulumi.getter(name="behaviorId")
    def behavior_id(self) -> str:
        """
        Existing Behavior that will be automatically invoked when the RDE of this RDE Type triggers the event
        """
        return pulumi.get(self, "behavior_id")

    @property
    @pulumi.getter
    def event(self) -> str:
        """
        Event that will invoke the Behavior, one of PostCreate, PostUpdate, PreDelete, PostDelete
        """
        return pulumi.get(self, "event")


@pulumi.output_type
class GetResourceSchemaAttributeResult(dict):
    def __init__(__self__, *,
                 computed: bool,
                 description: str,
                 name: str,
                 optional: bool,
                 required: bool,
                 sensitive: bool,
                 type: str):
        """
        :param bool computed: whether the attribute is computed
        :param str description: an optional description of the attribute
        :param str name: An unique name to identify the data source
        :param bool optional: whether the attribute is optional
        :param bool required: whether the attribute is required
        :param bool sensitive: whether the attribute is sensitive
        :param str type: attribute type
        """
        pulumi.set(__self__, "computed", computed)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "optional", optional)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "sensitive", sensitive)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def computed(self) -> bool:
        """
        whether the attribute is computed
        """
        return pulumi.get(self, "computed")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        an optional description of the attribute
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        An unique name to identify the data source
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> bool:
        """
        whether the attribute is optional
        """
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        whether the attribute is required
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def sensitive(self) -> bool:
        """
        whether the attribute is sensitive
        """
        return pulumi.get(self, "sensitive")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        attribute type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetResourceSchemaBlockAttributeResult(dict):
    def __init__(__self__, *,
                 attributes: Sequence['outputs.GetResourceSchemaBlockAttributeAttributeResult'],
                 name: str,
                 nesting_mode: str):
        """
        :param Sequence['GetResourceSchemaBlockAttributeAttributeArgs'] attributes: (Computed) Same composition of the simple `attributes` above.
        :param str name: An unique name to identify the data source
        :param str nesting_mode: How the block is nested
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "nesting_mode", nesting_mode)

    @property
    @pulumi.getter
    def attributes(self) -> Sequence['outputs.GetResourceSchemaBlockAttributeAttributeResult']:
        """
        (Computed) Same composition of the simple `attributes` above.
        """
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        An unique name to identify the data source
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="nestingMode")
    def nesting_mode(self) -> str:
        """
        How the block is nested
        """
        return pulumi.get(self, "nesting_mode")


@pulumi.output_type
class GetResourceSchemaBlockAttributeAttributeResult(dict):
    def __init__(__self__, *,
                 computed: bool,
                 description: str,
                 name: str,
                 optional: bool,
                 required: bool,
                 sensitive: bool,
                 type: str):
        """
        :param bool computed: whether the attribute is computed
        :param str description: an optional description of the attribute
        :param str name: An unique name to identify the data source
        :param bool optional: whether the attribute is optional
        :param bool required: whether the attribute is required
        :param bool sensitive: whether the attribute is sensitive
        :param str type: attribute type
        """
        pulumi.set(__self__, "computed", computed)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "optional", optional)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "sensitive", sensitive)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def computed(self) -> bool:
        """
        whether the attribute is computed
        """
        return pulumi.get(self, "computed")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        an optional description of the attribute
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        An unique name to identify the data source
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def optional(self) -> bool:
        """
        whether the attribute is optional
        """
        return pulumi.get(self, "optional")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        whether the attribute is required
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def sensitive(self) -> bool:
        """
        whether the attribute is sensitive
        """
        return pulumi.get(self, "sensitive")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        attribute type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRightImpliedRightResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: ID of the implied right
        :param str name: The name of the right.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the implied right
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the right.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSolutionLandingZoneCatalogResult(dict):
    def __init__(__self__, *,
                 capabilities: Sequence[str],
                 id: str,
                 name: str):
        """
        :param Sequence[str] capabilities: Capability set for catalog
        :param str id: ID of catalog
        :param str name: Catalog Name
        """
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def capabilities(self) -> Sequence[str]:
        """
        Capability set for catalog
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of catalog
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Catalog Name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSolutionLandingZoneVdcResult(dict):
    def __init__(__self__, *,
                 capabilities: Sequence[str],
                 compute_policies: Sequence['outputs.GetSolutionLandingZoneVdcComputePolicyResult'],
                 id: str,
                 is_default: bool,
                 name: str,
                 org_vdc_networks: Sequence['outputs.GetSolutionLandingZoneVdcOrgVdcNetworkResult'],
                 storage_policies: Sequence['outputs.GetSolutionLandingZoneVdcStoragePolicyResult']):
        """
        :param Sequence[str] capabilities: Set of capabilities of the VDC
        :param Sequence['GetSolutionLandingZoneVdcComputePolicyArgs'] compute_policies: Details of Compute Policy element
        :param str id: VDC ID
        :param bool is_default: Defines if this VDC should be treated as the default one
        :param str name: VDC Name
        :param Sequence['GetSolutionLandingZoneVdcOrgVdcNetworkArgs'] org_vdc_networks: Details of Org VDC Network element
        :param Sequence['GetSolutionLandingZoneVdcStoragePolicyArgs'] storage_policies: Details of Storage Policy element
        """
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "compute_policies", compute_policies)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_vdc_networks", org_vdc_networks)
        pulumi.set(__self__, "storage_policies", storage_policies)

    @property
    @pulumi.getter
    def capabilities(self) -> Sequence[str]:
        """
        Set of capabilities of the VDC
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter(name="computePolicies")
    def compute_policies(self) -> Sequence['outputs.GetSolutionLandingZoneVdcComputePolicyResult']:
        """
        Details of Compute Policy element
        """
        return pulumi.get(self, "compute_policies")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        VDC ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Defines if this VDC should be treated as the default one
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        VDC Name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="orgVdcNetworks")
    def org_vdc_networks(self) -> Sequence['outputs.GetSolutionLandingZoneVdcOrgVdcNetworkResult']:
        """
        Details of Org VDC Network element
        """
        return pulumi.get(self, "org_vdc_networks")

    @property
    @pulumi.getter(name="storagePolicies")
    def storage_policies(self) -> Sequence['outputs.GetSolutionLandingZoneVdcStoragePolicyResult']:
        """
        Details of Storage Policy element
        """
        return pulumi.get(self, "storage_policies")


@pulumi.output_type
class GetSolutionLandingZoneVdcComputePolicyResult(dict):
    def __init__(__self__, *,
                 capabilities: Sequence[str],
                 id: str,
                 is_default: bool,
                 name: str):
        """
        :param Sequence[str] capabilities: Set of capabilities for Compute Policy
        :param str id: ID of Compute Policy
        :param bool is_default: Boolean value that marks if this Compute Policy should be default
        :param str name: Name of Compute Policy
        """
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def capabilities(self) -> Sequence[str]:
        """
        Set of capabilities for Compute Policy
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Compute Policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Boolean value that marks if this Compute Policy should be default
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of Compute Policy
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSolutionLandingZoneVdcOrgVdcNetworkResult(dict):
    def __init__(__self__, *,
                 capabilities: Sequence[str],
                 id: str,
                 is_default: bool,
                 name: str):
        """
        :param Sequence[str] capabilities: Set of capabilities for Org VDC Network
        :param str id: ID of Org VDC Network
        :param bool is_default: Boolean value that marks if this Org VDC Network should be default
        :param str name: Name of Org VDC Network
        """
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def capabilities(self) -> Sequence[str]:
        """
        Set of capabilities for Org VDC Network
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Org VDC Network
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Boolean value that marks if this Org VDC Network should be default
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of Org VDC Network
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSolutionLandingZoneVdcStoragePolicyResult(dict):
    def __init__(__self__, *,
                 capabilities: Sequence[str],
                 id: str,
                 is_default: bool,
                 name: str):
        """
        :param Sequence[str] capabilities: Set of capabilities for Storage Policy
        :param str id: ID of Storage Policy
        :param bool is_default: Boolean value that marks if this Storage Policy should be default
        :param str name: Name of Storage Policy
        """
        pulumi.set(__self__, "capabilities", capabilities)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def capabilities(self) -> Sequence[str]:
        """
        Set of capabilities for Storage Policy
        """
        return pulumi.get(self, "capabilities")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of Storage Policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Boolean value that marks if this Storage Policy should be default
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of Storage Policy
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetStorageProfileIopsSettingResult(dict):
    def __init__(__self__, *,
                 default_disk_iops: int,
                 disk_iops_per_gb_max: int,
                 iops_limit: int,
                 iops_limiting_enabled: bool,
                 maximum_disk_iops: int):
        """
        :param int default_disk_iops: Value of 0 for disk IOPS means that no IOPS would be reserved or provisioned for that virtual disk
        :param int disk_iops_per_gb_max: The maximum disk IOPs per GB value that this storage profile is permitted to deliver. A value of 0 means there is no per GB IOPS restriction
        :param int iops_limit: Maximum number of IOPs that can be allocated for this profile. `0` means `maximum possible`
        :param bool iops_limiting_enabled: True if this storage profile is IOPS-based placement enabled
        :param int maximum_disk_iops: The maximum IOPS value that this storage profile is permitted to deliver. Value of 0 means this max setting is disabled and there is no max disk IOPS restriction
        """
        pulumi.set(__self__, "default_disk_iops", default_disk_iops)
        pulumi.set(__self__, "disk_iops_per_gb_max", disk_iops_per_gb_max)
        pulumi.set(__self__, "iops_limit", iops_limit)
        pulumi.set(__self__, "iops_limiting_enabled", iops_limiting_enabled)
        pulumi.set(__self__, "maximum_disk_iops", maximum_disk_iops)

    @property
    @pulumi.getter(name="defaultDiskIops")
    def default_disk_iops(self) -> int:
        """
        Value of 0 for disk IOPS means that no IOPS would be reserved or provisioned for that virtual disk
        """
        return pulumi.get(self, "default_disk_iops")

    @property
    @pulumi.getter(name="diskIopsPerGbMax")
    def disk_iops_per_gb_max(self) -> int:
        """
        The maximum disk IOPs per GB value that this storage profile is permitted to deliver. A value of 0 means there is no per GB IOPS restriction
        """
        return pulumi.get(self, "disk_iops_per_gb_max")

    @property
    @pulumi.getter(name="iopsLimit")
    def iops_limit(self) -> int:
        """
        Maximum number of IOPs that can be allocated for this profile. `0` means `maximum possible`
        """
        return pulumi.get(self, "iops_limit")

    @property
    @pulumi.getter(name="iopsLimitingEnabled")
    def iops_limiting_enabled(self) -> bool:
        """
        True if this storage profile is IOPS-based placement enabled
        """
        return pulumi.get(self, "iops_limiting_enabled")

    @property
    @pulumi.getter(name="maximumDiskIops")
    def maximum_disk_iops(self) -> int:
        """
        The maximum IOPS value that this storage profile is permitted to deliver. Value of 0 means this max setting is disabled and there is no max disk IOPS restriction
        """
        return pulumi.get(self, "maximum_disk_iops")


@pulumi.output_type
class GetStorageProfileMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSubscribedCatalogFilterResult(dict):
    def __init__(__self__, *,
                 date: Optional[str] = None,
                 earliest: Optional[bool] = None,
                 latest: Optional[bool] = None,
                 metadatas: Optional[Sequence['outputs.GetSubscribedCatalogFilterMetadataResult']] = None,
                 name_regex: Optional[str] = None):
        """
        :param str date: Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        :param bool earliest: Retrieves the oldest item
        :param bool latest: Retrieves the newest item
        :param Sequence['GetSubscribedCatalogFilterMetadataArgs'] metadatas: Optional metadata of the catalog. This is inherited from the publishing catalog
        :param str name_regex: Search by name with a regular expression
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if earliest is not None:
            pulumi.set(__self__, "earliest", earliest)
        if latest is not None:
            pulumi.set(__self__, "latest", latest)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name_regex is not None:
            pulumi.set(__self__, "name_regex", name_regex)

    @property
    @pulumi.getter
    def date(self) -> Optional[str]:
        """
        Search by date comparison ({>|>=|<|<=|==} yyyy-mm-dd[ hh[:mm[:ss]]])
        """
        return pulumi.get(self, "date")

    @property
    @pulumi.getter
    def earliest(self) -> Optional[bool]:
        """
        Retrieves the oldest item
        """
        return pulumi.get(self, "earliest")

    @property
    @pulumi.getter
    def latest(self) -> Optional[bool]:
        """
        Retrieves the newest item
        """
        return pulumi.get(self, "latest")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GetSubscribedCatalogFilterMetadataResult']]:
        """
        Optional metadata of the catalog. This is inherited from the publishing catalog
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="nameRegex")
    def name_regex(self) -> Optional[str]:
        """
        Search by name with a regular expression
        """
        return pulumi.get(self, "name_regex")


@pulumi.output_type
class GetSubscribedCatalogFilterMetadataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 is_system: Optional[bool] = None,
                 type: Optional[str] = None,
                 use_api_search: Optional[bool] = None):
        """
        :param str key: Metadata key (field name)
        :param str value: Metadata value (can be a regular expression if "use_api_search" is false)
        :param bool is_system: True if is a metadata@SYSTEM key
        :param str type: Type of metadata value (needed only if "use_api_search" is true)
        :param bool use_api_search: If true, will search the vCD using native metadata query (without regular expressions)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if is_system is not None:
            pulumi.set(__self__, "is_system", is_system)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if use_api_search is not None:
            pulumi.set(__self__, "use_api_search", use_api_search)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Metadata key (field name)
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Metadata value (can be a regular expression if "use_api_search" is false)
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> Optional[bool]:
        """
        True if is a metadata@SYSTEM key
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of metadata value (needed only if "use_api_search" is true)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="useApiSearch")
    def use_api_search(self) -> Optional[bool]:
        """
        If true, will search the vCD using native metadata query (without regular expressions)
        """
        return pulumi.get(self, "use_api_search")


@pulumi.output_type
class GetVappLeaseResult(dict):
    def __init__(__self__, *,
                 runtime_lease_in_sec: int,
                 storage_lease_in_sec: int):
        """
        :param int runtime_lease_in_sec: How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires.
        :param int storage_lease_in_sec: How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires.
        """
        pulumi.set(__self__, "runtime_lease_in_sec", runtime_lease_in_sec)
        pulumi.set(__self__, "storage_lease_in_sec", storage_lease_in_sec)

    @property
    @pulumi.getter(name="runtimeLeaseInSec")
    def runtime_lease_in_sec(self) -> int:
        """
        How long any of the VMs in the vApp can run before the vApp is automatically powered off or suspended. 0 means never expires.
        """
        return pulumi.get(self, "runtime_lease_in_sec")

    @property
    @pulumi.getter(name="storageLeaseInSec")
    def storage_lease_in_sec(self) -> int:
        """
        How long the vApp is available before being automatically deleted or marked as expired. 0 means never expires.
        """
        return pulumi.get(self, "storage_lease_in_sec")


@pulumi.output_type
class GetVappMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVappNetworkDhcpPoolResult(dict):
    def __init__(__self__, *,
                 default_lease_time: int,
                 enabled: bool,
                 end_address: str,
                 max_lease_time: int,
                 start_address: str):
        pulumi.set(__self__, "default_lease_time", default_lease_time)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "max_lease_time", max_lease_time)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="defaultLeaseTime")
    def default_lease_time(self) -> int:
        return pulumi.get(self, "default_lease_time")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="maxLeaseTime")
    def max_lease_time(self) -> int:
        return pulumi.get(self, "max_lease_time")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetVappNetworkStaticIpPoolResult(dict):
    def __init__(__self__, *,
                 end_address: str,
                 start_address: str):
        pulumi.set(__self__, "end_address", end_address)
        pulumi.set(__self__, "start_address", start_address)

    @property
    @pulumi.getter(name="endAddress")
    def end_address(self) -> str:
        return pulumi.get(self, "end_address")

    @property
    @pulumi.getter(name="startAddress")
    def start_address(self) -> str:
        return pulumi.get(self, "start_address")


@pulumi.output_type
class GetVappVmBootOptionResult(dict):
    def __init__(__self__, *,
                 boot_delay: int,
                 boot_retry_delay: int,
                 boot_retry_enabled: bool,
                 efi_secure_boot: bool,
                 enter_bios_setup_on_next_boot: bool):
        """
        :param int boot_delay: Number of milliseconds to wait between powering-on and booting the VM
        :param int boot_retry_delay: Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        :param bool boot_retry_enabled: If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        :param bool efi_secure_boot: If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        :param bool enter_bios_setup_on_next_boot: If set to true, the VM will enter BIOS setup on boot.
        """
        pulumi.set(__self__, "boot_delay", boot_delay)
        pulumi.set(__self__, "boot_retry_delay", boot_retry_delay)
        pulumi.set(__self__, "boot_retry_enabled", boot_retry_enabled)
        pulumi.set(__self__, "efi_secure_boot", efi_secure_boot)
        pulumi.set(__self__, "enter_bios_setup_on_next_boot", enter_bios_setup_on_next_boot)

    @property
    @pulumi.getter(name="bootDelay")
    def boot_delay(self) -> int:
        """
        Number of milliseconds to wait between powering-on and booting the VM
        """
        return pulumi.get(self, "boot_delay")

    @property
    @pulumi.getter(name="bootRetryDelay")
    def boot_retry_delay(self) -> int:
        """
        Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        """
        return pulumi.get(self, "boot_retry_delay")

    @property
    @pulumi.getter(name="bootRetryEnabled")
    def boot_retry_enabled(self) -> bool:
        """
        If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        """
        return pulumi.get(self, "boot_retry_enabled")

    @property
    @pulumi.getter(name="efiSecureBoot")
    def efi_secure_boot(self) -> bool:
        """
        If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        return pulumi.get(self, "efi_secure_boot")

    @property
    @pulumi.getter(name="enterBiosSetupOnNextBoot")
    def enter_bios_setup_on_next_boot(self) -> bool:
        """
        If set to true, the VM will enter BIOS setup on boot.
        """
        return pulumi.get(self, "enter_bios_setup_on_next_boot")


@pulumi.output_type
class GetVappVmCustomizationResult(dict):
    def __init__(__self__, *,
                 admin_password: str,
                 allow_local_admin_password: bool,
                 auto_generate_password: bool,
                 change_sid: bool,
                 enabled: bool,
                 force: bool,
                 initscript: str,
                 join_domain: bool,
                 join_domain_account_ou: str,
                 join_domain_name: str,
                 join_domain_password: str,
                 join_domain_user: str,
                 join_org_domain: bool,
                 must_change_password_on_first_login: bool,
                 number_of_auto_logons: int):
        """
        :param str admin_password: Manually specify admin password
        :param bool allow_local_admin_password: Allow local administrator password
        :param bool auto_generate_password: Auto generate password
        :param bool change_sid: 'true' value will change SID. Applicable only for Windows VMs
        :param bool enabled: 'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        :param bool force: 'true' value will cause the VM to reboot on every 'apply' operation
        :param str initscript: Script to run on initial boot or with customization.force=true set
        :param bool join_domain: Enable this VM to join a domain
        :param str join_domain_account_ou: Account organizational unit for domain name join
        :param str join_domain_name: Custom domain name for join
        :param str join_domain_password: Password for custom domain name join
        :param str join_domain_user: Username for custom domain name join
        :param bool join_org_domain: Use organization's domain for joining
        :param bool must_change_password_on_first_login: Require Administrator to change password on first login
        :param int number_of_auto_logons: Number of times to log on automatically
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "allow_local_admin_password", allow_local_admin_password)
        pulumi.set(__self__, "auto_generate_password", auto_generate_password)
        pulumi.set(__self__, "change_sid", change_sid)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "force", force)
        pulumi.set(__self__, "initscript", initscript)
        pulumi.set(__self__, "join_domain", join_domain)
        pulumi.set(__self__, "join_domain_account_ou", join_domain_account_ou)
        pulumi.set(__self__, "join_domain_name", join_domain_name)
        pulumi.set(__self__, "join_domain_password", join_domain_password)
        pulumi.set(__self__, "join_domain_user", join_domain_user)
        pulumi.set(__self__, "join_org_domain", join_org_domain)
        pulumi.set(__self__, "must_change_password_on_first_login", must_change_password_on_first_login)
        pulumi.set(__self__, "number_of_auto_logons", number_of_auto_logons)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        """
        Manually specify admin password
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="allowLocalAdminPassword")
    def allow_local_admin_password(self) -> bool:
        """
        Allow local administrator password
        """
        return pulumi.get(self, "allow_local_admin_password")

    @property
    @pulumi.getter(name="autoGeneratePassword")
    def auto_generate_password(self) -> bool:
        """
        Auto generate password
        """
        return pulumi.get(self, "auto_generate_password")

    @property
    @pulumi.getter(name="changeSid")
    def change_sid(self) -> bool:
        """
        'true' value will change SID. Applicable only for Windows VMs
        """
        return pulumi.get(self, "change_sid")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def force(self) -> bool:
        """
        'true' value will cause the VM to reboot on every 'apply' operation
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter
    def initscript(self) -> str:
        """
        Script to run on initial boot or with customization.force=true set
        """
        return pulumi.get(self, "initscript")

    @property
    @pulumi.getter(name="joinDomain")
    def join_domain(self) -> bool:
        """
        Enable this VM to join a domain
        """
        return pulumi.get(self, "join_domain")

    @property
    @pulumi.getter(name="joinDomainAccountOu")
    def join_domain_account_ou(self) -> str:
        """
        Account organizational unit for domain name join
        """
        return pulumi.get(self, "join_domain_account_ou")

    @property
    @pulumi.getter(name="joinDomainName")
    def join_domain_name(self) -> str:
        """
        Custom domain name for join
        """
        return pulumi.get(self, "join_domain_name")

    @property
    @pulumi.getter(name="joinDomainPassword")
    def join_domain_password(self) -> str:
        """
        Password for custom domain name join
        """
        return pulumi.get(self, "join_domain_password")

    @property
    @pulumi.getter(name="joinDomainUser")
    def join_domain_user(self) -> str:
        """
        Username for custom domain name join
        """
        return pulumi.get(self, "join_domain_user")

    @property
    @pulumi.getter(name="joinOrgDomain")
    def join_org_domain(self) -> bool:
        """
        Use organization's domain for joining
        """
        return pulumi.get(self, "join_org_domain")

    @property
    @pulumi.getter(name="mustChangePasswordOnFirstLogin")
    def must_change_password_on_first_login(self) -> bool:
        """
        Require Administrator to change password on first login
        """
        return pulumi.get(self, "must_change_password_on_first_login")

    @property
    @pulumi.getter(name="numberOfAutoLogons")
    def number_of_auto_logons(self) -> int:
        """
        Number of times to log on automatically
        """
        return pulumi.get(self, "number_of_auto_logons")


@pulumi.output_type
class GetVappVmDiskResult(dict):
    def __init__(__self__, *,
                 bus_number: str,
                 name: str,
                 size_in_mb: int,
                 unit_number: str):
        """
        :param str bus_number: Bus number on which to place the disk controller
        :param str name: A name for the VM, unique within the vApp
        :param int size_in_mb: The size of the disk in MB.
        :param str unit_number: Unit number (slot) on the bus specified by BusNumber
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size_in_mb", size_in_mb)
        pulumi.set(__self__, "unit_number", unit_number)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> str:
        """
        Bus number on which to place the disk controller
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name for the VM, unique within the vApp
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> int:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> str:
        """
        Unit number (slot) on the bus specified by BusNumber
        """
        return pulumi.get(self, "unit_number")


@pulumi.output_type
class GetVappVmExtraConfigResult(dict):
    def __init__(__self__, *,
                 key: str,
                 required: bool,
                 value: str):
        """
        :param str key: The key of the extra configuration item
        :param bool required: Whether the extra configuration item is required
        :param str value: The value of the extra configuration item
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        Whether the extra configuration item is required
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the extra configuration item
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVappVmInternalDiskResult(dict):
    def __init__(__self__, *,
                 bus_number: int,
                 bus_type: str,
                 disk_id: str,
                 iops: int,
                 size_in_mb: int,
                 storage_profile: str,
                 thin_provisioned: bool,
                 unit_number: int):
        """
        :param int bus_number: The number of the SCSI or IDE controller itself.
        :param str bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param str disk_id: The disk ID.
        :param int iops: Specifies the IOPS for the disk. Default is 0.
        :param int size_in_mb: The size of the disk in MB.
        :param str storage_profile: Storage profile to override the VM default one
        :param bool thin_provisioned: Specifies whether the disk storage is pre-allocated or allocated on demand.
        :param int unit_number: The device number on the SCSI or IDE controller of the disk.
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "bus_type", bus_type)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "size_in_mb", size_in_mb)
        pulumi.set(__self__, "storage_profile", storage_profile)
        pulumi.set(__self__, "thin_provisioned", thin_provisioned)
        pulumi.set(__self__, "unit_number", unit_number)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> int:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> str:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        The disk ID.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter
    def iops(self) -> int:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> int:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> str:
        """
        Storage profile to override the VM default one
        """
        return pulumi.get(self, "storage_profile")

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> bool:
        """
        Specifies whether the disk storage is pre-allocated or allocated on demand.
        """
        return pulumi.get(self, "thin_provisioned")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> int:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")


@pulumi.output_type
class GetVappVmMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVappVmNetworkResult(dict):
    def __init__(__self__, *,
                 adapter_type: str,
                 connected: bool,
                 ip: str,
                 ip_allocation_mode: str,
                 is_primary: bool,
                 mac: str,
                 name: str,
                 secondary_ip: str,
                 secondary_ip_allocation_mode: str,
                 type: str):
        """
        :param str adapter_type: Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        :param bool connected: It defines if NIC is connected or not.
        :param str ip: IP of the VM. Settings depend on `ip_allocation_mode`
        :param str ip_allocation_mode: IP address allocation mode.
        :param bool is_primary: Set to true if network interface should be primary. First network card in the list will be primary by default
        :param str mac: Mac address of network interface
        :param str name: A name for the VM, unique within the vApp
        :param str secondary_ip: Secondary (IPv6) IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param str secondary_ip_allocation_mode: Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        :param str type: Network type
        """
        pulumi.set(__self__, "adapter_type", adapter_type)
        pulumi.set(__self__, "connected", connected)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_allocation_mode", ip_allocation_mode)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secondary_ip", secondary_ip)
        pulumi.set(__self__, "secondary_ip_allocation_mode", secondary_ip_allocation_mode)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> str:
        """
        Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        """
        return pulumi.get(self, "adapter_type")

    @property
    @pulumi.getter
    def connected(self) -> bool:
        """
        It defines if NIC is connected or not.
        """
        return pulumi.get(self, "connected")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP of the VM. Settings depend on `ip_allocation_mode`
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipAllocationMode")
    def ip_allocation_mode(self) -> str:
        """
        IP address allocation mode.
        """
        return pulumi.get(self, "ip_allocation_mode")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> bool:
        """
        Set to true if network interface should be primary. First network card in the list will be primary by default
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        Mac address of network interface
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name for the VM, unique within the vApp
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secondaryIp")
    def secondary_ip(self) -> str:
        """
        Secondary (IPv6) IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "secondary_ip")

    @property
    @pulumi.getter(name="secondaryIpAllocationMode")
    def secondary_ip_allocation_mode(self) -> str:
        """
        Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "secondary_ip_allocation_mode")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Network type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVdcGroupParticipatingOrgVdcResult(dict):
    def __init__(__self__, *,
                 fault_domain_tag: str,
                 is_remote_org: bool,
                 network_provider_scope: str,
                 org_id: str,
                 org_name: str,
                 site_id: str,
                 site_name: str,
                 status: str,
                 vdc_id: str,
                 vdc_name: str):
        """
        :param str fault_domain_tag: Represents the fault domain of a given organization VDC
        :param bool is_remote_org: Specifies whether the VDC is local to this VCD site
        :param str network_provider_scope: Specifies the network provider scope of the VDC
        :param str org_id: Organization VDC belongs
        :param str org_name: Organization VDC belongs
        :param str site_id: Site VDC belongs
        :param str site_name: Site VDC belongs
        :param str status: The status that the VDC can be in e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED')
        :param str vdc_id: VDC ID
        :param str vdc_name: VDC name
        """
        pulumi.set(__self__, "fault_domain_tag", fault_domain_tag)
        pulumi.set(__self__, "is_remote_org", is_remote_org)
        pulumi.set(__self__, "network_provider_scope", network_provider_scope)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "org_name", org_name)
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "site_name", site_name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "vdc_id", vdc_id)
        pulumi.set(__self__, "vdc_name", vdc_name)

    @property
    @pulumi.getter(name="faultDomainTag")
    def fault_domain_tag(self) -> str:
        """
        Represents the fault domain of a given organization VDC
        """
        return pulumi.get(self, "fault_domain_tag")

    @property
    @pulumi.getter(name="isRemoteOrg")
    def is_remote_org(self) -> bool:
        """
        Specifies whether the VDC is local to this VCD site
        """
        return pulumi.get(self, "is_remote_org")

    @property
    @pulumi.getter(name="networkProviderScope")
    def network_provider_scope(self) -> str:
        """
        Specifies the network provider scope of the VDC
        """
        return pulumi.get(self, "network_provider_scope")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Organization VDC belongs
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> str:
        """
        Organization VDC belongs
        """
        return pulumi.get(self, "org_name")

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> str:
        """
        Site VDC belongs
        """
        return pulumi.get(self, "site_id")

    @property
    @pulumi.getter(name="siteName")
    def site_name(self) -> str:
        """
        Site VDC belongs
        """
        return pulumi.get(self, "site_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status that the VDC can be in e.g. 'SAVING', 'SAVED', 'CONFIGURING', 'REALIZED', 'REALIZATION_FAILED', 'DELETING', 'DELETE_FAILED', 'OBJECT_NOT_FOUND', 'UNCONFIGURED')
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="vdcId")
    def vdc_id(self) -> str:
        """
        VDC ID
        """
        return pulumi.get(self, "vdc_id")

    @property
    @pulumi.getter(name="vdcName")
    def vdc_name(self) -> str:
        """
        VDC name
        """
        return pulumi.get(self, "vdc_name")


@pulumi.output_type
class GetVmBootOptionResult(dict):
    def __init__(__self__, *,
                 boot_delay: int,
                 boot_retry_delay: int,
                 boot_retry_enabled: bool,
                 efi_secure_boot: bool,
                 enter_bios_setup_on_next_boot: bool):
        """
        :param int boot_delay: Number of milliseconds to wait between powering-on and booting the VM
        :param int boot_retry_delay: Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        :param bool boot_retry_enabled: If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        :param bool efi_secure_boot: If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        :param bool enter_bios_setup_on_next_boot: If set to true, the VM will enter BIOS setup on boot.
        """
        pulumi.set(__self__, "boot_delay", boot_delay)
        pulumi.set(__self__, "boot_retry_delay", boot_retry_delay)
        pulumi.set(__self__, "boot_retry_enabled", boot_retry_enabled)
        pulumi.set(__self__, "efi_secure_boot", efi_secure_boot)
        pulumi.set(__self__, "enter_bios_setup_on_next_boot", enter_bios_setup_on_next_boot)

    @property
    @pulumi.getter(name="bootDelay")
    def boot_delay(self) -> int:
        """
        Number of milliseconds to wait between powering-on and booting the VM
        """
        return pulumi.get(self, "boot_delay")

    @property
    @pulumi.getter(name="bootRetryDelay")
    def boot_retry_delay(self) -> int:
        """
        Delay in milliseconds before a boot retry. Only works if 'boot_retry_enabled' is set to true.
        """
        return pulumi.get(self, "boot_retry_delay")

    @property
    @pulumi.getter(name="bootRetryEnabled")
    def boot_retry_enabled(self) -> bool:
        """
        If set to true, a VM that fails to boot will try again after the 'boot_retry_delay' time period has expired
        """
        return pulumi.get(self, "boot_retry_enabled")

    @property
    @pulumi.getter(name="efiSecureBoot")
    def efi_secure_boot(self) -> bool:
        """
        If set to true, enables EFI Secure Boot for the VM. Can only be changed when the VM is powered off.
        """
        return pulumi.get(self, "efi_secure_boot")

    @property
    @pulumi.getter(name="enterBiosSetupOnNextBoot")
    def enter_bios_setup_on_next_boot(self) -> bool:
        """
        If set to true, the VM will enter BIOS setup on boot.
        """
        return pulumi.get(self, "enter_bios_setup_on_next_boot")


@pulumi.output_type
class GetVmCustomizationResult(dict):
    def __init__(__self__, *,
                 admin_password: str,
                 allow_local_admin_password: bool,
                 auto_generate_password: bool,
                 change_sid: bool,
                 enabled: bool,
                 force: bool,
                 initscript: str,
                 join_domain: bool,
                 join_domain_account_ou: str,
                 join_domain_name: str,
                 join_domain_password: str,
                 join_domain_user: str,
                 join_org_domain: bool,
                 must_change_password_on_first_login: bool,
                 number_of_auto_logons: int):
        """
        :param str admin_password: Manually specify admin password
        :param bool allow_local_admin_password: Allow local administrator password
        :param bool auto_generate_password: Auto generate password
        :param bool change_sid: 'true' value will change SID. Applicable only for Windows VMs
        :param bool enabled: 'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        :param bool force: 'true' value will cause the VM to reboot on every 'apply' operation
        :param str initscript: Script to run on initial boot or with customization.force=true set
        :param bool join_domain: Enable this VM to join a domain
        :param str join_domain_account_ou: Account organizational unit for domain name join
        :param str join_domain_name: Custom domain name for join
        :param str join_domain_password: Password for custom domain name join
        :param str join_domain_user: Username for custom domain name join
        :param bool join_org_domain: Use organization's domain for joining
        :param bool must_change_password_on_first_login: Require Administrator to change password on first login
        :param int number_of_auto_logons: Number of times to log on automatically
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "allow_local_admin_password", allow_local_admin_password)
        pulumi.set(__self__, "auto_generate_password", auto_generate_password)
        pulumi.set(__self__, "change_sid", change_sid)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "force", force)
        pulumi.set(__self__, "initscript", initscript)
        pulumi.set(__self__, "join_domain", join_domain)
        pulumi.set(__self__, "join_domain_account_ou", join_domain_account_ou)
        pulumi.set(__self__, "join_domain_name", join_domain_name)
        pulumi.set(__self__, "join_domain_password", join_domain_password)
        pulumi.set(__self__, "join_domain_user", join_domain_user)
        pulumi.set(__self__, "join_org_domain", join_org_domain)
        pulumi.set(__self__, "must_change_password_on_first_login", must_change_password_on_first_login)
        pulumi.set(__self__, "number_of_auto_logons", number_of_auto_logons)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> str:
        """
        Manually specify admin password
        """
        return pulumi.get(self, "admin_password")

    @property
    @pulumi.getter(name="allowLocalAdminPassword")
    def allow_local_admin_password(self) -> bool:
        """
        Allow local administrator password
        """
        return pulumi.get(self, "allow_local_admin_password")

    @property
    @pulumi.getter(name="autoGeneratePassword")
    def auto_generate_password(self) -> bool:
        """
        Auto generate password
        """
        return pulumi.get(self, "auto_generate_password")

    @property
    @pulumi.getter(name="changeSid")
    def change_sid(self) -> bool:
        """
        'true' value will change SID. Applicable only for Windows VMs
        """
        return pulumi.get(self, "change_sid")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        'true' value will enable guest customization. It may occur on first boot or when 'force' is used
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def force(self) -> bool:
        """
        'true' value will cause the VM to reboot on every 'apply' operation
        """
        return pulumi.get(self, "force")

    @property
    @pulumi.getter
    def initscript(self) -> str:
        """
        Script to run on initial boot or with customization.force=true set
        """
        return pulumi.get(self, "initscript")

    @property
    @pulumi.getter(name="joinDomain")
    def join_domain(self) -> bool:
        """
        Enable this VM to join a domain
        """
        return pulumi.get(self, "join_domain")

    @property
    @pulumi.getter(name="joinDomainAccountOu")
    def join_domain_account_ou(self) -> str:
        """
        Account organizational unit for domain name join
        """
        return pulumi.get(self, "join_domain_account_ou")

    @property
    @pulumi.getter(name="joinDomainName")
    def join_domain_name(self) -> str:
        """
        Custom domain name for join
        """
        return pulumi.get(self, "join_domain_name")

    @property
    @pulumi.getter(name="joinDomainPassword")
    def join_domain_password(self) -> str:
        """
        Password for custom domain name join
        """
        return pulumi.get(self, "join_domain_password")

    @property
    @pulumi.getter(name="joinDomainUser")
    def join_domain_user(self) -> str:
        """
        Username for custom domain name join
        """
        return pulumi.get(self, "join_domain_user")

    @property
    @pulumi.getter(name="joinOrgDomain")
    def join_org_domain(self) -> bool:
        """
        Use organization's domain for joining
        """
        return pulumi.get(self, "join_org_domain")

    @property
    @pulumi.getter(name="mustChangePasswordOnFirstLogin")
    def must_change_password_on_first_login(self) -> bool:
        """
        Require Administrator to change password on first login
        """
        return pulumi.get(self, "must_change_password_on_first_login")

    @property
    @pulumi.getter(name="numberOfAutoLogons")
    def number_of_auto_logons(self) -> int:
        """
        Number of times to log on automatically
        """
        return pulumi.get(self, "number_of_auto_logons")


@pulumi.output_type
class GetVmDiskResult(dict):
    def __init__(__self__, *,
                 bus_number: str,
                 name: str,
                 size_in_mb: int,
                 unit_number: str):
        """
        :param str bus_number: Bus number on which to place the disk controller
        :param str name: A name or ID for the standalone VM in VDC
        :param int size_in_mb: The size of the disk in MB.
        :param str unit_number: Unit number (slot) on the bus specified by BusNumber
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size_in_mb", size_in_mb)
        pulumi.set(__self__, "unit_number", unit_number)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> str:
        """
        Bus number on which to place the disk controller
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name or ID for the standalone VM in VDC
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> int:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> str:
        """
        Unit number (slot) on the bus specified by BusNumber
        """
        return pulumi.get(self, "unit_number")


@pulumi.output_type
class GetVmExtraConfigResult(dict):
    def __init__(__self__, *,
                 key: str,
                 required: bool,
                 value: str):
        """
        :param str key: The key of the extra configuration item
        :param bool required: Whether the extra configuration item is required
        :param str value: The value of the extra configuration item
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "required", required)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the extra configuration item
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def required(self) -> bool:
        """
        Whether the extra configuration item is required
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the extra configuration item
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVmInternalDiskResult(dict):
    def __init__(__self__, *,
                 bus_number: int,
                 bus_type: str,
                 disk_id: str,
                 iops: int,
                 size_in_mb: int,
                 storage_profile: str,
                 thin_provisioned: bool,
                 unit_number: int):
        """
        :param int bus_number: The number of the SCSI or IDE controller itself.
        :param str bus_type: The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        :param str disk_id: The disk ID.
        :param int iops: Specifies the IOPS for the disk. Default is 0.
        :param int size_in_mb: The size of the disk in MB.
        :param str storage_profile: Storage profile to override the VM default one
        :param bool thin_provisioned: Specifies whether the disk storage is pre-allocated or allocated on demand.
        :param int unit_number: The device number on the SCSI or IDE controller of the disk.
        """
        pulumi.set(__self__, "bus_number", bus_number)
        pulumi.set(__self__, "bus_type", bus_type)
        pulumi.set(__self__, "disk_id", disk_id)
        pulumi.set(__self__, "iops", iops)
        pulumi.set(__self__, "size_in_mb", size_in_mb)
        pulumi.set(__self__, "storage_profile", storage_profile)
        pulumi.set(__self__, "thin_provisioned", thin_provisioned)
        pulumi.set(__self__, "unit_number", unit_number)

    @property
    @pulumi.getter(name="busNumber")
    def bus_number(self) -> int:
        """
        The number of the SCSI or IDE controller itself.
        """
        return pulumi.get(self, "bus_number")

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> str:
        """
        The type of disk controller. Possible values: ide, parallel( LSI Logic Parallel SCSI), sas(LSI Logic SAS (SCSI)), paravirtual(Paravirtual (SCSI)), sata, nvme
        """
        return pulumi.get(self, "bus_type")

    @property
    @pulumi.getter(name="diskId")
    def disk_id(self) -> str:
        """
        The disk ID.
        """
        return pulumi.get(self, "disk_id")

    @property
    @pulumi.getter
    def iops(self) -> int:
        """
        Specifies the IOPS for the disk. Default is 0.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> int:
        """
        The size of the disk in MB.
        """
        return pulumi.get(self, "size_in_mb")

    @property
    @pulumi.getter(name="storageProfile")
    def storage_profile(self) -> str:
        """
        Storage profile to override the VM default one
        """
        return pulumi.get(self, "storage_profile")

    @property
    @pulumi.getter(name="thinProvisioned")
    def thin_provisioned(self) -> bool:
        """
        Specifies whether the disk storage is pre-allocated or allocated on demand.
        """
        return pulumi.get(self, "thin_provisioned")

    @property
    @pulumi.getter(name="unitNumber")
    def unit_number(self) -> int:
        """
        The device number on the SCSI or IDE controller of the disk.
        """
        return pulumi.get(self, "unit_number")


@pulumi.output_type
class GetVmMetadataEntryResult(dict):
    def __init__(__self__, *,
                 is_system: bool,
                 key: str,
                 type: str,
                 user_access: str,
                 value: str):
        """
        :param bool is_system: Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        :param str key: Key of this metadata entry
        :param str type: Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        :param str user_access: User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        :param str value: Value of this metadata entry
        """
        pulumi.set(__self__, "is_system", is_system)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_access", user_access)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isSystem")
    def is_system(self) -> bool:
        """
        Domain for this metadata entry. true, if it belongs to SYSTEM. false, if it belongs to GENERAL
        """
        return pulumi.get(self, "is_system")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of this metadata entry
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of this metadata entry. One of: 'MetadataStringValue', 'MetadataNumberValue', 'MetadataBooleanValue', 'MetadataDateTimeValue'
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userAccess")
    def user_access(self) -> str:
        """
        User access level for this metadata entry. One of: 'READWRITE', 'READONLY', 'PRIVATE'
        """
        return pulumi.get(self, "user_access")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this metadata entry
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetVmNetworkResult(dict):
    def __init__(__self__, *,
                 adapter_type: str,
                 connected: bool,
                 ip: str,
                 ip_allocation_mode: str,
                 is_primary: bool,
                 mac: str,
                 name: str,
                 secondary_ip: str,
                 secondary_ip_allocation_mode: str,
                 type: str):
        """
        :param str adapter_type: Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        :param bool connected: It defines if NIC is connected or not.
        :param str ip: IP of the VM. Settings depend on `ip_allocation_mode`
        :param str ip_allocation_mode: IP address allocation mode.
        :param bool is_primary: Set to true if network interface should be primary. First network card in the list will be primary by default
        :param str mac: Mac address of network interface
        :param str name: A name or ID for the standalone VM in VDC
        :param str secondary_ip: Secondary (IPv6) IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        :param str secondary_ip_allocation_mode: Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        :param str type: Network type
        """
        pulumi.set(__self__, "adapter_type", adapter_type)
        pulumi.set(__self__, "connected", connected)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "ip_allocation_mode", ip_allocation_mode)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "mac", mac)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secondary_ip", secondary_ip)
        pulumi.set(__self__, "secondary_ip_allocation_mode", secondary_ip_allocation_mode)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="adapterType")
    def adapter_type(self) -> str:
        """
        Network card adapter type. (e.g. 'E1000', 'E1000E', 'SRIOVETHERNETCARD', 'VMXNET3', 'PCNet32')
        """
        return pulumi.get(self, "adapter_type")

    @property
    @pulumi.getter
    def connected(self) -> bool:
        """
        It defines if NIC is connected or not.
        """
        return pulumi.get(self, "connected")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP of the VM. Settings depend on `ip_allocation_mode`
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipAllocationMode")
    def ip_allocation_mode(self) -> str:
        """
        IP address allocation mode.
        """
        return pulumi.get(self, "ip_allocation_mode")

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> bool:
        """
        Set to true if network interface should be primary. First network card in the list will be primary by default
        """
        return pulumi.get(self, "is_primary")

    @property
    @pulumi.getter
    def mac(self) -> str:
        """
        Mac address of network interface
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A name or ID for the standalone VM in VDC
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="secondaryIp")
    def secondary_ip(self) -> str:
        """
        Secondary (IPv6) IP of the VM. Settings depend on `ip_allocation_mode`. Omitted or empty for DHCP, POOL, NONE. Required for MANUAL
        """
        return pulumi.get(self, "secondary_ip")

    @property
    @pulumi.getter(name="secondaryIpAllocationMode")
    def secondary_ip_allocation_mode(self) -> str:
        """
        Secondary (IPv6) IP address allocation mode. One of POOL, DHCP, MANUAL, NONE
        """
        return pulumi.get(self, "secondary_ip_allocation_mode")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Network type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVmSizingPolicyCpusResult(dict):
    def __init__(__self__, *,
                 cores_per_socket: str,
                 count: str,
                 limit_in_mhz: str,
                 reservation_guarantee: str,
                 shares: str,
                 speed_in_mhz: str):
        """
        :param str cores_per_socket: The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        :param str count: Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        :param str limit_in_mhz: Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs.
        :param str reservation_guarantee: Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        :param str shares: Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param str speed_in_mhz: Defines the vCPU speed of a core in MHz.
        """
        pulumi.set(__self__, "cores_per_socket", cores_per_socket)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "limit_in_mhz", limit_in_mhz)
        pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        pulumi.set(__self__, "shares", shares)
        pulumi.set(__self__, "speed_in_mhz", speed_in_mhz)

    @property
    @pulumi.getter(name="coresPerSocket")
    def cores_per_socket(self) -> str:
        """
        The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        """
        return pulumi.get(self, "cores_per_socket")

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="limitInMhz")
    def limit_in_mhz(self) -> str:
        """
        Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs.
        """
        return pulumi.get(self, "limit_in_mhz")

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> str:
        """
        Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @property
    @pulumi.getter
    def shares(self) -> str:
        """
        Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @property
    @pulumi.getter(name="speedInMhz")
    def speed_in_mhz(self) -> str:
        """
        Defines the vCPU speed of a core in MHz.
        """
        return pulumi.get(self, "speed_in_mhz")


@pulumi.output_type
class GetVmSizingPolicyMemoryResult(dict):
    def __init__(__self__, *,
                 limit_in_mb: str,
                 reservation_guarantee: str,
                 shares: str,
                 size_in_mb: str):
        """
        :param str limit_in_mb: Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        :param str reservation_guarantee: Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        :param str shares: Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param str size_in_mb: Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        pulumi.set(__self__, "limit_in_mb", limit_in_mb)
        pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        pulumi.set(__self__, "shares", shares)
        pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="limitInMb")
    def limit_in_mb(self) -> str:
        """
        Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        """
        return pulumi.get(self, "limit_in_mb")

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> str:
        """
        Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @property
    @pulumi.getter
    def shares(self) -> str:
        """
        Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> str:
        """
        Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        return pulumi.get(self, "size_in_mb")


@pulumi.output_type
class GetVmVgpuPolicyCpusResult(dict):
    def __init__(__self__, *,
                 cores_per_socket: str,
                 count: str,
                 limit_in_mhz: str,
                 reservation_guarantee: str,
                 shares: str,
                 speed_in_mhz: str):
        """
        :param str cores_per_socket: The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        :param str count: Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        :param str limit_in_mhz: Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs.
        :param str reservation_guarantee: Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        :param str shares: Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param str speed_in_mhz: Defines the vCPU speed of a core in MHz.
        """
        pulumi.set(__self__, "cores_per_socket", cores_per_socket)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "limit_in_mhz", limit_in_mhz)
        pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        pulumi.set(__self__, "shares", shares)
        pulumi.set(__self__, "speed_in_mhz", speed_in_mhz)

    @property
    @pulumi.getter(name="coresPerSocket")
    def cores_per_socket(self) -> str:
        """
        The number of cores per socket for a VM. This is a VM hardware configuration. The number of vCPUs that is defined in the VM sizing policy must be divisible by the number of cores per socket. If the number of vCPUs is not divisible by the number of cores per socket, the number of cores per socket becomes invalid.
        """
        return pulumi.get(self, "cores_per_socket")

    @property
    @pulumi.getter
    def count(self) -> str:
        """
        Defines the number of vCPUs configured for a VM. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, this count becomes the configured number of vCPUs for the VM.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="limitInMhz")
    def limit_in_mhz(self) -> str:
        """
        Defines the CPU limit in MHz for a VM. If not defined in the VDC compute policy, CPU limit is equal to the vCPU speed multiplied by the number of vCPUs.
        """
        return pulumi.get(self, "limit_in_mhz")

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> str:
        """
        Defines how much of the CPU resources of a VM are reserved. The allocated CPU for a VM equals the number of vCPUs times the vCPU speed in MHz. The value of the attribute ranges between 0 and one. Value of 0 CPU reservation guarantee defines no CPU reservation. Value of 1 defines 100% of CPU reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @property
    @pulumi.getter
    def shares(self) -> str:
        """
        Defines the number of CPU shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of CPU as another VM, it is entitled to consume twice as much CPU when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @property
    @pulumi.getter(name="speedInMhz")
    def speed_in_mhz(self) -> str:
        """
        Defines the vCPU speed of a core in MHz.
        """
        return pulumi.get(self, "speed_in_mhz")


@pulumi.output_type
class GetVmVgpuPolicyMemoryResult(dict):
    def __init__(__self__, *,
                 limit_in_mb: str,
                 reservation_guarantee: str,
                 shares: str,
                 size_in_mb: str):
        """
        :param str limit_in_mb: Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        :param str reservation_guarantee: Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        :param str shares: Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        :param str size_in_mb: Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        pulumi.set(__self__, "limit_in_mb", limit_in_mb)
        pulumi.set(__self__, "reservation_guarantee", reservation_guarantee)
        pulumi.set(__self__, "shares", shares)
        pulumi.set(__self__, "size_in_mb", size_in_mb)

    @property
    @pulumi.getter(name="limitInMb")
    def limit_in_mb(self) -> str:
        """
        Defines the memory limit in MB for a VM. If not defined in the VM sizing policy, memory limit is equal to the allocated memory for the VM.
        """
        return pulumi.get(self, "limit_in_mb")

    @property
    @pulumi.getter(name="reservationGuarantee")
    def reservation_guarantee(self) -> str:
        """
        Defines the reserved amount of memory that is configured for a VM. The value of the attribute ranges between 0 and one. Value of 0 memory reservation guarantee defines no memory reservation. Value of 1 defines 100% of memory reserved.
        """
        return pulumi.get(self, "reservation_guarantee")

    @property
    @pulumi.getter
    def shares(self) -> str:
        """
        Defines the number of memory shares for a VM. Shares specify the relative importance of a VM within a virtual data center. If a VM has twice as many shares of memory as another VM, it is entitled to consume twice as much memory when these two virtual machines are competing for resources. If not defined in the VDC compute policy, normal shares are applied to the VM.
        """
        return pulumi.get(self, "shares")

    @property
    @pulumi.getter(name="sizeInMb")
    def size_in_mb(self) -> str:
        """
        Defines the memory configured for a VM in MB. This is a VM hardware configuration. When a tenant assigns the VM sizing policy to a VM, the VM receives the amount of memory defined by this attribute.
        """
        return pulumi.get(self, "size_in_mb")


@pulumi.output_type
class GetVmVgpuPolicyProviderVdcScopeResult(dict):
    def __init__(__self__, *,
                 cluster_names: Sequence[str],
                 provider_vdc_id: str,
                 vm_group_id: str):
        """
        :param Sequence[str] cluster_names: Set of cluster names within the provider virtual data center.
        :param str provider_vdc_id: Identifier for the provider virtual data center.
        :param str vm_group_id: Identifier for a VM group within the provider VDC scope.
        """
        pulumi.set(__self__, "cluster_names", cluster_names)
        pulumi.set(__self__, "provider_vdc_id", provider_vdc_id)
        pulumi.set(__self__, "vm_group_id", vm_group_id)

    @property
    @pulumi.getter(name="clusterNames")
    def cluster_names(self) -> Sequence[str]:
        """
        Set of cluster names within the provider virtual data center.
        """
        return pulumi.get(self, "cluster_names")

    @property
    @pulumi.getter(name="providerVdcId")
    def provider_vdc_id(self) -> str:
        """
        Identifier for the provider virtual data center.
        """
        return pulumi.get(self, "provider_vdc_id")

    @property
    @pulumi.getter(name="vmGroupId")
    def vm_group_id(self) -> str:
        """
        Identifier for a VM group within the provider VDC scope.
        """
        return pulumi.get(self, "vm_group_id")


@pulumi.output_type
class GetVmVgpuPolicyVgpuProfileResult(dict):
    def __init__(__self__, *,
                 count: int,
                 id: str):
        """
        :param int count: Specifies the number of vGPU profiles.
        :param str id: The identifier of the vGPU profile.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def count(self) -> int:
        """
        Specifies the number of vGPU profiles.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The identifier of the vGPU profile.
        """
        return pulumi.get(self, "id")


