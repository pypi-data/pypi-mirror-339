# -*- coding: utf-8 -*-
"""DBHL_20250328_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eLRrznIMxoDqqINxUdIC9rTe4dJdF6lY

# DebugHelper
デバッグ作業をサポートする。


```
2025/01/18 DebugHelper2をpip化するために作成
2025/01/19 flg_debugをなくすための修正
2025/02/11 0.2.1 CheckpointManager追加
2025/02/12 0.2.2 log_step改良。実行中のクラスとメソッドを表示するようにした。
2025/02/13 0.2.3 what_do_you_do を追加。コマンドの実行を選択できるようにした。
2025/02/14 0.2.4 what_do_you_do 改良。戻り値関係。
2025/02/14 0.2.5 what_do_you_do 改良。表示方法。
2025/02/14 0.2.7 what_do_you_do 改良。ログファイル作成機能、タイムスタンプ機能
2025/02/15 0.2.8 ログファイル作成機能改良。ログファイル名にタイムスタンプを入れる。
2025/02/15 0.2.9 log_stepバグ修正。整理のため、ログファイルストック数を5つに制限する。
2025/02/15 0.2.10 log_step 改良。引数charで冒頭文字の幅を広げる。
2025/02/16 0.2.11 log_step 改良。戻り値関係。
2025/02/16 0.2.12 run_command 改良。ログを出力。
2025/02/17 0.2.13 run_command 改良。subprocessを利用するようにする。
2025/02/17 0.2.14 run_command 改良。booleanだけでなく、numericも返す。
2025/02/18 0.2.15 run_command 改良。stdoutをログファイルに書き出すようにする。
2025/02/18 0.3.00 run_command 改良。stderrもログファイルに書き出すようにする。
2025/02/23 1.0.0 2つ以上のインスタンスにDebugHelperを設置しても、問題なくログを出力できるようにした。
2025/02/23 1.0.1 ログ出力先修正
2025/02/26 1.0.2 仮想環境からの出力でもログにするようにした。
2025/02/27 1.0.3 バグ取り
2025/02/27 1.0.4 バグ取り
2025/03/04 1.0.5 バグ取り
2025/03/04 1.0.6 バグ取り
2025/03/04 1.1.0 run_command改良。引数syncを導入
2025/03/21 1.1.1 debugフラグを有効化
2025/03/25 1.2.0 Installer 追加
2025/03/26 1.2.1 バグ取り
2025/03/26 1.2.4 Installer 修正
2025/03/27 1.3.0 Installer_sync 追加
2025/03/28 1.3.1 Installer_sync バグ修正
2025/03/28 1.3.2 installer, installer_sync バグ修正
2025/03/31 1.3.3 installer_sync バグ修正
```

# DebugHelper

## 1. 初期設定
"""

# @title a. 初期値設定{"form-width":"400px"}
# @markdown Log_folder, Log_file(デバッグログを記録)
log_folder = "/content/drive/MyDrive/log"  # @param {type:"string"}
log_file_stdout = ""  # @param {type:"string", "placeholder":"何も入力しなければタイムスタンプになります"}
log_file_stderr = ""  # @param {type:"string", "placeholder":"何も入力しなければタイムスタンプになります"}

# @title b. GDrive接続とcondacolab設定
if __name__ == '__main__':
    get_ipython().system( "pip install an_CondaInitializer" )
    from an_condainitializer import CondaInitializer

    condainitializer = CondaInitializer()

"""## 2. モジュール定義"""

# @title a. DebugHelper 定義{"form-width":"400px"}
import os
import sys
import re
import inspect
import subprocess
import threading
from datetime import datetime
from pathlib import Path

def is_valid_folder_name(name: str) -> bool:
    """
    フォルダ名として無効な文字（Windowsの場合: \ / : * ? " < > |）が含まれていないか、または空文字でないかをチェックする。
    Linuxではほとんどの文字が有効ですが、ここでは例としてWindowsの制約を利用します。
    """
    if not name:
        return False
    # Windowsで使用できない文字をチェック
    invalid_chars = r'[\\\/:*?"<>|]'
    return re.search(invalid_chars, name) is None

class DebugHelper:
    def __init__(self, instance_name="default", default_log_folder="/content/drive/MyDrive/log/"):
        """
        DebugHelper クラス
        args:
            instance_name (str): Debug対象となるインスタンスの名前
            default_log_folder (str): ログフォルダパス
        """
        self.instance_name = instance_name
        self.debug = True
        self.entries = []  # 記録するエントリ一覧
        self.wNo = 1
        self.silent_mode = False  # デフォルトは False（対話モード）

        # ログファイル出力関連
        self.log_to_file = False
        self.log_file_path = None
        self.log_to_file_stdout = False
        self.log_file_path_stdout = None
        self.log_to_file_stderr = False
        self.log_file_path_stderr = None

        self.timestamp = False  # タイムスタンプ有効化

        # デフォルトログフォルダの設定
        # 引数で受け取った default_log_folder が無効な場合は "Logs" を使用する
        if default_log_folder is None:
            self.default_log_folder = Path("/content/log")
        else:
            self.default_log_folder = Path(default_log_folder)
        try:
            Path(self.default_log_folder).mkdir(parents=True, exist_ok=True)
        except Exception as e:
            self.debug.log_step( f"デフォルトログフォルダの作成に失敗しました: {e}", char = "⚠️" )
            raise Exception(f"デフォルトログフォルダの作成に失敗しました: {e}")
        self.log_step( f"default_log_folder : { self.default_log_folder }")

    def enable_debug(self):
        self.debug = True

    def disable_debug(self):
        self.debug = False

    def enable_silent_mode(self):
        self.silent_mode = True

    def disable_silent_mode(self):
        self.silent_mode = False

    def prune_log_files(self, log_file_path, max_files=5):
        # 指定されたディレクトリ内の *.log ファイルを最新 max_files 個以外削除する
        log_path = log_file_path.parent
        self.debug_print(f"log_path: {log_path}")
        files = list(log_path.glob("*.log"))
        if len(files) <= max_files:
            return
        files.sort(key=lambda f: f.stat().st_mtime)
        for f in files[:-max_files]:
            try:
                f.unlink()
                print(f"Deleted old log file: {f}")
            except Exception as e:
                print(f"Error deleting {f}: {e}")

    def enable_log_to_file_stdout(self, log_file_path=None):
        """標準出力のログファイルへの出力を有効にする（インスタンスごとに独立したパスを使用）"""
        if log_file_path is None:
            # デフォルトのログフォルダを利用
            log_file_path = self.default_log_folder
        else:
            log_file_path = Path(log_file_path)
        self.log_to_file_stdout = True
        self.log_file_path_stdout = log_file_path
        if self.log_file_path_stdout.is_dir():
            # filename = "Stdout_Rec_" + datetime.now().strftime("%Y_%m_%d_%H_%M_%S") + ".log"
            filename = f"Stdout_Rec_{self.instance_name}_{datetime.now().strftime('%Y_%m_%d_%H_%M_%S_%f')}.log"
            self.log_file_path_stdout = self.log_file_path_stdout / filename
            self.prune_log_files(self.log_file_path_stdout)
        elif self.log_file_path_stdout.is_file():
            pass
        else:
            self.debug_print(f"⚠️ ログファイルパス (stdout) が不正です: {self.log_file_path_stdout}")
            sys.exit(1)
        self.debug_print(f"✅ [{self.instance_name}] 標準出力ログファイル出力を有効化: {self.log_file_path_stdout}")

    def enable_log_to_file_stderr(self, log_file_path=None):
        """標準エラー出力のログファイルへの出力を有効にする（インスタンスごとに独立したパスを使用）"""
        if log_file_path is None:
            log_file_path = self.default_log_folder
        else:
            log_file_path = Path(log_file_path)
        self.log_to_file_stderr = True
        self.log_file_path_stderr = log_file_path
        if self.log_file_path_stderr.is_dir():
            #filename = "Stderr_Rec_" + datetime.now().strftime("%Y_%m_%d_%H_%M_%S") + ".log"
            filename = f"Stderr_Rec_{self.instance_name}_{datetime.now().strftime('%Y_%m_%d_%H_%M_%S_%f')}.log"
            self.log_file_path_stderr = self.log_file_path_stderr / filename
            self.prune_log_files(self.log_file_path_stderr)
        elif self.log_file_path_stderr.is_file():
            pass
        else:
            self.debug_print(f"⚠️ ログファイルパス (stderr) が不正です: {self.log_file_path_stderr}")
            sys.exit(1)
        self.debug_print(f"✅ [{self.instance_name}] 標準エラーログファイル出力を有効化: {self.log_file_path_stderr}")

    def disable_log_to_file(self):
        self.log_to_file = False
        self.log_to_file_stdout = False
        self.log_to_file_stderr = False
        self.debug_print("🛑 ログファイル出力を無効化")

    def enable_timestamp(self):
        self.timestamp = True

    def disable_timestamp(self):
        self.timestamp = False

    def start_step(self, step_name):
        print(f"🔹 チェック開始: {step_name}")
        self.entries.append({"ステップ": step_name, "内容": "進行中", "結果": "⚠️ 進行中"})

    def add_step(self, step_key, description):
        if step_key not in self.entries:
            self.entries.append({
                "ステップ": step_key,
                "処理内容": description,
                "結果": "未実行"
            })
        else:
            print(f"⚠️ 手順 {step_key} はすでに登録済みです。")

    def complete_step(self, step_name, success=True):
        for entry in self.entries:
            if entry.get("ステップ") == step_name:
                entry["結果"] = "✅ 成功" if success else "❌ 失敗"
                return
        print(f"⚠️ ステップ `{step_name}` が見つかりません")

    def debug_print(self, *args, end="\n", back=0):
        cls_name, method_name = self.get_current_method_info(back=back)
        timestamp_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S") if self.timestamp else ""
        message = f"{timestamp_str} [{cls_name}.{method_name}] " + " ".join(map(str, args))
        if self.debug:
            print(message, end=end)

        # stdout用ログファイルへ書き込み（各インスタンスごと）
        if self.log_to_file_stdout and self.log_file_path_stdout:
            try:
                with open(self.log_file_path_stdout, "a", encoding="utf-8") as log_file:
                    log_file.write(message + end)
            except Exception as e:
                print(f"ログファイル書き込みエラー (stdout): {e}")

    def log_step(self, *args, end="\n", success=None, char=None, back=0):
        if char is None:
            if success is True:
                full_message = "✅ " + " ".join(map(str, args))
            elif success is False:
                full_message = "❌ " + " ".join(map(str, args))
            else:
                full_message = "🔹 " + " ".join(map(str, args))
        else:
            full_message = char + " " + " ".join(map(str, args))
        self.debug_print(full_message, end=end, back=back+1)

    def what_do_you_do(self, message, command):
        length = 100
        self.debug_print("\n" + "=" * length, back=1)
        mode_msg = "Silent mode: 即実行" if self.silent_mode else "Action mode: コマンド入力"
        self.debug_print(f"\n🔹🔹🔹🔹🔹 No.{self.wNo} {mode_msg} 🔹🔹🔹🔹🔹\n" + "-" * length, back=1)
        self.wNo += 1
        self.debug_print(f"\n🎮説明\n{message}", back=1)
        self.debug_print(f"\n🤔アクション\n{command}\n" + "-" * length, back=1)
        if not self.silent_mode:
            self.debug_print("\n📠コマンド\n1️⃣ 実行する 2️⃣ やめておく 3️⃣ コマンドを変更する 4️⃣ ここで中断", back=1)
            choice = input("\n🔹 どうする？ (1/2/3/4): ").strip()
            if choice == "1":
                pass
            elif choice == "2":
                self.debug_print("\n🛑 操作をキャンセルしました。", back=1)
                return None, None
            elif choice == "3":
                command = input("\n💬 新しいコマンドを入力してください: ").strip()
            elif choice == "4":
                self.debug_print("\n👋 中断します。", back=1)
                sys.exit(1)
            else:
                self.debug_print("\n⚠️ 無効な選択肢です", back=1)
                return None, None
        self.debug_print(f"\n🚀 実行中:\n{command}", back=1)
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            self.debug_print("\n✅ コマンド実行完了\n" + "-" * length, back=1)
            self.debug_print(f"\nstdout:\n{result.stdout}", back=1)
            self.debug_print(f"\nstderr:\n{result.stderr}\n" + "=" * length + "\n\n\n", back=1)
            return result.stdout, result.stderr
        except Exception as e:
            self.debug_print(f"\n❌ コマンド実行中にエラー: {e}", back=1)
            return None, None

    def get_current_method_info(self, back=0):
        frame = inspect.currentframe()
        for _ in range(2 + back):
            if frame is None or frame.f_back is None:
                break
            frame = frame.f_back
        method_name = frame.f_code.co_name if frame else "Unknown"
        cls_name = None
        if frame and 'self' in frame.f_locals:
            cls_name = frame.f_locals['self'].__class__.__name__
        return cls_name, method_name

    def add_entry(self, category, description, success=None):
        status = "✅ 成功" if success is True else "❌ 失敗" if success is False else "⚠️ 未判定"
        entry = {"カテゴリ": category, "処理内容": description, "結果": status}
        self.entries.append(entry)

    def display(self):
        """チェックリストをコンソールとstdout用ログファイルに表示する"""
        output_lines = []
        output_lines.append("\n🔹 **チェックリスト** 🔹")
        for idx, entry in enumerate(self.entries, start=1):
            category = entry.get("カテゴリ", entry.get("ステップ", "不明"))
            description = entry.get("処理内容", entry.get("内容", "説明なし"))
            result = entry.get("結果", "⚠️ 未判定")
            line = f"Step {idx}: [{category}] {description} → {result}"
            output_lines.append(line)

        for line in output_lines:
            print(line)

        if self.log_to_file_stdout and self.log_file_path_stdout:
            try:
                with open(self.log_file_path_stdout, "a", encoding="utf-8") as f:
                    for line in output_lines:
                        f.write(line + "\n")
            except Exception as e:
                self.debug_print(f"stdoutログファイルへの出力エラー: {e}")

    def export_log(self):
        """チェックリストをstdout用ログファイルに出力する"""
        if not self.log_file_path_stdout:
            self.debug_print("⚠️ stdoutログファイルパスが設定されていません。", back=1)
            return
        try:
            with open(self.log_file_path_stdout, "w", encoding="utf-8") as f:
                for idx, entry in enumerate(self.entries, start=1):
                    category = entry.get("カテゴリ", entry.get("ステップ", "不明"))
                    description = entry.get("処理内容", entry.get("内容", "説明なし"))
                    result = entry.get("結果", "⚠️ 未判定")
                    f.write(f"Step {idx}: [{category}] {description} → {result}\n")
            print(f"✅ チェックリストを {self.log_file_path_stdout} に保存しました。")
        except Exception as e:
            self.debug_print(f"stdoutログファイルへの保存エラー: {e}", back=1)

    def clear(self):
        self.entries = []
        self.debug_print("✅ チェックリストをリセットしました。", back=1)

    # --- 以下、既存のメソッドはそのまま ---

    def get_cuda_version(self):
        """
        nvcc --version の出力から CUDA のリリースバージョンを取得する。
        例: "Cuda compilation tools, release 12.5, V12.5.82" なら "12.5" を返す。
        """
        try:
            output = subprocess.check_output("nvcc --version", shell=True, text=True)
            for line in output.splitlines():
                if "release" in line:
                    # 例: "Cuda compilation tools, release 12.5, V12.5.82"
                    ver = line.split("release")[1].split(",")[0].strip()
                    return ver
            self.log_step("CUDA のバージョンが出力から取得できませんでした", success=False)
        except Exception as e:
            self.log_step(f"CUDA バージョンの取得に失敗: {e}", success=False)
        return None

    # def run_command(self, command, timeout=900, back=1, stdout=False, stderr=False, env=None, env_on = True ):
    #     """
    #     シェルコマンドをリアルタイムで実行し、コンソールとそれぞれのログファイルに出力する。

    #     Args:
    #         command (str): 実行するシェルコマンド
    #         timeout (int): タイムアウト時間（秒）
    #         back (int): ログ出力のオフセット
    #         stdout (bool): True の場合、標準出力をキャプチャする
    #         stderr (bool): True の場合、標準エラー出力をキャプチャする
    #         env (dict): サブプロセスで使用する環境変数。Noneの場合は、nvcc のバージョンに応じた環境変数が自動作成される。

    #     Returns:
    #         tuple: (終了コード, 標準出力 (str or None), 標準エラー出力 (str or None))
    #     """
    #     # env が指定されていなければ、自動で CUDA のバージョンに対応した環境変数を作成
    #     if env is None:
    #         cuda_ver = self.get_cuda_version()
    #         if cuda_ver is not None:
    #             env = os.environ.copy()
    #             # ここでは nvcc の出力に合わせて "/usr/local/cuda-<version>" を使用する前提
    #             # ※Colab ではシンボリックリンク等で管理されているので、実際のパスに合わせる必要がある場合は調整する
    #             env["CUDA_HOME"] = f"/usr/local/cuda-{cuda_ver}"
    #             env["PATH"] = f"/usr/local/cuda-{cuda_ver}/bin:" + env.get("PATH", "")
    #             env["LD_LIBRARY_PATH"] = f"/usr/local/cuda-{cuda_ver}/lib64:" + env.get("LD_LIBRARY_PATH", "")
    #         else:
    #             env = os.environ.copy()
    #             self.log_step("nvcc から CUDA バージョンが取得できなかったため、既存の環境変数を使用します", success=False)

    #     self.log_step(f"コマンド実行: {command}", success=None, back=back)
    #     stdout_data, stderr_data = [], []

    #     def monitor_output(stream, log_func, capture_list, log_file):
    #         try:
    #             for line in iter(stream.readline, ''):
    #                 log_func(line)
    #                 sys.stdout.flush()
    #                 capture_list.append(line)
    #                 if log_file:
    #                     log_file.write(line)
    #                     log_file.flush()
    #         except Exception as e:
    #             self.log_step(f"ストリーム処理中エラー: {str(e)}", success=False, back=back, char="💥")

    #     try:
    #         process = subprocess.Popen(
    #             command,
    #             shell=True,
    #             stdout=subprocess.PIPE,
    #             stderr=subprocess.PIPE,
    #             text=True,
    #             bufsize=1,
    #             env=env
    #         )

    #         if self.log_to_file_stdout and self.log_file_path_stdout:
    #             log_file_stdout = open(self.log_file_path_stdout, "a", encoding="utf-8")
    #         else:
    #             log_file_stdout = None

    #         if self.log_to_file_stderr and self.log_file_path_stderr:
    #             log_file_stderr = open(self.log_file_path_stderr, "a", encoding="utf-8")
    #         else:
    #             log_file_stderr = None

    #         stdout_thread = threading.Thread(target=monitor_output, args=(process.stdout, sys.stdout.write, stdout_data, log_file_stdout))
    #         stderr_thread = threading.Thread(target=monitor_output, args=(process.stderr, sys.stderr.write, stderr_data, log_file_stderr))

    #         stdout_thread.start()
    #         stderr_thread.start()

    #         process.wait(timeout=timeout)
    #         stdout_thread.join()
    #         stderr_thread.join()

    #         if log_file_stdout:
    #             log_file_stdout.close()
    #         if log_file_stderr:
    #             log_file_stderr.close()

    #         stdout_result = ''.join(stdout_data) if stdout else None
    #         stderr_result = ''.join(stderr_data) if stderr else None

    #         if process.returncode == 0:
    #             self.log_step(f"コマンド成功: {command} (コード: {process.returncode})", success=True, back=back)
    #         else:
    #             self.log_step(f"コマンド失敗: {command} (コード: {process.returncode})", success=False, back=back)

    #         return process.returncode, stdout_result, stderr_result

    #     except subprocess.TimeoutExpired:
    #         self.log_step(f"⏳ タイムアウト: {command}", char="⚠️", back=back)
    #         return -1, None, None
    #     except Exception as e:
    #         self.log_step(f"💥 実行エラー: {command}\n{str(e)}", success=False, back=back)
    #         return -2, None, None

    # 以降は他のメソッド（debug_print, log_step, etc.）はそのまま
    def run_command(self, command, timeout=900, back=1, stdout=False, stderr=False, env=None, env_on=True, sync=True):
        """
        シェルコマンドを実行し、結果を返す。

        Args:
            command (str): 実行するシェルコマンド
            timeout (int): タイムアウト時間（秒）
            stdout (bool): True の場合、標準出力をキャプチャする
            stderr (bool): True の場合、標準エラー出力をキャプチャする
            sync (bool): Trueなら同期処理(subprocess.run)を使用し、Falseなら非同期処理(Popen+スレッド)を使用する
            その他の引数は従来通り

        Returns:
            tuple: (終了コード, 標準出力 (str or None), 標準エラー出力 (str or None))
        """
        # 必要な環境変数の設定はそのまま
        if env is None:
            cuda_ver = self.get_cuda_version()
            if cuda_ver is not None:
                env = os.environ.copy()
                env["CUDA_HOME"] = f"/usr/local/cuda-{cuda_ver}"
                env["PATH"] = f"/usr/local/cuda-{cuda_ver}/bin:" + env.get("PATH", "")
                env["LD_LIBRARY_PATH"] = f"/usr/local/cuda-{cuda_ver}/lib64:" + env.get("LD_LIBRARY_PATH", "")
            else:
                env = os.environ.copy()
                self.log_step("nvcc から CUDA バージョンが取得できなかったため、既存の環境変数を使用します", success=False)

        self.log_step(f"コマンド実行: {command}", success=None, back=back)

        if sync:
            # 同期処理: subprocess.run を利用
            try:
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                    env=env
                )
                # 同期処理の場合は、出力はすべて result.stdout/result.stderr にある
                if result.returncode == 0:
                    self.log_step(f"コマンド成功: {command} (コード: {result.returncode})", success=True, back=back)
                else:
                    self.log_step(f"コマンド失敗: {command} (コード: {result.returncode})", success=False, back=back)
                return result.returncode, result.stdout if stdout else None, result.stderr if stderr else None
            except subprocess.TimeoutExpired:
                self.log_step(f"⏳ タイムアウト: {command}", char="⚠️", back=back)
                return -1, None, None
            except Exception as e:
                self.log_step(f"💥 実行エラー: {command}\n{str(e)}", success=False, back=back)
                return -2, None, None
        else:
            # 非同期処理: 現在の Popen とスレッドを使う実装
            stdout_data, stderr_data = [], []

            def monitor_output(stream, log_func, capture_list, log_file):
                try:
                    for line in iter(stream.readline, ''):
                        log_func(line)
                        sys.stdout.flush()
                        capture_list.append(line)
                        if log_file:
                            log_file.write(line)
                            log_file.flush()
                except Exception as e:
                    self.log_step(f"ストリーム処理中エラー: {str(e)}", success=False, back=back, char="💥")

            try:
                process = subprocess.Popen(
                    command,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    env=env
                )

                if self.log_to_file_stdout and self.log_file_path_stdout:
                    log_file_stdout = open(self.log_file_path_stdout, "a", encoding="utf-8")
                else:
                    log_file_stdout = None

                if self.log_to_file_stderr and self.log_file_path_stderr:
                    log_file_stderr = open(self.log_file_path_stderr, "a", encoding="utf-8")
                else:
                    log_file_stderr = None

                stdout_thread = threading.Thread(target=monitor_output, args=(process.stdout, sys.stdout.write, stdout_data, log_file_stdout))
                stderr_thread = threading.Thread(target=monitor_output, args=(process.stderr, sys.stderr.write, stderr_data, log_file_stderr))

                stdout_thread.start()
                stderr_thread.start()

                process.wait(timeout=timeout)
                stdout_thread.join()
                stderr_thread.join()

                if log_file_stdout:
                    log_file_stdout.close()
                if log_file_stderr:
                    log_file_stderr.close()

                stdout_result = ''.join(stdout_data) if stdout else None
                stderr_result = ''.join(stderr_data) if stderr else None

                if process.returncode == 0:
                    self.log_step(f"コマンド成功: {command} (コード: {process.returncode})", success=True, back=back)
                else:
                    self.log_step(f"コマンド失敗: {command} (コード: {process.returncode})", success=False, back=back)

                return process.returncode, stdout_result, stderr_result

            except subprocess.TimeoutExpired:
                self.log_step(f"⏳ タイムアウト: {command}", char="⚠️", back=back)
                return -1, None, None
            except Exception as e:
                self.log_step(f"💥 実行エラー: {command}\n{str(e)}", success=False, back=back)
                return -2, None, None


    def installer( self, command, shell = False, back = 0 ):
        """
        sインストーラー。インストーラー以外にも使える。
        args:
            command( str ) : コマンド
            shell( bool ) : コマンドの書き方。Trueだと文字配列で、Falseだと文字列で
            back( int ) : メッセージ微調整用
        """
        self.log_step( f"command : { command }", success = None, back = back + 1 )
        result = subprocess.run( command, shell = shell, capture_output=True, text=True )
        self.log_step( f"result  : { result.returncode }", success = None, back = back + 1 )
        self.log_step( f"stdout  :\n{ result.stdout     }", success = None, back = back + 1 )
        self.log_step( f"stderr  :\n{ result.stderr     }", success = None, back = back + 1 )
        return result


    def installer_sync(self, command, shell=False, back=0):
        """
        sync仕様インストーラー。インストーラー以外にも使える。
        args:
            command( str ) : コマンド
            shell( bool ) : コマンドの書き方。Trueだと文字配列で、Falseだと文字列で
            back( int ) : メッセージ微調整用
        """
        self.log_step(f"command: {command}", success=None, back = back + 1)

        # Popenでプロセスを起動し、stdout, stderr をリアルタイムに取得する
        process = subprocess.Popen(
            command,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,  # 行単位でバッファリング
            universal_newlines=True
        )

        # stdoutをリアルタイムでログ出力するためのスレッド
        def log_stdout(pipe):
            for line in iter(pipe.readline, ''):
                self.log_step(line.rstrip(), success = None, back = back )
            pipe.close()

        # stderrも同様にログ出力する（必要に応じて）
        def log_stderr(pipe):
            for line in iter(pipe.readline, ''):
                self.log_step(f"ERR: {line.rstrip()}", success = None, back = back )
            pipe.close()

        stdout_thread = threading.Thread(target=log_stdout, args=(process.stdout,))
        stderr_thread = threading.Thread(target=log_stderr, args=(process.stderr,))
        stdout_thread.start()
        stderr_thread.start()

        # プロセスの終了を待つ
        process.wait()
        stdout_thread.join()
        stderr_thread.join()

        self.log_step(f"result: {process.returncode}", success=None, back = back + 1 )

        # 完了後、出力をまとめて返す場合は communicate() の代わりに、
        # 今回はすでに各行をログ出力しているので、必要に応じて空文字列などを返す
        return subprocess.CompletedProcess(args=command, returncode=process.returncode, stdout="", stderr="")

"""## 2. テスト"""

# @title a. テスト {"form-width":"400px"}
# get_ipython().system( "pip install an_EasyVen" )
# from an_easyven import EasyVen

class TestClass:
    def __init__(self):
        self.debugger = DebugHelper()
        self.debugger.debug_print("TestClassのコンストラクタが呼ばれました。")
        self.debugger.log_step("TestClassのコンストラクタが呼ばれました。", success=True)
        self.debugger.add_entry("テストクラス", "TestClassのコンストラクタが呼ばれました。", success=True)
        self.debugger.add_step("テストクラス", "TestClassのコンストラクタが呼ばれました。")
        self.debugger.display()
        self.debugger.export_log()
        self.debugger.clear()

        # self.even = EasyVen()
        # self.bch_path, self.dst_path, self.cur_path, self.src_path, self.arc_path, self.lcl_path, self.bin_path, self.lib_path = self.even.setup( venv_name = "kohya_env" )



    def test_method(self):
        self.debugger.enable_log_to_file_stdout()
        self.debugger.enable_log_to_file_stderr()
        self.debugger.enable_timestamp()
        self.debugger.enable_silent_mode()
        self.debugger.log_step("にゃにゃにゃふ", char = "🐈")
        self.debugger.log_step("にゃにゃにゃふ", char = "🐈", back = 1)
        self.debugger.add_entry("テストメソッド", "test_methodが呼ばれました。", success=True)
        ### cmd = [str(self.bin_path / "python"), "-m"]
        ### cmdlist = [ "pip", "--version" ]
        ### conda run -p /content/cEnv/venv/kohya_env/contents python -m pip --version
        ### cmd = [ "conda", "run", "-p", str( self.lcl_path ), "python", "-m" ] ※ 2025/03/25 圧縮&解凍した仮想環境では、conda run は使えないことがわかった
        ### full_cmd = cmdlist
        ### self.debugger.installer( command = cmdlist )
        # self.debugger.what_do_you_do("バカめ!!!", "echo バカめバカめバカめ!!!")
        self.debugger.disable_silent_mode()
        # self.debugger.what_do_you_do("そうはいくか!!!!", "echo ちぇすとぉぉぉぉ!!!")
        result, stdout, stderr = self.debugger.run_command(['/content/cEnv/venv/kohya_env/contents/bin/python', '-m', 'pip', '--version'], stdout = True, stderr = True)
        print( f"result : {result}")
        print( f"stdout : {stdout}")
        print( f"stderr : {stderr}")
        self.debugger.run_command( "ls -l" )
        result, stdout, stderr = self.debugger.run_command("nvcc --version", stdout = True, stderr = True)
        print( f"result : {result}")
        print( f"stdout : {stdout}")
        print( f"stderr : {stderr}")
        if not result:
            for line in stdout.split("\n"):
                if "release" in line:
                    version = line.split(",")[1].strip().split(" ")[1]
                    self.debugger.log_step(f"CUDA バージョン検出: {version}", success=True)
                    break
        result = self.debugger.installer( command = "nvcc --version", shell = True )
        print( f"result.stdout : { result.stdout }" )



if __name__ == "__main__":
    tc1 = TestClass()
    tc1.test_method()

class checktest():
    def __init__(self):
        self.debug = DebugHelper()

    def check_torch_cuda(self):
        """仮想環境内で PyTorch の CUDA 利用可否を確認"""
        # python_path = self.virtual_env_manager.get_python_path()  # 仮想環境の Python パス
        python_path = "/content/drive/MyDrive/venv/kohya_venv/bin/python"
        # python_path = "python"
        # 必要な環境変数を明示的に設定（例: CUDA_HOME, LD_LIBRARY_PATH, PATH）

        command = f"{python_path} -c 'import torch; print(torch.cuda.is_available())'"
        return_code, stdout, stderr = self.debug.run_command(command, stdout=True, stderr=True)

        if return_code == 0 and stdout.strip() == "True":
            self.debug.log_step("✅ PyTorch が CUDA を正しく認識しています", success=True)
            return True
        else:
            self.debug.log_step("⚠️ PyTorch が CUDA を認識できていません", success=False)
            return False

    def check_cupy_cuda(self):
        """仮想環境内で CuPy の CUDA 利用可否を確認"""
        # python_path = self.virtual_env_manager.get_python_path()  # 仮想環境の Python パス
        python_path = "/content/drive/MyDrive/venv/kohya_venv/bin/python"
        # python_path = "python"

        command = f"{python_path} -c 'import cupy; print(cupy.cuda.runtime.getDeviceCount() > 0)'"
        return_code, stdout, stderr = self.debug.run_command(command, stdout=True, stderr=True )

        if return_code == 0 and stdout.strip() == "True":
            self.debug.log_step("✅ CuPy が CUDA を正しく認識しています", success=True)
            return True
        else:
            self.debug.log_step("⚠️ CuPy が CUDA を認識できていません", success=False)
            return False

if __name__ == "__main__":
    ck = checktest()
    ck.check_torch_cuda()
    ck.check_cupy_cuda()