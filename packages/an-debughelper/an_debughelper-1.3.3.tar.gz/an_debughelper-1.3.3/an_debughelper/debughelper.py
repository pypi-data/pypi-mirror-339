# -*- coding: utf-8 -*-
"""DBHL_20250328_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eLRrznIMxoDqqINxUdIC9rTe4dJdF6lY

# DebugHelper
ãƒ‡ãƒãƒƒã‚°ä½œæ¥­ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã€‚


```
2025/01/18 DebugHelper2ã‚’pipåŒ–ã™ã‚‹ãŸã‚ã«ä½œæˆ
2025/01/19 flg_debugã‚’ãªãã™ãŸã‚ã®ä¿®æ­£
2025/02/11 0.2.1 CheckpointManagerè¿½åŠ 
2025/02/12 0.2.2 log_stepæ”¹è‰¯ã€‚å®Ÿè¡Œä¸­ã®ã‚¯ãƒ©ã‚¹ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«ã—ãŸã€‚
2025/02/13 0.2.3 what_do_you_do ã‚’è¿½åŠ ã€‚ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œã‚’é¸æŠã§ãã‚‹ã‚ˆã†ã«ã—ãŸã€‚
2025/02/14 0.2.4 what_do_you_do æ”¹è‰¯ã€‚æˆ»ã‚Šå€¤é–¢ä¿‚ã€‚
2025/02/14 0.2.5 what_do_you_do æ”¹è‰¯ã€‚è¡¨ç¤ºæ–¹æ³•ã€‚
2025/02/14 0.2.7 what_do_you_do æ”¹è‰¯ã€‚ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ©Ÿèƒ½ã€ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—æ©Ÿèƒ½
2025/02/15 0.2.8 ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆæ©Ÿèƒ½æ”¹è‰¯ã€‚ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«åã«ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å…¥ã‚Œã‚‹ã€‚
2025/02/15 0.2.9 log_stepãƒã‚°ä¿®æ­£ã€‚æ•´ç†ã®ãŸã‚ã€ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒƒã‚¯æ•°ã‚’5ã¤ã«åˆ¶é™ã™ã‚‹ã€‚
2025/02/15 0.2.10 log_step æ”¹è‰¯ã€‚å¼•æ•°charã§å†’é ­æ–‡å­—ã®å¹…ã‚’åºƒã’ã‚‹ã€‚
2025/02/16 0.2.11 log_step æ”¹è‰¯ã€‚æˆ»ã‚Šå€¤é–¢ä¿‚ã€‚
2025/02/16 0.2.12 run_command æ”¹è‰¯ã€‚ãƒ­ã‚°ã‚’å‡ºåŠ›ã€‚
2025/02/17 0.2.13 run_command æ”¹è‰¯ã€‚subprocessã‚’åˆ©ç”¨ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
2025/02/17 0.2.14 run_command æ”¹è‰¯ã€‚booleanã ã‘ã§ãªãã€numericã‚‚è¿”ã™ã€‚
2025/02/18 0.2.15 run_command æ”¹è‰¯ã€‚stdoutã‚’ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™ã‚ˆã†ã«ã™ã‚‹ã€‚
2025/02/18 0.3.00 run_command æ”¹è‰¯ã€‚stderrã‚‚ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãå‡ºã™ã‚ˆã†ã«ã™ã‚‹ã€‚
2025/02/23 1.0.0 2ã¤ä»¥ä¸Šã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«DebugHelperã‚’è¨­ç½®ã—ã¦ã‚‚ã€å•é¡Œãªããƒ­ã‚°ã‚’å‡ºåŠ›ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã€‚
2025/02/23 1.0.1 ãƒ­ã‚°å‡ºåŠ›å…ˆä¿®æ­£
2025/02/26 1.0.2 ä»®æƒ³ç’°å¢ƒã‹ã‚‰ã®å‡ºåŠ›ã§ã‚‚ãƒ­ã‚°ã«ã™ã‚‹ã‚ˆã†ã«ã—ãŸã€‚
2025/02/27 1.0.3 ãƒã‚°å–ã‚Š
2025/02/27 1.0.4 ãƒã‚°å–ã‚Š
2025/03/04 1.0.5 ãƒã‚°å–ã‚Š
2025/03/04 1.0.6 ãƒã‚°å–ã‚Š
2025/03/04 1.1.0 run_commandæ”¹è‰¯ã€‚å¼•æ•°syncã‚’å°å…¥
2025/03/21 1.1.1 debugãƒ•ãƒ©ã‚°ã‚’æœ‰åŠ¹åŒ–
2025/03/25 1.2.0 Installer è¿½åŠ 
2025/03/26 1.2.1 ãƒã‚°å–ã‚Š
2025/03/26 1.2.4 Installer ä¿®æ­£
2025/03/27 1.3.0 Installer_sync è¿½åŠ 
2025/03/28 1.3.1 Installer_sync ãƒã‚°ä¿®æ­£
2025/03/28 1.3.2 installer, installer_sync ãƒã‚°ä¿®æ­£
2025/03/31 1.3.3 installer_sync ãƒã‚°ä¿®æ­£
```

# DebugHelper

## 1. åˆæœŸè¨­å®š
"""

# @title a. åˆæœŸå€¤è¨­å®š{"form-width":"400px"}
# @markdown Log_folder, Log_file(ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’è¨˜éŒ²)
log_folder = "/content/drive/MyDrive/log"  # @param {type:"string"}
log_file_stdout = ""  # @param {type:"string", "placeholder":"ä½•ã‚‚å…¥åŠ›ã—ãªã‘ã‚Œã°ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã«ãªã‚Šã¾ã™"}
log_file_stderr = ""  # @param {type:"string", "placeholder":"ä½•ã‚‚å…¥åŠ›ã—ãªã‘ã‚Œã°ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã«ãªã‚Šã¾ã™"}

# @title b. GDriveæ¥ç¶šã¨condacolabè¨­å®š
if __name__ == '__main__':
    get_ipython().system( "pip install an_CondaInitializer" )
    from an_condainitializer import CondaInitializer

    condainitializer = CondaInitializer()

"""## 2. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©"""

# @title a. DebugHelper å®šç¾©{"form-width":"400px"}
import os
import sys
import re
import inspect
import subprocess
import threading
from datetime import datetime
from pathlib import Path

def is_valid_folder_name(name: str) -> bool:
    """
    ãƒ•ã‚©ãƒ«ãƒ€åã¨ã—ã¦ç„¡åŠ¹ãªæ–‡å­—ï¼ˆWindowsã®å ´åˆ: \ / : * ? " < > |ï¼‰ãŒå«ã¾ã‚Œã¦ã„ãªã„ã‹ã€ã¾ãŸã¯ç©ºæ–‡å­—ã§ãªã„ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã€‚
    Linuxã§ã¯ã»ã¨ã‚“ã©ã®æ–‡å­—ãŒæœ‰åŠ¹ã§ã™ãŒã€ã“ã“ã§ã¯ä¾‹ã¨ã—ã¦Windowsã®åˆ¶ç´„ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚
    """
    if not name:
        return False
    # Windowsã§ä½¿ç”¨ã§ããªã„æ–‡å­—ã‚’ãƒã‚§ãƒƒã‚¯
    invalid_chars = r'[\\\/:*?"<>|]'
    return re.search(invalid_chars, name) is None

class DebugHelper:
    def __init__(self, instance_name="default", default_log_folder="/content/drive/MyDrive/log/"):
        """
        DebugHelper ã‚¯ãƒ©ã‚¹
        args:
            instance_name (str): Debugå¯¾è±¡ã¨ãªã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åå‰
            default_log_folder (str): ãƒ­ã‚°ãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹
        """
        self.instance_name = instance_name
        self.debug = True
        self.entries = []  # è¨˜éŒ²ã™ã‚‹ã‚¨ãƒ³ãƒˆãƒªä¸€è¦§
        self.wNo = 1
        self.silent_mode = False  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ Falseï¼ˆå¯¾è©±ãƒ¢ãƒ¼ãƒ‰ï¼‰

        # ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›é–¢é€£
        self.log_to_file = False
        self.log_file_path = None
        self.log_to_file_stdout = False
        self.log_file_path_stdout = None
        self.log_to_file_stderr = False
        self.log_file_path_stderr = None

        self.timestamp = False  # ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—æœ‰åŠ¹åŒ–

        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ­ã‚°ãƒ•ã‚©ãƒ«ãƒ€ã®è¨­å®š
        # å¼•æ•°ã§å—ã‘å–ã£ãŸ default_log_folder ãŒç„¡åŠ¹ãªå ´åˆã¯ "Logs" ã‚’ä½¿ç”¨ã™ã‚‹
        if default_log_folder is None:
            self.default_log_folder = Path("/content/log")
        else:
            self.default_log_folder = Path(default_log_folder)
        try:
            Path(self.default_log_folder).mkdir(parents=True, exist_ok=True)
        except Exception as e:
            self.debug.log_step( f"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ­ã‚°ãƒ•ã‚©ãƒ«ãƒ€ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: {e}", char = "âš ï¸" )
            raise Exception(f"ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ­ã‚°ãƒ•ã‚©ãƒ«ãƒ€ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
        self.log_step( f"default_log_folder : { self.default_log_folder }")

    def enable_debug(self):
        self.debug = True

    def disable_debug(self):
        self.debug = False

    def enable_silent_mode(self):
        self.silent_mode = True

    def disable_silent_mode(self):
        self.silent_mode = False

    def prune_log_files(self, log_file_path, max_files=5):
        # æŒ‡å®šã•ã‚ŒãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã® *.log ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æœ€æ–° max_files å€‹ä»¥å¤–å‰Šé™¤ã™ã‚‹
        log_path = log_file_path.parent
        self.debug_print(f"log_path: {log_path}")
        files = list(log_path.glob("*.log"))
        if len(files) <= max_files:
            return
        files.sort(key=lambda f: f.stat().st_mtime)
        for f in files[:-max_files]:
            try:
                f.unlink()
                print(f"Deleted old log file: {f}")
            except Exception as e:
                print(f"Error deleting {f}: {e}")

    def enable_log_to_file_stdout(self, log_file_path=None):
        """æ¨™æº–å‡ºåŠ›ã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®å‡ºåŠ›ã‚’æœ‰åŠ¹ã«ã™ã‚‹ï¼ˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã”ã¨ã«ç‹¬ç«‹ã—ãŸãƒ‘ã‚¹ã‚’ä½¿ç”¨ï¼‰"""
        if log_file_path is None:
            # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ­ã‚°ãƒ•ã‚©ãƒ«ãƒ€ã‚’åˆ©ç”¨
            log_file_path = self.default_log_folder
        else:
            log_file_path = Path(log_file_path)
        self.log_to_file_stdout = True
        self.log_file_path_stdout = log_file_path
        if self.log_file_path_stdout.is_dir():
            # filename = "Stdout_Rec_" + datetime.now().strftime("%Y_%m_%d_%H_%M_%S") + ".log"
            filename = f"Stdout_Rec_{self.instance_name}_{datetime.now().strftime('%Y_%m_%d_%H_%M_%S_%f')}.log"
            self.log_file_path_stdout = self.log_file_path_stdout / filename
            self.prune_log_files(self.log_file_path_stdout)
        elif self.log_file_path_stdout.is_file():
            pass
        else:
            self.debug_print(f"âš ï¸ ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ (stdout) ãŒä¸æ­£ã§ã™: {self.log_file_path_stdout}")
            sys.exit(1)
        self.debug_print(f"âœ… [{self.instance_name}] æ¨™æº–å‡ºåŠ›ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã‚’æœ‰åŠ¹åŒ–: {self.log_file_path_stdout}")

    def enable_log_to_file_stderr(self, log_file_path=None):
        """æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®å‡ºåŠ›ã‚’æœ‰åŠ¹ã«ã™ã‚‹ï¼ˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã”ã¨ã«ç‹¬ç«‹ã—ãŸãƒ‘ã‚¹ã‚’ä½¿ç”¨ï¼‰"""
        if log_file_path is None:
            log_file_path = self.default_log_folder
        else:
            log_file_path = Path(log_file_path)
        self.log_to_file_stderr = True
        self.log_file_path_stderr = log_file_path
        if self.log_file_path_stderr.is_dir():
            #filename = "Stderr_Rec_" + datetime.now().strftime("%Y_%m_%d_%H_%M_%S") + ".log"
            filename = f"Stderr_Rec_{self.instance_name}_{datetime.now().strftime('%Y_%m_%d_%H_%M_%S_%f')}.log"
            self.log_file_path_stderr = self.log_file_path_stderr / filename
            self.prune_log_files(self.log_file_path_stderr)
        elif self.log_file_path_stderr.is_file():
            pass
        else:
            self.debug_print(f"âš ï¸ ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ (stderr) ãŒä¸æ­£ã§ã™: {self.log_file_path_stderr}")
            sys.exit(1)
        self.debug_print(f"âœ… [{self.instance_name}] æ¨™æº–ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã‚’æœ‰åŠ¹åŒ–: {self.log_file_path_stderr}")

    def disable_log_to_file(self):
        self.log_to_file = False
        self.log_to_file_stdout = False
        self.log_to_file_stderr = False
        self.debug_print("ğŸ›‘ ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã‚’ç„¡åŠ¹åŒ–")

    def enable_timestamp(self):
        self.timestamp = True

    def disable_timestamp(self):
        self.timestamp = False

    def start_step(self, step_name):
        print(f"ğŸ”¹ ãƒã‚§ãƒƒã‚¯é–‹å§‹: {step_name}")
        self.entries.append({"ã‚¹ãƒ†ãƒƒãƒ—": step_name, "å†…å®¹": "é€²è¡Œä¸­", "çµæœ": "âš ï¸ é€²è¡Œä¸­"})

    def add_step(self, step_key, description):
        if step_key not in self.entries:
            self.entries.append({
                "ã‚¹ãƒ†ãƒƒãƒ—": step_key,
                "å‡¦ç†å†…å®¹": description,
                "çµæœ": "æœªå®Ÿè¡Œ"
            })
        else:
            print(f"âš ï¸ æ‰‹é † {step_key} ã¯ã™ã§ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚")

    def complete_step(self, step_name, success=True):
        for entry in self.entries:
            if entry.get("ã‚¹ãƒ†ãƒƒãƒ—") == step_name:
                entry["çµæœ"] = "âœ… æˆåŠŸ" if success else "âŒ å¤±æ•—"
                return
        print(f"âš ï¸ ã‚¹ãƒ†ãƒƒãƒ— `{step_name}` ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")

    def debug_print(self, *args, end="\n", back=0):
        cls_name, method_name = self.get_current_method_info(back=back)
        timestamp_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S") if self.timestamp else ""
        message = f"{timestamp_str} [{cls_name}.{method_name}] " + " ".join(map(str, args))
        if self.debug:
            print(message, end=end)

        # stdoutç”¨ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸æ›¸ãè¾¼ã¿ï¼ˆå„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã”ã¨ï¼‰
        if self.log_to_file_stdout and self.log_file_path_stdout:
            try:
                with open(self.log_file_path_stdout, "a", encoding="utf-8") as log_file:
                    log_file.write(message + end)
            except Exception as e:
                print(f"ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿ã‚¨ãƒ©ãƒ¼ (stdout): {e}")

    def log_step(self, *args, end="\n", success=None, char=None, back=0):
        if char is None:
            if success is True:
                full_message = "âœ… " + " ".join(map(str, args))
            elif success is False:
                full_message = "âŒ " + " ".join(map(str, args))
            else:
                full_message = "ğŸ”¹ " + " ".join(map(str, args))
        else:
            full_message = char + " " + " ".join(map(str, args))
        self.debug_print(full_message, end=end, back=back+1)

    def what_do_you_do(self, message, command):
        length = 100
        self.debug_print("\n" + "=" * length, back=1)
        mode_msg = "Silent mode: å³å®Ÿè¡Œ" if self.silent_mode else "Action mode: ã‚³ãƒãƒ³ãƒ‰å…¥åŠ›"
        self.debug_print(f"\nğŸ”¹ğŸ”¹ğŸ”¹ğŸ”¹ğŸ”¹ No.{self.wNo} {mode_msg} ğŸ”¹ğŸ”¹ğŸ”¹ğŸ”¹ğŸ”¹\n" + "-" * length, back=1)
        self.wNo += 1
        self.debug_print(f"\nğŸ®èª¬æ˜\n{message}", back=1)
        self.debug_print(f"\nğŸ¤”ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n{command}\n" + "-" * length, back=1)
        if not self.silent_mode:
            self.debug_print("\nğŸ“ ã‚³ãƒãƒ³ãƒ‰\n1ï¸âƒ£ å®Ÿè¡Œã™ã‚‹ 2ï¸âƒ£ ã‚„ã‚ã¦ãŠã 3ï¸âƒ£ ã‚³ãƒãƒ³ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹ 4ï¸âƒ£ ã“ã“ã§ä¸­æ–­", back=1)
            choice = input("\nğŸ”¹ ã©ã†ã™ã‚‹ï¼Ÿ (1/2/3/4): ").strip()
            if choice == "1":
                pass
            elif choice == "2":
                self.debug_print("\nğŸ›‘ æ“ä½œã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚", back=1)
                return None, None
            elif choice == "3":
                command = input("\nğŸ’¬ æ–°ã—ã„ã‚³ãƒãƒ³ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„: ").strip()
            elif choice == "4":
                self.debug_print("\nğŸ‘‹ ä¸­æ–­ã—ã¾ã™ã€‚", back=1)
                sys.exit(1)
            else:
                self.debug_print("\nâš ï¸ ç„¡åŠ¹ãªé¸æŠè‚¢ã§ã™", back=1)
                return None, None
        self.debug_print(f"\nğŸš€ å®Ÿè¡Œä¸­:\n{command}", back=1)
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            self.debug_print("\nâœ… ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œå®Œäº†\n" + "-" * length, back=1)
            self.debug_print(f"\nstdout:\n{result.stdout}", back=1)
            self.debug_print(f"\nstderr:\n{result.stderr}\n" + "=" * length + "\n\n\n", back=1)
            return result.stdout, result.stderr
        except Exception as e:
            self.debug_print(f"\nâŒ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}", back=1)
            return None, None

    def get_current_method_info(self, back=0):
        frame = inspect.currentframe()
        for _ in range(2 + back):
            if frame is None or frame.f_back is None:
                break
            frame = frame.f_back
        method_name = frame.f_code.co_name if frame else "Unknown"
        cls_name = None
        if frame and 'self' in frame.f_locals:
            cls_name = frame.f_locals['self'].__class__.__name__
        return cls_name, method_name

    def add_entry(self, category, description, success=None):
        status = "âœ… æˆåŠŸ" if success is True else "âŒ å¤±æ•—" if success is False else "âš ï¸ æœªåˆ¤å®š"
        entry = {"ã‚«ãƒ†ã‚´ãƒª": category, "å‡¦ç†å†…å®¹": description, "çµæœ": status}
        self.entries.append(entry)

    def display(self):
        """ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã¨stdoutç”¨ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«è¡¨ç¤ºã™ã‚‹"""
        output_lines = []
        output_lines.append("\nğŸ”¹ **ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ** ğŸ”¹")
        for idx, entry in enumerate(self.entries, start=1):
            category = entry.get("ã‚«ãƒ†ã‚´ãƒª", entry.get("ã‚¹ãƒ†ãƒƒãƒ—", "ä¸æ˜"))
            description = entry.get("å‡¦ç†å†…å®¹", entry.get("å†…å®¹", "èª¬æ˜ãªã—"))
            result = entry.get("çµæœ", "âš ï¸ æœªåˆ¤å®š")
            line = f"Step {idx}: [{category}] {description} â†’ {result}"
            output_lines.append(line)

        for line in output_lines:
            print(line)

        if self.log_to_file_stdout and self.log_file_path_stdout:
            try:
                with open(self.log_file_path_stdout, "a", encoding="utf-8") as f:
                    for line in output_lines:
                        f.write(line + "\n")
            except Exception as e:
                self.debug_print(f"stdoutãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®å‡ºåŠ›ã‚¨ãƒ©ãƒ¼: {e}")

    def export_log(self):
        """ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’stdoutç”¨ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã™ã‚‹"""
        if not self.log_file_path_stdout:
            self.debug_print("âš ï¸ stdoutãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚", back=1)
            return
        try:
            with open(self.log_file_path_stdout, "w", encoding="utf-8") as f:
                for idx, entry in enumerate(self.entries, start=1):
                    category = entry.get("ã‚«ãƒ†ã‚´ãƒª", entry.get("ã‚¹ãƒ†ãƒƒãƒ—", "ä¸æ˜"))
                    description = entry.get("å‡¦ç†å†…å®¹", entry.get("å†…å®¹", "èª¬æ˜ãªã—"))
                    result = entry.get("çµæœ", "âš ï¸ æœªåˆ¤å®š")
                    f.write(f"Step {idx}: [{category}] {description} â†’ {result}\n")
            print(f"âœ… ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ {self.log_file_path_stdout} ã«ä¿å­˜ã—ã¾ã—ãŸã€‚")
        except Exception as e:
            self.debug_print(f"stdoutãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}", back=1)

    def clear(self):
        self.entries = []
        self.debug_print("âœ… ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚", back=1)

    # --- ä»¥ä¸‹ã€æ—¢å­˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãã®ã¾ã¾ ---

    def get_cuda_version(self):
        """
        nvcc --version ã®å‡ºåŠ›ã‹ã‚‰ CUDA ã®ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å–å¾—ã™ã‚‹ã€‚
        ä¾‹: "Cuda compilation tools, release 12.5, V12.5.82" ãªã‚‰ "12.5" ã‚’è¿”ã™ã€‚
        """
        try:
            output = subprocess.check_output("nvcc --version", shell=True, text=True)
            for line in output.splitlines():
                if "release" in line:
                    # ä¾‹: "Cuda compilation tools, release 12.5, V12.5.82"
                    ver = line.split("release")[1].split(",")[0].strip()
                    return ver
            self.log_step("CUDA ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå‡ºåŠ›ã‹ã‚‰å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ", success=False)
        except Exception as e:
            self.log_step(f"CUDA ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®å–å¾—ã«å¤±æ•—: {e}", success=False)
        return None

    # def run_command(self, command, timeout=900, back=1, stdout=False, stderr=False, env=None, env_on = True ):
    #     """
    #     ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§å®Ÿè¡Œã—ã€ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã¨ãã‚Œãã‚Œã®ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã«å‡ºåŠ›ã™ã‚‹ã€‚

    #     Args:
    #         command (str): å®Ÿè¡Œã™ã‚‹ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰
    #         timeout (int): ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ï¼ˆç§’ï¼‰
    #         back (int): ãƒ­ã‚°å‡ºåŠ›ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    #         stdout (bool): True ã®å ´åˆã€æ¨™æº–å‡ºåŠ›ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã™ã‚‹
    #         stderr (bool): True ã®å ´åˆã€æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã™ã‚‹
    #         env (dict): ã‚µãƒ–ãƒ—ãƒ­ã‚»ã‚¹ã§ä½¿ç”¨ã™ã‚‹ç’°å¢ƒå¤‰æ•°ã€‚Noneã®å ´åˆã¯ã€nvcc ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å¿œã˜ãŸç’°å¢ƒå¤‰æ•°ãŒè‡ªå‹•ä½œæˆã•ã‚Œã‚‹ã€‚

    #     Returns:
    #         tuple: (çµ‚äº†ã‚³ãƒ¼ãƒ‰, æ¨™æº–å‡ºåŠ› (str or None), æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ› (str or None))
    #     """
    #     # env ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã‘ã‚Œã°ã€è‡ªå‹•ã§ CUDA ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«å¯¾å¿œã—ãŸç’°å¢ƒå¤‰æ•°ã‚’ä½œæˆ
    #     if env is None:
    #         cuda_ver = self.get_cuda_version()
    #         if cuda_ver is not None:
    #             env = os.environ.copy()
    #             # ã“ã“ã§ã¯ nvcc ã®å‡ºåŠ›ã«åˆã‚ã›ã¦ "/usr/local/cuda-<version>" ã‚’ä½¿ç”¨ã™ã‚‹å‰æ
    #             # â€»Colab ã§ã¯ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ç­‰ã§ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€å®Ÿéš›ã®ãƒ‘ã‚¹ã«åˆã‚ã›ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆã¯èª¿æ•´ã™ã‚‹
    #             env["CUDA_HOME"] = f"/usr/local/cuda-{cuda_ver}"
    #             env["PATH"] = f"/usr/local/cuda-{cuda_ver}/bin:" + env.get("PATH", "")
    #             env["LD_LIBRARY_PATH"] = f"/usr/local/cuda-{cuda_ver}/lib64:" + env.get("LD_LIBRARY_PATH", "")
    #         else:
    #             env = os.environ.copy()
    #             self.log_step("nvcc ã‹ã‚‰ CUDA ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå–å¾—ã§ããªã‹ã£ãŸãŸã‚ã€æ—¢å­˜ã®ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ç”¨ã—ã¾ã™", success=False)

    #     self.log_step(f"ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ: {command}", success=None, back=back)
    #     stdout_data, stderr_data = [], []

    #     def monitor_output(stream, log_func, capture_list, log_file):
    #         try:
    #             for line in iter(stream.readline, ''):
    #                 log_func(line)
    #                 sys.stdout.flush()
    #                 capture_list.append(line)
    #                 if log_file:
    #                     log_file.write(line)
    #                     log_file.flush()
    #         except Exception as e:
    #             self.log_step(f"ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ä¸­ã‚¨ãƒ©ãƒ¼: {str(e)}", success=False, back=back, char="ğŸ’¥")

    #     try:
    #         process = subprocess.Popen(
    #             command,
    #             shell=True,
    #             stdout=subprocess.PIPE,
    #             stderr=subprocess.PIPE,
    #             text=True,
    #             bufsize=1,
    #             env=env
    #         )

    #         if self.log_to_file_stdout and self.log_file_path_stdout:
    #             log_file_stdout = open(self.log_file_path_stdout, "a", encoding="utf-8")
    #         else:
    #             log_file_stdout = None

    #         if self.log_to_file_stderr and self.log_file_path_stderr:
    #             log_file_stderr = open(self.log_file_path_stderr, "a", encoding="utf-8")
    #         else:
    #             log_file_stderr = None

    #         stdout_thread = threading.Thread(target=monitor_output, args=(process.stdout, sys.stdout.write, stdout_data, log_file_stdout))
    #         stderr_thread = threading.Thread(target=monitor_output, args=(process.stderr, sys.stderr.write, stderr_data, log_file_stderr))

    #         stdout_thread.start()
    #         stderr_thread.start()

    #         process.wait(timeout=timeout)
    #         stdout_thread.join()
    #         stderr_thread.join()

    #         if log_file_stdout:
    #             log_file_stdout.close()
    #         if log_file_stderr:
    #             log_file_stderr.close()

    #         stdout_result = ''.join(stdout_data) if stdout else None
    #         stderr_result = ''.join(stderr_data) if stderr else None

    #         if process.returncode == 0:
    #             self.log_step(f"ã‚³ãƒãƒ³ãƒ‰æˆåŠŸ: {command} (ã‚³ãƒ¼ãƒ‰: {process.returncode})", success=True, back=back)
    #         else:
    #             self.log_step(f"ã‚³ãƒãƒ³ãƒ‰å¤±æ•—: {command} (ã‚³ãƒ¼ãƒ‰: {process.returncode})", success=False, back=back)

    #         return process.returncode, stdout_result, stderr_result

    #     except subprocess.TimeoutExpired:
    #         self.log_step(f"â³ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {command}", char="âš ï¸", back=back)
    #         return -1, None, None
    #     except Exception as e:
    #         self.log_step(f"ğŸ’¥ å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {command}\n{str(e)}", success=False, back=back)
    #         return -2, None, None

    # ä»¥é™ã¯ä»–ã®ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆdebug_print, log_step, etc.ï¼‰ã¯ãã®ã¾ã¾
    def run_command(self, command, timeout=900, back=1, stdout=False, stderr=False, env=None, env_on=True, sync=True):
        """
        ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã€çµæœã‚’è¿”ã™ã€‚

        Args:
            command (str): å®Ÿè¡Œã™ã‚‹ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰
            timeout (int): ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚é–“ï¼ˆç§’ï¼‰
            stdout (bool): True ã®å ´åˆã€æ¨™æº–å‡ºåŠ›ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã™ã‚‹
            stderr (bool): True ã®å ´åˆã€æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ›ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã™ã‚‹
            sync (bool): Trueãªã‚‰åŒæœŸå‡¦ç†(subprocess.run)ã‚’ä½¿ç”¨ã—ã€Falseãªã‚‰éåŒæœŸå‡¦ç†(Popen+ã‚¹ãƒ¬ãƒƒãƒ‰)ã‚’ä½¿ç”¨ã™ã‚‹
            ãã®ä»–ã®å¼•æ•°ã¯å¾“æ¥é€šã‚Š

        Returns:
            tuple: (çµ‚äº†ã‚³ãƒ¼ãƒ‰, æ¨™æº–å‡ºåŠ› (str or None), æ¨™æº–ã‚¨ãƒ©ãƒ¼å‡ºåŠ› (str or None))
        """
        # å¿…è¦ãªç’°å¢ƒå¤‰æ•°ã®è¨­å®šã¯ãã®ã¾ã¾
        if env is None:
            cuda_ver = self.get_cuda_version()
            if cuda_ver is not None:
                env = os.environ.copy()
                env["CUDA_HOME"] = f"/usr/local/cuda-{cuda_ver}"
                env["PATH"] = f"/usr/local/cuda-{cuda_ver}/bin:" + env.get("PATH", "")
                env["LD_LIBRARY_PATH"] = f"/usr/local/cuda-{cuda_ver}/lib64:" + env.get("LD_LIBRARY_PATH", "")
            else:
                env = os.environ.copy()
                self.log_step("nvcc ã‹ã‚‰ CUDA ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå–å¾—ã§ããªã‹ã£ãŸãŸã‚ã€æ—¢å­˜ã®ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ç”¨ã—ã¾ã™", success=False)

        self.log_step(f"ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ: {command}", success=None, back=back)

        if sync:
            # åŒæœŸå‡¦ç†: subprocess.run ã‚’åˆ©ç”¨
            try:
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                    env=env
                )
                # åŒæœŸå‡¦ç†ã®å ´åˆã¯ã€å‡ºåŠ›ã¯ã™ã¹ã¦ result.stdout/result.stderr ã«ã‚ã‚‹
                if result.returncode == 0:
                    self.log_step(f"ã‚³ãƒãƒ³ãƒ‰æˆåŠŸ: {command} (ã‚³ãƒ¼ãƒ‰: {result.returncode})", success=True, back=back)
                else:
                    self.log_step(f"ã‚³ãƒãƒ³ãƒ‰å¤±æ•—: {command} (ã‚³ãƒ¼ãƒ‰: {result.returncode})", success=False, back=back)
                return result.returncode, result.stdout if stdout else None, result.stderr if stderr else None
            except subprocess.TimeoutExpired:
                self.log_step(f"â³ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {command}", char="âš ï¸", back=back)
                return -1, None, None
            except Exception as e:
                self.log_step(f"ğŸ’¥ å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {command}\n{str(e)}", success=False, back=back)
                return -2, None, None
        else:
            # éåŒæœŸå‡¦ç†: ç¾åœ¨ã® Popen ã¨ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½¿ã†å®Ÿè£…
            stdout_data, stderr_data = [], []

            def monitor_output(stream, log_func, capture_list, log_file):
                try:
                    for line in iter(stream.readline, ''):
                        log_func(line)
                        sys.stdout.flush()
                        capture_list.append(line)
                        if log_file:
                            log_file.write(line)
                            log_file.flush()
                except Exception as e:
                    self.log_step(f"ã‚¹ãƒˆãƒªãƒ¼ãƒ å‡¦ç†ä¸­ã‚¨ãƒ©ãƒ¼: {str(e)}", success=False, back=back, char="ğŸ’¥")

            try:
                process = subprocess.Popen(
                    command,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    env=env
                )

                if self.log_to_file_stdout and self.log_file_path_stdout:
                    log_file_stdout = open(self.log_file_path_stdout, "a", encoding="utf-8")
                else:
                    log_file_stdout = None

                if self.log_to_file_stderr and self.log_file_path_stderr:
                    log_file_stderr = open(self.log_file_path_stderr, "a", encoding="utf-8")
                else:
                    log_file_stderr = None

                stdout_thread = threading.Thread(target=monitor_output, args=(process.stdout, sys.stdout.write, stdout_data, log_file_stdout))
                stderr_thread = threading.Thread(target=monitor_output, args=(process.stderr, sys.stderr.write, stderr_data, log_file_stderr))

                stdout_thread.start()
                stderr_thread.start()

                process.wait(timeout=timeout)
                stdout_thread.join()
                stderr_thread.join()

                if log_file_stdout:
                    log_file_stdout.close()
                if log_file_stderr:
                    log_file_stderr.close()

                stdout_result = ''.join(stdout_data) if stdout else None
                stderr_result = ''.join(stderr_data) if stderr else None

                if process.returncode == 0:
                    self.log_step(f"ã‚³ãƒãƒ³ãƒ‰æˆåŠŸ: {command} (ã‚³ãƒ¼ãƒ‰: {process.returncode})", success=True, back=back)
                else:
                    self.log_step(f"ã‚³ãƒãƒ³ãƒ‰å¤±æ•—: {command} (ã‚³ãƒ¼ãƒ‰: {process.returncode})", success=False, back=back)

                return process.returncode, stdout_result, stderr_result

            except subprocess.TimeoutExpired:
                self.log_step(f"â³ ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: {command}", char="âš ï¸", back=back)
                return -1, None, None
            except Exception as e:
                self.log_step(f"ğŸ’¥ å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {command}\n{str(e)}", success=False, back=back)
                return -2, None, None


    def installer( self, command, shell = False, back = 0 ):
        """
        sã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ©ãƒ¼ã€‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ©ãƒ¼ä»¥å¤–ã«ã‚‚ä½¿ãˆã‚‹ã€‚
        args:
            command( str ) : ã‚³ãƒãƒ³ãƒ‰
            shell( bool ) : ã‚³ãƒãƒ³ãƒ‰ã®æ›¸ãæ–¹ã€‚Trueã ã¨æ–‡å­—é…åˆ—ã§ã€Falseã ã¨æ–‡å­—åˆ—ã§
            back( int ) : ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¾®èª¿æ•´ç”¨
        """
        self.log_step( f"command : { command }", success = None, back = back + 1 )
        result = subprocess.run( command, shell = shell, capture_output=True, text=True )
        self.log_step( f"result  : { result.returncode }", success = None, back = back + 1 )
        self.log_step( f"stdout  :\n{ result.stdout     }", success = None, back = back + 1 )
        self.log_step( f"stderr  :\n{ result.stderr     }", success = None, back = back + 1 )
        return result


    def installer_sync(self, command, shell=False, back=0):
        """
        syncä»•æ§˜ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ©ãƒ¼ã€‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ©ãƒ¼ä»¥å¤–ã«ã‚‚ä½¿ãˆã‚‹ã€‚
        args:
            command( str ) : ã‚³ãƒãƒ³ãƒ‰
            shell( bool ) : ã‚³ãƒãƒ³ãƒ‰ã®æ›¸ãæ–¹ã€‚Trueã ã¨æ–‡å­—é…åˆ—ã§ã€Falseã ã¨æ–‡å­—åˆ—ã§
            back( int ) : ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¾®èª¿æ•´ç”¨
        """
        self.log_step(f"command: {command}", success=None, back = back + 1)

        # Popenã§ãƒ—ãƒ­ã‚»ã‚¹ã‚’èµ·å‹•ã—ã€stdout, stderr ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã«å–å¾—ã™ã‚‹
        process = subprocess.Popen(
            command,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,  # è¡Œå˜ä½ã§ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°
            universal_newlines=True
        )

        # stdoutã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ãƒ­ã‚°å‡ºåŠ›ã™ã‚‹ãŸã‚ã®ã‚¹ãƒ¬ãƒƒãƒ‰
        def log_stdout(pipe):
            for line in iter(pipe.readline, ''):
                self.log_step(line.rstrip(), success = None, back = back )
            pipe.close()

        # stderrã‚‚åŒæ§˜ã«ãƒ­ã‚°å‡ºåŠ›ã™ã‚‹ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
        def log_stderr(pipe):
            for line in iter(pipe.readline, ''):
                self.log_step(f"ERR: {line.rstrip()}", success = None, back = back )
            pipe.close()

        stdout_thread = threading.Thread(target=log_stdout, args=(process.stdout,))
        stderr_thread = threading.Thread(target=log_stderr, args=(process.stderr,))
        stdout_thread.start()
        stderr_thread.start()

        # ãƒ—ãƒ­ã‚»ã‚¹ã®çµ‚äº†ã‚’å¾…ã¤
        process.wait()
        stdout_thread.join()
        stderr_thread.join()

        self.log_step(f"result: {process.returncode}", success=None, back = back + 1 )

        # å®Œäº†å¾Œã€å‡ºåŠ›ã‚’ã¾ã¨ã‚ã¦è¿”ã™å ´åˆã¯ communicate() ã®ä»£ã‚ã‚Šã«ã€
        # ä»Šå›ã¯ã™ã§ã«å„è¡Œã‚’ãƒ­ã‚°å‡ºåŠ›ã—ã¦ã„ã‚‹ã®ã§ã€å¿…è¦ã«å¿œã˜ã¦ç©ºæ–‡å­—åˆ—ãªã©ã‚’è¿”ã™
        return subprocess.CompletedProcess(args=command, returncode=process.returncode, stdout="", stderr="")

"""## 2. ãƒ†ã‚¹ãƒˆ"""

# @title a. ãƒ†ã‚¹ãƒˆ {"form-width":"400px"}
# get_ipython().system( "pip install an_EasyVen" )
# from an_easyven import EasyVen

class TestClass:
    def __init__(self):
        self.debugger = DebugHelper()
        self.debugger.debug_print("TestClassã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚")
        self.debugger.log_step("TestClassã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚", success=True)
        self.debugger.add_entry("ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹", "TestClassã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚", success=True)
        self.debugger.add_step("ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹", "TestClassã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚")
        self.debugger.display()
        self.debugger.export_log()
        self.debugger.clear()

        # self.even = EasyVen()
        # self.bch_path, self.dst_path, self.cur_path, self.src_path, self.arc_path, self.lcl_path, self.bin_path, self.lib_path = self.even.setup( venv_name = "kohya_env" )



    def test_method(self):
        self.debugger.enable_log_to_file_stdout()
        self.debugger.enable_log_to_file_stderr()
        self.debugger.enable_timestamp()
        self.debugger.enable_silent_mode()
        self.debugger.log_step("ã«ã‚ƒã«ã‚ƒã«ã‚ƒãµ", char = "ğŸˆ")
        self.debugger.log_step("ã«ã‚ƒã«ã‚ƒã«ã‚ƒãµ", char = "ğŸˆ", back = 1)
        self.debugger.add_entry("ãƒ†ã‚¹ãƒˆãƒ¡ã‚½ãƒƒãƒ‰", "test_methodãŒå‘¼ã°ã‚Œã¾ã—ãŸã€‚", success=True)
        ### cmd = [str(self.bin_path / "python"), "-m"]
        ### cmdlist = [ "pip", "--version" ]
        ### conda run -p /content/cEnv/venv/kohya_env/contents python -m pip --version
        ### cmd = [ "conda", "run", "-p", str( self.lcl_path ), "python", "-m" ] â€» 2025/03/25 åœ§ç¸®&è§£å‡ã—ãŸä»®æƒ³ç’°å¢ƒã§ã¯ã€conda run ã¯ä½¿ãˆãªã„ã“ã¨ãŒã‚ã‹ã£ãŸ
        ### full_cmd = cmdlist
        ### self.debugger.installer( command = cmdlist )
        # self.debugger.what_do_you_do("ãƒã‚«ã‚!!!", "echo ãƒã‚«ã‚ãƒã‚«ã‚ãƒã‚«ã‚!!!")
        self.debugger.disable_silent_mode()
        # self.debugger.what_do_you_do("ãã†ã¯ã„ãã‹!!!!", "echo ã¡ã‡ã™ã¨ã‰ã‰ã‰ã‰!!!")
        result, stdout, stderr = self.debugger.run_command(['/content/cEnv/venv/kohya_env/contents/bin/python', '-m', 'pip', '--version'], stdout = True, stderr = True)
        print( f"result : {result}")
        print( f"stdout : {stdout}")
        print( f"stderr : {stderr}")
        self.debugger.run_command( "ls -l" )
        result, stdout, stderr = self.debugger.run_command("nvcc --version", stdout = True, stderr = True)
        print( f"result : {result}")
        print( f"stdout : {stdout}")
        print( f"stderr : {stderr}")
        if not result:
            for line in stdout.split("\n"):
                if "release" in line:
                    version = line.split(",")[1].strip().split(" ")[1]
                    self.debugger.log_step(f"CUDA ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ¤œå‡º: {version}", success=True)
                    break
        result = self.debugger.installer( command = "nvcc --version", shell = True )
        print( f"result.stdout : { result.stdout }" )



if __name__ == "__main__":
    tc1 = TestClass()
    tc1.test_method()

class checktest():
    def __init__(self):
        self.debug = DebugHelper()

    def check_torch_cuda(self):
        """ä»®æƒ³ç’°å¢ƒå†…ã§ PyTorch ã® CUDA åˆ©ç”¨å¯å¦ã‚’ç¢ºèª"""
        # python_path = self.virtual_env_manager.get_python_path()  # ä»®æƒ³ç’°å¢ƒã® Python ãƒ‘ã‚¹
        python_path = "/content/drive/MyDrive/venv/kohya_venv/bin/python"
        # python_path = "python"
        # å¿…è¦ãªç’°å¢ƒå¤‰æ•°ã‚’æ˜ç¤ºçš„ã«è¨­å®šï¼ˆä¾‹: CUDA_HOME, LD_LIBRARY_PATH, PATHï¼‰

        command = f"{python_path} -c 'import torch; print(torch.cuda.is_available())'"
        return_code, stdout, stderr = self.debug.run_command(command, stdout=True, stderr=True)

        if return_code == 0 and stdout.strip() == "True":
            self.debug.log_step("âœ… PyTorch ãŒ CUDA ã‚’æ­£ã—ãèªè­˜ã—ã¦ã„ã¾ã™", success=True)
            return True
        else:
            self.debug.log_step("âš ï¸ PyTorch ãŒ CUDA ã‚’èªè­˜ã§ãã¦ã„ã¾ã›ã‚“", success=False)
            return False

    def check_cupy_cuda(self):
        """ä»®æƒ³ç’°å¢ƒå†…ã§ CuPy ã® CUDA åˆ©ç”¨å¯å¦ã‚’ç¢ºèª"""
        # python_path = self.virtual_env_manager.get_python_path()  # ä»®æƒ³ç’°å¢ƒã® Python ãƒ‘ã‚¹
        python_path = "/content/drive/MyDrive/venv/kohya_venv/bin/python"
        # python_path = "python"

        command = f"{python_path} -c 'import cupy; print(cupy.cuda.runtime.getDeviceCount() > 0)'"
        return_code, stdout, stderr = self.debug.run_command(command, stdout=True, stderr=True )

        if return_code == 0 and stdout.strip() == "True":
            self.debug.log_step("âœ… CuPy ãŒ CUDA ã‚’æ­£ã—ãèªè­˜ã—ã¦ã„ã¾ã™", success=True)
            return True
        else:
            self.debug.log_step("âš ï¸ CuPy ãŒ CUDA ã‚’èªè­˜ã§ãã¦ã„ã¾ã›ã‚“", success=False)
            return False

if __name__ == "__main__":
    ck = checktest()
    ck.check_torch_cuda()
    ck.check_cupy_cuda()