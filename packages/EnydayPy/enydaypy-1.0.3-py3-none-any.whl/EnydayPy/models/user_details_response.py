# coding: utf-8

"""
    Enyday API

    This API allows integration with the Enyday platform, providing access to user authentication, user details, authorization data, address information, and power consumption data. It helps in integrating Enyday into platforms like Home Assistant. 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from EnydayPy.models.user_details_response_roles import UserDetailsResponseRoles
from EnydayPy.models.user_details_response_user_btms import UserDetailsResponseUserBtms
from typing import Optional, Set
from typing_extensions import Self

class UserDetailsResponse(BaseModel):
    """
    UserDetailsResponse
    """ # noqa: E501
    id: Optional[StrictInt] = None
    first_name: Optional[StrictStr] = Field(default=None, alias="firstName")
    last_name: Optional[StrictStr] = Field(default=None, alias="lastName")
    email: Optional[StrictStr] = None
    last_changed_password: Optional[StrictStr] = None
    complete_profile: Optional[StrictStr] = Field(default=None, alias="completeProfile")
    has_user_registered_his_devices: Optional[StrictBool] = Field(default=None, alias="hasUserRegisteredHisDevices")
    nr_of_devices: Optional[StrictInt] = Field(default=None, alias="nrOfDevices")
    roles: Optional[List[UserDetailsResponseRoles]] = None
    eloverblik_customer_key: Optional[StrictStr] = None
    user_btms: Optional[List[UserDetailsResponseUserBtms]] = None
    admin_btms: Optional[List[Dict[str, Any]]] = None
    reg_date: Optional[StrictStr] = None
    post_number: Optional[StrictStr] = Field(default=None, alias="PostNumber")
    phone_number: Optional[StrictStr] = Field(default=None, alias="PhoneNumber")
    has_battery: Optional[StrictBool] = Field(default=None, alias="hasBattery")
    has_ev: Optional[StrictBool] = Field(default=None, alias="hasEV")
    subscription: Optional[StrictBool] = None
    customer_id: Optional[StrictStr] = None
    is_bot: Optional[StrictBool] = None
    address_id: Optional[StrictInt] = None
    submeter_id: Optional[List[StrictInt]] = None
    last_login: Optional[datetime] = None
    expo_push_token: Optional[StrictStr] = None
    __properties: ClassVar[List[str]] = ["id", "firstName", "lastName", "email", "last_changed_password", "completeProfile", "hasUserRegisteredHisDevices", "nrOfDevices", "roles", "eloverblik_customer_key", "user_btms", "admin_btms", "reg_date", "PostNumber", "PhoneNumber", "hasBattery", "hasEV", "subscription", "customer_id", "is_bot", "address_id", "submeter_id", "last_login", "expo_push_token"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UserDetailsResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in roles (list)
        _items = []
        if self.roles:
            for _item_roles in self.roles:
                if _item_roles:
                    _items.append(_item_roles.to_dict())
            _dict['roles'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in user_btms (list)
        _items = []
        if self.user_btms:
            for _item_user_btms in self.user_btms:
                if _item_user_btms:
                    _items.append(_item_user_btms.to_dict())
            _dict['user_btms'] = _items
        # set to None if last_changed_password (nullable) is None
        # and model_fields_set contains the field
        if self.last_changed_password is None and "last_changed_password" in self.model_fields_set:
            _dict['last_changed_password'] = None

        # set to None if complete_profile (nullable) is None
        # and model_fields_set contains the field
        if self.complete_profile is None and "complete_profile" in self.model_fields_set:
            _dict['completeProfile'] = None

        # set to None if eloverblik_customer_key (nullable) is None
        # and model_fields_set contains the field
        if self.eloverblik_customer_key is None and "eloverblik_customer_key" in self.model_fields_set:
            _dict['eloverblik_customer_key'] = None

        # set to None if reg_date (nullable) is None
        # and model_fields_set contains the field
        if self.reg_date is None and "reg_date" in self.model_fields_set:
            _dict['reg_date'] = None

        # set to None if post_number (nullable) is None
        # and model_fields_set contains the field
        if self.post_number is None and "post_number" in self.model_fields_set:
            _dict['PostNumber'] = None

        # set to None if customer_id (nullable) is None
        # and model_fields_set contains the field
        if self.customer_id is None and "customer_id" in self.model_fields_set:
            _dict['customer_id'] = None

        # set to None if address_id (nullable) is None
        # and model_fields_set contains the field
        if self.address_id is None and "address_id" in self.model_fields_set:
            _dict['address_id'] = None

        # set to None if expo_push_token (nullable) is None
        # and model_fields_set contains the field
        if self.expo_push_token is None and "expo_push_token" in self.model_fields_set:
            _dict['expo_push_token'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UserDetailsResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "firstName": obj.get("firstName"),
            "lastName": obj.get("lastName"),
            "email": obj.get("email"),
            "last_changed_password": obj.get("last_changed_password"),
            "completeProfile": obj.get("completeProfile"),
            "hasUserRegisteredHisDevices": obj.get("hasUserRegisteredHisDevices"),
            "nrOfDevices": obj.get("nrOfDevices"),
            "roles": [UserDetailsResponseRoles.from_dict(_item) for _item in obj["roles"]] if obj.get("roles") is not None else None,
            "eloverblik_customer_key": obj.get("eloverblik_customer_key"),
            "user_btms": [UserDetailsResponseUserBtms.from_dict(_item) for _item in obj["user_btms"]] if obj.get("user_btms") is not None else None,
            "admin_btms": obj.get("admin_btms"),
            "reg_date": obj.get("reg_date"),
            "PostNumber": obj.get("PostNumber"),
            "PhoneNumber": obj.get("PhoneNumber"),
            "hasBattery": obj.get("hasBattery"),
            "hasEV": obj.get("hasEV"),
            "subscription": obj.get("subscription"),
            "customer_id": obj.get("customer_id"),
            "is_bot": obj.get("is_bot"),
            "address_id": obj.get("address_id"),
            "submeter_id": obj.get("submeter_id"),
            "last_login": obj.get("last_login"),
            "expo_push_token": obj.get("expo_push_token")
        })
        return _obj


