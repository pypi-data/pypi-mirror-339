Metadata-Version: 2.4
Name: dyntastic
Version: 0.18.0
Summary: A DynamoDB library on top of Pydantic and boto3.
Home-page: https://github.com/nayaverdier/dyntastic
Author: Naya Verdier
License: MIT
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Requires-Python: >=3.7
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: boto3>=1.10.0; python_version < "3.12"
Requires-Dist: boto3>=1.20.0; python_version >= "3.12"
Requires-Dist: pydantic<3,>=1.7.1
Requires-Dist: importlib-metadata>=1.0.0; python_version < "3.8"
Provides-Extra: dev
Requires-Dist: black; extra == "dev"
Requires-Dist: boto3-stubs[dynamodb]; extra == "dev"
Requires-Dist: coverage; extra == "dev"
Requires-Dist: flake8==6.0.0; python_version > "3.7" and extra == "dev"
Requires-Dist: flake8<5; python_version == "3.7" and extra == "dev"
Requires-Dist: flake8-bugbear; extra == "dev"
Requires-Dist: isort; extra == "dev"
Requires-Dist: moto==4.2.2; extra == "dev"
Requires-Dist: mypy; extra == "dev"
Requires-Dist: pre-commit; extra == "dev"
Requires-Dist: pytest; extra == "dev"
Requires-Dist: pytest-cov; extra == "dev"
Requires-Dist: pytest-mock; extra == "dev"
Requires-Dist: pytest-sugar; extra == "dev"
Requires-Dist: pytest-xdist; extra == "dev"
Provides-Extra: deploy
Requires-Dist: twine; extra == "deploy"
Dynamic: author
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: license
Dynamic: license-file
Dynamic: provides-extra
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

# dyntastic

[![CI](https://github.com/nayaverdier/dyntastic/actions/workflows/ci.yml/badge.svg)](https://github.com/nayaverdier/dyntastic/actions/workflows/ci.yml)
[![codecov](https://codecov.io/gh/nayaverdier/dyntastic/branch/main/graph/badge.svg)](https://codecov.io/gh/nayaverdier/dyntastic)
[![pypi](https://img.shields.io/pypi/v/dyntastic)](https://pypi.org/project/dyntastic)
[![license](https://img.shields.io/github/license/nayaverdier/dyntastic.svg)](https://github.com/nayaverdier/dyntastic/blob/main/LICENSE)

A DynamoDB library on top of Pydantic and boto3.

## Installation

```bash
pip3 install dyntastic
```

If the Pydantic binaries are too large for you (they can exceed 90MB),
use the following:

```bash
pip3 uninstall pydantic  # if pydantic is already installed
pip3 install dyntastic --no-binary pydantic
```

## Usage

The core functionality of this library is provided by the `Dyntastic` class.

`Dyntastic` is a subclass of Pydantic's `BaseModel`, so can be used in all the
same places a Pydantic model can be used (FastAPI, etc).

```python
import uuid
from datetime import datetime
from typing import Optional

from dyntastic import Dyntastic
from pydantic import Field

class Product(Dyntastic):
    __table_name__ = "products"
    __hash_key__ = "product_id"

    product_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    description: Optional[str] = None
    price: float
    tax: Optional[float] = None


class Event(Dyntastic):
    __table_name__ = "events"
    __hash_key__ = "event_id"
    __range_key__ = "timestamp"

    event_id: str
    timestamp: datetime
    data: dict

# All your favorite pydantic functionality still works:

p = Product(name="bread", price=3.49)
# Product(product_id='d2e91c30-e701-422f-b71b-465b02749f18', name='bread', description=None, price=3.49, tax=None)

p.model_dump()
# {'product_id': 'd2e91c30-e701-422f-b71b-465b02749f18', 'name': 'bread', 'description': None, 'price': 3.49, 'tax': None}

p.model_dump_json()
# '{"product_id": "d2e91c30-e701-422f-b71b-465b02749f18", "name": "bread", "description": null, "price": 3.49, "tax": null}'

```

### Inserting into DynamoDB

Using the `Product` example from above, simply:

```python
product = Product(name="bread", description="Sourdough Bread", price=3.99)
product.product_id
# d2e91c30-e701-422f-b71b-465b02749f18

# Nothing is written to DynamoDB until .save() is called:
product.save()
```

### Getting Items from DynamoDB

```python
Product.get("d2e91c30-e701-422f-b71b-465b02749f18")
# Product(product_id='d2e91c30-e701-422f-b71b-465b02749f18', name='bread', description="Sourdough Bread", price=3.99, tax=None)
```

The range key must be provided if one is defined:

```python
Event.get("d2e91c30-e701-422f-b71b-465b02749f18", "2022-02-12T18:27:55.837Z")
```

Consistent reads are supported:

```python
Event.get(..., consistent_read=True)
```

A `DoesNotExist` error is raised by `get` if a key is not found:

```python
Product.get("nonexistent")
# Traceback (most recent call last):
#   ...
# dyntastic.exceptions.DoesNotExist
```

Use `safe_get` instead to return `None` if the key is not found:

```python
Product.safe_get("nonexistent")
# None
```

### Querying Items in DynamoDB

```python
# A is shorthand for the Attr class (i.e. attribute)
from dyntastic import A

# auto paging iterable
for event in Event.query("some_event_id"):
    print(event)


Event.query("some_event_id", per_page=10)
Event.query("some_event_id")
Event.query("some_event_id", range_key_condition=A.timestamp < datetime(2022, 2, 13))
Event.query("some_event_id", filter_condition=A.some_field == "foo")

# query an index
Event.query(A.my_other_field == 12345, index="my_other_field-index")

# note: Must provide a condition expression rather than just the value
Event.query(123545, index="my_other_field-index")  # errors!

# query an index with an optional filter expression
filter_expression = None
if filter_value:
    filter_expression = A('filter_field').eq(filter_value)
Event.query(
    A.my_other_field == 12345,
    index="my_other_field-index",
    filter_expression=filter_expression
)

# consistent read
Event.query("some_event_id", consistent_read=True)

# specifies the order for index traversal, the default is ascending order
# returns the results in the order in which they are stored by sort key value
Event.query("some_event_id", range_key_condition=A.version.begins_with("2023"), scan_index_forward=False)
```

DynamoDB Indexes using a `KEYS_ONLY` or `INCLUDE` projection are supported:

```python
for event in Event.query("2023-09-22", index="date-keys-only-index"):
    event.id
    # "..."
    event.timestamp
    # datetime(...)

    event.data
    # ValueError: Dyntastic instance was loaded from a KEYS_ONLY or INCLUDE index.
    #             Call refresh() to load the full item, or pass load_full_item=True
    #             to query() or scan()

# automatically fetch the full items
for event in Event.query("2023-09-22", index="date-keys-only-index", load_full_item=True):
    event.data
    # {...}
```

If you need to manually handle pagination, use `query_page`:

```python
page = Event.query_page(...)
page.items
# [...]
page.has_more
# True
page.last_evaluated_key
# {"event_id": "some_event_id", "timestamp": "..."}

Event.query_page(..., last_evaluated_key=page.last_evaluated_key)
```

### Scanning Items in DynamoDB

Scanning is done identically to querying, except there are no hash key
or range key conditions.

```python
# auto paging iterable
for event in Event.scan():
    pass

Event.scan((A.my_field < 5) & (A.some_other_field.is_in(["a", "b", "c"])))
Event.scan(..., consistent_read=True)
```

### Updating Items in DynamoDB

Examples:

```python
my_item.update(A.my_field.set("new_value"))
my_item.update(A.my_field.set(A.another_field))
my_item.update(A.my_int.set(A.another_int - 10))
my_item.update(A.my_int.set(A.my_int + 1))
my_item.update(A.my_list.append("new_element"))
my_item.update(A.some_attribute.set_default("value_if_not_already_present"))

my_item.update(A.my_field.remove())
my_item.update(A.my_list.remove(2))  # remove by index

my_item.update(A.my_string_set.add("new_element"))
my_item.update(A.my_string_set.add({"new_1", "new_2"}))
my_item.update(A.my_string_set.delete("element_to_remove"))
my_item.update(A.my_string_set.delete({"remove_1", "remove_2"}))

# Multiple updates can be performed at once
my_item.update(
    A.my_field.set("new_value"),
    A.my_int.set(A.my_int + 1),
    ...
)
```

The data is automatically refreshed after the update request. To disable this
behavior, pass `refresh=False`:

```python
my_item.update(..., refresh=False)
```

Supports conditions:

```python
my_item.update(..., condition=A.my_field == "something")
```

By default, if the condition is not met, the update call will be a noop.
To instead error in this situation, pass `require_condition=True`:

```python
my_item.update(..., require_condition=True)
```

### Batch Reads

Multiple items can be read from a table at the same time using the `batch_get` function.

Note that DynamoDB limits the number of items that can be read at one time to
100 items or 16MB, whichever comes first.

Note that if any of the provided keys are missing from dynamo, they will simply
be excluded in the result set.

```python
MyModel.batch_get(["hash_key_1", "hash_key_2", "hash_key_3"])
# => [MyModel(...), MyModel(...)]
```

For models with a range key defined:

```python
MyModel.batch_get([("hash_key_1", "range_key_1"), ("hash_key_2", "range_key_2")])
# => [MyModel(...), MyModel(...)]
```

### Batch Writes

Save and delete operations may also be performed in batches.

Note that DynamoDB limits the number of items that can be written in a single
batch to 25 items or 16MB, whichever comes first. Dyntastic will automatically
batch in chunks of 25, or less if desired.

```python
with MyModel.batch_writer():
    MyModel(id="0").delete()
    MyModel(id="1").save()
    MyModel(id="2").save()

# all operations are performed once the `with` context is exited
```

To configure a smaller batch size, for example when each item is relatively large:

```python
with MyModel.batch_writer(batch_size=2):
    MyModel(id="1").save()
    MyModel(id="2").save()
    # the previous two models are written immediately, since the batch size was reached
    MyModel(id="3).save()

# The final operation is performed here now that the `with` context has exited
```


### Transactions

Dyntastic supports DynamoDB transactions. Transactions are performed using the
`transaction` context manager and can be used to perform operations across one or multiple
tables that reside in the same region.

```python
from dyntastic import transaction

with transaction():
    item1 = SomeTable(...)
    item2 = AnotherTable.get(...)
    item1.save()
    item2.update(A.something.set("..."))
```

Note that DynamoDB limits the number of items that can be written in a single
transaction to 100 items or 4MB, whichever comes first. Dyntastic can automatically
flush the transaction in chunks of 100 (or fewer if desired) by passing `auto_commit=True`.

For example, to commit every 50 items:
```python
with transaction(auto_commit=True, commit_every=50):
    item1 = SomeTable(...)
    item2 = AnotherTable.get(...)
    item1.save()
    item2.update(A.something.set("..."))
```

### Create a DynamoDB Table

This functionality is currently meant only for use in unit tests as it does not
support configuring throughput.

To create a table with no secondary indexes:

```python
MyModel.create_table()

# Do not wait until the table creation is complete (subsequent operations
# may error if they are performed before the table creation is finished)
MyModel.create_table(wait=False)
```

To define global secondary indexes (creating local secondary indexes is not
currently supported):

```python
# All of the following are equivalent
index1 = "my_field"
index1 = Index("my_field")
index1 = Index("my_field", index_name="my_field-index")

# Range keys are also supported
index2 = Index("my_field", "my_second_field")
index2 = Index("my_field", "my_second_field", index_name="my_field_my_second_field-index")

MyModel.create_table(index1, index2)
```

## Dynamic table names
In some circumstances you may want the table name to be defined dynamically.
This can be done by setting the `__table_name__` attribute to a Callable that returns the table name
from the source of your choice. In the example below, we are using an environment variable. 

```python
import os
from dyntastic import Dyntastic

os.environ["MY_TABLE_NAME"] = "my_table"

class Product(Dyntastic):
    __table_name__ = lambda: os.getenv("MY_TABLE_NAME")
    __hash_key__ = "product_id"

    product_id: str
```

## Custom dynamodb endpoint or region for local development
To explicitly define an AWS region or DynamoDB endpoint url (for using a local
dynamodb docker instance, for example), set `__table_region__` or `__table_host__`.
These attributes can be a string or a Callable that returns a string.

```python
from dyntastic import Dyntastic

class Product(Dyntastic):
    __table_name__ = "products"
    __table_region__ = "us-east-1"
    __table_host__ = "http://localhost:8000"
    __hash_key__ = "product_id"

    product_id: str
```

You can also set the environment variables `DYNTASTIC_HOST` and/or `DYNTASTIC_REGION` to control the behavior
of the underlying boto3 client and resource objects. 

*Note*: if both the environment variables and the class attributes are set,
the class attributes will take precedence. 

```python
import os
from dyntastic import Dyntastic

os.environ["DYNTASTIC_HOST"] = "http://localhost:8000"
os.environ["DYNTASTIC_REGION"] = "us-east-1"

class Product(Dyntastic):
    __table_name__ = "products"
    __hash_key__ = "product_id"

    product_id: str
```

## Contributing / Developer Setup

Make sure [`just`](https://github.com/casey/just) is installed on your system

To setup the dev environment and install dependencies:

```bash
# create and activate a new venv
python3 -m venv .venv
. .venv/bin/activate

# install all dev dependencies
just install-dev

# to automatically run pre-commit before all commits
pre-commit install
```

After making changes, lint all code + run tests:

```bash
just pre-commit

# or individually:
just isort
just black
just flake8
just mypy
just test

# run a specific test/tests
just test tests/test_save.py tests/test_get.py
just test tests/some_save.py::test_save_aliased_item
```


# Changelog

## 0.18.0 2025-04-05

- Add support for specifying `billing_mode` when creating a table (Thanks
  @groovecoder)

## 0.17.0 2025-02-25

- Add support for ipv4 and ipv6 IP addresses (Thanks @GitToby)
- Fix handling of aliases, including bug where tables with an aliased hash key
  could not be deleted (Thanks @Nathan-Kr for reporting)

## 0.16.0 2024-12-18

- Fix double serialization of conditions inside a transaction (Thanks @krewx)
- Fix validation error due to empty ExpressionAttributeValue during transaction
  (Thanks @regoawt for reporting)

## 0.15.0 2024-05-18

- Make Dyntastic.batch_get work with keys that are aliases on the model fields.
- Improve error messages when validating keys passed to `get`, `safe_get` or `batch_get`
- Minor fixes to `batch_get` type hints

## 0.14.0 2023-12-21

- Add support for `__table_region__` and `__table_host__` to be lazy callables
- Default `__table_region__` and `__table_host__` to `DYNTASTIC_REGION` and
  `DYNTASTIC_HOST` environment variables if not otherwise defined

## 0.13.1 2023-11-21

- Fix import error when using `pydantic>=2.5`

## 0.13.0 2023-11-18

- Add support for python3.12

## 0.13.0a1 2023-11-03

- Add support for pydantic v2

## 0.12.0 2023-09-22

- Support KEYS_ONLY and INCLUDE DynamoDB indexes

## 0.11.0 2023-09-22

- Make commit limit configurable on `transaction()` context manager

## 0.11.0a2 2023-08-25

- Fix issue with query returning no results when using a filter with sparse matches

## 0.11.0a1 2023-07-20

- Add support for transaction writes using `transaction()` context manager
- No longer commit batch when an exception is raised during the batch context
  manager `__exit__`

## 0.10.0 2023-04-16

- Add support for `scan_index_forward` for specifying ascending (True) or
  descending (False) traversal of the index.

## 0.9.0 2023-04-15

- Add support for `__table_host__` for local testing

## 0.8.2 2022-11-12

- Make mypy linting more strict

## 0.8.1 2022-11-08

- Fixed `batch_read` to support non-string hash keys

## 0.8.0 2022-10-12

- Add `py.typed` marker to indicate this library ships with type hints

## 0.7.0 2022-10-11

- No changes since 0.7.0a1

## 0.7.0a1 2022-10-08

- Change dependency version pinning to be more flexible
- Only require `importlib_metadata` for python3.7 and earlier

## 0.6.0 2022-09-17

- Added support for `__table_name__` being a `Callable[[], str]` to allow
  dynamic table name
- Added support for batch reads and writes
- Fixed `consistent_read` behavior for `safe_get` (previously was always set to
  `True`)

## 0.5.0 2022-05-09

- Added support for multiple subclasses within one table (`get_model` function)

## 0.4.1 2022-04-26

- Fixed serialization of dynamo types when using Pydantic aliases

## 0.4.0 2022-04-26

- Fixed compatibility with Pydantic aliases

## 0.3.0 2022-04-25

- Added support for nested attribute conditions and update expressions
- Fixed bug where `refresh()` would cause nested Pydantic models to be
  converted to dictionaries instead of loaded into their models
- Added Pydantic aliases (models will all be dumped using pydantic's
  `by_alias=True` flag).

## 0.2.0 2022-04-23

**BREAKING**: Accessing attributes after calling `update(..., refresh=False)`
will trigger a ValueError. Read below for more information.

- Added built in safety for unrefreshed instances after an update. Any
  attribute accesses on an instance that was updated with `refresh=False`
  will raise a ValueError. This can be fixed by calling `refresh()` to get
  the most up-to-date data of the item, or by calling `ignore_unrefreshed()`
  to explicitly opt-in to using stale data.

## 0.1.0 2022-02-13

- Initial release
